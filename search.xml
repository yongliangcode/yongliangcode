<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>FA2# 集群流控使用场景和实现原理</title>
    <url>/posts/dd40ab43/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>资源是有限的，预测是必要的，然而意外也是可能发生的。我们可以看到一些重大生产事故往往是被突发的流量冲跨的，对流量的治理和防护就尤为重要。防患于未然，保障服务高可用，需要引起重视。另外我们也需要对标行业一流治理能力，本文介绍下高可用中另外一个成员，集群限流。</p>
<h1 id="集群流控使用场景"><a href="#集群流控使用场景" class="headerlink" title="集群流控使用场景"></a>集群流控使用场景</h1><h3 id="场景一-需要控制调用总量"><a href="#场景一-需要控制调用总量" class="headerlink" title="场景一  需要控制调用总量"></a>场景一  需要控制调用总量</h3><p>某些场景下，需要对APP应用某些资源（接口）的调用总量设置限制。例如：该APP由于依赖了第三方提供服务，第三方流量有限制，需要对总量进行管控。部署的节点可能扩缩容，这种单纯通过单机限流措施难以凑效。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/%E5%9C%BA%E6%99%AF%E4%B8%80%20%20%E9%9C%80%E8%A6%81%E6%8E%A7%E5%88%B6%E8%B0%83%E7%94%A8%E6%80%BB%E9%87%8F.png"></p>
<a id="more"></a>



<h3 id="场景二-单机流量不均衡"><a href="#场景二-单机流量不均衡" class="headerlink" title="场景二 单机流量不均衡"></a>场景二 单机流量不均衡</h3><p>应用APP部署了10个节点，总流量为2000QPS，每个节点200。这事理想状态，实际可能由于负载均衡造成流量倾斜。有的节点流量高、有的节点流量低。如果只从单机限流角度限流，可能会出现一个APP应用中有的节点已经发生限流，有的负载还很低的情况。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/%E5%9C%BA%E6%99%AF%E4%BA%8C%20%E5%8D%95%E6%9C%BA%E6%B5%81%E9%87%8F%E4%B8%8D%E5%9D%87%E8%A1%A1.png"></p>
<h3 id="场景三-部署节点配置不同"><a href="#场景三-部署节点配置不同" class="headerlink" title="场景三  部署节点配置不同"></a>场景三  部署节点配置不同</h3><p>应用APP部署了10个节点，有的节点2C4G，有的节点8C16G。这种混合部署的场景，如果只从单机设置限流阈值，只能以配置低的压测值作为设置阈值，高配置节点会造成资源浪费。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/%E5%9C%BA%E6%99%AF%E4%B8%89%20%20%E9%83%A8%E7%BD%B2%E8%8A%82%E7%82%B9%E9%85%8D%E7%BD%AE%E4%B8%8D%E5%90%8C.png"></p>
<p><strong>备注：通过集群流控配合单机限流更好的应对不同场景流量防护，是流量防护中比较好的实践。</strong> </p>
<h1 id="集群流控实现原理"><a href="#集群流控实现原理" class="headerlink" title="集群流控实现原理"></a>集群流控实现原理</h1><p>实现集群流控，需要统计请求的调用总量。我们采用在应用内部选一台机器作为Token Server，用于流量的统计和token的发放。</p>
<h3 id="请求流程"><a href="#请求流程" class="headerlink" title="请求流程"></a>请求流程</h3><p>如下图所示，在请求链路中当服务A发起的请求调用B服务时，B服务开启了集群流控，其中一个节点作为Token Server，其他节点均为Token Client。流程如下：</p>
<ul>
<li>当请求到达节点时会向Token Server发起token请求</li>
<li>Token Server根据是否达到阈值决定是否发放token</li>
<li>承接请求的节点获取token后向下游调用，超过限流阈值Token Server未发放token，请求被拒绝</li>
</ul>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/%E9%9B%86%E7%BE%A4%E6%B5%81%E6%8E%A7%E5%8E%9F%E7%90%86.png"></p>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>集群流控的实现依然基于令牌桶实现的，下面为示意图：</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/%E4%BB%A4%E7%89%8C%E7%AE%97%E6%B3%95%20(1).png"></p>
<p><strong>工作过程</strong></p>
<ul>
<li>请求流量从令牌桶中获取令牌，持有令牌放行，否则被拒</li>
<li>假如设置阈值每秒允许100个请求通过，则请求发送速率r=100/s</li>
<li>需要令牌生产速率为1/r，即1/100每10毫秒产生一个令牌</li>
<li>令牌桶容量为b已满多余的令牌将被丢弃</li>
<li>令牌桶为空请求被拒</li>
<li>允许突发流量最大突发流量为令牌桶容量b</li>
<li>请求通过相应的令牌从令牌桶中移除</li>
</ul>
<h3 id="动态选主"><a href="#动态选主" class="headerlink" title="动态选主"></a>动态选主</h3><p>我们的服务有发布、有扩缩容，原来被选为Token Server的节点可能会下线等，我们采取了基于分布式锁（公平锁）的方式来动态选主。</p>
<p>使用公平锁主要避免独占锁带来的羊群效益。</p>
<h3 id="阈值设置"><a href="#阈值设置" class="headerlink" title="阈值设置"></a>阈值设置</h3><p>集群阈值的设置有两种类型：全局阈值和单机均摊</p>
<ul>
<li><p>全局阈值表示整个集群能承受的总阈值流量，不随节点的变化而变化<br>例如：全局阈值设置为500，无论该应用部署了多少节点，总的流量阈值保持500不变</p>
</li>
<li><p>单机均摊指每个节点能承受的阈值，随着节点的增减Token Server的阈值会动态变化<br>例如：单机均摊设置为100，3个节点集群流控总阈值为300；扩容了两个节点后，总阈值则为500</p>
</li>
</ul>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>方案设计</category>
      </categories>
      <tags>
        <tag>方案设计</tag>
      </tags>
  </entry>
  <entry>
    <title>FA1# 微服务流控防护场景与应对措施</title>
    <url>/posts/9bf5e4df/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>微服务成了互联网架构的标配模式，对微服务之间的调用的流量治理和管控就尤为重要。哪些场景需要流量防控，针对这些场景又有哪些应对措施。有没有一个通用的措施来降低风险呢？这篇文章咱就聊聊这个。</p>
<a id="more"></a>





<h1 id="服务被过载调用"><a href="#服务被过载调用" class="headerlink" title="服务被过载调用"></a>服务被过载调用</h1><p>当服务D的某个接口服务被上游服务过载调用时，如果不对服务D加入保护，可能整体将服务D整体拖垮。在这种场景中，我们需要对服务D配置限流，以保护服务D不被整体冲跨。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%99%90%E6%B5%81.png"></p>
<p><strong>应对措施：</strong> 针对服务提供方D配置流量防护规则，对进入服务D的流量进行控制，从而对服务D提供保护。触发流控时可以有多重策略，例如：快速失败、预热模式、排队等待、预热模式+排队等待。</p>
<p><strong>快速失败：</strong> 发生流控时直接抛出异常。</p>
<p><strong>预热模式：</strong> 发生流控时，流量缓慢增加的一种模式，效果如下图所示，流量QPS从200缓慢增加到600。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210109141101.png"></p>
<p><strong>排队等待：</strong> 请求匀速通过，过多请求需要排队，此时排队有超时时间，超过排队时间抛出流控异常。效果如下图所示：请求QPS保持1000的匀速通过。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210109141720.png"></p>
<p><strong>预热模式+排队等待：</strong> 这种模式是预热和排队等待的叠加模式，请求以匀速的方式缓慢增加。如下图：请求从0缓慢增加到500，匀速通过一段时间后，再增加到1000。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210109142131.png"></p>
<h1 id="服务慢调用或故障"><a href="#服务慢调用或故障" class="headerlink" title="服务慢调用或故障"></a>服务慢调用或故障</h1><p>下面的场景A调用B、A调用C、A调用D，当服务B服务不稳定时，服务A调用服务B发生了慢调用或者大量异常错误。这种场景，如果不干预，可能影响到A调用C和A调用D的状况。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/%E7%86%94%E6%96%AD%E9%99%8D%E7%BA%A7.png"></p>
<p><strong>应对措施：</strong> A调用B配置熔断降级规则，当服务B不稳定发生慢调用或者异常时，如果触发阈值，将服务B的调用熔断；从而保护了服务A调用C、服务A调用D的正常情况。</p>
<p><strong>熔断效果：</strong> 熔断的实现通常通过断路器实现，具体过程为：</p>
<ul>
<li>当满足慢调用比例、异常比例、异常数量阈值后，触发熔断（OPEN），在熔断时长内拒绝所有请求</li>
<li>当熔断过了定义的熔断时长，状态由熔断（OPEN）变为探测（HALF_OPEN）</li>
<li>接下来的一个请求不发生慢调用或者异常，熔断结束由探测状态（HALF_OPEN）变为（CLOSED）</li>
<li>接下来的一个请求发生慢调用或者异常，继续熔断，由探测状态（HALF_OPEN）变为（OPEN）</li>
</ul>
<h1 id="服务资源被挤占"><a href="#服务资源被挤占" class="headerlink" title="服务资源被挤占"></a>服务资源被挤占</h1><p>分布式链路中，如果某一条链路产生慢调用，对其他链路造成挤压。除了上面提到配置熔断降级外，可以通过线程并发控制来隔离。</p>
<p>下图中有3条链路，其中链路1由于服务E的不稳定，产生了慢调用。</p>
<table>
<thead>
<tr>
<th>链路标号</th>
<th>调用链</th>
</tr>
</thead>
<tbody><tr>
<td>链路1</td>
<td>服务A–&gt;服务D#Method1–&gt;服务E</td>
</tr>
<tr>
<td>链路2</td>
<td>服务B–&gt;服务D#Method2–&gt;服务F</td>
</tr>
<tr>
<td>链路3</td>
<td>服务C–&gt;服务D#Method2–&gt;服务G</td>
</tr>
</tbody></table>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E9%87%8D%E7%94%BB%20(1).png"></p>
<p>链路1慢调用可能导致如下情况：</p>
<ul>
<li>链路1线程数增多对服务D资源造成挤压</li>
<li>对服务D资源的过度挤压，链路2和链路3造成不稳定</li>
<li>极端情况导致整个服务D不可用，严重时引发雪崩</li>
</ul>
<p><strong>应对措施：</strong> 通过对服务D的MethodA1、MethodA2的线程数并发设置规则，超过阈值时将会触发阻断，不再向下游调用，避免不可用引发雪崩。</p>
<p><strong>并发控制效果</strong> 下图中设置了调用方的并发线程数为10，通过每分钟的查询可以看出，线程数一直保持在10。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210109150939.png"></p>
<h1 id="数据过热挤占资源"><a href="#数据过热挤占资源" class="headerlink" title="数据过热挤占资源"></a>数据过热挤占资源</h1><p>热点数据，比如：大促时的热销产品、秒杀类产品等。如下图所示，如果不对热点商品下单流量进行管控，可能对其他商品造成挤压；影响整个商品下单体验。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/%E7%83%AD%E7%82%B9%E5%8F%82%E6%95%B0.png"></p>
<p><strong>应对措施：</strong> 通过对热点参数测速，配置流控规则，超过阈值时触发流控。例如：通过对入参产品ID进行测速，超过设置的阈值时，触发流控，避免对其过度挤占资源。</p>
<h1 id="通用防护分组措施"><a href="#通用防护分组措施" class="headerlink" title="通用防护分组措施"></a>通用防护分组措施</h1><p>上面的现象中，无论是服务不稳定、还是被挤占、或者被过载调用。除了通过上述的防护措施外，可以对服务进行等级划分并分组。</p>
<p>如下图所示：服务A和服务D为核心服务、服务B和服务C为非核心服务。通过将服务D进行分组，分成了1组和2组。分组1只允许核心服务调用，分组2只允许非核心服务调用。</p>
<p>这样做的好处：将流量进行物理隔离，避免由于非核心业务流量对核心业务流量造成挤压、保护核心链路稳定性。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/%E5%88%86%E7%BB%84%E6%8E%AA%E6%96%BD.png"></p>
<p><strong>分组措施@1</strong>  通常可以更换注册中心路径实现，服务A和服务D（分组1）放在同一个注册中心路径（例如：soa-group1）；服务B、服务C、服务D（分组2）放在另一个不同的注册中心路径（例如：soa-group2）。</p>
<p><strong>分组措施@2</strong> 通过对分组的服务节点打标实现，例如：服务D（分组1）节点被打标为group1，服务D（分组2）节点被打标为group2。在服务消费方订阅节点时根据不同的分组筛选节点调用。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>方案设计</category>
      </categories>
      <tags>
        <tag>方案设计</tag>
      </tags>
  </entry>
  <entry>
    <title>FA3# ZK做注册中心不是最好的选择</title>
    <url>/posts/6531e1a8/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Zookeeper作为注册中心不是跑的好好的吗？为什么要替换，是不是闲的？在过去的一段时间替换它的优先级的确不高，然而腾出手来是要替换掉它的，只是因为Zookeeper不适合做注册中心。换句话说选择注册中心时有更好的选择。</p>
<h1 id="CAP定理与举例"><a href="#CAP定理与举例" class="headerlink" title="CAP定理与举例"></a>CAP定理与举例</h1><h3 id="CAP定理"><a href="#CAP定理" class="headerlink" title="CAP定理"></a>CAP定理</h3><p>CAP定理已经深入每个开发者心里，我们一起回顾下，下面摘自维基百科定义。</p>
<p>CAP定理（CAP theorem），又被称作布鲁尔定理（Brewer’s theorem），它指出对于一个分布式计算系统来说，不可能同时满足以下三点：</p>
<ul>
<li>一致性（Consistency）：等同于所有节点访问同一份最新的数据副本</li>
<li>可用性（Availability）每次请求都能获取到非错的响应——但是不保证获取的数据为最新数据</li>
<li>分区容错性（Partition tolerance）以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择</li>
</ul>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/CAP%E5%AE%9A%E7%90%86%E6%96%B02.png"></p>
<h3 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h3><p>例如：有5个节点被网络分区，分区1有三个节点，分区2有两个节点。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/%E7%BD%91%E7%BB%9C%E5%88%86%E5%8C%BA%E7%A4%BA%E4%BE%8B.png"></p>
<ul>
<li>如果保证两个分区节点都可用（AP），由于网络不通，那么无法保证两个分区数据一致性（CP）</li>
<li>如果保证两个分区数据一致性（CP），由于网络不通，那么会导致至少一个分区不可用</li>
<li>如果既想保证所有节点一致性，还要保证节点都可用（CA），那么网络就必须是好的，不能出现网络分区，失去了分区容错性（P）</li>
</ul>
<p>因此，三者不可兼得。</p>
<a id="more"></a>



<h1 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h1><h3 id="架构图示"><a href="#架构图示" class="headerlink" title="架构图示"></a>架构图示</h3><p>『服务提供者』将自己在注册中心注册，『服务消费者』通过服务名将『服务提供者』的节点找出来，最后向『服务提供者』发起RPC调用。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E6%9E%B6%E6%9E%84.png"></p>
<p>注册中心本质在提供服务和节点之间的注册查询服务，也就是说注册中心是服务之间交互辅助作用。</p>
<h3 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h3><p>除了注册中心提供基本的服务注册和节点查询外。我们还想注册中心有以下功能：</p>
<p><strong>健康检查</strong>  </p>
<p>注册中心返回的服务提供者节点是好的，是能提供服务的，不健康的就别提供了。</p>
<p><strong>健康保护</strong> </p>
<p>虽然不想你把不好的节点给我，但是如果服务大部分节点都不好了，流量全部偏移到健康节点，可能把健康的节点也打挂掉。</p>
<p>所以需要一个不好节点的范围加以保护，避免雪崩。</p>
<p><strong>流量分配</strong> </p>
<p>希望注册中心能够支持流量均衡，并能够支持按照一定的规则在注册节点中分配流量。</p>
<h3 id="故障场景"><a href="#故障场景" class="headerlink" title="故障场景"></a>故障场景</h3><p>当注册中心发生故障时，需要尽可能保障服务调用的可用性。下面分几种场景</p>
<h5 id="注册中心瘫痪"><a href="#注册中心瘫痪" class="headerlink" title="注册中心瘫痪"></a>注册中心瘫痪</h5><p>这种场景是指整个注册中心机房/可用区故障或者注册中心本身故障无法对外提供服务。</p>
<ul>
<li>新服务提供者注册不上去</li>
<li>新启动的服务消费者订阅不了</li>
</ul>
<p><strong>备注：</strong> 这种场景应该只影响新启动的『服务提供者』和『服务消费者』，对已有的服务不应该产生影响，需要故障演练做到不影响。</p>
<h5 id="注册中心分区"><a href="#注册中心分区" class="headerlink" title="注册中心分区"></a>注册中心分区</h5><p>当注册中心发生分区时，根据上面CAP定理和示例，有两种选择，选择CP或者AP。</p>
<ul>
<li>选择两个分区数据一致性（CP），牺牲至少一个分区不可用</li>
<li>选择两个分区节点都可用（AP），牺牲两个分区数据一致性</li>
</ul>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%88%86%E5%8C%BA.png"></p>
<p><strong>选择两个分区数据一致性（CP）</strong></p>
<p>假如其中一个分区（不可用），本分区的的服务不能再从注册中心获取节点信息，类似本注册中心分区全部瘫痪。此时要求服务能够剥离注册中心后不影响服务之间调用。</p>
<p><strong>选择两个分区节点都可用（AP）</strong></p>
<p>两个分区数据一致性，分区1和分区2的注册节点可能不同，从而造成流量可能发生倾斜。</p>
<p><strong>备注</strong>：从架构来看，看发生网络分区，选择AP发生的流量倾斜远远好于选择CP导致分区的不可用。尽管分区不可用有一些缓存手段能保证服务可以继续交互。</p>
<h1 id="关于Zookeeper"><a href="#关于Zookeeper" class="headerlink" title="关于Zookeeper"></a>关于Zookeeper</h1><p>Zookeeper使用通过Zab协议保证数据的一致性，实现了CAP定理中的CP，通过上面分析注册中心更适合AP。至于保证一致性的在网络分区时有分区不可用，上面已经分析过。</p>
<h3 id="擅长"><a href="#擅长" class="headerlink" title="擅长"></a>擅长</h3><p>Zookeeper被广泛的用在分布式协调中，例如：Pulsar、Kafka、Flink、Hadoop等。</p>
<h3 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h3><p><strong>性能</strong></p>
<p>由于Zookeeper的写操作由Leader负责，我们线上9个zk节点，只有一个节点负责写请求，增加节点并不能分担Leader的写压力，那意味着只要服务到了一个量级必然会影响zk集群的性能。</p>
<p><strong>多语言</strong> </p>
<p>除了Java语言外，缺少其他语言对Zookeeper客户端良好封装，给使用者带来一定的挑战。</p>
<p><strong>心跳检测</strong></p>
<p>当Zookeeper作为注册中心时，依赖其基于session的心跳检测不能证明服务节点是不是好的。换句话说，使用zk的心跳作为注册中心健康检测是不合适的。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>方案设计</category>
      </categories>
      <tags>
        <tag>方案设计</tag>
      </tags>
  </entry>
  <entry>
    <title>FA4# 哈啰在分布式消息治理和微服务治理中的实践</title>
    <url>/posts/e67256f4/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="偶然"><a href="#偶然" class="headerlink" title="偶然"></a>偶然</h1><p>在今年3月初的时候敏捷教练陈文博应该是接到大领导指示让去召集人去投稿全球架构师大会（ArchSummit），目的在于提升公司的影响力和增进技术交流。</p>
<p>文博发我一个大会议题链接说让投稿，老梁扫了一眼没发现没合适的主题。这家伙找益伟去了，益伟给了个列表，微服务架构方向让我试试看。领导说让试试，你还能说不？这个大会老梁以前作为听众参加过，被选中其实不太容易，不太确定的事花太多时间划不来，老梁花了十来分钟拟了个提纲发给了他。</p>
<p>过了几天反馈说被选中了，让继续细化提纲、突出难点、听众受益点，就这么稀里糊涂的被选中去参加了这个大会。</p>
<p>江湖很大，圈子很小，来去匆匆少了联系，再见依旧是故人。在这个过程中也跟业内优秀的专家们建立一些链接，特别感谢：</p>
<ul>
<li>感谢敏捷教练陈文博方方面面的支持和推动</li>
<li>感谢组员李莹在PPT动画制作过程中的多次修改</li>
<li>感谢领导鹏哥（杨鹏）、益伟在准备PPT过程中的指导和提点</li>
<li>感谢大会主编薛梁和专题出品人蚂蚁资深技术专家黄挺（鲁直）的邀请</li>
</ul>
<p>老梁参加大会主要两部分，第一天是一个现场分享、第二天是一个视频录制。下面是参加大会分享的内容，其实也没啥，大伙随便看看。</p>
<a id="more"></a>



<h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210504130210.png"></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210504130355.png"></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210504130412.png"></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210504130442.png"></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210504130510.png"></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210504130529.png"></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210504130550.png"></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210504130608.png"></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210504130625.png"></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210504130641.png"></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210504130701.png"></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210504130718.png"></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210504130742.png"></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210504130804.png"></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210504130837.png"></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210504130930.png"></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210504130950.png"></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210504131010.png"></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210504131029.png"></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210504131044.png"></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210504131106.png"></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210504131126.png"></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210504131144.png"></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210504131201.png"></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210504131219.png"></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210504131235.png"></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210504131303.png"></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210504131347.png"></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210504131403.png"></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210504131422.png"></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210504131505.png"></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210504131524.png"></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210504131539.png"></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210504183140.png"></p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>方案设计</category>
      </categories>
      <tags>
        <tag>方案设计</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka1# 异常复盘NotLeaderForPartitionException.md</title>
    <url>/posts/9706ef5d/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="情况分析"><a href="#情况分析" class="headerlink" title="情况分析"></a>情况分析</h1><p><strong>客户端异常报警</strong> </p>
<p>晚上10点20分接到使用方电话，日志持续报以下异常，持续时间已有10多分钟。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ERROR 2019-05-15 23:05:23,221 [kafka-producer-network-thread | producer-1] A failure occurred sending a message to Kafka.</span><br><span class="line">org.apache.kafka.common.errors.NotLeaderForPartitionException: This server is not the leader for that topic-partition.</span><br><span class="line">WARN 2019-05-15 23:05:23,237 [main] Error sending event to listener kafkahandler, status: ABEND, event: Commit transaction</span><br></pre></td></tr></table></figure>



<a id="more"></a>



<p><strong>集群状况查看</strong></p>
<p>监控及Kafka Manager显示节点数量正常。问题集群有6个节点，3个副本。查看日志发现，都在大量输出选举的日志，日志中暂时没有发现明显的ERROR和FATAL日志。类似内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[2019-05-15 22:03:49,511] INFO Rolled new log segment for &#39;order-KSTREAM-AGGREGATE-STATE-STORE-0000000002-repartition-196&#39; in 1 ms. (kafka.log.Log)</span><br><span class="line">[2019-05-15 22:20:13,880] INFO Updated PartitionLeaderEpoch. New: &#123;epoch:1, offset:5910507&#125;, Current: &#123;epoch:0, offset4932329&#125; for Partition: zto_big_marks_mq-46. Cache now contains 1 entries. (kafka.server.epoch.LeaderEpochFileCache)</span><br><span class="line">[2019-05-15 22:20:13,881] INFO Updated PartitionLeaderEpoch. New: &#123;epoch:78, offset:1070147099&#125;, Current: &#123;epoch:77, offset1041132585&#125; for Partition: zto_scan_rec-11. Cache now contains 1 entries. </span><br></pre></td></tr></table></figure>



<p><strong>GC日志查看</strong></p>
<p>通过查看各个节点GC日志发现，其中一台节点GC回收异常，堆内存回后，只能回收600来M的空间。应该可以初步确定为问题节点。</p>
<p>日志内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2019-05-15T23:51:14.885+0800: 21994518.023: [GC pause (G1 Evacuation Pause) (young), 0.0749305 secs]</span><br><span class="line">   [Parallel Time: 70.4 ms, GC Workers: 33]</span><br><span class="line">      [GC Worker Start (ms): Min: 21994518023.0, Avg: 21994518023.5, Max: 21994518023.9, Diff: 0.9]</span><br><span class="line">      [Ext Root Scanning (ms): Min: 14.9, Avg: 15.7, Max: 17.1, Diff: 2.2, Sum: 518.0]</span><br><span class="line">      [Update RS (ms): Min: 3.4, Avg: 5.0, Max: 7.8, Diff: 4.5, Sum: 166.5]</span><br><span class="line">         [Processed Buffers: Min: 1, Avg: 1.7, Max: 7, Diff: 6, Sum: 57]</span><br><span class="line">      [Scan RS (ms): Min: 0.0, Avg: 2.1, Max: 3.7, Diff: 3.7, Sum: 69.4]</span><br><span class="line">      [Code Root Scanning (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]</span><br><span class="line">      [Object Copy (ms): Min: 45.9, Avg: 46.6, Max: 47.2, Diff: 1.3, Sum: 1536.2]</span><br><span class="line">      [Termination (ms): Min: 0.0, Avg: 0.1, Max: 0.1, Diff: 0.1, Sum: 3.3]</span><br><span class="line">         [Termination Attempts: Min: 1, Avg: 38.3, Max: 52, Diff: 51, Sum: 1263]</span><br><span class="line">      [GC Worker Other (ms): Min: 0.0, Avg: 0.1, Max: 0.2, Diff: 0.2, Sum: 2.8]</span><br><span class="line">      [GC Worker Total (ms): Min: 69.1, Avg: 69.6, Max: 70.1, Diff: 1.0, Sum: 2296.1]</span><br><span class="line">      [GC Worker End (ms): Min: 21994518093.0, Avg: 21994518093.1, Max: 21994518093.2, Diff: 0.2]</span><br><span class="line">   [Code Root Fixup: 0.1 ms]</span><br><span class="line">   [Code Root Purge: 0.0 ms]</span><br><span class="line">   [Clear CT: 1.0 ms]</span><br><span class="line">   [Other: 3.4 ms]</span><br><span class="line">      [Choose CSet: 0.0 ms]</span><br><span class="line">      [Ref Proc: 1.5 ms]</span><br><span class="line">      [Ref Enq: 0.0 ms]</span><br><span class="line">      [Redirty Cards: 0.9 ms]</span><br><span class="line">      [Humongous Register: 0.0 ms]</span><br><span class="line">      [Humongous Reclaim: 0.1 ms]</span><br><span class="line">      [Free CSet: 0.5 ms]</span><br><span class="line">   [Eden: 380.0M(380.0M)-&gt;0.0B(356.0M) Survivors: 28.0M-&gt;52.0M Heap: 5649.6M(8192.0M)-&gt;5466.5M(8192.0M)]</span><br><span class="line"> [Times: user&#x3D;2.31 sys&#x3D;0.00, real&#x3D;0.07 secs] </span><br><span class="line">2019-05-15T23:51:44.433+0800: 21994547.571: [GC pause (G1 Evacuation Pause) (mixed), 0.1036003 secs]</span><br><span class="line">   [Parallel Time: 81.6 ms, GC Workers: 33]</span><br><span class="line">      [GC Worker Start (ms): Min: 21994547572.2, Avg: 21994547573.2, Max: 21994547574.3, Diff: 2.1]</span><br><span class="line">      [Ext Root Scanning (ms): Min: 20.8, Avg: 24.4, Max: 80.8, Diff: 60.1, Sum: 805.5]</span><br><span class="line">      [Update RS (ms): Min: 0.0, Avg: 2.0, Max: 3.4, Diff: 3.4, Sum: 65.7]</span><br><span class="line">         [Processed Buffers: Min: 0, Avg: 2.0, Max: 5, Diff: 5, Sum: 65]</span><br><span class="line">      [Scan RS (ms): Min: 0.0, Avg: 10.1, Max: 10.9, Diff: 10.9, Sum: 334.2]</span><br><span class="line">      [Code Root Scanning (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]</span><br><span class="line">      [Object Copy (ms): Min: 0.0, Avg: 33.4, Max: 35.2, Diff: 35.2, Sum: 1102.0]</span><br><span class="line">      [Termination (ms): Min: 0.0, Avg: 10.3, Max: 10.7, Diff: 10.7, Sum: 338.8]</span><br><span class="line">         [Termination Attempts: Min: 1, Avg: 26.2, Max: 38, Diff: 37, Sum: 865]</span><br><span class="line">      [GC Worker Other (ms): Min: 0.0, Avg: 0.1, Max: 0.4, Diff: 0.3, Sum: 2.8]</span><br><span class="line">      [GC Worker Total (ms): Min: 79.2, Avg: 80.3, Max: 81.2, Diff: 2.1, Sum: 2649.0]</span><br><span class="line">      [GC Worker End (ms): Min: 21994547653.4, Avg: 21994547653.5, Max: 21994547653.5, Diff: 0.1]</span><br><span class="line">   [Code Root Fixup: 0.1 ms]</span><br><span class="line">   [Code Root Purge: 0.0 ms]</span><br><span class="line">   [Clear CT: 1.7 ms]</span><br><span class="line">   [Other: 20.3 ms]</span><br><span class="line">      [Choose CSet: 0.2 ms]</span><br><span class="line">      [Ref Proc: 16.5 ms]</span><br><span class="line">      [Ref Enq: 0.0 ms]</span><br><span class="line">      [Redirty Cards: 0.8 ms]</span><br><span class="line">      [Humongous Register: 0.2 ms]</span><br><span class="line">      [Humongous Reclaim: 0.0 ms]</span><br><span class="line">      [Free CSet: 1.9 ms]</span><br><span class="line">   [Eden: 356.0M(356.0M)-&gt;0.0B(364.0M) Survivors: 52.0M-&gt;44.0M Heap: 5822.5M(8192.0M)-&gt;5240.1M(8192.0M)]</span><br><span class="line"> [Times: user&#x3D;2.69 sys&#x3D;0.00, real&#x3D;0.10 secs] </span><br></pre></td></tr></table></figure>



<h1 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h1><p><strong>问题节点下线</strong> </p>
<p>确定为问题节点后，先将该节点下线。由于三个副本，所以对可用性不能造成影响。在该节点下线后，客户端报警解除，恢复正常。</p>
<p><strong>问题节点恢复</strong></p>
<p>问题节点为正常下线（kill -s TERM）, 当时在恢复过程中出现卡顿，其中一个分区卡顿长达20多分钟没有继续往下走。</p>
<p>尝试将该问题分区移除日志目录，重新启动，该topic又出现了其他问题的卡顿。索性将该topic的所有分区全部移除日志目录。但是依然有其他topic的分区卡顿不前，在反复近10次重启后，依然没有恢复该节点。最后使用空目录启动，节点恢复。</p>
<h1 id="问题复盘"><a href="#问题复盘" class="headerlink" title="问题复盘"></a>问题复盘</h1><p><strong>有几个问题需要澄清</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.配置了GC回收短信告警，而告警没有发出</span><br><span class="line"></span><br><span class="line">2.什么原因导致频繁的Leader选举</span><br><span class="line"></span><br><span class="line">3.GC为何不能正常回收</span><br><span class="line"></span><br><span class="line">4.为什么正常关机而重新启动后不能正常恢复</span><br><span class="line"></span><br><span class="line">故障后的第二天，需要对以上问题作出分析。</span><br></pre></td></tr></table></figure>



<p><strong>查看问题节点server日志</strong> </p>
<p>发现Unable to reconnect to ZooKeeper service出现频率非常高，没隔1到2分钟就会打印一次。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[2019-05-15 22:20:14,397] INFO Opening socket connection to server 192.168.x.x&#x2F;192.168.x.x2181. Will not attempt to authenticate using SASL (unknown error) (org.apache.zookeeper.ClientCnxn)</span><br><span class="line">[2019-05-15 22:20:14,398] INFO Socket connection established to 192.168.x.x&#x2F;192.168.x.x2181, initiating session (org.apache.zookeeper.ClientCnxn)</span><br><span class="line">[2019-05-15 22:20:14,399] WARN Unable to reconnect to ZooKeeper service, session 0x167772767ad92fd has expired (org.apache.zookeeper.ClientCnxn)</span><br><span class="line">[2019-05-15 22:20:14,399] INFO zookeeper state changed (Expired) (org.I0Itec.zkclient.ZkClient)</span><br><span class="line">[2019-05-15 22:20:14,399] INFO Updated PartitionLeaderEpoch. New: &#123;epoch:21, offset:248090181&#125;, Current: &#123;epoch:20, offset234983013&#125; for Partition: ZTO_BALANCE_SITE_LIST-7. Cache now contains 1 entries. (kafka.server.epoch.LeaderEpochFileCache)</span><br><span class="line">[2019-05-15 22:20:14,399] INFO Unable to reconnect to ZooKeeper service, session 0x167772767ad92fd has expired, closing socket connection (org.apache.zookeeper.ClientCnxn)</span><br><span class="line">[2019-05-15 22:20:14,399] INFO Initiating client connection, connectString&#x3D;192.168.x.x:2181,192.168.x.x:2181,192.168.x.x:2181 sessionTimeout&#x3D;6000 watcher&#x3D;org.I0Itec.zkclient.ZkClient@50a638b5 (org.apache.zookeeper.ZooKeeper)</span><br></pre></td></tr></table></figure>



<p><strong>查看zk日志</strong> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2019-05-15 22:49:58,992 [myid:3] - INFO  [NIOServerCxn.Factory:0.0.0.0&#x2F;0.0.0.0:2181:ZooKeeperServer@942] - Client attempting to establish new session at &#x2F;192.168.x.x:20482</span><br><span class="line">2019-05-15 22:49:58,993 [myid:3] - INFO  [CommitProcessor:3:ZooKeeperServer@687] - Established session 0x367772767999305 with negotiated timeout 6000 for client &#x2F;192.168.x.x:20482</span><br><span class="line">2019-05-15 22:49:58,994 [myid:3] - INFO  [ProcessThread(sid:3 cport:-1)::PrepRequestProcessor@648] - Got user-level KeeperException when processing sessionid:0x367772767999305 type:create cxid:0x3 zxid:0x204ae6e7d txntype:-1 reqpath:n&#x2F;a Error Path:&#x2F;brokers Error:KeeperErrorCode &#x3D; NodeExists for &#x2F;brokers</span><br><span class="line">2019-05-15 22:49:58,994 [myid:3] - INFO  [ProcessThread(sid:3 cport:-1)::PrepRequestProcessor@648] - Got user-level KeeperException when processing sessionid:0x367772767999305 type:create cxid:0x4 zxid:0x204ae6e7e txntype:-1 reqpath:n&#x2F;a Error Path:&#x2F;brokers&#x2F;ids Error:KeeperErrorCode &#x3D; NodeExists for &#x2F;brokers&#x2F;ids</span><br><span class="line">2019-05-15 22:50:01,633 [myid:3] - INFO  [NIOServerCxn.Factory:0.0.0.0&#x2F;0.0.0.0:2181:NIOServerCnxnFactory@192] - Accepted socket connection from &#x2F;127.0.0.1:14379</span><br><span class="line">2019-05-15 22:50:01,636 [myid:3] - INFO  [NIOServerCxn.Factory:0.0.0.0&#x2F;0.0.0.0:2181:ZooKeeperServer@942] - Client attempting to establish new session at &#x2F;127.0.0.1:14379</span><br><span class="line">2019-05-15 22:50:01,637 [myid:3] - INFO  [CommitProcessor:3:ZooKeeperServer@687] - Established session 0x367772767999306 with negotiated timeout 30000 for client &#x2F;127.0.0.1:14379</span><br><span class="line">2019-05-15 22:50:01,958 [myid:3] - WARN  [NIOServerCxn.Factory:0.0.0.0&#x2F;0.0.0.0:2181:NIOServerCnxn@368] - caught end of stream exception</span><br><span class="line">EndOfStreamException: Unable to read additional data from client sessionid 0x367772767999306, likely client has closed socket</span><br><span class="line">	at org.apache.zookeeper.server.NIOServerCnxn.doIO(NIOServerCnxn.java:239)</span><br><span class="line">	at org.apache.zookeeper.server.NIOServerCnxnFactory.run(NIOServerCnxnFactory.java:203)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:745)</span><br></pre></td></tr></table></figure>



<p><strong>查看GC日志</strong> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2019-05-15T22:25:59.422+0800: 21989402.560: [Full GC (Allocation Failure)  8071M-&gt;4285M(8192M), 10.3987109 secs]</span><br><span class="line">   [Eden: 0.0B(408.0M)-&gt;0.0B(408.0M) Survivors: 0.0B-&gt;0.0B Heap: 8071.2M(8192.0M)-&gt;4285.7M(8192.0M)], [Metaspace: 32321K-&gt;32321K(1077248K)]</span><br><span class="line"> [Times: user&#x3D;21.74 sys&#x3D;0.00, real&#x3D;10.39 secs] </span><br><span class="line">2019-05-15T22:26:09.824+0800: 21989412.962: [GC concurrent-mark-abort]</span><br><span class="line">2019-05-15T22:26:09.915+0800: 21989413.053: [GC pause (G1 Humongous Allocation) (young) (initial-mark), 0.0274477 secs]</span><br><span class="line">   [Parallel Time: 22.3 ms, GC Workers: 33]</span><br><span class="line">      [GC Worker Start (ms): Min: 21989413054.9, Avg: 21989413055.4, Max: 21989413055.8, Diff: 0.9]</span><br><span class="line">      [Ext Root Scanning (ms): Min: 13.3, Avg: 14.2, Max: 15.2, Diff: 1.9, Sum: 468.0]</span><br><span class="line">      [Update RS (ms): Min: 0.7, Avg: 1.2, Max: 2.1, Diff: 1.3, Sum: 40.4]</span><br><span class="line">         [Processed Buffers: Min: 1, Avg: 2.7, Max: 6, Diff: 5, Sum: 89]</span><br><span class="line">      [Scan RS (ms): Min: 0.0, Avg: 0.3, Max: 0.6, Diff: 0.6, Sum: 8.6]</span><br><span class="line">      [Code Root Scanning (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]</span><br><span class="line">      [Object Copy (ms): Min: 4.6, Avg: 5.8, Max: 6.6, Diff: 2.0, Sum: 191.1]</span><br><span class="line">      [Termination (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.4]</span><br><span class="line">         [Termination Attempts: Min: 1, Avg: 1.4, Max: 3, Diff: 2, Sum: 46]</span><br><span class="line">      [GC Worker Other (ms): Min: 0.0, Avg: 0.1, Max: 0.2, Diff: 0.2, Sum: 2.9]</span><br><span class="line">      [GC Worker Total (ms): Min: 21.1, Avg: 21.6, Max: 22.0, Diff: 0.9, Sum: 711.5]</span><br><span class="line">      [GC Worker End (ms): Min: 21989413076.9, Avg: 21989413076.9, Max: 21989413077.0, Diff: 0.2]</span><br><span class="line">   [Code Root Fixup: 0.2 ms]</span><br><span class="line">   [Code Root Purge: 0.1 ms]</span><br><span class="line">   [Clear CT: 0.5 ms]</span><br><span class="line">   [Other: 4.3 ms]</span><br><span class="line">      [Choose CSet: 0.0 ms]</span><br><span class="line">      [Ref Proc: 1.2 ms]</span><br><span class="line">      [Ref Enq: 0.0 ms]</span><br><span class="line">      [Redirty Cards: 0.9 ms]</span><br><span class="line">      [Humongous Register: 0.0 ms]</span><br><span class="line">      [Humongous Reclaim: 0.0 ms]</span><br><span class="line">      [Free CSet: 0.3 ms]</span><br><span class="line">   [Eden: 192.0M(408.0M)-&gt;0.0B(396.0M) Survivors: 0.0B-&gt;12.0M Heap: 4476.9M(8192.0M)-&gt;4295.3M(8192.0M)]</span><br><span class="line"> [Times: user&#x3D;0.73 sys&#x3D;0.00, real&#x3D;0.03 secs] </span><br><span class="line"> </span><br><span class="line"> 2019-05-15T22:26:49.312+0800: 21989452.450: [Full GC (Allocation Failure)  8056M-&gt;3891M(8192M), 10.2331784 secs]</span><br><span class="line">   [Eden: 0.0B(408.0M)-&gt;0.0B(408.0M) Survivors: 0.0B-&gt;0.0B Heap: 8056.7M(8192.0M)-&gt;3891.8M(8192.0M)], [Metaspace: 32321K-&gt;32321K(1077248K)]</span><br><span class="line"> [Times: user&#x3D;21.25 sys&#x3D;0.00, real&#x3D;10.23 secs] </span><br><span class="line">2019-05-15T22:26:59.548+0800: 21989462.686: [GC concurrent-mark-abort]</span><br><span class="line">2019-05-15T22:26:59.554+0800: 21989462.692: [GC pause (G1 Humongous Allocation) (young) (initial-mark), 0.0472311 secs]</span><br><span class="line">   [Parallel Time: 41.6 ms, GC Workers: 33]</span><br><span class="line">      [GC Worker Start (ms): Min: 21989462693.5, Avg: 21989462693.8, Max: 21989462694.2, Diff: 0.7]</span><br><span class="line">      [Ext Root Scanning (ms): Min: 14.4, Avg: 15.6, Max: 16.7, Diff: 2.4, Sum: 515.6]</span><br><span class="line">      [Update RS (ms): Min: 0.4, Avg: 1.2, Max: 5.1, Diff: 4.7, Sum: 38.4]</span><br><span class="line">         [Processed Buffers: Min: 1, Avg: 2.5, Max: 8, Diff: 7, Sum: 82]</span><br><span class="line">      [Scan RS (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.1]</span><br><span class="line">      [Code Root Scanning (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]</span><br><span class="line">      [Object Copy (ms): Min: 19.3, Avg: 23.8, Max: 25.1, Diff: 5.8, Sum: 783.9]</span><br><span class="line">      [Termination (ms): Min: 0.0, Avg: 0.2, Max: 0.2, Diff: 0.2, Sum: 5.8]</span><br><span class="line">         [Termination Attempts: Min: 1, Avg: 72.2, Max: 93, Diff: 92, Sum: 2384]</span><br><span class="line">      [GC Worker Other (ms): Min: 0.0, Avg: 0.0, Max: 0.1, Diff: 0.1, Sum: 1.6]</span><br><span class="line">      [GC Worker Total (ms): Min: 40.4, Avg: 40.8, Max: 41.1, Diff: 0.7, Sum: 1345.4]</span><br><span class="line">      [GC Worker End (ms): Min: 21989462734.6, Avg: 21989462734.6, Max: 21989462734.6, Diff: 0.1]</span><br><span class="line">   [Code Root Fixup: 0.3 ms]</span><br><span class="line">   [Code Root Purge: 0.1 ms]</span><br><span class="line">   [Clear CT: 0.8 ms]</span><br><span class="line">   [Other: 4.6 ms]</span><br><span class="line">      [Choose CSet: 0.0 ms]</span><br><span class="line">      [Ref Proc: 1.6 ms]</span><br><span class="line">      [Ref Enq: 0.0 ms]</span><br><span class="line">      [Redirty Cards: 1.1 ms]</span><br><span class="line">      [Humongous Register: 0.0 ms]</span><br><span class="line">      [Humongous Reclaim: 0.0 ms]</span><br><span class="line">      [Free CSet: 0.1 ms]</span><br><span class="line">   [Eden: 40.0M(408.0M)-&gt;0.0B(388.0M) Survivors: 0.0B-&gt;20.0M Heap: 3933.8M(8192.0M)-&gt;3912.6M(8192.0M)]</span><br></pre></td></tr></table></figure>



<p>备注：频繁Full GC, 间隔在1到2分钟，每次Full GC的时间长达10秒以上。查看server和zk日志，发现问题节点在频繁的连接zk，导致partition leader的频繁选举。</p>
<p><strong>监控查看</strong> </p>
<p>问题节点堆内存和老年代回收居高不下</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210224095739.png"></p>
<p>回收时间和回收次数明显增加</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210224095811.png"></p>
<p>网络空闲率显著高于其他节点</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210224095900.png"></p>
<p>问题节点在三天前堆内存和老年代使用开始陡增</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210224095949.png"></p>
<h1 id="复盘总结"><a href="#复盘总结" class="headerlink" title="复盘总结"></a>复盘总结</h1><ol>
<li><p>由于堆内存不能正常回收，导致频繁(1到2分钟)的Full GC.</p>
</li>
<li><p>每次Full GC长达10秒以上，导致连接zk的session过期（默认6秒）</p>
</li>
<li><p>Session的过期导致问题节点频繁重连zk集群，造成频繁Partition Leader选举</p>
</li>
</ol>
<h1 id="未尽事项"><a href="#未尽事项" class="headerlink" title="未尽事项"></a>未尽事项</h1><ol>
<li><p>由于未dump当时的堆照，分析堆内存异常原因比较困难，如果调查三天来有哪些业务使用造成的，也比较困难。</p>
</li>
<li><p>恢复GC短信告警，发生时问题时告警短信异常。</p>
</li>
<li><p>除了增加GC回收告警外，增加Full GC告警</p>
</li>
</ol>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka2# 堆内存不能正常回收问题分析（0.11.0.2版本）</title>
    <url>/posts/d1c2f69e/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>短信报警堆内存GC后依然超过4G内存，跟上篇文章所说情况相同。只是上次情况告警短信没发出来。这次介入前，dump了该节点的堆照，方便定位引起的问题。</p>
<p>告警GC日志，回收后依然在4G内存，回收前后只减少了几百M。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2019-05-26T20:41:52.086+0800: 12768164.084: [GC pause (G1 Evacuation Pause) (young), 0.0296753 secs]</span><br><span class="line">   [Parallel Time: 27.0 ms, GC Workers: 28]</span><br><span class="line">      [GC Worker Start (ms): Min: 12768164084.0, Avg: 12768164084.2, Max: 12768164084.5, Diff: 0.5]</span><br><span class="line">      [Ext Root Scanning (ms): Min: 18.1, Avg: 19.0, Max: 19.9, Diff: 1.8, Sum: 532.0]</span><br><span class="line">      [Update RS (ms): Min: 1.2, Avg: 1.7, Max: 2.3, Diff: 1.1, Sum: 47.6]</span><br><span class="line">         [Processed Buffers: Min: 1, Avg: 2.4, Max: 8, Diff: 7, Sum: 68]</span><br><span class="line">      [Scan RS (ms): Min: 1.2, Avg: 1.8, Max: 2.1, Diff: 0.9, Sum: 49.6]</span><br><span class="line">      [Code Root Scanning (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]</span><br><span class="line">      [Object Copy (ms): Min: 3.1, Avg: 3.9, Max: 4.6, Diff: 1.4, Sum: 110.6]</span><br><span class="line">      [Termination (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.4]</span><br><span class="line">         [Termination Attempts: Min: 1, Avg: 1.0, Max: 1, Diff: 0, Sum: 28]</span><br><span class="line">      [GC Worker Other (ms): Min: 0.0, Avg: 0.1, Max: 0.1, Diff: 0.1, Sum: 1.6]</span><br><span class="line">      [GC Worker Total (ms): Min: 26.2, Avg: 26.5, Max: 26.7, Diff: 0.5, Sum: 742.2]</span><br><span class="line">      [GC Worker End (ms): Min: 12768164110.7, Avg: 12768164110.7, Max: 12768164110.8, Diff: 0.1]</span><br><span class="line">   [Code Root Fixup: 0.1 ms]</span><br><span class="line">   [Code Root Purge: 0.0 ms]</span><br><span class="line">   [Clear CT: 0.7 ms]</span><br><span class="line">   [Other: 1.9 ms]</span><br><span class="line">      [Choose CSet: 0.0 ms]</span><br><span class="line">      [Ref Proc: 0.6 ms]</span><br><span class="line">      [Ref Enq: 0.0 ms]</span><br><span class="line">      [Redirty Cards: 0.3 ms]</span><br><span class="line">      [Humongous Register: 0.1 ms]</span><br><span class="line">      [Humongous Reclaim: 0.0 ms]</span><br><span class="line">      [Free CSet: 0.4 ms]</span><br><span class="line">   [Eden: 400.0M(400.0M)-&gt;0.0B(400.0M) Survivors: 8192.0K-&gt;8192.0K Heap: 4426.3M(8192.0M)-&gt;4024.2M(8192.0M)]</span><br><span class="line"> [Times: user&#x3D;0.75 sys&#x3D;0.00, real&#x3D;0.03 secs]</span><br></pre></td></tr></table></figure>



<a id="more"></a>



<h1 id="堆内存分析"><a href="#堆内存分析" class="headerlink" title="堆内存分析"></a>堆内存分析</h1><p>有个对象的内存占用高达2.5G</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210224100318.png"></p>
<p>通过图示可以看到该类：</p>
<p>org.apache.kafka.common.metrics.JmxReporter有个Map，持有高达近330万个的子Map对象。这些子Map中的结构都类似，只是clientId数值不同。</p>
<p>问题：为何消费者注册到该Reporter不删除呢？</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210224100448.png"></p>
<h1 id="代码追踪"><a href="#代码追踪" class="headerlink" title="代码追踪"></a>代码追踪</h1><p><strong>JmxReport类分析</strong> </p>
<p>下面贴出JmxReporter完整的类，成员变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private final Map&lt;String, KafkaMbean&gt; mbeans &#x3D; new HashMap&lt;String, KafkaMbean&gt;();即该mbeans持有330万个子对象。</span><br><span class="line"></span><br><span class="line">KafkaMbean中的两个成员变量：</span><br><span class="line"></span><br><span class="line">private final ObjectName objectName;</span><br><span class="line"></span><br><span class="line">private final Map&lt;String, KafkaMetric&gt; metrics;</span><br><span class="line"></span><br><span class="line">metrics中的key即为：堆分析中的kafka.server:type&#x3D;Request,client-id&#x3D;admin-3685211</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package org.apache.kafka.common.metrics;</span><br><span class="line"></span><br><span class="line">import java.lang.management.ManagementFactory;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">import javax.management.Attribute;</span><br><span class="line">import javax.management.AttributeList;</span><br><span class="line">import javax.management.AttributeNotFoundException;</span><br><span class="line">import javax.management.DynamicMBean;</span><br><span class="line">import javax.management.InvalidAttributeValueException;</span><br><span class="line">import javax.management.JMException;</span><br><span class="line">import javax.management.MBeanAttributeInfo;</span><br><span class="line">import javax.management.MBeanException;</span><br><span class="line">import javax.management.MBeanInfo;</span><br><span class="line">import javax.management.MBeanServer;</span><br><span class="line">import javax.management.MalformedObjectNameException;</span><br><span class="line">import javax.management.ObjectName;</span><br><span class="line">import javax.management.ReflectionException;</span><br><span class="line"></span><br><span class="line">import org.apache.kafka.common.KafkaException;</span><br><span class="line">import org.apache.kafka.common.MetricName;</span><br><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Register metrics in JMX as dynamic mbeans based on the metric names</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class JmxReporter implements MetricsReporter &#123;</span><br><span class="line"></span><br><span class="line">    private static final Logger log &#x3D; LoggerFactory.getLogger(JmxReporter.class);</span><br><span class="line">    private static final Object LOCK &#x3D; new Object();</span><br><span class="line">    private String prefix;</span><br><span class="line">    private final Map&lt;String, KafkaMbean&gt; mbeans &#x3D; new HashMap&lt;String, KafkaMbean&gt;();</span><br><span class="line"></span><br><span class="line">    public JmxReporter() &#123;</span><br><span class="line">        this(&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Create a JMX reporter that prefixes all metrics with the given string.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public JmxReporter(String prefix) &#123;</span><br><span class="line">        this.prefix &#x3D; prefix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configure(Map&lt;String, ?&gt; configs) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void init(List&lt;KafkaMetric&gt; metrics) &#123;</span><br><span class="line">        synchronized (LOCK) &#123;</span><br><span class="line">            for (KafkaMetric metric : metrics)</span><br><span class="line">                addAttribute(metric);</span><br><span class="line">            for (KafkaMbean mbean : mbeans.values())</span><br><span class="line">                reregister(mbean);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    boolean containsMbean(String mbeanName) &#123;</span><br><span class="line">        return mbeans.containsKey(mbeanName);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void metricChange(KafkaMetric metric) &#123;</span><br><span class="line">        synchronized (LOCK) &#123;</span><br><span class="line">            KafkaMbean mbean &#x3D; addAttribute(metric);</span><br><span class="line">            reregister(mbean);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void metricRemoval(KafkaMetric metric) &#123;</span><br><span class="line">        synchronized (LOCK) &#123;</span><br><span class="line">            MetricName metricName &#x3D; metric.metricName();</span><br><span class="line">            String mBeanName &#x3D; getMBeanName(prefix, metricName);</span><br><span class="line">            KafkaMbean mbean &#x3D; removeAttribute(metric, mBeanName);</span><br><span class="line">            if (mbean !&#x3D; null) &#123;</span><br><span class="line">                if (mbean.metrics.isEmpty()) &#123;</span><br><span class="line">                    unregister(mbean);</span><br><span class="line">                    mbeans.remove(mBeanName);</span><br><span class="line">                &#125; else</span><br><span class="line">                    reregister(mbean);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private KafkaMbean removeAttribute(KafkaMetric metric, String mBeanName) &#123;</span><br><span class="line">        MetricName metricName &#x3D; metric.metricName();</span><br><span class="line">        KafkaMbean mbean &#x3D; this.mbeans.get(mBeanName);</span><br><span class="line">        if (mbean !&#x3D; null)</span><br><span class="line">            mbean.removeAttribute(metricName.name());</span><br><span class="line">        return mbean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private KafkaMbean addAttribute(KafkaMetric metric) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            MetricName metricName &#x3D; metric.metricName();</span><br><span class="line">            String mBeanName &#x3D; getMBeanName(prefix, metricName);</span><br><span class="line">            if (!this.mbeans.containsKey(mBeanName))</span><br><span class="line">                mbeans.put(mBeanName, new KafkaMbean(mBeanName));</span><br><span class="line">            KafkaMbean mbean &#x3D; this.mbeans.get(mBeanName);</span><br><span class="line">            mbean.setAttribute(metricName.name(), metric);</span><br><span class="line">            return mbean;</span><br><span class="line">        &#125; catch (JMException e) &#123;</span><br><span class="line">            throw new KafkaException(&quot;Error creating mbean attribute for metricName :&quot; + metric.metricName(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * @param metricName</span><br><span class="line">     * @return standard JMX MBean name in the following format domainName:type&#x3D;metricType,key1&#x3D;val1,key2&#x3D;val2</span><br><span class="line">     *&#x2F;</span><br><span class="line">    static String getMBeanName(String prefix, MetricName metricName) &#123;</span><br><span class="line">        StringBuilder mBeanName &#x3D; new StringBuilder();</span><br><span class="line">        mBeanName.append(prefix);</span><br><span class="line">        mBeanName.append(&quot;:type&#x3D;&quot;);</span><br><span class="line">        mBeanName.append(metricName.group());</span><br><span class="line">        for (Map.Entry&lt;String, String&gt; entry : metricName.tags().entrySet()) &#123;</span><br><span class="line">            if (entry.getKey().length() &lt;&#x3D; 0 || entry.getValue().length() &lt;&#x3D; 0)</span><br><span class="line">                continue;</span><br><span class="line">            mBeanName.append(&quot;,&quot;);</span><br><span class="line">            mBeanName.append(entry.getKey());</span><br><span class="line">            mBeanName.append(&quot;&#x3D;&quot;);</span><br><span class="line">            mBeanName.append(entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        return mBeanName.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void close() &#123;</span><br><span class="line">        synchronized (LOCK) &#123;</span><br><span class="line">            for (KafkaMbean mbean : this.mbeans.values())</span><br><span class="line">                unregister(mbean);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void unregister(KafkaMbean mbean) &#123;</span><br><span class="line">        MBeanServer server &#x3D; ManagementFactory.getPlatformMBeanServer();</span><br><span class="line">        try &#123;</span><br><span class="line">            if (server.isRegistered(mbean.name()))</span><br><span class="line">                server.unregisterMBean(mbean.name());</span><br><span class="line">        &#125; catch (JMException e) &#123;</span><br><span class="line">            throw new KafkaException(&quot;Error unregistering mbean&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void reregister(KafkaMbean mbean) &#123;</span><br><span class="line">        unregister(mbean);</span><br><span class="line">        try &#123;</span><br><span class="line">            ManagementFactory.getPlatformMBeanServer().registerMBean(mbean, mbean.name());</span><br><span class="line">        &#125; catch (JMException e) &#123;</span><br><span class="line">            throw new KafkaException(&quot;Error registering mbean &quot; + mbean.name(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class KafkaMbean implements DynamicMBean &#123;</span><br><span class="line">        private final ObjectName objectName;</span><br><span class="line">        private final Map&lt;String, KafkaMetric&gt; metrics;</span><br><span class="line"></span><br><span class="line">        public KafkaMbean(String mbeanName) throws MalformedObjectNameException &#123;</span><br><span class="line">            this.metrics &#x3D; new HashMap&lt;String, KafkaMetric&gt;();</span><br><span class="line">            this.objectName &#x3D; new ObjectName(mbeanName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public ObjectName name() &#123;</span><br><span class="line">            return objectName;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void setAttribute(String name, KafkaMetric metric) &#123;</span><br><span class="line">            this.metrics.put(name, metric);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public Object getAttribute(String name) throws AttributeNotFoundException, MBeanException, ReflectionException &#123;</span><br><span class="line">            if (this.metrics.containsKey(name))</span><br><span class="line">                return this.metrics.get(name).value();</span><br><span class="line">            else</span><br><span class="line">                throw new AttributeNotFoundException(&quot;Could not find attribute &quot; + name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public AttributeList getAttributes(String[] names) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                AttributeList list &#x3D; new AttributeList();</span><br><span class="line">                for (String name : names)</span><br><span class="line">                    list.add(new Attribute(name, getAttribute(name)));</span><br><span class="line">                return list;</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                log.error(&quot;Error getting JMX attribute: &quot;, e);</span><br><span class="line">                return new AttributeList();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public KafkaMetric removeAttribute(String name) &#123;</span><br><span class="line">            return this.metrics.remove(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public MBeanInfo getMBeanInfo() &#123;</span><br><span class="line">            MBeanAttributeInfo[] attrs &#x3D; new MBeanAttributeInfo[metrics.size()];</span><br><span class="line">            int i &#x3D; 0;</span><br><span class="line">            for (Map.Entry&lt;String, KafkaMetric&gt; entry : this.metrics.entrySet()) &#123;</span><br><span class="line">                String attribute &#x3D; entry.getKey();</span><br><span class="line">                KafkaMetric metric &#x3D; entry.getValue();</span><br><span class="line">                attrs[i] &#x3D; new MBeanAttributeInfo(attribute,</span><br><span class="line">                                                  double.class.getName(),</span><br><span class="line">                                                  metric.metricName().description(),</span><br><span class="line">                                                  true,</span><br><span class="line">                                                  false,</span><br><span class="line">                                                  false);</span><br><span class="line">                i +&#x3D; 1;</span><br><span class="line">            &#125;</span><br><span class="line">            return new MBeanInfo(this.getClass().getName(), &quot;&quot;, attrs, null, null, null);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public Object invoke(String name, Object[] params, String[] sig) throws MBeanException, ReflectionException &#123;</span><br><span class="line">            throw new UnsupportedOperationException(&quot;Set not allowed.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void setAttribute(Attribute attribute) throws AttributeNotFoundException,</span><br><span class="line">                                                     InvalidAttributeValueException,</span><br><span class="line">                                                     MBeanException,</span><br><span class="line">                                                     ReflectionException &#123;</span><br><span class="line">            throw new UnsupportedOperationException(&quot;Set not allowed.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public AttributeList setAttributes(AttributeList list) &#123;</span><br><span class="line">            throw new UnsupportedOperationException(&quot;Set not allowed.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>Jconsole查看</strong> </p>
<p>kafka.server:type=Request</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210224100710.png"></p>
<h1 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h1><p>刚开始觉得是我们使用的问题，是否资源没有关闭，查看源代码也未能看出哪里出了问题。<br>后来确定为kafka 0.11.0.2版本的Bug，在0.11.0.3版本已经修复。</p>
<p>ISSUE<br><a href="https://issues.apache.org/jira/browse/KAFKA-6199">https://issues.apache.org/jira/browse/KAFKA-6199</a><br><a href="https://issues.apache.org/jira/browse/KAFKA-6307">https://issues.apache.org/jira/browse/KAFKA-6307</a></p>
<p>两个版本的源码对比 JmxReporter</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210224100835.png"></p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka3# 集群平滑扩容及Leader均衡</title>
    <url>/posts/ab8fecf6/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>当集群中新增加节点时，需要对已有的topic的副本进行迁移，以平衡流量。以公司集群扩增两个节点broker 4和broker 5为例说明操作过程。</p>
<p>问题：怎么做才能做到平滑呢？即尽量做到客户端应用无感知。</p>
<p>为了解决平滑问题，分为三步完成</p>
<p>1.副本均衡设置</p>
<p>​    对Topic的副本平均分配到各个broker上</p>
<p>2.偏好副本设置</p>
<p>​    将偏好副本平均分配到各个broker上, 为Leader均衡做准备</p>
<p>3.Leader均衡</p>
<p>​    执行Leader平衡</p>
<a id="more"></a>



<p><strong>要点备注</strong> </p>
<p>第一步操作要点</p>
<p>为了不影响客户端使用，保持原有集群Leader副本现状不变，将其他副本平均分配到各个broker上。</p>
<p>副本均衡设置后，需要等待与观察，最终让这些设置的副本进入ISR列表后（新加入的副本跟上了Leader副本数据进度）再执行第二步。</p>
<p>第二步操作要点</p>
<p>在第二步偏好副本设置时，将偏好副本均匀的分布broker上，每个broker上的偏好副本数量=分区总数/broker数量</p>
<p>第三步操作要点</p>
<p>这一步开始实际leader均衡操作</p>
<h1 id="副本均衡设置"><a href="#副本均衡设置" class="headerlink" title="副本均衡设置"></a>副本均衡设置</h1><p><strong>查看当前Topic的副本分配情况</strong></p>
<p>bin/kafka-topics.sh –describe –zookeeper 192.168.x.x:2181,192.168.x.x:2181,192.168.x.x:2181 –topic zto_sign_disfee</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Topic:zto_sign_disfee   PartitionCount:12       ReplicationFactor:3     Configs:</span><br><span class="line">Topic: zto_sign_disfee  Partition: 0    Leader: 2       Replicas: 2,0,3 Isr: 3,0,2</span><br><span class="line">Topic: zto_sign_disfee  Partition: 1    Leader: 0       Replicas: 0,1,3 Isr: 3,0,1</span><br><span class="line">Topic: zto_sign_disfee  Partition: 2    Leader: 1       Replicas: 1,2,3 Isr: 3,1,2</span><br><span class="line">Topic: zto_sign_disfee  Partition: 3    Leader: 2       Replicas: 2,1,3 Isr: 3,1,2</span><br><span class="line">Topic: zto_sign_disfee  Partition: 4    Leader: 0       Replicas: 0,2,3 Isr: 3,0,2</span><br><span class="line">Topic: zto_sign_disfee  Partition: 5    Leader: 1       Replicas: 1,0,2 Isr: 0,1,2</span><br><span class="line">Topic: zto_sign_disfee  Partition: 6    Leader: 2       Replicas: 2,0,1 Isr: 0,1,2</span><br><span class="line">Topic: zto_sign_disfee  Partition: 7    Leader: 0       Replicas: 0,1,3 Isr: 3,0,1</span><br><span class="line">Topic: zto_sign_disfee  Partition: 8    Leader: 1       Replicas: 1,2,0 Isr: 0,1,2</span><br><span class="line">Topic: zto_sign_disfee  Partition: 9    Leader: 2       Replicas: 2,1,3 Isr: 3,1,2</span><br><span class="line">Topic: zto_sign_disfee  Partition: 10   Leader: 0       Replicas: 0,2,3 Isr: 3,0,2</span><br><span class="line">Topic: zto_sign_disfee  Partition: 11   Leader: 1       Replicas: 1,0,3 Isr: 3,0,1</span><br></pre></td></tr></table></figure>



<p><strong>准备执行计划的Topic</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &#39;&#123;&quot;version&quot;:1,&quot;topics&quot;:[&#123;&quot;topic&quot;:&quot;zto_sign_disfee&quot;&#125;]&#125;&#39; &gt; plan02&#x2F;zto_sign_disfee.json</span><br></pre></td></tr></table></figure>



<p><strong>生成执行计划</strong></p>
<p>bin/kafka-reassign-partitions.sh –zookeeper 192.168.x.x:2181,192.168.x.x:2181,192.168.x.x:2181 –topics-to-move-json-file plan02/zto_sign_disfee.json –broker-list “0,1,2,3,4,5” –generate</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Current partition replica assignment</span><br><span class="line">&#123;&quot;version&quot;:1,&quot;partitions&quot;:[&#123;&quot;topic&quot;:&quot;zto_sign_disfee&quot;,&quot;partition&quot;:11,&quot;replicas&quot;:[1,0,3]&#125;,&#123;&quot;topic&quot;:&quot;zto_sign_disfee&quot;,&quot;partition&quot;:7,&quot;replicas&quot;:[0,1,3]&#125;,&#123;&quot;topic&quot;:&quot;zto_sign_disfee&quot;,&quot;partition&quot;:3,&quot;replicas&quot;:[2,1,3]&#125;,&#123;&quot;topic&quot;:&quot;zto_sign_disfee&quot;,&quot;partition&quot;:1,&quot;replicas&quot;:[0,1,3]&#125;,&#123;&quot;topic&quot;:&quot;zto_sign_disfee&quot;,&quot;partition&quot;:2,&quot;replicas&quot;:[1,2,3]&#125;,&#123;&quot;topic&quot;:&quot;zto_sign_disfee&quot;,&quot;partition&quot;:5,&quot;replicas&quot;:[1,0,2]&#125;,&#123;&quot;topic&quot;:&quot;zto_sign_disfee&quot;,&quot;partition&quot;:4,&quot;replicas&quot;:[0,2,3]&#125;,&#123;&quot;topic&quot;:&quot;zto_sign_disfee&quot;,&quot;partition&quot;:0,&quot;replicas&quot;:[2,0,3]&#125;,&#123;&quot;topic&quot;:&quot;zto_sign_disfee&quot;,&quot;partition&quot;:9,&quot;replicas&quot;:[2,1,3]&#125;,&#123;&quot;topic&quot;:&quot;zto_sign_disfee&quot;,&quot;partition&quot;:8,&quot;replicas&quot;:[1,2,0]&#125;,&#123;&quot;topic&quot;:&quot;zto_sign_disfee&quot;,&quot;partition&quot;:6,&quot;replicas&quot;:[2,0,1]&#125;,&#123;&quot;topic&quot;:&quot;zto_sign_disfee&quot;,&quot;partition&quot;:10,&quot;replicas&quot;:[0,2,3]&#125;]&#125;</span><br><span class="line">Proposed partition reassignment configuration</span><br><span class="line">&#123;&quot;version&quot;:1,&quot;partitions&quot;:[&#123;&quot;topic&quot;:&quot;zto_sign_disfee&quot;,&quot;partition&quot;:11,&quot;replicas&quot;:[4,3,5]&#125;,&#123;&quot;topic&quot;:&quot;zto_sign_disfee&quot;,&quot;partition&quot;:7,&quot;replicas&quot;:[0,5,1]&#125;,&#123;&quot;topic&quot;:&quot;zto_sign_disfee&quot;,&quot;partition&quot;:1,&quot;replicas&quot;:[0,4,5]&#125;,&#123;&quot;topic&quot;:&quot;zto_sign_disfee&quot;,&quot;partition&quot;:3,&quot;replicas&quot;:[2,0,1]&#125;,&#123;&quot;topic&quot;:&quot;zto_sign_disfee&quot;,&quot;partition&quot;:4,&quot;replicas&quot;:[3,1,2]&#125;,&#123;&quot;topic&quot;:&quot;zto_sign_disfee&quot;,&quot;partition&quot;:2,&quot;replicas&quot;:[1,5,0]&#125;,&#123;&quot;topic&quot;:&quot;zto_sign_disfee&quot;,&quot;partition&quot;:5,&quot;replicas&quot;:[4,2,3]&#125;,&#123;&quot;topic&quot;:&quot;zto_sign_disfee&quot;,&quot;partition&quot;:0,&quot;replicas&quot;:[5,3,4]&#125;,&#123;&quot;topic&quot;:&quot;zto_sign_disfee&quot;,&quot;partition&quot;:9,&quot;replicas&quot;:[2,1,3]&#125;,&#123;&quot;topic&quot;:&quot;zto_sign_disfee&quot;,&quot;partition&quot;:8,&quot;replicas&quot;:[1,0,2]&#125;,&#123;&quot;topic&quot;:&quot;zto_sign_disfee&quot;,&quot;partition&quot;:6,&quot;replicas&quot;:[5,4,0]&#125;,&#123;&quot;topic&quot;:&quot;zto_sign_disfee&quot;,&quot;partition&quot;:10,&quot;replicas&quot;:[3,2,4]&#125;]&#125;</span><br></pre></td></tr></table></figure>



<p><strong>重新分配副本</strong></p>
<p>zto_sign_disfee-reassign.json</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;version&quot;: 1,</span><br><span class="line">    &quot;partitions&quot;: [&#123;</span><br><span class="line">        &quot;topic&quot;: &quot;zto_sign_disfee&quot;,</span><br><span class="line">        &quot;partition&quot;: 11,</span><br><span class="line">        &quot;replicas&quot;: [1,</span><br><span class="line">        4,</span><br><span class="line">        3]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;topic&quot;: &quot;zto_sign_disfee&quot;,</span><br><span class="line">        &quot;partition&quot;: 7,</span><br><span class="line">        &quot;replicas&quot;: [0,</span><br><span class="line">        4,</span><br><span class="line">        3]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;topic&quot;: &quot;zto_sign_disfee&quot;,</span><br><span class="line">        &quot;partition&quot;: 3,</span><br><span class="line">        &quot;replicas&quot;: [2,</span><br><span class="line">        4,</span><br><span class="line">        3]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;topic&quot;: &quot;zto_sign_disfee&quot;,</span><br><span class="line">        &quot;partition&quot;: 1,</span><br><span class="line">        &quot;replicas&quot;: [0,</span><br><span class="line">        4,</span><br><span class="line">        3]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;topic&quot;: &quot;zto_sign_disfee&quot;,</span><br><span class="line">        &quot;partition&quot;: 2,</span><br><span class="line">        &quot;replicas&quot;: [1,</span><br><span class="line">        5,</span><br><span class="line">        3]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;topic&quot;: &quot;zto_sign_disfee&quot;,</span><br><span class="line">        &quot;partition&quot;: 5,</span><br><span class="line">        &quot;replicas&quot;: [1,</span><br><span class="line">        4,</span><br><span class="line">        2]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;topic&quot;: &quot;zto_sign_disfee&quot;,</span><br><span class="line">        &quot;partition&quot;: 4,</span><br><span class="line">        &quot;replicas&quot;: [0,</span><br><span class="line">        5,</span><br><span class="line">        3]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;topic&quot;: &quot;zto_sign_disfee&quot;,</span><br><span class="line">        &quot;partition&quot;: 0,</span><br><span class="line">        &quot;replicas&quot;: [2,</span><br><span class="line">        4,</span><br><span class="line">        5]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;topic&quot;: &quot;zto_sign_disfee&quot;,</span><br><span class="line">        &quot;partition&quot;: 9,</span><br><span class="line">        &quot;replicas&quot;: [2,</span><br><span class="line">        1,</span><br><span class="line">        5]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;topic&quot;: &quot;zto_sign_disfee&quot;,</span><br><span class="line">        &quot;partition&quot;: 8,</span><br><span class="line">        &quot;replicas&quot;: [1,</span><br><span class="line">        5,</span><br><span class="line">        0]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;topic&quot;: &quot;zto_sign_disfee&quot;,</span><br><span class="line">        &quot;partition&quot;: 6,</span><br><span class="line">        &quot;replicas&quot;: [2,</span><br><span class="line">        0,</span><br><span class="line">        1]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;topic&quot;: &quot;zto_sign_disfee&quot;,</span><br><span class="line">        &quot;partition&quot;: 10,</span><br><span class="line">        &quot;replicas&quot;: [0,</span><br><span class="line">        2,</span><br><span class="line">        5]</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>执行计划</strong></p>
<p>bin/kafka-reassign-partitions.sh –zookeeper 192.168.x.x:2181,192.168.x.x:2181,192.168.x.x:2181 –reassignment-json-file plan02/zto_sign_disfee-reassign.json –execute</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Current partition replica assignment</span><br><span class="line">&#123;&quot;version&quot;:1,&quot;partitions&quot;:[&#123;&quot;topic&quot;:&quot;zto_sign_disfee&quot;,&quot;partition&quot;:11,&quot;replicas&quot;:[1,0,3]&#125;,&#123;&quot;topic&quot;:&quot;zto_sign_disfee&quot;,&quot;partition&quot;:7,&quot;replicas&quot;:[0,1,3]&#125;,&#123;&quot;topic&quot;:&quot;zto_sign_disfee&quot;,&quot;partition&quot;:3,&quot;replicas&quot;:[2,1,3]&#125;,&#123;&quot;topic&quot;:&quot;zto_sign_disfee&quot;,&quot;partition&quot;:1,&quot;replicas&quot;:[0,1,3]&#125;,&#123;&quot;topic&quot;:&quot;zto_sign_disfee&quot;,&quot;partition&quot;:2,&quot;replicas&quot;:[1,2,3]&#125;,&#123;&quot;topic&quot;:&quot;zto_sign_disfee&quot;,&quot;partition&quot;:5,&quot;replicas&quot;:[1,0,2]&#125;,&#123;&quot;topic&quot;:&quot;zto_sign_disfee&quot;,&quot;partition&quot;:4,&quot;replicas&quot;:[0,2,3]&#125;,&#123;&quot;topic&quot;:&quot;zto_sign_disfee&quot;,&quot;partition&quot;:0,&quot;replicas&quot;:[2,0,3]&#125;,&#123;&quot;topic&quot;:&quot;zto_sign_disfee&quot;,&quot;partition&quot;:9,&quot;replicas&quot;:[2,1,3]&#125;,&#123;&quot;topic&quot;:&quot;zto_sign_disfee&quot;,&quot;partition&quot;:8,&quot;replicas&quot;:[1,2,0]&#125;,&#123;&quot;topic&quot;:&quot;zto_sign_disfee&quot;,&quot;partition&quot;:6,&quot;replicas&quot;:[2,0,1]&#125;,&#123;&quot;topic&quot;:&quot;zto_sign_disfee&quot;,&quot;partition&quot;:10,&quot;replicas&quot;:[0,2,3]&#125;]&#125;</span><br><span class="line">Save this to use as the --reassignment-json-file option during rollback</span><br><span class="line">Successfully started reassignment of partitions.</span><br></pre></td></tr></table></figure>



<p><strong>验证</strong> </p>
<p>bin/kafka-reassign-partitions.sh –zookeeper 192.168.x.x:2181,192.168.x.x:2181,192.168.x.x:2181 –reassignment-json-file plan02/zto_sign_disfee-reassign.json –verify</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Status of partition reassignment:</span><br><span class="line">Reassignment of partition [zto_sign_disfee,9] completed successfully</span><br><span class="line">Reassignment of partition [zto_sign_disfee,10] completed successfully</span><br><span class="line">Reassignment of partition [zto_sign_disfee,6] completed successfully</span><br><span class="line">Reassignment of partition [zto_sign_disfee,7] completed successfully</span><br><span class="line">Reassignment of partition [zto_sign_disfee,5] completed successfully</span><br><span class="line">Reassignment of partition [zto_sign_disfee,3] completed successfully</span><br><span class="line">Reassignment of partition [zto_sign_disfee,11] completed successfully</span><br><span class="line">Reassignment of partition [zto_sign_disfee,1] completed successfully</span><br><span class="line">Reassignment of partition [zto_sign_disfee,8] completed successfully</span><br><span class="line">Reassignment of partition [zto_sign_disfee,2] completed successfully</span><br><span class="line">Reassignment of partition [zto_sign_disfee,0] completed successfully</span><br><span class="line">Reassignment of partition [zto_sign_disfee,4] completed successfully</span><br></pre></td></tr></table></figure>



<p><strong>查看topic副本情况</strong></p>
<p>bin/kafka-topics.sh –describe –zookeeper 192.168.x.x:2181,192.168.x.x:2181,192.168.x.x:2181 –topic zto_sign_disfee</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Topic:zto_sign_disfee   PartitionCount:12       ReplicationFactor:3     Configs:</span><br><span class="line">Topic: zto_sign_disfee  Partition: 0    Leader: 2       Replicas: 2,4,5 Isr: 5,2,4</span><br><span class="line">Topic: zto_sign_disfee  Partition: 1    Leader: 0       Replicas: 0,4,3 Isr: 3,0,4</span><br><span class="line">Topic: zto_sign_disfee  Partition: 2    Leader: 1       Replicas: 1,5,3 Isr: 3,1,5</span><br><span class="line">Topic: zto_sign_disfee  Partition: 3    Leader: 2       Replicas: 2,4,3 Isr: 3,2,4</span><br><span class="line">Topic: zto_sign_disfee  Partition: 4    Leader: 0       Replicas: 0,5,3 Isr: 3,0,5</span><br><span class="line">Topic: zto_sign_disfee  Partition: 5    Leader: 1       Replicas: 1,4,2 Isr: 1,2,4</span><br><span class="line">Topic: zto_sign_disfee  Partition: 6    Leader: 2       Replicas: 2,0,1 Isr: 0,1,2</span><br><span class="line">Topic: zto_sign_disfee  Partition: 7    Leader: 0       Replicas: 0,4,3 Isr: 3,0,4</span><br><span class="line">Topic: zto_sign_disfee  Partition: 8    Leader: 1       Replicas: 1,5,0 Isr: 0,1,5</span><br><span class="line">Topic: zto_sign_disfee  Partition: 9    Leader: 2       Replicas: 2,1,5 Isr: 1,2,5</span><br><span class="line">Topic: zto_sign_disfee  Partition: 10   Leader: 0       Replicas: 0,2,5 Isr: 0,2,5</span><br><span class="line">Topic: zto_sign_disfee  Partition: 11   Leader: 1       Replicas: 1,4,3 Isr: 3,1,4</span><br></pre></td></tr></table></figure>



<h1 id="偏好副本设置"><a href="#偏好副本设置" class="headerlink" title="偏好副本设置"></a>偏好副本设置</h1><p><strong>准备计划文件</strong></p>
<p>zto_sign_disfee-perf-reassign.json</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;version&quot;:1,&quot;partitions&quot;:[&#123;&quot;topic&quot;:&quot;zto_sign_disfee&quot;,&quot;partition&quot;:11,&quot;replicas&quot;:[3,4,1]&#125;,&#123;&quot;topic&quot;:&quot;zto_sign_disfee&quot;,&quot;partition&quot;:7,&quot;replicas&quot;:[4,0,3]&#125;,&#123;&quot;topic&quot;:&quot;zto_sign_disfee&quot;,&quot;partition&quot;:3,&quot;replicas&quot;:[3,4,2]&#125;,&#123;&quot;topic&quot;:&quot;zto_sign_disfee&quot;,&quot;partition&quot;:1,&quot;replicas&quot;:[4,0,3]&#125;,&#123;&quot;topic&quot;:&quot;zto_sign_disfee&quot;,&quot;partition&quot;:2,&quot;replicas&quot;:[5,1,3]&#125;,&#123;&quot;topic&quot;:&quot;zto_sign_disfee&quot;,&quot;partition&quot;:5,&quot;replicas&quot;:[1,4,2]&#125;,&#123;&quot;topic&quot;:&quot;zto_sign_disfee&quot;,&quot;partition&quot;:4,&quot;replicas&quot;:[0,5,3]&#125;,&#123;&quot;topic&quot;:&quot;zto_sign_disfee&quot;,&quot;partition&quot;:0,&quot;replicas&quot;:[2,4,5]&#125;,&#123;&quot;topic&quot;:&quot;zto_sign_disfee&quot;,&quot;partition&quot;:9,&quot;replicas&quot;:[2,1,5]&#125;,&#123;&quot;topic&quot;:&quot;zto_sign_disfee&quot;,&quot;partition&quot;:8,&quot;replicas&quot;:[5,1,0]&#125;,&#123;&quot;topic&quot;:&quot;zto_sign_disfee&quot;,&quot;partition&quot;:6,&quot;replicas&quot;:[1,0,2]&#125;,&#123;&quot;topic&quot;:&quot;zto_sign_disfee&quot;,&quot;partition&quot;:10,&quot;replicas&quot;:[0,2,5]&#125;]&#125;</span><br></pre></td></tr></table></figure>



<p><strong>执行与验证</strong> </p>
<p>bin/kafka-reassign-partitions.sh –zookeeper 192.168.x.x:2181,192.168.x.x:2181,192.168.x.x:2181 –reassignment-json-file plan02/zto_sign_disfee-perf-reassign.json –execute</p>
<p>bin/kafka-reassign-partitions.sh –zookeeper 192.168.x.x:2181,192.168.x.x:2181,192.168.x.x:2181 –reassignment-json-file plan02/zto_sign_disfee-perf-reassign.json –verify</p>
<h1 id="Leader均衡"><a href="#Leader均衡" class="headerlink" title="Leader均衡"></a>Leader均衡</h1><p><strong>准备计划文件</strong> </p>
<p>zto_sign_disfee-leader-reassign.json</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;partitions&quot;:[&#123;&quot;topic&quot;:&quot;zto_sign_disfee&quot;,&quot;partition&quot;:0&#125;,&#123;&quot;topic&quot;:&quot;zto_sign_disfee&quot;,&quot;partition&quot;:1&#125;,&#123;&quot;topic&quot;:&quot;zto_sign_disfee&quot;,&quot;partition&quot;:2&#125;,&#123;&quot;topic&quot;:&quot;zto_sign_disfee&quot;,&quot;partition&quot;:3&#125;,&#123;&quot;topic&quot;:&quot;zto_sign_disfee&quot;,&quot;partition&quot;:4&#125;,&#123;&quot;topic&quot;:&quot;zto_sign_disfee&quot;,&quot;partition&quot;:5&#125;,&#123;&quot;topic&quot;:&quot;zto_sign_disfee&quot;,&quot;partition&quot;:6&#125;,&#123;&quot;topic&quot;:&quot;zto_sign_disfee&quot;,&quot;partition&quot;:7&#125;,&#123;&quot;topic&quot;:&quot;zto_sign_disfee&quot;,&quot;partition&quot;:8&#125;,&#123;&quot;topic&quot;:&quot;zto_sign_disfee&quot;,&quot;partition&quot;:9&#125;,&#123;&quot;topic&quot;:&quot;zto_sign_disfee&quot;,&quot;partition&quot;:10&#125;,&#123;&quot;topic&quot;:&quot;zto_sign_disfee&quot;,&quot;partition&quot;:11&#125;]&#125;</span><br></pre></td></tr></table></figure>



<p><strong>执行计划</strong></p>
<p>bin/kafka-preferred-replica-election.sh –zookeeper 192.168.x.x:2181,192.168.x.x:2181,192.168.x.x:2181 –path-to-json-file plan02/zto_sign_disfee-leader-reassign.json</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka4# 从0.11.0.2升级到2.2.1</title>
    <url>/posts/c9cb0a93/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="升级记录"><a href="#升级记录" class="headerlink" title="升级记录"></a>升级记录</h1><p>消息格式没有变化，只需要更改borker版本即可。</p>
<p>下载2.2.1客户端，保持原有节点配置不变增加设置0.11版本，逐台重启机器，在流入流出正常后再重启下一台，重要客户端做好观察。</p>
<p>inter.broker.protocol.version=0.11.0</p>
<p>全部正常后，再设置broker版本到2.2，逐台重启机器，在流入流出正常后再重启下一台，重要客户端做好观察。</p>
<p>inter.broker.protocol.version=2.2</p>
<a id="more"></a>



<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>在客户端版本使用0.9或者更低版本时会出现以下错误，升级后异常可解决。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210224101154.png"></p>
<h1 id="官方升级文档"><a href="#官方升级文档" class="headerlink" title="官方升级文档"></a>官方升级文档</h1><p><a href="https://kafka.apache.org/22/documentation.html#upgrade">https://kafka.apache.org/22/documentation.html#upgrade</a></p>
<p>1.5 Upgrading From Previous Versions</p>
<p>Upgrading from 0.8.x, 0.9.x, 0.10.0.x, 0.10.1.x, 0.10.2.x, 0.11.0.x, 1.0.x, 1.1.x, 2.0.x or 2.1.x to 2.2.0</p>
<p>If you are upgrading from a version prior to 2.1.x, please see the note below about the change to the schema used to store consumer offsets. Once you have changed the inter.broker.protocol.version to the latest version, it will not be possible to downgrade to a version prior to 2.1.</p>
<p>For a rolling upgrade:</p>
<p>Update server.properties on all brokers and add the following properties. CURRENT_KAFKA_VERSION refers to the version you are upgrading from. CURRENT_MESSAGE_FORMAT_VERSION refers to the message format version currently in use. If you have previously overridden the message format version, you should keep its current value. Alternatively, if you are upgrading from a version prior to 0.11.0.x, then CURRENT_MESSAGE_FORMAT_VERSION should be set to match CURRENT_KAFKA_VERSION.</p>
<p>inter.broker.protocol.version=CURRENT_KAFKA_VERSION (e.g. 0.8.2, 0.9.0, 0.10.0, 0.10.1, 0.10.2, 0.11.0, 1.0, 1.1).</p>
<p>log.message.format.version=CURRENT_MESSAGE_FORMAT_VERSION (See potential performance impact following the upgrade for the details on what this configuration does.)</p>
<p>If you are upgrading from 0.11.0.x, 1.0.x, 1.1.x, or 2.0.x and you have not overridden the message format, then you only need to override the inter-broker protocol version.</p>
<p>inter.broker.protocol.version=CURRENT_KAFKA_VERSION (0.11.0, 1.0, 1.1, 2.0).</p>
<p>Upgrade the brokers one at a time: shut down the broker, update the code, and restart it. Once you have done so, the brokers will be running the latest version and you can verify that the cluster’s behavior and performance meets expectations. It is still possible to downgrade at this point if there are any problems.</p>
<p>Once the cluster’s behavior and performance has been verified, bump the protocol version by editing inter.broker.protocol.version and setting it to 2.2.</p>
<p>Restart the brokers one by one for the new protocol version to take effect. Once the brokers begin using the latest protocol version, it will no longer be possible to downgrade the cluster to an older version.</p>
<p>If you have overridden the message format version as instructed above, then you need to do one more rolling restart to upgrade it to its latest version. Once all (or most) consumers have been upgraded to 0.11.0 or later, change log.message.format.version to 2.2 on each broker and restart them one by one. Note that the older Scala clients, which are no longer maintained, do not support the message format introduced in 0.11, so to avoid conversion costs (or to take advantage of exactly once semantics), the newer Java clients must be used.</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka5# 常用JMX监控指标整理</title>
    <url>/posts/9bbf6c38/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">系统相关指标</span><br><span class="line">GC相关指标</span><br><span class="line">JVM相关指标</span><br><span class="line">Topic相关指标</span><br><span class="line">Broker相关指标</span><br></pre></td></tr></table></figure>



<h1 id="系统相关指标"><a href="#系统相关指标" class="headerlink" title="系统相关指标"></a>系统相关指标</h1><p><strong>系统信息收</strong></p>
<p>java.lang:type=OperatingSystem</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;freePhysicalMemorySize&quot;:&quot;806023168&quot;,&quot;maxFileDescriptorCount&quot;:&quot;4096&quot;,&quot;openFileDescriptorCount&quot;:&quot;283&quot;,&quot;processCpuLoad&quot;:&quot;0.0017562901839817224&quot;,&quot;systemCpuLoad&quot;:&quot;0.014336627412954635&quot;,&quot;systemLoadAverage&quot;:&quot;0.37&quot;&#125;</span><br></pre></td></tr></table></figure>



<p><strong>Thread信息收集</strong></p>
<p>java.lang:type=Threading</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;peakThreadCount&quot;:&quot;88&quot;,&quot;threadCount&quot;:&quot;74&quot;&#125;</span><br></pre></td></tr></table></figure>



<p><strong>获取mmaped和direct空间</strong></p>
<p>通过BufferPoolMXBean获取used、capacity、count</p>
<a id="more"></a>



<h1 id="GC相关指标"><a href="#GC相关指标" class="headerlink" title="GC相关指标"></a>GC相关指标</h1><p><strong>Young GC</strong></p>
<p>java.lang:type=GarbageCollector,name=G1 Young Generation</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;collectionCount&quot;:&quot;534&quot;,&quot;collectionTime&quot;:&quot;8258&quot;&#125;</span><br></pre></td></tr></table></figure>



<p><strong>Old GC</strong></p>
<p>java.lang:type=GarbageCollector,name=G1 Old Generation</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;collectionCount&quot;:&quot;0&quot;,&quot;collectionTime&quot;:&quot;0&quot;&#125;</span><br></pre></td></tr></table></figure>



<h1 id="JVM相关指标"><a href="#JVM相关指标" class="headerlink" title="JVM相关指标"></a>JVM相关指标</h1><p>通过MemoryMXBean获取JVM相关信息HeapMemoryUsage和NonHeapMemoryUsage；通过MemoryPoolMXBean获取其他JVM内存空间指标，例如：Metaspace、Codespace等</p>
<h1 id="Topic相关指标"><a href="#Topic相关指标" class="headerlink" title="Topic相关指标"></a>Topic相关指标</h1><p><strong>Topic消息入站速率（Byte）</strong></p>
<p>kafka.server:type=BrokerTopicMetrics,name=BytesInPerSec,topic=” + topic</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;count&quot;:&quot;0&quot;,&quot;fifteenMinuteRate&quot;:&quot;0.0&quot;,&quot;fiveMinuteRate&quot;:&quot;0.0&quot;,&quot;meanRate&quot;:&quot;0.0&quot;,&quot;oneMinuteRate&quot;:&quot;0.0&quot;&#125;</span><br></pre></td></tr></table></figure>



<p><strong>Topic消息出站速率（Byte）</strong></p>
<p>kafka.server:type=BrokerTopicMetrics,name=BytesOutPerSec,topic=” + topic</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;count&quot;:&quot;0&quot;,&quot;fifteenMinuteRate&quot;:&quot;0.0&quot;,&quot;fiveMinuteRate&quot;:&quot;0.0&quot;,&quot;meanRate&quot;:&quot;0.0&quot;,&quot;oneMinuteRate&quot;:&quot;0.0&quot;&#125;</span><br></pre></td></tr></table></figure>



<p><strong>Topic请求被拒速率</strong></p>
<p>kafka.server:type=BrokerTopicMetrics,name=BytesRejectedPerSec,topic=” + topic</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;count&quot;:&quot;0&quot;,&quot;fifteenMinuteRate&quot;:&quot;0.0&quot;,&quot;fiveMinuteRate&quot;:&quot;0.0&quot;,&quot;meanRate&quot;:&quot;0.0&quot;,&quot;oneMinuteRate&quot;:&quot;0.0&quot;&#125;</span><br></pre></td></tr></table></figure>



<p><strong>Topic失败拉去请求速</strong></p>
<p>kafka.server:type=BrokerTopicMetrics,name=FailedFetchRequestsPerSec,topic=” + topic;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;count&quot;:&quot;0&quot;,&quot;fifteenMinuteRate&quot;:&quot;0.0&quot;,&quot;fiveMinuteRate&quot;:&quot;0.0&quot;,&quot;meanRate&quot;:&quot;0.0&quot;,&quot;oneMinuteRate&quot;:&quot;0.0&quot;&#125;</span><br></pre></td></tr></table></figure>



<p><strong>Topic发送请求失败速</strong></p>
<p>kafka.server:type=BrokerTopicMetrics,name=FailedProduceRequestsPerSec,topic=” + topic</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;count&quot;:&quot;0&quot;,&quot;fifteenMinuteRate&quot;:&quot;0.0&quot;,&quot;fiveMinuteRate&quot;:&quot;0.0&quot;,&quot;meanRate&quot;:&quot;0.0&quot;,&quot;oneMinuteRate&quot;:&quot;0.0&quot;&#125;</span><br></pre></td></tr></table></figure>



<p><strong>Topic消息入站速率</strong></p>
<p>kafka.server:type=BrokerTopicMetrics,name=MessagesInPerSec,topic=” + topic</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;count&quot;:&quot;0&quot;,&quot;fifteenMinuteRate&quot;:&quot;0.0&quot;,&quot;fiveMinuteRate&quot;:&quot;0.0&quot;,&quot;meanRate&quot;:&quot;0.0&quot;,&quot;oneMinuteRate&quot;:&quot;0.0&quot;&#125;</span><br></pre></td></tr></table></figure>



<h1 id="Broker相关指标"><a href="#Broker相关指标" class="headerlink" title="Broker相关指标"></a>Broker相关指标</h1><p><strong>Log flush rate and time</strong></p>
<p>kafka.log:type=LogFlushStats,name=LogFlushRateAndTimeMs</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;50thPercentile&quot;:&quot;1.074103&quot;,&quot;75thPercentile&quot;:&quot;1.669793&quot;,&quot;95thPercentile&quot;:&quot;6.846556&quot;,&quot;98thPercentile&quot;:&quot;6.846556&quot;,&quot;999thPercentile&quot;:&quot;6.846556&quot;,&quot;99thPercentile&quot;:&quot;6.846556&quot;,&quot;count&quot;:&quot;19&quot;,&quot;max&quot;:&quot;6.846556&quot;,&quot;mean&quot;:&quot;1.628646052631579&quot;,&quot;min&quot;:&quot;0.512879&quot;,&quot;stdDev&quot;:&quot;1.6007003364105892&quot;&#125;</span><br></pre></td></tr></table></figure>



<p><strong>同步失效的副本数</strong></p>
<p>kafka.server:type=ReplicaManager,name=UnderReplicatedPartitions</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;value&quot;:&quot;0&quot;&#125;</span><br></pre></td></tr></table></figure>



<p><strong>消息入站速率（消息数）</strong></p>
<p>kafka.server:type=BrokerTopicMetrics,name=MessagesInPerSec</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;count&quot;:&quot;86845&quot;,&quot;fifteenMinuteRate&quot;:&quot;0.6456600497006455&quot;,&quot;fiveMinuteRate&quot;:&quot;0.6444164288097876&quot;,&quot;meanRate&quot;:&quot;0.5314899330400695&quot;,&quot;oneMinuteRate&quot;:&quot;0.6494649408329609&quot;&#125;</span><br></pre></td></tr></table></figure>



<p><strong>消息入站速率（Byte）</strong></p>
<p>kafka.server:type=BrokerTopicMetrics,name=BytesInPerSec</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;count&quot;:&quot;57302357&quot;,&quot;fifteenMinuteRate&quot;:&quot;379.11342092748146&quot;,&quot;fiveMinuteRate&quot;:&quot;371.8482236385939&quot;,&quot;meanRate&quot;:&quot;351.37122686037435&quot;,&quot;oneMinuteRate&quot;:&quot;351.8348952308101&quot;&#125;</span><br></pre></td></tr></table></figure>



<p><strong>消息出站速率（Byte）</strong></p>
<p>kafka.server:type=BrokerTopicMetrics,name=BytesOutPerSec</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;count&quot;:&quot;246&quot;,&quot;fifteenMinuteRate&quot;:&quot;4.508738367219028E-34&quot;,&quot;fiveMinuteRate&quot;:&quot;1.4721921790135324E-98&quot;,&quot;meanRate&quot;:&quot;0.0015031168286836175&quot;,&quot;oneMinuteRate&quot;:&quot;2.964393875E-314&quot;&#125;</span><br></pre></td></tr></table></figure>



<p><strong>请求被拒速率</strong> </p>
<p>kafka.server:type=BrokerTopicMetrics,name=BytesRejectedPerSec</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;count&quot;:&quot;0&quot;,&quot;fifteenMinuteRate&quot;:&quot;0.0&quot;,&quot;fiveMinuteRate&quot;:&quot;0.0&quot;,&quot;meanRate&quot;:&quot;0.0&quot;,&quot;oneMinuteRate&quot;:&quot;0.0&quot;&#125;</span><br></pre></td></tr></table></figure>



<p><strong>失败拉去请求速率</strong></p>
<p>kafka.server:type=BrokerTopicMetrics,name=FailedFetchRequestsPerSec</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;count&quot;:&quot;0&quot;,&quot;fifteenMinuteRate&quot;:&quot;0.0&quot;,&quot;fiveMinuteRate&quot;:&quot;0.0&quot;,&quot;meanRate&quot;:&quot;0.0&quot;,&quot;oneMinuteRate&quot;:&quot;0.0&quot;&#125;</span><br></pre></td></tr></table></figure>



<p><strong>发送请求失败速率</strong></p>
<p>kafka.server:type=BrokerTopicMetrics,name=FailedProduceRequestsPerSec</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;count&quot;:&quot;0&quot;,&quot;fifteenMinuteRate&quot;:&quot;0.0&quot;,&quot;fiveMinuteRate&quot;:&quot;0.0&quot;,&quot;meanRate&quot;:&quot;0.0&quot;,&quot;oneMinuteRate&quot;:&quot;0.0&quot;&#125;</span><br></pre></td></tr></table></figure>



<p><strong>Leader副本数</strong></p>
<p>kafka.server:type=ReplicaManager,name=LeaderCount</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;value&quot;:&quot;92&quot;&#125;</span><br></pre></td></tr></table></figure>



<p><strong>Partition数量</strong></p>
<p>kafka.server:type=ReplicaManager,name=PartitionCount</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;value&quot;:&quot;135&quot;&#125;</span><br></pre></td></tr></table></figure>



<p><strong>下线Partition数量</strong></p>
<p>kafka.controller:type=KafkaController,name=OfflinePartitionsCount</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;value&quot;:&quot;0&quot;&#125;</span><br></pre></td></tr></table></figure>



<p><strong>Broker网络处理线程</strong></p>
<p>kafka.server:type=KafkaRequestHandlerPool,name=RequestHandlerAvgIdlePercent</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;count&quot;:&quot;164506926671008&quot;,&quot;fifteenMinuteRate&quot;:&quot;0.9999327359820058&quot;,&quot;fiveMinuteRate&quot;:&quot;1.0000290054537715&quot;,&quot;meanRate&quot;:&quot;0.9998854371393514&quot;,&quot;oneMinuteRate&quot;:&quot;1.0007836499581673&quot;&#125;</span><br></pre></td></tr></table></figure>



<p><strong>Leader选举比率</strong></p>
<p>kafka.controller:type=ControllerStats,name=LeaderElectionRateAndTimeMs</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;count&quot;:&quot;7&quot;,&quot;fifteenMinuteRate&quot;:&quot;5.134993718576819E-82&quot;,&quot;fiveMinuteRate&quot;:&quot;6.882658450509451E-240&quot;,&quot;meanRate&quot;:&quot;4.2525243043608314E-5&quot;,&quot;oneMinuteRate&quot;:&quot;2.964393875E-314&quot;&#125;</span><br></pre></td></tr></table></figure>



<p><strong>Unclean Leader选举比率</strong></p>
<p>kafka.controller:type=ControllerStats,name=UncleanLeaderElectionsPerSec</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;count&quot;:&quot;0&quot;,&quot;fifteenMinuteRate&quot;:&quot;0.0&quot;,&quot;fiveMinuteRate&quot;:&quot;0.0&quot;,&quot;meanRate&quot;:&quot;0.0&quot;,&quot;oneMinuteRate&quot;:&quot;0.0&quot;&#125;</span><br></pre></td></tr></table></figure>



<p><strong>Controller存活</strong></p>
<p>kafka.controller:type=KafkaController,name=ActiveControllerCount</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;value&quot;:&quot;1&quot;&#125;</span><br></pre></td></tr></table></figure>



<p><strong>请求速率</strong></p>
<p>kafka.network:type=RequestMetrics,name=RequestsPerSec,request=Produce</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;count&quot;:&quot;83233&quot;,&quot;fifteenMinuteRate&quot;:&quot;0.6303485369828705&quot;,&quot;fiveMinuteRate&quot;:&quot;0.6357199085092445&quot;,&quot;meanRate&quot;:&quot;0.5046486472186744&quot;,&quot;oneMinuteRate&quot;:&quot;0.6563203475530601&quot;&#125;</span><br></pre></td></tr></table></figure>



<p><strong>Consumer拉取速率</strong></p>
<p>kafka.network:type=RequestMetrics,name=RequestsPerSec,request=FetchConsumer</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;count&quot;:&quot;125796&quot;,&quot;fifteenMinuteRate&quot;:&quot;1.14193044007404E-33&quot;,&quot;fiveMinuteRate&quot;:&quot;7.699516480260211E-100&quot;,&quot;meanRate&quot;:&quot;0.7623419964866819&quot;,&quot;oneMinuteRate&quot;:&quot;2.964393875E-314&quot;&#125;</span><br></pre></td></tr></table></figure>



<p><strong>Follower拉去速率</strong></p>
<p>kafka.network:type=RequestMetrics,name=RequestsPerSec,request=FetchFollower</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;count&quot;:&quot;375108&quot;,&quot;fifteenMinuteRate&quot;:&quot;2.302746562040189&quot;,&quot;fiveMinuteRate&quot;:&quot;2.292459728166488&quot;,&quot;meanRate&quot;:&quot;2.2721808581484693&quot;,&quot;oneMinuteRate&quot;:&quot;2.2814260196672973&quot;&#125;</span><br></pre></td></tr></table></figure>



<p><strong>Request total time</strong></p>
<p>kafka.network:type=RequestMetrics,name=TotalTimeMs,request=Produce</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;50thPercentile&quot;:&quot;1.0&quot;,&quot;75thPercentile&quot;:&quot;1.0&quot;,&quot;95thPercentile&quot;:&quot;2.0&quot;,&quot;98thPercentile&quot;:&quot;2.0&quot;,&quot;999thPercentile&quot;:&quot;28.0&quot;,&quot;99thPercentile&quot;:&quot;4.0&quot;,&quot;count&quot;:&quot;83384&quot;,&quot;max&quot;:&quot;48.0&quot;,&quot;mean&quot;:&quot;1.2344934279957787&quot;,&quot;min&quot;:&quot;0.0&quot;,&quot;stdDev&quot;:&quot;1.1783192073287214&quot;&#125;</span><br></pre></td></tr></table></figure>



<p><strong>Consumer fetch total time</strong></p>
<p>kafka.network:type=RequestMetrics,name=TotalTimeMs,request=FetchConsumer</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;50thPercentile&quot;:&quot;500.0&quot;,&quot;75thPercentile&quot;:&quot;501.0&quot;,&quot;95thPercentile&quot;:&quot;501.0&quot;,&quot;98thPercentile&quot;:&quot;501.0&quot;,&quot;999thPercentile&quot;:&quot;501.971&quot;,&quot;99thPercentile&quot;:&quot;501.0&quot;,&quot;count&quot;:&quot;125796&quot;,&quot;max&quot;:&quot;535.0&quot;,&quot;mean&quot;:&quot;499.83123469744663&quot;,&quot;min&quot;:&quot;0.0&quot;,&quot;stdDev&quot;:&quot;17.138716708632025&quot;&#125;</span><br></pre></td></tr></table></figure>



<p><strong>Follower fetch total time</strong></p>
<p>kafka.network:type=RequestMetrics,name=TotalTimeMs,request=FetchFollower</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;50thPercentile&quot;:&quot;500.0&quot;,&quot;75thPercentile&quot;:&quot;500.0&quot;,&quot;95thPercentile&quot;:&quot;501.0&quot;,&quot;98thPercentile&quot;:&quot;501.0&quot;,&quot;999thPercentile&quot;:&quot;507.826&quot;,&quot;99thPercentile&quot;:&quot;501.0&quot;,&quot;count&quot;:&quot;375564&quot;,&quot;max&quot;:&quot;532.0&quot;,&quot;mean&quot;:&quot;437.79763502359117&quot;,&quot;min&quot;:&quot;0.0&quot;,&quot;stdDev&quot;:&quot;148.25999023472986&quot;&#125;</span><br></pre></td></tr></table></figure>



<p><strong>Time the follower fetch request waits in the request queue</strong></p>
<p>kafka.network:type=RequestMetrics,name=RequestQueueTimeMs,request=FetchFollo</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;50thPercentile&quot;:&quot;0.0&quot;,&quot;75thPercentile&quot;:&quot;0.0&quot;,&quot;95thPercentile&quot;:&quot;0.0&quot;,&quot;98thPercentile&quot;:&quot;0.0&quot;,&quot;999thPercentile&quot;:&quot;0.0&quot;,&quot;99thPercentile&quot;:&quot;0.0&quot;,&quot;count&quot;:&quot;376206&quot;,&quot;max&quot;:&quot;28.0&quot;,&quot;mean&quot;:&quot;0.0010260336092459982&quot;,&quot;min&quot;:&quot;0.0&quot;,&quot;stdDev&quot;:&quot;0.1282889653905258&quot;&#125;</span><br></pre></td></tr></table></figure>



<p><strong>Time the Consumer fetch request waits in the request queue</strong></p>
<p>kafka.network:type=RequestMetrics,name=RequestQueueTimeMs,request=FetchConsumer</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;50thPercentile&quot;:&quot;0.0&quot;,&quot;75thPercentile&quot;:&quot;0.0&quot;,&quot;95thPercentile&quot;:&quot;0.0&quot;,&quot;98thPercentile&quot;:&quot;0.0&quot;,&quot;999thPercentile&quot;:&quot;0.0&quot;,&quot;99thPercentile&quot;:&quot;0.0&quot;,&quot;count&quot;:&quot;125796&quot;,&quot;max&quot;:&quot;24.0&quot;,&quot;mean&quot;:&quot;0.0018124582657636174&quot;,&quot;min&quot;:&quot;0.0&quot;,&quot;stdDev&quot;:&quot;0.18122860552537737&quot;&#125;</span><br></pre></td></tr></table></figure>



<p><strong>Time the Produce fetch request waits in the request queue</strong></p>
<p>kafka.network:type=RequestMetrics,name=RequestQueueTimeMs,request=Produce</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;50thPercentile&quot;:&quot;0.0&quot;,&quot;75thPercentile&quot;:&quot;0.0&quot;,&quot;95thPercentile&quot;:&quot;0.0&quot;,&quot;98thPercentile&quot;:&quot;0.0&quot;,&quot;999thPercentile&quot;:&quot;0.0&quot;,&quot;99thPercentile&quot;:&quot;0.0&quot;,&quot;count&quot;:&quot;83704&quot;,&quot;max&quot;:&quot;12.0&quot;,&quot;mean&quot;:&quot;2.6283092803211315E-4&quot;,&quot;min&quot;:&quot;0.0&quot;,&quot;stdDev&quot;:&quot;0.042892540270754634&quot;&#125;</span><br></pre></td></tr></table></figure>



<p><strong>Broker I/O工作处理线程空闲率</strong></p>
<p>kafka.network:type=SocketServer,name=NetworkProcessorAvgIdlePercent</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;value&quot;:&quot;1.0015540075894207&quot;&#125;</span><br></pre></td></tr></table></figure>



<p><strong>ISR变化速率</strong></p>
<p>kafka.server:type=ReplicaManager,name=IsrShrinksPerSec</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;count&quot;:&quot;0&quot;,&quot;fifteenMinuteRate&quot;:&quot;0.0&quot;,&quot;fiveMinuteRate&quot;:&quot;0.0&quot;,&quot;meanRate&quot;:&quot;0.0&quot;,&quot;oneMinuteRate&quot;:&quot;0.0&quot;&#125;</span><br></pre></td></tr></table></figure>





</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka6# Producer重试参数retries设置取舍</title>
    <url>/posts/f3ea839a/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="retries参数说明"><a href="#retries参数说明" class="headerlink" title="retries参数说明"></a>retries参数说明</h1><p>参数的设置通常是一种取舍，看下retries参数在版本0.11.3说明：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Setting a value greater than zero will cause the client to resend</span><br><span class="line"></span><br><span class="line">any record whose send fails with a potentially transient error.</span><br><span class="line"></span><br><span class="line">Note that this retry is no different than if the client resent the</span><br><span class="line"></span><br><span class="line">record upon receiving the error.</span><br><span class="line"></span><br><span class="line">Allowing retries without setting max.in.flight.requests.per.connection to 1 will potentially change</span><br><span class="line"></span><br><span class="line">the ordering of records because if two batches are sent to a single</span><br><span class="line"></span><br><span class="line">partition, and the first fails and is retried but the second succeeds,</span><br><span class="line"></span><br><span class="line">then the records in the second batch may appear first.</span><br></pre></td></tr></table></figure>



<p>备注：当发送失败时客户端会进行重试，重试的次数由retries指定，此参数默认设置为0。即：快速失败模式，当发送失败时由客户端来处理后续是否要进行继续发送。如果设置retries大于0而没有设置max.in.flight.requests.per.connection=1则意味着放弃发送消息的顺序性。</p>
<a id="more"></a>



<h1 id="retries使用建议"><a href="#retries使用建议" class="headerlink" title="retries使用建议"></a>retries使用建议</h1><p>使用retries的默认值交给使用方自己去控制，结果往往是不处理。所以通用设置建议设置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">retries &#x3D; Integer.MAX_VALUE</span><br><span class="line"></span><br><span class="line">max.in.flight.requests.per.connection &#x3D; 1</span><br></pre></td></tr></table></figure>



<p>备注：这样设置后，发送客户端会一直进行重试直到broker返回ack；同时只有一个连接向broker发送数据保证了数据的顺序性。在Leader选举、集群中一个broker挂掉时，发送端会一直重试直到Leader选举结束。避免由于客户端对异常未处理造成的数据丢失，例如：遇到类似“This server is not the leader for that topic-partition”会自动恢复。</p>
<h1 id="retries后续发展"><a href="#retries后续发展" class="headerlink" title="retries后续发展"></a>retries后续发展</h1><p>该参数的设置已经在kafka 2.4版本中默认设置为Integer.MAX_VALUE；同时增加了delivery.timeout.ms的参数设置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The default value for the producer&#39;s retries config was changed to</span><br><span class="line"></span><br><span class="line">Integer.MAX_VALUE, as we introduced delivery.timeout.ms in KIP-91,</span><br><span class="line"></span><br><span class="line">which sets an upper bound on the total time between sending a</span><br><span class="line"></span><br><span class="line">record and receiving acknowledgement from the broker.</span><br><span class="line"></span><br><span class="line">By default, the delivery timeout is set to 2 minutes.</span><br><span class="line"></span><br><span class="line">KIP-91: https:&#x2F;&#x2F;cwiki.apache.org&#x2F;confluence&#x2F;display&#x2F;KAFKA&#x2F;KIP-91+Provide+Intuitive+User+Timeouts+in+The+Producer</span><br></pre></td></tr></table></figure>

</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka6# 常用JMX监控指标整理</title>
    <url>/posts/df1e4920/</url>
    <content><![CDATA[<div id="vip-container"><p>本文盘点下到Kafka 2.4.1版本以来的一些亮点，这些亮点或笔者实际中踩过的坑、或可能将来会在实践中使用、或个人关注的，点击官方发布日志连接查看全貌。</p>
<h1 id="0-11-0-3"><a href="#0-11-0-3" class="headerlink" title="0.11.0.3"></a>0.11.0.3</h1><p>0.11.0.2于2017年11月17日发布；0.11.0.3于2018年6月2日发布修订版本。</p>
<p>其中修复了0.11.0.2以前的一个BUG，该Bug曾导致过生产事故；即堆内存不能正常回收，频繁Full GC。详见：Kafka(0.11.0.2版本)堆内存不能正常回收问题分析【实战笔记】[<a href="https://issues.apache.org/jira/browse/KAFKA-6307">KAFKA-6307</a>]</p>
<p><a href="https://archive.apache.org/dist/kafka/0.11.0.3/RELEASE_NOTES.html">0.11.0.3官方发布日志</a></p>
<a id="more"></a>



<h1 id="1-0-0"><a href="#1-0-0" class="headerlink" title="1.0.0"></a>1.0.0</h1><p>1.0.0于2017年11月1日发布；1.0.1于2018年3月5日发布；1.0.2于2018年6月8日发布。</p>
<p>增强各个组件的稳定性。可以容忍JBOD磁盘故障，故障时不再导致broker崩溃，会保留可用磁盘上的日志文件。<a href="https://issues.apache.org/jira/browse/KAFKA-4763">[KAFKA-4763]</a></p>
<p>幂等生产者或者我们要保证消息顺序性时需要设置max.in.flight.requests.per.connection=1；1.0.0之后可以最大设置为5，从而提升投递性能。<a href="https://issues.apache.org/jira/browse/KAFKA-5494">[KAFKA-5494]</a></p>
<p><a href="https://archive.apache.org/dist/kafka/1.0.0/RELEASE_NOTES.html">1.0.0官方发布日志</a></p>
<p><a href="https://archive.apache.org/dist/kafka/1.0.1/RELEASE_NOTES.html">1.0.1官方发布日志</a></p>
<p><a href="https://archive.apache.org/dist/kafka/1.0.2/RELEASE_NOTES.html">1.0.2官方发布日志</a></p>
<h1 id="1-1-0"><a href="#1-1-0" class="headerlink" title="1.1.0"></a>1.1.0</h1><p>1.1.0于2018年3月28日发布；1.1.1于2018年6月19日发布</p>
<p>1.1.0通过将同步方式修改为异步方式，提升了KafkaI使Controller的shutdown速度；由于Controller性能的改进促使集群可以支持20万个分区。<a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-227%3A+Introduce+Incremental+FetchRequests+to+Increase+Partition+Scalability?S_TACT=M16103KW">[KIP-227]</a></p>
<p><a href="https://www.confluent.io/blog/apache-kafka-supports-200k-partitions-per-cluster/">Apache Kafka Supports 200K Partitions Per Cluster</a></p>
<p><a href="https://www.cnblogs.com/huxi2b/p/9984523.html">Apache Kafka支持单集群20万分区</a></p>
<p>增加了对单broker日志目录之间的数据迁移，例如：一个broker下挂了多个磁盘，当各个分区出现不均衡时，1.1.0之后支持该broker磁盘将分区迁移实现数据均衡。<a href="https://issues.apache.org/jira/browse/KAFKA-5163">[KAFKA-5163]</a></p>
<p><a href="https://archive.apache.org/dist/kafka/1.1.0/RELEASE_NOTES.html">1.1.0官方发布日志</a></p>
<p><a href="https://archive.apache.org/dist/kafka/1.1.1/RELEASE_NOTES.html">1.1.1官方发布日志</a></p>
<h1 id="2-0-0"><a href="#2-0-0" class="headerlink" title="2.0.0"></a>2.0.0</h1><p>2.0.0于2018年6月30日发布；2.0.1于2018年11月9日发布；增加了主题前缀或通配符的ACL的支持，从而简化了大型安全部署中的访问控制管理。<a href="https://issues.apache.org/jira/browse/KAFKA-6841">[KAFKA-6841]</a></p>
<p>支持OAuth 2.0认证<a href="https://issues.apache.org/jira/browse/KAFKA-6562">[KAFKA-6562]</a></p>
<p><a href="https://archive.apache.org/dist/kafka/2.0.0/RELEASE_NOTES.html">2.0.0官方发布日志</a></p>
<p><a href="https://archive.apache.org/dist/kafka/2.0.1/RELEASE_NOTES.html">2.0.1官方发布日志</a></p>
<h1 id="2-1-0"><a href="#2-1-0" class="headerlink" title="2.1.0"></a>2.1.0</h1><p>2.1.0于2018年11月20日发布；2.1.1于2019年2月15日发布。</p>
<p>支持Zstandard压缩算法</p>
<p><a href="https://issues.apache.org/jira/browse/KAFKA-4514">[KAFKA-4514]</a></p>
<p><a href="https://archive.apache.org/dist/kafka/2.1.0/RELEASE_NOTES.html">2.1.0官方发布日志</a></p>
<p><a href="https://archive.apache.org/dist/kafka/2.1.1/RELEASE_NOTES.html">2.1.1官方发布日志</a></p>
<h1 id="2-2-0"><a href="#2-2-0" class="headerlink" title="2.2.0"></a>2.2.0</h1><p>2.2.0于2019年3月22日发布；2.2.1于2019年6月1日发布；2.2.2于2019年12月1日发布。</p>
<p>改进消费组管理，默认group.id为null，以前为空字符串。<a href="https://issues.apache.org/jira/browse/KAFKA-6774">[KAFKA-6774]</a></p>
<p><a href="https://archive.apache.org/dist/kafka/2.2.0/RELEASE_NOTES.html">2.2.0官方发布日志</a></p>
<p><a href="https://archive.apache.org/dist/kafka/2.2.1/RELEASE_NOTES.html">2.2.1官方发布日志</a></p>
<p><a href="https://www.apache.org/dist/kafka/2.2.2/RELEASE_NOTES.html">2.2.2官方发布日志</a></p>
<h1 id="2-3-0"><a href="#2-3-0" class="headerlink" title="2.3.0"></a>2.3.0</h1><p>2.3.0于2019年6月25日发布；2.3.1于2019年10月24日发布。</p>
<p>提供命令查看哪些topic的分区小于最小ISR的数量。<a href="https://issues.apache.org/jira/browse/KAFKA-7236">[KAFKA-7236]</a></p>
<p><a href="https://www.apache.org/dist/kafka/2.3.0/RELEASE_NOTES.html">2.3.0官方发布日志</a></p>
<p><a href="https://www.apache.org/dist/kafka/2.3.1/RELEASE_NOTES.html">2.3.1官方发布日志</a></p>
<h1 id="2-4-0"><a href="#2-4-0" class="headerlink" title="2.4.0"></a>2.4.0</h1><p>2.4.0于2019年12月16日发布；2.4.1于2020年3月12日发布。</p>
<p>允许消费者从最近的副本(follower)获取数据 <a href="https://issues.apache.org/jira/browse/KAFKA-8443">[KAFKA-8443]</a></p>
<p>跨机房数据同步引擎MirrorMaker 2.0 <a href="https://issues.apache.org/jira/browse/KAFKA-7500">[KAFKA-7500]</a></p>
<p>升级ZooKeeper到3.5.7该版本fix了21个issue <a href="https://issues.apache.org/jira/browse/KAFKA-9515">[KAFKA-9515]</a></p>
<p><a href="https://www.apache.org/dist/kafka/2.4.0/RELEASE_NOTES.html">2.4.0官方发布日志</a></p>
<p><a href="https://www.apache.org/dist/kafka/2.4.1/RELEASE_NOTES.html">2.4.1官方发布日志</a></p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ1# RocketMQ Connection命令</title>
    <url>/posts/6957c801/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="消费端连接信息"><a href="#消费端连接信息" class="headerlink" title="消费端连接信息"></a>消费端连接信息</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin consumerConnection -g T_SCANRECORD_NEW_GROUP -n 192.168.1.x:9876</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option PermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">001 127.0.0.1@60190 192.168.2.x:50104 JAVA V3_2_6_SNAPSHOT</span><br><span class="line"></span><br><span class="line">002 127.0.0.1@7454 192.168.7.x:27692 JAVA V3_2_6_SNAPSHOT</span><br><span class="line"></span><br><span class="line">003 127.0.0.1@31600 192.168.21.x:40243 JAVA V3_2_6_SNAPSHOT</span><br><span class="line"></span><br><span class="line">004 127.0.0.1@21322 192.168.21.x:31416 JAVA V3_2_6_SNAPSHOT</span><br><span class="line"></span><br><span class="line">005 127.0.0.1@39557 192.168.2.x:45959 JAVA V3_2_6_SNAPSHOT</span><br><span class="line"></span><br><span class="line">006 127.0.0.1@24765 192.168.7.x:15166 JAVA V3_2_6_SNAPSHOT</span><br><span class="line"></span><br><span class="line">007 127.0.0.1@26993 192.168.7.x:57864 JAVA V3_2_6_SNAPSHOT</span><br><span class="line"></span><br><span class="line">008 127.0.0.1@652 192.168.21.x:59261 JAVA V3_2_6_SNAPSHOT</span><br><span class="line"></span><br><span class="line">009 127.0.0.1@10388 192.168.21.x:1671 JAVA V3_2_6_SNAPSHOT</span><br><span class="line"></span><br><span class="line">Below is subscription:001 Topic: %RETRY%T_SCANRECORD_NEW_GROUP SubExpression: *</span><br><span class="line"></span><br><span class="line">002 Topic: T_SCANRECORD_NEW SubExpression: 1||2||3||4 || 5 || -5||7 || 45</span><br><span class="line"></span><br><span class="line">ConsumeType: CONSUME_PASSIVELY</span><br><span class="line"></span><br><span class="line">MessageModel: CLUSTERING</span><br><span class="line"></span><br><span class="line">ConsumeFromWhere: CONSUME_FROM_FIRST_OFFSET</span><br></pre></td></tr></table></figure>



<a id="more"></a>



<h1 id="生产连接信息"><a href="#生产连接信息" class="headerlink" title="生产连接信息"></a>生产连接信息</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin producerConnection -t T_SCANRECORD_NEW -g producetGroup -n 192.168.1.x:9876</span><br></pre></td></tr></table></figure>







</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ10# RocketMQ查询死信队列中的消息内容</title>
    <url>/posts/cad2b239/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>RocketMQ中当重试消息超过最大重试次数（默认16次），会被发送到%DLQ%开头的死信队列，默认死信队列为只写权限。在有些情况下，想看看死信队列里的内容。</p>
<h1 id="更改死信队列权限"><a href="#更改死信队列权限" class="headerlink" title="更改死信队列权限"></a>更改死信队列权限</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin updateTopicPerm -c ClusterB -t %DLQ%online-tst -p 6 -n 192.168.1.x:9876</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option PermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">update topic perm from 2 to 6 in 192.168.1.x:10911 success.</span><br><span class="line"></span><br><span class="line">update topic perm from 2 to 6 in 192.168.1.x:10911 success.</span><br><span class="line"></span><br><span class="line">update topic perm from 2 to 6 in 192.168.1.x:10911 success.</span><br><span class="line"></span><br><span class="line">update topic perm from 2 to 6 in 192.168.1.x:10911 success.</span><br><span class="line"></span><br><span class="line">注：将死信队列只写权限更改为读写权限</span><br></pre></td></tr></table></figure>



<a id="more"></a>



<h1 id="查询死信队列状态"><a href="#查询死信队列状态" class="headerlink" title="查询死信队列状态"></a>查询死信队列状态</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin topicStatus -n 192.168.1.x:9876 -t %DLQ%online-tst</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option PermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">Broker Name QID Min Offset Max Offset Last Updated</span><br><span class="line"></span><br><span class="line">broker-a 0 0 109 2018-12-10 18:03:08,732</span><br><span class="line"></span><br><span class="line">broker-a 1 0 109 2018-12-10 18:03:08,740</span><br><span class="line"></span><br><span class="line">broker-a 2 0 110 2018-12-10 18:03:08,750</span><br><span class="line"></span><br><span class="line">broker-a 3 0 109 2018-12-10 18:03:08,728</span><br></pre></td></tr></table></figure>



<h1 id="根据offset查询消息内容"><a href="#根据offset查询消息内容" class="headerlink" title="根据offset查询消息内容"></a>根据offset查询消息内容</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin queryMsgByOffset -n localhost:9876 -t %DLQ%online-tst -b broker-a -i 0 -o 108</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option PermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">OffsetID: 0A090F2800002A9F000000D70519DD35</span><br><span class="line"></span><br><span class="line">OffsetID: 0A090F2800002A9F000000D70519DD35</span><br><span class="line"></span><br><span class="line">Topic: %DLQ%online-tst</span><br><span class="line"></span><br><span class="line">Tags: [null]</span><br><span class="line"></span><br><span class="line">Keys: [null]</span><br><span class="line"></span><br><span class="line">Queue ID: 0</span><br><span class="line"></span><br><span class="line">Queue Offset: 108</span><br><span class="line"></span><br><span class="line">CommitLog Offset: 923503549749</span><br><span class="line"></span><br><span class="line">Reconsume Times: 0</span><br><span class="line"></span><br><span class="line">Born Timestamp: 2018-12-10 17:59:24,731</span><br><span class="line"></span><br><span class="line">Store Timestamp: 2018-12-10 18:03:08,732</span><br><span class="line"></span><br><span class="line">Born Host: 10.10.128.183:51889</span><br><span class="line"></span><br><span class="line">Store Host: 10.9.15.40:10911</span><br><span class="line"></span><br><span class="line">System Flag: 0</span><br><span class="line"></span><br><span class="line">Properties: &#123;MIN_OFFSET&#x3D;0, MAX_OFFSET&#x3D;109, UNIQ_KEY&#x3D;0A0A80B78DE818B4AAC22FA2493B01B2, WAIT&#x3D;true&#125;</span><br><span class="line"></span><br><span class="line">Message Body Path: &#x2F;tmp&#x2F;rocketmq&#x2F;msgbodys&#x2F;0A0A80B78DE818B4AAC22FA2493B01B2</span><br><span class="line"></span><br><span class="line">注：使用打印命令消息临时存储在&#x2F;tmp&#x2F;rocketmq&#x2F;msgbodys</span><br></pre></td></tr></table></figure>

<h1 id="查看消息内容"><a href="#查看消息内容" class="headerlink" title="查看消息内容"></a>查看消息内容</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &#x2F;tmp&#x2F;rocketmq&#x2F;msgbodys&#x2F;0A0A80B78DE818B4AAC22FA2490F01AE</span><br><span class="line"></span><br><span class="line">Hello RocketMQ430</span><br></pre></td></tr></table></figure>

</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ11# RocketMQ集群生产环境节点下线操作</title>
    <url>/posts/6887b617/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="现状描述"><a href="#现状描述" class="headerlink" title="现状描述"></a>现状描述</h1><p>集群其中一台物理机未知原因导致单用户无法登陆机器，该物理机需要重启修改密码或者重装系统。该台为master节点，运行正常。</p>
<p>配置策略为：异步刷盘 &amp; 主从异步复制</p>
<p>如果直接下线该master，由于主从异步复制，可能导致部分消息来不及复制到slave造成消息丢失。所以该方案不可行。</p>
<p>另一种方案选择：关闭该broker的写入权限，待该broker不再有写入和消费时，再下线该节点。</p>
<h1 id="关闭broker写权限"><a href="#关闭broker写权限" class="headerlink" title="关闭broker写权限"></a>关闭broker写权限</h1><p>2表示只写权限，4表示只读权限，6表示读写权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin updateBrokerConfig -b 192.168.x.x:10911 -n 192.168.x.x:9876 -k brokerPermission -v 4</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option PermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">update broker config success, 192.168.x.x:10911</span><br></pre></td></tr></table></figure>



<a id="more"></a>



<h1 id="观察节点流量"><a href="#观察节点流量" class="headerlink" title="观察节点流量"></a>观察节点流量</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin clusterList -n 192.168.x.x:9876</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option PermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">\#Cluster Name #Broker Name #BID #Addr #Version #InTPS(LOAD) #OutTPS(LOAD) #PCWait(ms) #Hour #SPACE</span><br><span class="line"></span><br><span class="line">ZmsClusterA broker-a 0 192.168.x.x:10911 V4_1_0_SNAPSHOT 2492.95(0,0ms) 2269.27(1,0ms) 0 137.57 0.1861</span><br><span class="line"></span><br><span class="line">ZmsClusterA broker-a 1 192.168.x.x:10911 V4_1_0_SNAPSHOT 2485.45(0,0ms) 0.00(0,0ms) 0 125.26 0.3055</span><br><span class="line"></span><br><span class="line">ZmsClusterA broker-b 0 192.168.x.x:10911 V4_1_0_SNAPSHOT 26.47(0,0ms) 26.08(0,0ms) 0 137.24 0.1610</span><br><span class="line"></span><br><span class="line">ZmsClusterA broker-b 1 192.168.x.x:10915 V4_1_0_SNAPSHOT 20.47(0,0ms) 0.00(0,0ms) 0 125.22 0.3055</span><br><span class="line"></span><br><span class="line">ZmsClusterA broker-c 0 192.168.x.x:10911 V4_1_0_SNAPSHOT 2061.09(0,0ms) 1967.30(0,0ms) 0 125.28 0.2031</span><br><span class="line"></span><br><span class="line">ZmsClusterA broker-c 1 192.168.x.x:10911 V4_1_0_SNAPSHOT 2048.20(0,0ms) 0.00(0,0ms) 0 137.51 0.2789</span><br><span class="line"></span><br><span class="line">ZmsClusterA broker-d 0 192.168.x.x:10911 V4_1_0_SNAPSHOT 2017.40(0,0ms) 1788.32(0,0ms) 0 125.22 0.1261</span><br><span class="line"></span><br><span class="line">ZmsClusterA broker-d 1 192.168.x.x:10915 V4_1_0_SNAPSHOT 2026.50(0,0ms) 0.00(0,0ms) 0 137.61 0.2789</span><br></pre></td></tr></table></figure>



<p>观察InTPS和OutTPS，理想情况都为零时，并不再变化时，则该节点可下线了。</p>
<p>然而，在实际过程中并没有出现为零的情况，InTPS和OutTPS总是有值，有时个位数字有时是两位数字，大部分时间在20多的值。此刻要分析下broker目前的消费状态。</p>
<h1 id="观察broker消费状态"><a href="#观察broker消费状态" class="headerlink" title="观察broker消费状态"></a>观察broker消费状态</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh bin&#x2F;mqadmin brokerConsumeStats -b 192.168.x.x:10911 -n 192.168.x.x:9876 &gt;&gt; brokerConsumeStats.tmp</span><br></pre></td></tr></table></figure>



<p>查看brokerConsumeStats.tmp，主要查看#LastTime和#Diff。 发现%RETRY%重试类队列#Diff有很微小（1或者3）的数据，而其他topic均为0. LastTime时间最新也是发生在%RETRY%队列中。此时可以让该节点下线操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#Topic #Group #Broker Name #QID #Broker Offset #Consumer Offset #Diff #LastTime</span><br><span class="line"></span><br><span class="line">SV_Multi_Message ZTO_SV_EmchatWebConsumerGroup broker-b 0 2171742 2171742 0 2019-04-24 23:38:09</span><br><span class="line"></span><br><span class="line">SV_Multi_Message ZTO_SV_EmchatWebConsumerGroup broker-b 1 2171756 2171756 0 2019-04-24 23:38:50</span><br><span class="line"></span><br><span class="line">SV_Multi_Message ZTO_SV_EmchatWebConsumerGroup broker-b 2 2171740 2171740 0 2019-04-24 23:42:58</span><br><span class="line"></span><br><span class="line">SV_Multi_Message ZTO_SV_EmchatWebConsumerGroup broker-b 3 2171759 2171759 0 2019-04-24 23:40:44</span><br><span class="line"></span><br><span class="line">SV_Multi_Message ZTO_SV_EmchatWebConsumerGroup broker-b 4 2171743 2171743 0 2019-04-24 23:32:48</span><br><span class="line"></span><br><span class="line">SV_Multi_Message ZTO_SV_EmchatWebConsumerGroup broker-b 5 2171740 2171740 0 2019-04-24 23:35:58</span><br><span class="line"></span><br><span class="line">SV_Multi_Message ZTO_SV_EmchatWebConsumerGroup broker-b 6 2171758 2171758 0 2019-04-24 23:36:23</span><br><span class="line"></span><br><span class="line">SV_Multi_Message ZTO_SV_EmchatWebConsumerGroup broker-b 7 2171740 2171740 0 2019-04-24 23:37:50</span><br><span class="line"></span><br><span class="line">%RETRY%ZTO_SV_EmchatWebConsumerG ZTO_SV_EmchatWebConsumerGroup broker-b 0 61876 61876 0 2019-04-24 10:09:04</span><br><span class="line"></span><br><span class="line">%RETRY%SVC_TRACK_CONSUMER SVC_TRACK_CONSUMER broker-b 0 497968 497968 0 2019-04-19 12:51:24</span><br><span class="line"></span><br><span class="line">SVC_TRACK_TOPIC SVC_TRACK_CONSUMER broker-b 0 191710 191710 0 2019-04-24 23:44:22</span><br><span class="line"></span><br><span class="line">SVC_TRACK_TOPIC SVC_TRACK_CONSUMER broker-b 1 191706 191706 0 2019-04-24 23:44:25</span><br><span class="line"></span><br><span class="line">SVC_TRACK_TOPIC SVC_TRACK_CONSUMER broker-b 2 191697 191697 0 2019-04-24 23:44:44</span><br><span class="line"></span><br><span class="line">SVC_TRACK_TOPIC SVC_TRACK_CONSUMER broker-b 3 191695 191695 0 2019-04-24 23:44:47</span><br><span class="line"></span><br><span class="line">SVC_TRACK_TOPIC SVC_TRACK_CONSUMER broker-b 4 191688 191688 0 2019-04-24 23:44:47</span><br><span class="line"></span><br><span class="line">SVC_TRACK_TOPIC SVC_TRACK_CONSUMER broker-b 5 191683 191683 0 2019-04-24 23:44:48</span><br><span class="line"></span><br><span class="line">SVC_TRACK_TOPIC SVC_TRACK_CONSUMER broker-b 6 191676 191676 0 2019-04-24 23:44:49</span><br><span class="line"></span><br><span class="line">SVC_TRACK_TOPIC SVC_TRACK_CONSUMER broker-b 7 191672 191672 0 2019-04-24 23:44:49</span><br></pre></td></tr></table></figure>



<h1 id="borker读写权限恢复"><a href="#borker读写权限恢复" class="headerlink" title="borker读写权限恢复"></a>borker读写权限恢复</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin updateBrokerConfig -b 192.168.x.x:10911 -n 192.168.x.x:9876 -k brokerPermission -v 6</span><br></pre></td></tr></table></figure>



<h1 id="观察各节点流量是否正常"><a href="#观察各节点流量是否正常" class="headerlink" title="观察各节点流量是否正常"></a>观察各节点流量是否正常</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin clusterList -n 192.168.x.x:9876</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option PermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">\#Cluster Name #Broker Name #BID #Addr #Version #InTPS(LOAD) #OutTPS(LOAD) #PCWait(ms) #Hour #SPACE</span><br><span class="line"></span><br><span class="line">ZmsClusterA broker-a 0 192.168.x.x:10911 V4_1_0_SNAPSHOT 2492.95(0,0ms) 2269.27(1,0ms) 0 137.57 0.1861</span><br><span class="line"></span><br><span class="line">ZmsClusterA broker-a 1 192.168.x.x:10911 V4_1_0_SNAPSHOT 2485.45(0,0ms) 0.00(0,0ms) 0 125.26 0.3055</span><br><span class="line"></span><br><span class="line">ZmsClusterA broker-b 0 192.168.x.x:10911 V4_1_0_SNAPSHOT 2299.47(0,0ms) 2226.08(0,0ms) 0 137.24 0.1610</span><br><span class="line"></span><br><span class="line">ZmsClusterA broker-b 1 192.168.x.x:10915 V4_1_0_SNAPSHOT 2280.47(0,0ms) 0.00(0,0ms) 0 125.22 0.3055</span><br><span class="line"></span><br><span class="line">ZmsClusterA broker-c 0 192.168.x.x:10911 V4_1_0_SNAPSHOT 2061.09(0,0ms) 1967.30(0,0ms) 0 125.28 0.2031</span><br><span class="line"></span><br><span class="line">ZmsClusterA broker-c 1 192.168.x.x:10911 V4_1_0_SNAPSHOT 2048.20(0,0ms) 0.00(0,0ms) 0 137.51 0.2789</span><br><span class="line"></span><br><span class="line">ZmsClusterA broker-d 0 192.168.x.x:10911 V4_1_0_SNAPSHOT 2017.40(0,0ms) 1788.32(0,0ms) 0 125.22 0.1261</span><br><span class="line"></span><br><span class="line">ZmsClusterA broker-d 1 192.168.x.x:10915 V4_1_0_SNAPSHOT 2026.50(0,0ms) 0.00(0,0ms) 0 137.61 0.2789</span><br></pre></td></tr></table></figure>

</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ12# RocketMQ性能优化</title>
    <url>/posts/eb676532/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一、系统优化</span><br><span class="line"></span><br><span class="line">1.最大文件数</span><br><span class="line"></span><br><span class="line">2.系统参数调整</span><br><span class="line"></span><br><span class="line">二、RocketMQ性能调优</span><br><span class="line"></span><br><span class="line">1.开启异步刷盘</span><br><span class="line"></span><br><span class="line">2.开启堆外内存设置</span><br><span class="line"></span><br><span class="line">3.开启文件预热</span><br><span class="line"></span><br><span class="line">4.开启Slave读权限</span><br><span class="line"></span><br><span class="line">5.关闭堆内存据传输</span><br></pre></td></tr></table></figure>



<h1 id="系统优化"><a href="#系统优化" class="headerlink" title="系统优化"></a>系统优化</h1><h2 id="最大文件数"><a href="#最大文件数" class="headerlink" title="最大文件数"></a>最大文件数</h2><p>limits.conf 设置用户能打开的最大文件数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;security&#x2F;limits.conf</span><br><span class="line"></span><br><span class="line">\# End of file</span><br><span class="line"></span><br><span class="line">baseuser soft nofile 655360</span><br><span class="line"></span><br><span class="line">baseuser hard nofile 655360</span><br><span class="line"></span><br><span class="line">\* soft nofile 655360</span><br><span class="line"></span><br><span class="line">\* hard nofile 655360</span><br></pre></td></tr></table></figure>



<a id="more"></a>



<h2 id="系统参数调整"><a href="#系统参数调整" class="headerlink" title="系统参数调整"></a>系统参数调整</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo vim &#x2F;etc&#x2F;sysctl.conf</span><br><span class="line"></span><br><span class="line">vm.overcommit_memory&#x3D;1</span><br><span class="line"></span><br><span class="line">vm.drop_caches&#x3D;1</span><br><span class="line"></span><br><span class="line">vm.zone_reclaim_mode&#x3D;0</span><br><span class="line"></span><br><span class="line">vm.max_map_count&#x3D;655360</span><br><span class="line"></span><br><span class="line">vm.dirty_background_ratio&#x3D;50</span><br><span class="line"></span><br><span class="line">vm.dirty_ratio&#x3D;50</span><br><span class="line"></span><br><span class="line">vm.dirty_writeback_centisecs&#x3D;360000</span><br><span class="line"></span><br><span class="line">vm.page-cluster&#x3D;3</span><br><span class="line"></span><br><span class="line">vm.swappiness&#x3D;1</span><br><span class="line"></span><br><span class="line">vm.zone_reclaim_mode&#x3D;1 &#x2F;&#x2F; 主节点</span><br><span class="line"></span><br><span class="line">vm.min_free_kbytes&#x3D;512000</span><br><span class="line"></span><br><span class="line">sudo sysctl -p</span><br></pre></td></tr></table></figure>



<h2 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h2><h3 id="overcommit-memory"><a href="#overcommit-memory" class="headerlink" title="overcommit_memory"></a>overcommit_memory</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">是否允许内存的过量分配</span><br><span class="line"></span><br><span class="line">当为0的时候，当用户申请内存的时候，内核会去检查是否有这么大的内存空间</span><br><span class="line"></span><br><span class="line">当为1的时候，内核始终认为，有足够大的内存空间，直到它用完了为止</span><br><span class="line"></span><br><span class="line">当为2的时候，内核禁止任何形式的过量分配内存</span><br></pre></td></tr></table></figure>

<h3 id="drop-caches"><a href="#drop-caches" class="headerlink" title="drop_caches"></a>drop_caches</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">写入的时候，内核会清空缓存，腾出内存来，相当于sync</span><br><span class="line"></span><br><span class="line">写1的时候，会清空页缓存，就是文件</span><br><span class="line"></span><br><span class="line">写2的时候，会清空inode和目录树</span><br><span class="line"></span><br><span class="line">写3的时候，都清空</span><br><span class="line"></span><br><span class="line">This is a non-destructive operation and will only free things that are completely unused.</span><br><span class="line"></span><br><span class="line">Dirty objects will continue to be in use until written out to disk and are not freeable.</span><br><span class="line"></span><br><span class="line">If you run &quot;sync&quot; first to flush them out to disk, these drop operations will tend to free more memory.</span><br></pre></td></tr></table></figure>

<h3 id="zone-reclaim-mode"><a href="#zone-reclaim-mode" class="headerlink" title="zone_reclaim_mode"></a>zone_reclaim_mode</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果为0的话，那么系统会倾向于从其他节点分配内存</span><br><span class="line"></span><br><span class="line">如果为1的话，那么系统会倾向于从本地节点回收Cache内存多数时候</span><br></pre></td></tr></table></figure>

<h3 id="max-map-count"><a href="#max-map-count" class="headerlink" title="max_map_count"></a>max_map_count</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">定义了一个进程能拥有的最多的内存区域，默认为65536</span><br></pre></td></tr></table></figure>



<h3 id="dirty-background-bytes-dirty-background-ratio"><a href="#dirty-background-bytes-dirty-background-ratio" class="headerlink" title="dirty_background_bytes/dirty_background_ratio"></a>dirty_background_bytes/dirty_background_ratio</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当dirty cache到了多少的时候，就启动pdflush进程，将dirty cache写回磁盘</span><br><span class="line"></span><br><span class="line">当有dirty_background_bytes存在的时候，dirty_background_ratio是被自动计算的</span><br></pre></td></tr></table></figure>



<h3 id="dirty-bytes-dirty-ratio"><a href="#dirty-bytes-dirty-ratio" class="headerlink" title="dirty_bytes/dirty_ratio"></a>dirty_bytes/dirty_ratio</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当一个进程的dirty cache到了多少的时候，启动pdflush进程，将dirty cache写回磁盘</span><br><span class="line"></span><br><span class="line">当dirty_bytes存在的时候，dirty_ratio是被自动计算的</span><br></pre></td></tr></table></figure>



<h3 id="dirty-writeback-centisecs"><a href="#dirty-writeback-centisecs" class="headerlink" title="dirty_writeback_centisecs"></a>dirty_writeback_centisecs</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pdflush每隔多久，自动运行一次（单位是百分之一秒）</span><br></pre></td></tr></table></figure>



<h3 id="page-cluster"><a href="#page-cluster" class="headerlink" title="page-cluster"></a>page-cluster</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">每次swap in或者swap out操作多少内存页为2的指数。</span><br><span class="line"></span><br><span class="line">等于0的时候，为1页；等于1的时候，为2页；等于2的时候，为4页</span><br></pre></td></tr></table></figure>



<h3 id="swappiness"><a href="#swappiness" class="headerlink" title="swappiness"></a>swappiness</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">swappiness&#x3D;0 仅在内存不足的情况下，当剩余空闲内存低于vm.min_free_kbytes limit时，使用交换空间</span><br><span class="line"></span><br><span class="line">swappiness&#x3D;1 内核版本3.5及以上、Red Hat内核版本2.6.32-303及以上，进行最少量的交换，而不禁用交换</span><br><span class="line"></span><br><span class="line">swappiness&#x3D;10 当系统存在足够内存时，推荐设置为该值以提高性能</span><br><span class="line"></span><br><span class="line">swappiness&#x3D;60 默认值</span><br><span class="line"></span><br><span class="line">swappiness&#x3D;100 内核将积极的使用交换空间</span><br></pre></td></tr></table></figure>





<h1 id="RocketMQ性能调优"><a href="#RocketMQ性能调优" class="headerlink" title="RocketMQ性能调优"></a>RocketMQ性能调优</h1><p>线上RocketMQ的JVM未做调优，堆内存使用8G；主要从RocketMQ配置参数方面梳理下。</p>
<h2 id="开启异步刷盘"><a href="#开启异步刷盘" class="headerlink" title="开启异步刷盘"></a>开启异步刷盘</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flushDiskType&#x3D;ASYNC_FLUSH</span><br><span class="line"></span><br><span class="line">同步刷盘TPS过低，较难满足业务发展需求</span><br></pre></td></tr></table></figure>



<h2 id="开启堆外内存设置"><a href="#开启堆外内存设置" class="headerlink" title="开启堆外内存设置"></a>开启堆外内存设置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">transientStorePoolEnable&#x3D;true</span><br><span class="line"></span><br><span class="line">消息写入到堆外内存，消费时从pageCache消费，读写分离，提升集群性能</span><br></pre></td></tr></table></figure>



<h2 id="开启文件预热"><a href="#开启文件预热" class="headerlink" title="开启文件预热"></a>开启文件预热</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">warmMapedFileEnable&#x3D;true</span><br><span class="line"></span><br><span class="line">开启文件预热，避免日志文件在分配内存时缺页中断</span><br></pre></td></tr></table></figure>



<h2 id="开启Slave读权限"><a href="#开启Slave读权限" class="headerlink" title="开启Slave读权限"></a>开启Slave读权限</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">slaveReadEnable&#x3D;true</span><br><span class="line"></span><br><span class="line">消息占用物理内存的大小通过accessMessageInMemoryMaxRatio来配置默认为40%；</span><br><span class="line"></span><br><span class="line">如果消费的消息不在内存中，开启slaveReadEnable时会从slave节点读取；提高Master内存利用率</span><br></pre></td></tr></table></figure>



<h2 id="关闭堆内存据传输"><a href="#关闭堆内存据传输" class="headerlink" title="关闭堆内存据传输"></a>关闭堆内存据传输</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">transferMsgByHeap默认true设置为false</span><br><span class="line"></span><br><span class="line">Broker响应消费请求时，不必将数据重新读到堆内存再发送给客户端；</span><br><span class="line"></span><br><span class="line">直接从PageCache将数据发送给客户端</span><br></pre></td></tr></table></figure>



<h2 id="延长发送队列等待时间"><a href="#延长发送队列等待时间" class="headerlink" title="延长发送队列等待时间"></a>延长发送队列等待时间</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">waitTimeMillsInSendQueue默认200ms；适当延长到1000ms</span><br><span class="line"></span><br><span class="line">降低由于等待超时客户端快速失败抛出[TIMEOUT_CLEAN_QUEUE]broker busy频率</span><br></pre></td></tr></table></figure>

</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ14# RocketMQ同步复制性能优化</title>
    <url>/posts/d1c4e530/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>早些时候写过性能测试和性能优化文章，主要基于异步刷盘/异步复制；由于业务需要需要搭建异步刷盘/同步复制集群；同时对性能进行压测。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">压测结果显示集群几乎无法使用，TPS居然是个位数，客户端也在报错。</span><br></pre></td></tr></table></figure>



<a id="more"></a>



<h2 id="压测日志"><a href="#压测日志" class="headerlink" title="压测日志"></a>压测日志</h2><p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201218231410.png"></p>
<h2 id="客户端日志"><a href="#客户端日志" class="headerlink" title="客户端日志"></a>客户端日志</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2019-09-19 19:22:38,038 ERROR RocketmqClient - [BENCHMARK_PRODUCER] Send Exception</span><br><span class="line"></span><br><span class="line">org.apache.rocketmq.client.exception.MQBrokerException: CODE: 2 DESC: [TIMEOUT_CLEAN_QUEUE]broker busy, start flow control for a while, period in queue: 209ms, size of queue: 9</span><br><span class="line"></span><br><span class="line">For more information, please visit the url, http:&#x2F;&#x2F;rocketmq.apache.org&#x2F;docs&#x2F;faq&#x2F;</span><br><span class="line"></span><br><span class="line">at org.apache.rocketmq.client.impl.MQClientAPIImpl.processSendResponse(MQClientAPIImpl.java:671)</span><br><span class="line"></span><br><span class="line">at org.apache.rocketmq.client.impl.MQClientAPIImpl.sendMessageSync(MQClientAPIImpl.java:467)</span><br><span class="line"></span><br><span class="line">at org.apache.rocketmq.client.impl.MQClientAPIImpl.sendMessage(MQClientAPIImpl.java:449)</span><br><span class="line"></span><br><span class="line">at</span><br></pre></td></tr></table></figure>



<h1 id="解决发送失败情况"><a href="#解决发送失败情况" class="headerlink" title="解决发送失败情况"></a>解决发送失败情况</h1><p>经排查，将transientStorePoolEnable关闭(默认为false)；压测显示最高TPS有1.9万。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brokerRole&#x3D;SYNC_MASTER</span><br><span class="line"></span><br><span class="line">\#transientStorePoolEnable&#x3D;true</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201218231653.png"></p>
<h1 id="解决发送TPS过低情况"><a href="#解决发送TPS过低情况" class="headerlink" title="解决发送TPS过低情况"></a>解决发送TPS过低情况</h1><p>最高TPS只有1.9万，依然过低，与预期相差甚远，我们预期压测应该可以到7到8万这样可以满足业务发展需要。再次检查broker端参数配置，没有发现有参数导致性能如此过低。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">回顾性能调优的几个方面：系统调优、集群调优、JVM调优。</span><br></pre></td></tr></table></figure>

<p>系统调优与集群调优都已经做过了，唯一没有优化的JVM调优，堆内存设置默认的8G。</p>
<p>JAVA_OPT=”${JAVA_OPT} -server -Xms8g -Xmx8g -Xmn4g”</p>
<p>将JVM堆内存提高4倍后，压测效果明显提升，基本可以达到预期7万多的TPS。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201218231833.png"></p>
<h1 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h1><p>1.为什么在异步刷盘/同步复制时开启堆外内存池transientStorePoolEnable后，集群压测几乎无法进行？</p>
<p>2.为什么在异步刷盘/同步复制时调大JVM堆内存后，性能明显提升呢？提升了的倍数几乎是堆内存增大的倍数。</p>
<h2 id="刷盘流程回顾"><a href="#刷盘流程回顾" class="headerlink" title="刷盘流程回顾"></a>刷盘流程回顾</h2><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMzY2MDYzMA==&mid=2247483827&idx=1&sn=d7204473069dbad47b0cc7e05ad83acc&chksm=9b9e790aace9f01c84d0e9d686309875064a22704d843cdb941fbebe46728dfb338dc4cfa4bd&scene=21#wechat_redirect">RocketMQ存储–消息追加【源码笔记】</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMzY2MDYzMA==&mid=2247483855&idx=1&sn=710f8b2eb72ec28ff10eb7dbaf44dc7f&chksm=9b9e7976ace9f0608b5da4d4cf9676580aa599e7ce239b6aba9736cc6c60ff8efafb7910f7b1&scene=21#wechat_redirect">RocketMQ存储–同步刷盘和异步刷盘【源码笔记】</a></p>
<p><strong>异步刷盘未开启堆外缓存示意图</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201218232152.png"></p>
<p><strong>异步刷盘开启堆外缓存示意图</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201218232214.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：异步刷盘未开启transientStorePoolEnable时，消息追加到mappedByteBuffer中，异步线程刷调用mappedByteBuffer.force落盘；异步刷盘开启transientStorePoolEnable时，消息写入wrtieBuffer中，异步线程将消息提交到fileChannel，然后异步线程调用fileChannel.force落盘。</span><br></pre></td></tr></table></figure>



<h2 id="主从复制回顾"><a href="#主从复制回顾" class="headerlink" title="主从复制回顾"></a>主从复制回顾</h2><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMzY2MDYzMA==&mid=2247483701&idx=1&sn=9760e50c69285aad2d868a13d810394e&chksm=9b9e798cace9f09aa5d31b5c4b972e627b3fe1afcb892d40fbf57c561b18175bd12119e8c08c&scene=21#wechat_redirect">RocketMQ存储–主从同步【源码笔记】</a></p>
<p>HAConnection#WriteSocketService负责向Slave发送数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;查找待拉取偏移量之后所有的可读消息</span><br><span class="line"></span><br><span class="line">SelectMappedBufferResult selectResult &#x3D; HAConnection.this.haService.getDefaultMessageStore().getCommitLogData(this.nextTransferFromWhere);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line"></span><br><span class="line">SelectMappedBufferResult result &#x3D; mappedFile.selectMappedBuffer(pos);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line"></span><br><span class="line">ByteBuffer byteBuffer &#x3D; this.mappedByteBuffer.slice();</span><br><span class="line"></span><br><span class="line">byteBuffer.position(pos);</span><br><span class="line"></span><br><span class="line">int size &#x3D; readPosition - pos; &#x2F;&#x2F;计算距离最大可读位置的大小</span><br><span class="line"></span><br><span class="line">ByteBuffer byteBufferNew &#x3D; byteBuffer.slice();</span><br><span class="line"></span><br><span class="line">byteBufferNew.limit(size);</span><br><span class="line"></span><br><span class="line">return new SelectMappedBufferResult()</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：主从复制使用mappedByteBuffer向Slave同步数据。</span><br></pre></td></tr></table></figure>

<h2 id="流程模拟"><a href="#流程模拟" class="headerlink" title="流程模拟"></a>流程模拟</h2><h3 id="开启堆外内存池流程"><a href="#开启堆外内存池流程" class="headerlink" title="开启堆外内存池流程"></a>开启堆外内存池流程</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line"></span><br><span class="line">public void test01()&#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 堆外内存池transientStorePoolEnable开启后，消息追加操作</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">File file &#x3D; new File(&quot;&#x2F;Users&#x2F;yongliang&#x2F;logs&#x2F;temp.log&quot;);</span><br><span class="line"></span><br><span class="line">FileChannel fileChannel &#x3D; new RandomAccessFile(file, &quot;rw&quot;).getChannel();</span><br><span class="line"></span><br><span class="line">String data &#x3D; &quot;beautiful girl!&quot;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; mmap 文件映射操作</span><br><span class="line"></span><br><span class="line">MappedByteBuffer mappedByteBuffer &#x3D; fileChannel.map(FileChannel.MapMode.READ_WRITE, 0, data.length());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 堆外内存transientStorePoolEnable开启</span><br><span class="line"></span><br><span class="line">ByteBuffer byteBuffer &#x3D; ByteBuffer.allocateDirect(data.length());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ----------------消息追加开始-----------------------</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 注意此时使用堆内内存分配</span><br><span class="line"></span><br><span class="line">ByteBuffer msgStoreItemMemory &#x3D; ByteBuffer.allocate(data.length());</span><br><span class="line"></span><br><span class="line">msgStoreItemMemory.put(data.getBytes());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 开启transientStorePoolEnable消息写入了ByteBuffer</span><br><span class="line"></span><br><span class="line">byteBuffer.put(msgStoreItemMemory.array(),0,data.length());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ----------------消息追加结束-----------------------</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ----------------消息提交开始-----------------------</span><br><span class="line"></span><br><span class="line">byteBuffer.position(0);</span><br><span class="line"></span><br><span class="line">byteBuffer.limit(data.length());</span><br><span class="line"></span><br><span class="line">fileChannel.write(byteBuffer);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ----------------消息提交结束-----------------------</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; --------主从复制从mappedByteBuffer获取消息开始----------</span><br><span class="line"></span><br><span class="line">mappedByteBuffer.position(0);</span><br><span class="line"></span><br><span class="line">mappedByteBuffer.limit(data.length());</span><br><span class="line"></span><br><span class="line">Charset charset &#x3D; Charset.forName(&quot;UTF-8&quot;);</span><br><span class="line"></span><br><span class="line">CharsetDecoder decoder &#x3D; charset.newDecoder();</span><br><span class="line"></span><br><span class="line">CharBuffer charBuffer &#x3D; decoder.decode(mappedByteBuffer.asReadOnlyBuffer());</span><br><span class="line"></span><br><span class="line">System.out.println(charBuffer.toString());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; --------主从复制从mappedByteBuffer获取消息结束----------</span><br><span class="line"></span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">e.printStackTrace();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：模拟开启堆外内存池transientStorePoolEnable的消息追加及主从复制流程。</span><br></pre></td></tr></table></figure>

<h3 id="未开启堆外内存池流程"><a href="#未开启堆外内存池流程" class="headerlink" title="未开启堆外内存池流程"></a>未开启堆外内存池流程</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line"></span><br><span class="line">public void test02()&#123;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">File file &#x3D; new File(&quot;&#x2F;Users&#x2F;yongliang&#x2F;logs&#x2F;temp1.log&quot;);</span><br><span class="line"></span><br><span class="line">FileChannel fileChannel &#x3D; new RandomAccessFile(file, &quot;rw&quot;).getChannel();</span><br><span class="line"></span><br><span class="line">String data &#x3D; &quot;beautiful girl!&quot;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; mmap 文件映射操作</span><br><span class="line"></span><br><span class="line">MappedByteBuffer mappedByteBuffer &#x3D; fileChannel.map(FileChannel.MapMode.READ_WRITE, 0, data.length());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ----------------消息追加开始-----------------------</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 注意消息组装使用堆内内存分配</span><br><span class="line"></span><br><span class="line">ByteBuffer msgStoreItemMemory &#x3D; ByteBuffer.allocate(data.length());</span><br><span class="line"></span><br><span class="line">msgStoreItemMemory.put(data.getBytes());</span><br><span class="line"></span><br><span class="line">mappedByteBuffer.put(msgStoreItemMemory.array(),0,data.length());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ----------------消息追加结束-----------------------</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; --------主从复制从mappedByteBuffer获取消息开始----------</span><br><span class="line"></span><br><span class="line">mappedByteBuffer.position(0);</span><br><span class="line"></span><br><span class="line">mappedByteBuffer.limit(data.length());</span><br><span class="line"></span><br><span class="line">Charset charset &#x3D; Charset.forName(&quot;UTF-8&quot;);</span><br><span class="line"></span><br><span class="line">CharsetDecoder decoder &#x3D; charset.newDecoder();</span><br><span class="line"></span><br><span class="line">CharBuffer charBuffer &#x3D; decoder.decode(mappedByteBuffer.asReadOnlyBuffer());</span><br><span class="line"></span><br><span class="line">System.out.println(charBuffer.toString());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; --------主从复制从mappedByteBuffer获取消息结束----------</span><br><span class="line"></span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">e.printStackTrace();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：模拟未开启堆外内存池transientStorePoolEnable的消息追加及主从复制流程。</span><br></pre></td></tr></table></figure>

<h1 id="原因总结"><a href="#原因总结" class="headerlink" title="原因总结"></a>原因总结</h1><p>1.为什么在异步刷盘/同步复制时开启堆外内存transientStorePoolEnable后，集群压测几乎无法进行？</p>
<p>解释：</p>
<p>1&gt;主从同步复制使用mappedByteBuffer；</p>
<p>2&gt;开启堆外内存池transientStorePoolEnable后数据先落到WriteBuffer，再通过异步提交线程提交到FileChannel，再通过mmap将数据映射到mappedByteBuffer；</p>
<p>3&gt;未开启堆外内存池transientStorePoolEnable数据直接写入到mappedByteBuffe；</p>
<p>由于开启堆外内存数据映射到mappedByteBuffer比直接写入mappedByteBuffer多了很多步骤，再加上发送队列处理事件默认只有200毫秒（waitTimeMillsInSendQueue=200），造成集群不能正常压测的原因。</p>
<p>2.为什么在异步刷盘/同步复制时调大JVM堆内存后，性能明显提升呢？提升了的倍数几乎是对内存增大的倍数。</p>
<p>解释：</p>
<p>从模拟流程中可以看出，在组装消息时使用堆内存，提高堆内存显著提高写入Tps的原因所在。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 注意消息组装使用堆内内存分配</span><br><span class="line"></span><br><span class="line">ByteBuffer msgStoreItemMemory &#x3D; ByteBuffer.allocate(data.length());</span><br></pre></td></tr></table></figure>

</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ16# RocketMQ一次延迟消息故障排查</title>
    <url>/posts/258cdfc5/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>RocketMQ社区版本支持18个延迟级别，每个级别在设定的时间都被会消费者准确消费到。为此也专门测试过消费的间隔是不是准确，测试结果显示很准确。</p>
<p>然而，如此准确的特性居然出问题了，接到业务同学报告线上某个集群延迟消息消费不到，开发环境、测试环境都没问题。各个环境的版本都是统一的RocketMQ 4.5.2。诡异！</p>
<a id="more"></a>

<h1 id="临时方案"><a href="#临时方案" class="headerlink" title="临时方案"></a>临时方案</h1><p>将该业务的topic和consumer转移到线上其他集群，延迟消息消费正常。</p>
<h1 id="问题定位"><a href="#问题定位" class="headerlink" title="问题定位"></a>问题定位</h1><h2 id="搜查日志"><a href="#搜查日志" class="headerlink" title="搜查日志"></a>搜查日志</h2><p>发现storeerror.log一直刷下面的日志，观察发现offset远远超过了存储的大小！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2020-03-18 16:38:06 WARN ScheduleMessageTimerThread - Offset not matched. Request offset: 509548460, firstOffset: 0, lastOffset: 6000000, mappedFileSize: 6000000, mappedFiles count: 1</span><br><span class="line"></span><br><span class="line">2020-03-18 16:38:06 WARN ScheduleMessageTimerThread - Offset not matched. Request offset: 665682360, firstOffset: 0, lastOffset: 6000000, mappedFileSize: 6000000, mappedFiles count: 1</span><br><span class="line"></span><br><span class="line">2020-03-18 16:38:07 WARN ScheduleMessageTimerThread - Offset not matched. Request offset: 509548460, firstOffset: 0, lastOffset: 6000000, mappedFileSize: 6000000, mappedFiles count: 1</span><br><span class="line"></span><br><span class="line">2020-03-18 16:38:07 WARN ScheduleMessageTimerThread - Offset not matched. Request offset: 665682360, firstOffset: 0, lastOffset: 6000000, mappedFileSize: 6000000, mappedFiles count: 1</span><br><span class="line"></span><br><span class="line">2020-03-18 16:38:07 WARN ScheduleMessageTimerThread - Offset not matched. Request offset: 509548460, firstOffset: 0, lastOffset: 6000000, mappedFileSize: 6000000, mappedFiles count: 1</span><br><span class="line"></span><br><span class="line">2020-03-18 16:38:07 WARN ScheduleMessageTimerThread - Offset not matched. Request offset: 665682360, firstOffset: 0, lastOffset: 6000000, mappedFileSize: 6000000, mappedFiles count: 1</span><br><span class="line"></span><br><span class="line">2020-03-18 16:38:07 WARN ScheduleMessageTimerThread - Offset not matched. Request offset: 509548460, firstOffset: 0, lastOffset: 6000000, mappedFileSize: 6000000, mappedFiles count: 1</span><br></pre></td></tr></table></figure>



<h2 id="消息查询"><a href="#消息查询" class="headerlink" title="消息查询"></a>消息查询</h2><p>通过查询发送延迟的消息，发现该消息存储成功；已经存储在了“SCHEDULE_TOPIC_XXXX”中了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin queryMsgById -n x.x.x.x:9876 -i 0A6F160300002A9F000000BACA44720C</span><br><span class="line"></span><br><span class="line">RocketMQLog:WARN No appenders could be found for logger (io.netty.util.internal.PlatformDependent0).</span><br><span class="line"></span><br><span class="line">RocketMQLog:WARN Please initialize the logger system properly.</span><br><span class="line"></span><br><span class="line">OffsetID: 0A6F160300002A9F000000BACA44720C</span><br><span class="line"></span><br><span class="line">OffsetID: 0A6F160300002A9F000000BACA44720C</span><br><span class="line"></span><br><span class="line">Topic: SCHEDULE_TOPIC_XXXX</span><br><span class="line"></span><br><span class="line">Tags: [null]</span><br><span class="line"></span><br><span class="line">Keys: [rocketmq.key.-1351724170]</span><br><span class="line"></span><br><span class="line">Queue ID: 3</span><br><span class="line"></span><br><span class="line">Queue Offset: 142</span><br><span class="line"></span><br><span class="line">CommitLog Offset: 802257400332</span><br><span class="line"></span><br><span class="line">Reconsume Times: 0</span><br><span class="line"></span><br><span class="line">Born Timestamp: 2020-03-18 15:27:37,512</span><br><span class="line"></span><br><span class="line">Store Timestamp: 2020-03-18 15:27:37,513</span><br><span class="line"></span><br><span class="line">Born Host: 10.x.x.x:56650</span><br><span class="line"></span><br><span class="line">Store Host: 10.x.x.x:10911</span><br><span class="line"></span><br><span class="line">System Flag: 0</span><br><span class="line"></span><br><span class="line">Properties: &#123;REAL_TOPIC&#x3D;melon_online_test, KEYS&#x3D;rocketmq.key.-1351724170, UNIQ_KEY&#x3D;0A6F15AB6305070DEA4E5ADD60280023, WAIT&#x3D;true, DELAY&#x3D;4, REAL_QID&#x3D;1&#125;</span><br><span class="line"></span><br><span class="line">Message Body Path: &#x2F;tmp&#x2F;rocketmq&#x2F;msgbodys&#x2F;0A6F15AB6305070DEA4E5ADD60280023</span><br><span class="line"></span><br><span class="line">org.apache.rocketmq.client.exception.MQClientException: CODE: 17 DESC: No topic route info in name server for the topic: SCHEDULE_TOPIC_XXXX</span><br><span class="line"></span><br><span class="line">See http:&#x2F;&#x2F;rocketmq.apache.org&#x2F;docs&#x2F;faq&#x2F; for further details.</span><br><span class="line"></span><br><span class="line">at org.apache.rocketmq.client.impl.MQClientAPIImpl.getTopicRouteInfoFromNameServer(MQClientAPIImpl.java:1351)</span><br><span class="line"></span><br><span class="line">at org.apache.rocketmq.client.impl.MQClientAPIImpl.getTopicRouteInfoFromNameServer(MQClientAPIImpl.java:1321)</span><br><span class="line"></span><br><span class="line">at org.apache.rocketmq.tools.admin.DefaultMQAdminExtImpl.examineTopicRouteInfo(DefaultMQAdminExtImpl.java:305)</span><br><span class="line"></span><br><span class="line">at org.apache.rocketmq.tools.admin.DefaultMQAdminExtImpl.queryTopicConsumeByWho(DefaultMQAdminExtImpl.java:619)</span><br><span class="line"></span><br><span class="line">at org.apache.rocketmq.tools.admin.DefaultMQAdminExtImpl.messageTrackDetail(DefaultMQAdminExtImpl.java:776)</span><br><span class="line"></span><br><span class="line">at org.apache.rocketmq.tools.admin.DefaultMQAdminExt.messageTrackDetail(DefaultMQAdminExt.java:435)</span><br><span class="line"></span><br><span class="line">at org.apache.rocketmq.tools.command.message.QueryMsgByIdSubCommand.printMsg(QueryMsgByIdSubCommand.java:145)</span><br><span class="line"></span><br><span class="line">at org.apache.rocketmq.tools.command.message.QueryMsgByIdSubCommand.queryById(QueryMsgByIdSubCommand.java:49)</span><br><span class="line"></span><br><span class="line">at org.apache.rocketmq.tools.command.message.QueryMsgByIdSubCommand.execute(QueryMsgByIdSubCommand.java:252)</span><br><span class="line"></span><br><span class="line">at org.apache.rocketmq.tools.command.MQAdminStartup.main0(MQAdminStartup.java:138)</span><br><span class="line"></span><br><span class="line">at org.apache.rocketmq.tools.command.MQAdminStartup.main(MQAdminStartup.java:89)</span><br></pre></td></tr></table></figure>



<h2 id="原理回顾"><a href="#原理回顾" class="headerlink" title="原理回顾"></a>原理回顾</h2><p>延迟消息存储时被替换为“SCHEDULE_TOPIC_XXXX”主题，broker会为每个等级的建立定时任务进行调度，将各个等级到时间的消息替换为原来的主题，从而消费者可以消费到该消息。</p>
<p>以上日志加上消息查询结果已存储在“SCHEDULE_TOPIC_XXXX”，可以断定调度环节出问题了，由于offset远远超过最大offset而报错；没能将目标主题成功替换。</p>
<h2 id="报错源码"><a href="#报错源码" class="headerlink" title="报错源码"></a>报错源码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public MappedFile findMappedFileByOffset(final long offset, final boolean returnFirstOnNotFound) &#123;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">MappedFile firstMappedFile &#x3D; this.getFirstMappedFile();</span><br><span class="line"></span><br><span class="line">MappedFile lastMappedFile &#x3D; this.getLastMappedFile();</span><br><span class="line"></span><br><span class="line">if (firstMappedFile !&#x3D; null &amp;&amp; lastMappedFile !&#x3D; null) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这里报错了，每次用offset&#x3D;509548460来查，可是总大小才6000000</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 每次来查报错返回null</span><br><span class="line"></span><br><span class="line">if (offset &lt; firstMappedFile.getFileFromOffset() || offset &gt;&#x3D; lastMappedFile.getFileFromOffset() + this.mappedFileSize) &#123;</span><br><span class="line"></span><br><span class="line">LOG_ERROR.warn(&quot;Offset not matched. Request offset: &#123;&#125;, firstOffset: &#123;&#125;, lastOffset: &#123;&#125;, mappedFileSize: &#123;&#125;, mappedFiles count: &#123;&#125;&quot;,</span><br><span class="line"></span><br><span class="line">offset,</span><br><span class="line"></span><br><span class="line">firstMappedFile.getFileFromOffset(),</span><br><span class="line"></span><br><span class="line">lastMappedFile.getFileFromOffset() + this.mappedFileSize,</span><br><span class="line"></span><br><span class="line">this.mappedFileSize,</span><br><span class="line"></span><br><span class="line">this.mappedFiles.size());</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">log.error(&quot;findMappedFileByOffset Exception&quot;, e);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return null;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>调用位置：ScheduleMessageService#executeOnTimeup</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 根据offset捞取消息内容</span><br><span class="line"></span><br><span class="line">MessageExt msgExt &#x3D; ScheduleMessageService.this.defaultMessageStore.lookMessageByOffset(</span><br><span class="line">offsetPy, sizePy);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 处理结束后处理位点自增</span><br><span class="line"></span><br><span class="line">nextOffset &#x3D; offset + (i &#x2F; ConsumeQueue.CQ_STORE_UNIT_SIZE);</span><br><span class="line">ScheduleMessageService.this.updateOffset(this.delayLevel, nextOffset);</span><br></pre></td></tr></table></figure>



<p>其中offsetPy来自ConsumeQueue；另外delayOffset.json存储延迟消息的处理进度。</p>
<h1 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h1><p>将”delayOffset.json”和”consumequeue/SCHEDULE_TOPIC_XXXX”移到其他目录，相当于删除；逐台重启broker节点。重启结束后，经过验证，延迟消息功能正常发送和消费。</p>
<h1 id="结束了吗？"><a href="#结束了吗？" class="headerlink" title="结束了吗？"></a>结束了吗？</h1><p>看到这里你可能还有疑问，offset如何能增长到665682360这么大的？而且offset完全由broker自身去调度后自增的，并非由客户端上报的。记得前年RocketMQ也出现过类似问题，那时候RocketMQ版本是4.1，在测试环境延迟消息失效。此问题很罕见，一年未必碰到一会，后面会提交给社区讨论下。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ15# RocketMQ生产环境配置</title>
    <url>/posts/50d4ff7d/</url>
    <content><![CDATA[<div id="vip-container"><p>一份RocketMQ生产环境的配置文件，供参考，集群架构为异步刷盘异步复制。另外有补充的欢迎后台留言给我。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#请修改</span><br><span class="line"></span><br><span class="line">brokerClusterName&#x3D;XXXCluster</span><br><span class="line"></span><br><span class="line">brokerName&#x3D;broker-a</span><br><span class="line"></span><br><span class="line">brokerId&#x3D;0</span><br><span class="line"></span><br><span class="line">listenPort&#x3D;10911</span><br><span class="line"></span><br><span class="line">#请修改</span><br><span class="line"></span><br><span class="line">namesrvAddr&#x3D;x.x.x.x:9876;x.x.x.x::9876</span><br><span class="line"></span><br><span class="line">defaultTopicQueueNums&#x3D;4</span><br><span class="line"></span><br><span class="line">autoCreateTopicEnable&#x3D;false</span><br><span class="line"></span><br><span class="line">autoCreateSubscriptionGroup&#x3D;false</span><br><span class="line"></span><br><span class="line">deleteWhen&#x3D;04</span><br><span class="line"></span><br><span class="line">fileReservedTime&#x3D;48</span><br><span class="line"></span><br><span class="line">mapedFileSizeCommitLog&#x3D;1073741824</span><br><span class="line"></span><br><span class="line">mapedFileSizeConsumeQueue&#x3D;50000000</span><br><span class="line"></span><br><span class="line">destroyMapedFileIntervalForcibly&#x3D;120000</span><br><span class="line"></span><br><span class="line">redeleteHangedFileInterval&#x3D;120000</span><br><span class="line"></span><br><span class="line">diskMaxUsedSpaceRatio&#x3D;88</span><br><span class="line"></span><br><span class="line">#存储路径</span><br><span class="line"></span><br><span class="line">storePathRootDir&#x3D;&#x2F;data&#x2F;rocketmq&#x2F;store</span><br><span class="line"></span><br><span class="line">#commitLog存储路径</span><br><span class="line"></span><br><span class="line">storePathCommitLog&#x3D;&#x2F;data&#x2F;rocketmq&#x2F;store&#x2F;commitlog</span><br><span class="line"></span><br><span class="line">#消费队列存储路径</span><br><span class="line"></span><br><span class="line">storePathConsumeQueue&#x3D;&#x2F;data&#x2F;rocketmq&#x2F;store&#x2F;consumequeue</span><br><span class="line"></span><br><span class="line"># 消息索引存储路径</span><br><span class="line"></span><br><span class="line">storePathIndex&#x3D;&#x2F;data&#x2F;rocketmq&#x2F;store&#x2F;index</span><br><span class="line"></span><br><span class="line"># checkpoint 文件存储路径</span><br><span class="line"></span><br><span class="line">storeCheckpoint&#x3D;&#x2F;data&#x2F;rocketmq&#x2F;store&#x2F;checkpoint</span><br><span class="line"></span><br><span class="line">#abort 文件存储路径</span><br><span class="line"></span><br><span class="line">abortFile&#x3D;&#x2F;data&#x2F;rocketmq&#x2F;store&#x2F;abort</span><br><span class="line"></span><br><span class="line">maxMessageSize&#x3D;65536</span><br><span class="line"></span><br><span class="line">flushCommitLogLeastPages&#x3D;4</span><br><span class="line"></span><br><span class="line">flushConsumeQueueLeastPages&#x3D;2</span><br><span class="line"></span><br><span class="line">flushCommitLogThoroughInterval&#x3D;10000</span><br><span class="line"></span><br><span class="line">flushConsumeQueueThoroughInterval&#x3D;60000</span><br><span class="line"></span><br><span class="line">brokerRole&#x3D;SYNC_MASTER</span><br><span class="line"></span><br><span class="line">flushDiskType&#x3D;ASYNC_FLUSH</span><br><span class="line"></span><br><span class="line">checkTransactionMessageEnable&#x3D;false</span><br><span class="line"></span><br><span class="line">maxTransferCountOnMessageInMemory&#x3D;1000</span><br><span class="line"></span><br><span class="line">transientStorePoolEnable&#x3D;true</span><br><span class="line"></span><br><span class="line">warmMapedFileEnable&#x3D;true</span><br><span class="line"></span><br><span class="line">pullMessageThreadPoolNums&#x3D;128</span><br><span class="line"></span><br><span class="line">slaveReadEnable&#x3D;true</span><br><span class="line"></span><br><span class="line">transferMsgByHeap&#x3D;false</span><br><span class="line"></span><br><span class="line">waitTimeMillsInSendQueue&#x3D;1000</span><br></pre></td></tr></table></figure>

</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ17# RocketMQ/Kafka监控项整理</title>
    <url>/posts/7cbb1243/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="系统监控项"><a href="#系统监控项" class="headerlink" title="系统监控项"></a>系统监控项</h1><h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><p>CPU使用率、CPU Load、</p>
<h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>内存使用率</p>
<h2 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h2><p>磁盘使用率、磁盘IO、磁盘IOWAIT</p>
<h2 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h2><p>带宽检测</p>
<a id="more"></a>



<h2 id="实例存活"><a href="#实例存活" class="headerlink" title="实例存活"></a>实例存活</h2><p>集群实例是否存活、实例端口是否可达</p>
<h2 id="JVM监控"><a href="#JVM监控" class="headerlink" title="JVM监控"></a>JVM监控</h2><p>堆内存、Full GC时间等</p>
<h1 id="集群监控项"><a href="#集群监控项" class="headerlink" title="集群监控项"></a>集群监控项</h1><h2 id="集群节点数量"><a href="#集群节点数量" class="headerlink" title="集群节点数量"></a>集群节点数量</h2><p>注：比如RocketMQ集群中有4主4从；当Master节点数量小于4时</p>
<h2 id="集群节点可用性"><a href="#集群节点可用性" class="headerlink" title="集群节点可用性"></a>集群节点可用性</h2><p>注：检测集群节点是否可达以及RT Time</p>
<h2 id="集群写入TPS"><a href="#集群写入TPS" class="headerlink" title="集群写入TPS"></a>集群写入TPS</h2><p>注：例如集群写入TPS压测值的40%</p>
<h2 id="集群消费TPS"><a href="#集群消费TPS" class="headerlink" title="集群消费TPS"></a>集群消费TPS</h2><p>注：集群消费TPS需关注带宽及CPU</p>
<h2 id="集群写入TPS变化率"><a href="#集群写入TPS变化率" class="headerlink" title="集群写入TPS变化率"></a>集群写入TPS变化率</h2><p>注：例如5分钟内集群TPS陡增30%</p>
<h2 id="集群消费TPS变化率"><a href="#集群消费TPS变化率" class="headerlink" title="集群消费TPS变化率"></a>集群消费TPS变化率</h2><p>注：例如5分钟内集群TPS陡增30%</p>
<h2 id="集群日消息总量的变化"><a href="#集群日消息总量的变化" class="headerlink" title="集群日消息总量的变化"></a>集群日消息总量的变化</h2><p>注：例如集群中每日的消息总量监控</p>
<h2 id="Broker写入-消费TPS"><a href="#Broker写入-消费TPS" class="headerlink" title="Broker写入/消费TPS"></a>Broker写入/消费TPS</h2><p>注：单节点的写入/消费TPS</p>
<!--more-->



<h1 id="主题监控项"><a href="#主题监控项" class="headerlink" title="主题监控项"></a>主题监控项</h1><h2 id="主题写入TPS"><a href="#主题写入TPS" class="headerlink" title="主题写入TPS"></a>主题写入TPS</h2><p>注：单一主题的写入速率</p>
<h2 id="主题写入TPS的变化率"><a href="#主题写入TPS的变化率" class="headerlink" title="主题写入TPS的变化率"></a>主题写入TPS的变化率</h2><p>注：例如某一主题5分钟内速率陡增30%</p>
<h2 id="主题日消息量"><a href="#主题日消息量" class="headerlink" title="主题日消息量"></a>主题日消息量</h2><p>注：例如单一主题每日消息量</p>
<h2 id="死信队列监控"><a href="#死信队列监控" class="headerlink" title="死信队列监控"></a>死信队列监控</h2><p>注：被丢入死信队列的消息监控</p>
<h1 id="消费组监控项"><a href="#消费组监控项" class="headerlink" title="消费组监控项"></a>消费组监控项</h1><h2 id="消费积压"><a href="#消费积压" class="headerlink" title="消费积压"></a>消费积压</h2><p>注：积压量的监控</p>
<h2 id="消费TPS"><a href="#消费TPS" class="headerlink" title="消费TPS"></a>消费TPS</h2><p>注：消费速率监控</p>
<h2 id="消费阻塞"><a href="#消费阻塞" class="headerlink" title="消费阻塞"></a>消费阻塞</h2><p>注：消费者隔特定时间未消费数据</p>
<h2 id="消费速率变化"><a href="#消费速率变化" class="headerlink" title="消费速率变化"></a>消费速率变化</h2><p>注：例如5分钟之内消费速率陡降了30%</p>
<h1 id="发送客户端监控项"><a href="#发送客户端监控项" class="headerlink" title="发送客户端监控项"></a>发送客户端监控项</h1><h2 id="发送消息体大小变化"><a href="#发送消息体大小变化" class="headerlink" title="发送消息体大小变化"></a>发送消息体大小变化</h2><p>注：发送消息的大小在小于1K、1～2K、大于5K等的分布</p>
<h2 id="发送耗时变化"><a href="#发送耗时变化" class="headerlink" title="发送耗时变化"></a>发送耗时变化</h2><p>注：单节点消息发送在不通时间范围内的分布</p>
<h2 id="发送速率变化"><a href="#发送速率变化" class="headerlink" title="发送速率变化"></a>发送速率变化</h2><p>注：单个发送节点速率变化</p>
<h2 id="发送成功失败分布"><a href="#发送成功失败分布" class="headerlink" title="发送成功失败分布"></a>发送成功失败分布</h2><p>注：消息发送成功/失败分布情况</p>
<h1 id="消费客户端监控项"><a href="#消费客户端监控项" class="headerlink" title="消费客户端监控项"></a>消费客户端监控项</h1><h2 id="消费速率变化-1"><a href="#消费速率变化-1" class="headerlink" title="消费速率变化"></a>消费速率变化</h2><p>注：单节点速率变化</p>
<h2 id="消费耗时变化"><a href="#消费耗时变化" class="headerlink" title="消费耗时变化"></a>消费耗时变化</h2><p>注：单节点发送耗时分布情况</p>
<h2 id="消费成功失败分布"><a href="#消费成功失败分布" class="headerlink" title="消费成功失败分布"></a>消费成功失败分布</h2><p>注：单节点消费成功失败的分布情况</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ19# RocketMQ集群CPU毛刺问题复盘</title>
    <url>/posts/649ec9da/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>RocketMQ从节点、主节点频繁CPU飙高，很明显的毛刺，很多次从节点直接挂掉了。</p>
<p>详情截图如下：</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219075750.png"></p>
<a id="more"></a>



<h1 id="集群情况"><a href="#集群情况" class="headerlink" title="集群情况"></a>集群情况</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RocketMQ版本使用4.5.2，4主4从模式</span><br><span class="line"></span><br><span class="line">集群tps在8000左右</span><br><span class="line"></span><br><span class="line">单节点配置32C&#x2F;128G&#x2F;1.7T</span><br><span class="line"></span><br><span class="line">其中2从部署在阿里云ECS上，即一个集群6台ECS</span><br><span class="line"></span><br><span class="line">内核版本：Linux version 2.6.32-754.18.2.el6.x86_64 (mockbuild@x86-01.bsys.centos.org) (gcc version 4.4.7 20120313 (Red Hat 4.4.7-23) (GCC) ) #1 SMP Wed Aug 14 16:26:59 UTC 2019</span><br></pre></td></tr></table></figure>



<h1 id="内核参数"><a href="#内核参数" class="headerlink" title="内核参数"></a>内核参数</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vm.overcommit_memory&#x3D;1</span><br><span class="line"></span><br><span class="line">vm.drop_caches&#x3D;1</span><br><span class="line"></span><br><span class="line">vm.zone_reclaim_mode&#x3D;0</span><br><span class="line"></span><br><span class="line">vm.max_map_count&#x3D;655360</span><br><span class="line"></span><br><span class="line">vm.dirty_background_ratio&#x3D;50</span><br><span class="line"></span><br><span class="line">vm.dirty_ratio&#x3D;50</span><br><span class="line"></span><br><span class="line">vm.dirty_writeback_centisecs&#x3D;360000</span><br><span class="line"></span><br><span class="line">vm.page-cluster&#x3D;3</span><br><span class="line"></span><br><span class="line">vm.swappiness&#x3D;1</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">备注：搭建时的内核参数主从一致的，内容如上，之前使用该参数配置在RocketMQ集群4.1版本中，未发生任何异常情况。</span><br></pre></td></tr></table></figure>

<h1 id="从节点JVM参数"><a href="#从节点JVM参数" class="headerlink" title="从节点JVM参数"></a>从节点JVM参数</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;java&#x2F;jdk1.8.0_66&#x2F;bin&#x2F;java -server -Xms8g -Xmx8g -Xmn4g -XX:+UseG1GC -XX:G1HeapRegionSize&#x3D;16m -XX:G1ReservePercent&#x3D;25 -XX:InitiatingHeapOccupancyPercent&#x3D;30 -XX:SoftRefLRUPolicyMSPerMB&#x3D;0 -verbose:gc -Xloggc:&#x2F;dev&#x2F;shm&#x2F;rmq_broker_gc_%p_%t.log -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCApplicationStoppedTime -XX:+PrintAdaptiveSizePolicy -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles&#x3D;5 -XX:GCLogFileSize&#x3D;30m -XX:-OmitStackTraceInFastThrow -XX:+AlwaysPreTouch -XX:MaxDirectMemorySize&#x3D;15g -XX:-UseLargePages -XX:-UseBiasedLocking -Djava.ext.dirs&#x3D;&#x2F;usr&#x2F;java&#x2F;jdk1.8.0_66&#x2F;jre&#x2F;lib&#x2F;ext:&#x2F;workspace&#x2F;rocketmq-all-4.5.2-bin-release&#x2F;bin&#x2F;..&#x2F;lib -cp .:&#x2F;workspace&#x2F;rocketmq-all-4.5.2-bin-release&#x2F;bin&#x2F;..&#x2F;conf:.:&#x2F;usr&#x2F;java&#x2F;jdk1.8.0_66&#x2F;lib&#x2F;tools.jar:&#x2F;usr&#x2F;java&#x2F;jdk1.8.0_66&#x2F;lib&#x2F;dt.jar org.apache.rocketmq.broker.BrokerStartup -c &#x2F;workspace&#x2F;rocketmq-all-4.5.2-bin-release&#x2F;conf&#x2F;2m-2s-async&#x2F;broker-d-s.properties</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">备注：堆内存分配为8G</span><br></pre></td></tr></table></figure>

<h1 id="问题详情"><a href="#问题详情" class="headerlink" title="问题详情"></a>问题详情</h1><h2 id="主节点出现闪断"><a href="#主节点出现闪断" class="headerlink" title="主节点出现闪断"></a>主节点出现闪断</h2><p>在3月16日出现了CPU sys飙高导致broker约有1分钟的不可用，具体系统日志错误为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2020-03-16T17:56:07.505715+08:00 VECS0xxxx kernel: &lt;IRQ&gt; [&lt;ffffffff81143c31&gt;] ? __alloc_pages_nodemask+0x7e1&#x2F;0x960</span><br><span class="line"></span><br><span class="line">2020-03-16T17:56:07.505717+08:00 VECS0xxxx kernel: java: page allocation failure. order:0, mode:0x20</span><br><span class="line"></span><br><span class="line">2020-03-16T17:56:07.505719+08:00 VECS0xxxx kernel: Pid: 12845, comm: java Not tainted 2.6.32-754.17.1.el6.x86_64 #1</span><br><span class="line"></span><br><span class="line">2020-03-16T17:56:07.505721+08:00 VECS0xxxx kernel: Call Trace:</span><br><span class="line"></span><br><span class="line">2020-03-16T17:56:07.505724+08:00 VECS0xxxx kernel: &lt;IRQ&gt; [&lt;ffffffff81143c31&gt;] ? __alloc_pages_nodemask+0x7e1&#x2F;0x960</span><br><span class="line"></span><br><span class="line">2020-03-16T17:56:07.505726+08:00 VECS0xxxx kernel: [&lt;ffffffff8148e700&gt;] ? dev_queue_xmit+0xd0&#x2F;0x360</span><br><span class="line"></span><br><span class="line">2020-03-16T17:56:07.505729+08:00 VECS0xxxx kernel: [&lt;ffffffff814cb3e2&gt;] ? ip_finish_output+0x192&#x2F;0x380</span><br><span class="line"></span><br><span class="line">2020-03-16T17:56:07.505732+08:00 VECS0xxxx kernel: [&lt;ffffffff811862e2&gt;] ?</span><br></pre></td></tr></table></figure>



<p>截图如下：</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219080000.png"></p>
<p>解决方式调整了主节点的内核参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vm.zone_reclaim_mode &#x3D; 1</span><br><span class="line"></span><br><span class="line">vm.min_free_kbytes &#x3D; 512000</span><br></pre></td></tr></table></figure>



<p>当前主节点的内核参数配置为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vm.overcommit_memory&#x3D;1</span><br><span class="line"></span><br><span class="line">vm.drop_caches&#x3D;1</span><br><span class="line"></span><br><span class="line">vm.zone_reclaim_mode&#x3D;0</span><br><span class="line"></span><br><span class="line">vm.max_map_count&#x3D;655360</span><br><span class="line"></span><br><span class="line">vm.dirty_background_ratio&#x3D;25</span><br><span class="line"></span><br><span class="line">vm.dirty_ratio&#x3D;25</span><br><span class="line"></span><br><span class="line">vm.dirty_writeback_centisecs&#x3D;360000</span><br><span class="line"></span><br><span class="line">vm.page-cluster&#x3D;3</span><br><span class="line"></span><br><span class="line">vm.swappiness&#x3D;1</span><br><span class="line"></span><br><span class="line">vm.zone_reclaim_mode &#x3D; 1</span><br><span class="line"></span><br><span class="line">vm.min_free_kbytes &#x3D; 512000</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">备注：主节点详细过程参见下文：</span><br></pre></td></tr></table></figure>

<p>RocketMQ关于Broker闪断故障排查【实战笔记】</p>
<p><a href="https://mp.weixin.qq.com/s/8EE7_MqV-oZBYqtrdrlUIw">https://mp.weixin.qq.com/s/8EE7_MqV-oZBYqtrdrlUIw</a></p>
<h2 id="从节点挂掉情况"><a href="#从节点挂掉情况" class="headerlink" title="从节点挂掉情况"></a>从节点挂掉情况</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">调整主节点时把从节点也统一调整了，从节点也调整成了zone_reclaim_mode和min_free_kbytes参数</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vm.overcommit_memory&#x3D;0</span><br><span class="line"></span><br><span class="line">vm.drop_caches&#x3D;1</span><br><span class="line"></span><br><span class="line">vm.zone_reclaim_mode&#x3D;0</span><br><span class="line"></span><br><span class="line">vm.max_map_count&#x3D;655360</span><br><span class="line"></span><br><span class="line">vm.dirty_background_ratio&#x3D;10</span><br><span class="line"></span><br><span class="line">vm.dirty_ratio&#x3D;10</span><br><span class="line"></span><br><span class="line">vm.dirty_writeback_centisecs&#x3D;360000</span><br><span class="line"></span><br><span class="line">vm.page-cluster&#x3D;3</span><br><span class="line"></span><br><span class="line">vm.swappiness&#x3D;1</span><br><span class="line"></span><br><span class="line">vm.zone_reclaim_mode &#x3D; 1</span><br><span class="line"></span><br><span class="line">vm.min_free_kbytes &#x3D; 512000</span><br></pre></td></tr></table></figure>



<p>此后从节点频繁出现了CPU飙高导致节点挂掉的情况，都是CPU sys在飙高，系统日志如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">30 2020-03-27T10:35:28.769900+08:00 VECSxxxx kernel: INFO: task AliYunDunUpdate:29054 blocked for more than 120 seconds.</span><br><span class="line"></span><br><span class="line">31 2020-03-27T10:35:28.769932+08:00 VECSxxxx kernel: Not tainted 2.6.32-754.17.1.el6.x86_64 #1</span><br><span class="line"></span><br><span class="line">32 2020-03-27T10:35:28.771650+08:00 VECS0xxxx kernel: &quot;echo 0 &gt; &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;hung_task_timeout_secs&quot; disables this message.</span><br><span class="line"></span><br><span class="line">33 2020-03-27T10:35:28.774631+08:00 VECS0xxxx kernel: AliYunDunUpda D ffffffff815592fb 0 29054 1 0x10000080</span><br><span class="line"></span><br><span class="line">34 2020-03-27T10:35:28.777500+08:00 VECS0xxxx kernel: ffff8803ef75baa0 0000000000000082 ffff8803ef75ba68 ffff8803ef75ba64</span><br><span class="line"></span><br><span class="line">35 2020-03-27T10:35:28.780557+08:00 VECS0xxxx kernel: ffff8803ef75bae8 00000000000014a6 002d61b26118849c ffff880099b18c00</span><br><span class="line"></span><br><span class="line">36 2020-03-27T10:35:28.782853+08:00 VECS0xxxx kernel: 00000003f95c0502 0000000000000a2a ffff880488c665f8 ffff8803ef75bfd8</span><br></pre></td></tr></table></figure>



<p>为解决“blocked for more than 120 seconds”问题两次调整从节点dirty参数，从50%调整到25%后还是出现飙高情况，然后调整到10%，最终还是出现CPU飙高，截图如下：</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219080121.png"></p>
<p>系统message日志</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1656 2020-04-01T17:19:52.462310+08:00 VECS0xxxx kernel: INFO: task netstat:30311 blocked for more than 120 seconds.</span><br><span class="line"></span><br><span class="line">1657 2020-04-01T17:19:52.464266+08:00 VECS0xxx kernel: Not tainted 2.6.32-754.18.2.el6.x86_64 #1</span><br><span class="line"></span><br><span class="line">1658 2020-04-01T17:19:52.466011+08:00 VECS0xxxx kernel: &quot;echo 0 &gt; &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;hung_task_timeout_secs&quot; disables this messa ge.</span><br><span class="line"></span><br><span class="line">1659 2020-04-01T17:19:52.468971+08:00 VECS0xxxx kernel: netstat D ffffffff8160d9e0 0 30311 1 0x10000084</span><br><span class="line"></span><br><span class="line">1660 2020-04-01T17:19:52.471907+08:00 VECS0xxx kernel: ffff8801b0443d10 0000000000000082 0000000000000000 ffff88011ffc6ab0</span><br><span class="line"></span><br><span class="line">1661 2020-04-01T17:19:52.474211+08:00 VECS0xxxx kernel: ffff88000005b5c0 ffff88011ffc6ab0 0000275feaea8627 0000000000000002</span><br><span class="line"></span><br><span class="line">1662 2020-04-01T17:19:52.477311+08:00 VECS0xxxx kernel: 00000001029004e5 000000000000030f ffff88011ffc7068 ffff8801b0443fd8</span><br><span class="line"></span><br><span class="line">1663 2020-04-01T17:19:52.477323+08:00 VECS0xxxx kernel: Call Trace:</span><br><span class="line"></span><br><span class="line">1664 2020-04-01T17:19:52.478328+08:00 VECS0xxxx kernel: [&lt;ffffffff811c4b60&gt;] ? mntput_no_expire+0x30&#x2F;0x110</span><br><span class="line"></span><br><span class="line">1665 2020-04-01T17:19:52.482136+08:00 VECS0xxxx kernel: [&lt;ffffffff8155c6d5&gt;] rwsem_down_failed_common+0x95&#x2F;0x1d0</span><br><span class="line"></span><br><span class="line">1666 2020-04-01T17:19:52.482149+08:00 VECS0xxxx kernel: [&lt;ffffffff81244db5&gt;] ? security_inode_permission+0x25&#x2F;0x30</span><br></pre></td></tr></table></figure>



<h1 id="继续调整内核参数"><a href="#继续调整内核参数" class="headerlink" title="继续调整内核参数"></a>继续调整内核参数</h1><p>问题首先发生在主节点，调整min_free_kbytes和zone_reclaim_mode参数后，主节点问题没有再发生。是否由于把从节点的也调整了，导致了从节点CPU sys飙高挂掉？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">将min_free_kbytes调低来看下从节点的运行情况，将min_free_kbytes调低到128000</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：但是很遗憾，不管内核参数如何调整。CPU毛刺现象只能缓解，却不能有效根除。</span><br></pre></td></tr></table></figure>

<p>CPU spike on slave node: <a href="https://github.com/apache/rocketmq/issues/1910">https://github.com/apache/rocketmq/issues/1910</a></p>
<!--more-->



<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>为此特在社区提了个问题，也得到了RocketMQ创始人冯嘉和RocketMQ Committer杜恒两位大佬的关注和指点。杜恒大佬有提Linux内核2.6的操作系统有bug会导致类似情况。回想一下原东家的RocketMQ集群运行以来从未出现过如此诡异现象，虽让好友将内核版本发与我，内核版本为3.10。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219080227.png"></p>
<p>问题必须解决，这里是生产环境。所以对线上所有集群主从节点全部从centos6升级到centos7，内核版本也从从2.6升级到3.10。升级后通过半个月左右的观察，未出现CPU毛刺问题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Linux version 3.10.0-1062.4.1.el7.x86_64 (mockbuild@kbuilder.bsys.centos.org) (gcc version 4.8.5 20150623 (Red Hat 4.8.5-39) (GCC) ) #1 SMP Fri Oct 18 17:15:30 UTC 2019</span><br></pre></td></tr></table></figure>



</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ18# RocketMQ关于Broker闪断故障排查</title>
    <url>/posts/89ef1054/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>在2020-03-16 18:00左右收到告警，业务出现发送RocketMQ失败，在约1分钟左右后自动恢复。RocketMQ运行向来稳定，为何也抖动了？</p>
<a id="more"></a>



<h1 id="Broker日志分析"><a href="#Broker日志分析" class="headerlink" title="Broker日志分析"></a>Broker日志分析</h1><h2 id="查看GC日志"><a href="#查看GC日志" class="headerlink" title="查看GC日志"></a>查看GC日志</h2><p>通过查看发时间问题时间附近GC日志并无发现异常。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2020-03-16T17:49:13.785+0800: 13484510.599: Total time for which application threads were stopped: 0.0072354 seconds, Stopping threads took: 0.0001536 seconds</span><br><span class="line"></span><br><span class="line">2020-03-16T18:01:23.149+0800: 13485239.963: [GC pause (G1 Evacuation Pause) (young) 13485239.965: [G1Ergonomics (CSet Construction) start choosing CSet, _pending_cards: 7738, predicted base time: 5.74 ms, remaining time: 194.26 ms, target pause time: 200.00 ms]</span><br><span class="line"></span><br><span class="line">13485239.965: [G1Ergonomics (CSet Construction) add young regions to CSet, eden: 255 regions, survivors: 1 regions, predicted young region time: 0.52 ms]</span><br><span class="line"></span><br><span class="line">13485239.965: [G1Ergonomics (CSet Construction) finish choosing CSet, eden: 255 regions, survivors: 1 regions, old: 0 regions, predicted pause time: 6.26 ms, target pause time: 200.00 ms]</span><br><span class="line"></span><br><span class="line">, 0.0090963 secs]</span><br><span class="line"></span><br><span class="line">[Parallel Time: 2.3 ms, GC Workers: 23]</span><br><span class="line"></span><br><span class="line">[GC Worker Start (ms): Min: 13485239965.1, Avg: 13485239965.4, Max: 13485239965.7, Diff: 0.6]</span><br><span class="line"></span><br><span class="line">[Ext Root Scanning (ms): Min: 0.0, Avg: 0.3, Max: 0.6, Diff: 0.6, Sum: 8.0]</span><br><span class="line"></span><br><span class="line">[Update RS (ms): Min: 0.1, Avg: 0.3, Max: 0.6, Diff: 0.5, Sum: 7.8]</span><br><span class="line"></span><br><span class="line">[Processed Buffers: Min: 2, Avg: 5.7, Max: 11, Diff: 9, Sum: 131]</span><br><span class="line"></span><br><span class="line">[Scan RS (ms): Min: 0.0, Avg: 0.0, Max: 0.1, Diff: 0.1, Sum: 0.8]</span><br><span class="line"></span><br><span class="line">[Code Root Scanning (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.3]</span><br><span class="line"></span><br><span class="line">[Object Copy (ms): Min: 0.2, Avg: 0.5, Max: 0.7, Diff: 0.4, Sum: 11.7]</span><br><span class="line"></span><br><span class="line">[Termination (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.3]</span><br><span class="line"></span><br><span class="line">[Termination Attempts: Min: 1, Avg: 1.0, Max: 1, Diff: 0, Sum: 23]</span><br><span class="line"></span><br><span class="line">[GC Worker Other (ms): Min: 0.0, Avg: 0.2, Max: 0.3, Diff: 0.3, Sum: 3.6]</span><br><span class="line"></span><br><span class="line">[GC Worker Total (ms): Min: 1.0, Avg: 1.4, Max: 1.9, Diff: 0.8, Sum: 32.6]</span><br><span class="line"></span><br><span class="line">[GC Worker End (ms): Min: 13485239966.7, Avg: 13485239966.9, Max: 13485239967.0, Diff: 0.3]</span><br><span class="line"></span><br><span class="line">[Code Root Fixup: 0.0 ms]</span><br><span class="line"></span><br><span class="line">[Code Root Purge: 0.0 ms]</span><br><span class="line"></span><br><span class="line">[Clear CT: 0.9 ms]</span><br><span class="line"></span><br><span class="line">[Other: 5.9 ms]</span><br><span class="line"></span><br><span class="line">[Choose CSet: 0.0 ms]</span><br><span class="line"></span><br><span class="line">[Ref Proc: 1.9 ms]</span><br><span class="line"></span><br><span class="line">[Ref Enq: 0.0 ms]</span><br><span class="line"></span><br><span class="line">[Redirty Cards: 1.0 ms]</span><br><span class="line"></span><br><span class="line">[Humongous Register: 0.0 ms]</span><br><span class="line"></span><br><span class="line">[Humongous Reclaim: 0.0 ms]</span><br><span class="line"></span><br><span class="line">[Free CSet: 0.2 ms]</span><br><span class="line"></span><br><span class="line">[Eden: 4080.0M(4080.0M)-&gt;0.0B(4080.0M) Survivors: 16.0M-&gt;16.0M Heap: 4176.5M(8192.0M)-&gt;96.5M(8192.0M)]</span><br><span class="line"></span><br><span class="line">[Times: user&#x3D;0.05 sys&#x3D;0.00, real&#x3D;0.01 secs]</span><br></pre></td></tr></table></figure>



<h2 id="查看Broker日志"><a href="#查看Broker日志" class="headerlink" title="查看Broker日志"></a>查看Broker日志</h2><p>由日志可以看出：slave与问题节点broker同步信息异常。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2020-03-16 17:55:15 ERROR BrokerControllerScheduledThread1 - SyncTopicConfig Exception, x.x.x.x:10911</span><br><span class="line"></span><br><span class="line">org.apache.rocketmq.remoting.exception.RemotingTimeoutException: wait response on the channel &lt;x.x.x.x:10909&gt; timeout, 3000(ms)</span><br><span class="line"></span><br><span class="line">at org.apache.rocketmq.remoting.netty.NettyRemotingAbstract.invokeSyncImpl(NettyRemotingAbstract.java:427) ~[rocketmq-remoting-4.5.2.jar:4.5.2]</span><br><span class="line"></span><br><span class="line">at org.apache.rocketmq.remoting.netty.NettyRemotingClient.invokeSync(NettyRemotingClient.java:375) ~[rocketmq-remoting-4.5.2.jar:4.5.2]</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">备注：通过查看RocketMQ的集群和GC日志，只能说明但是网络不可用，造成主从同步问题；并未发现Broker自身出问题了。</span><br></pre></td></tr></table></figure>



<!--more-->



<h2 id="系统监控分析"><a href="#系统监控分析" class="headerlink" title="系统监控分析"></a>系统监控分析</h2><h2 id="网络监控"><a href="#网络监控" class="headerlink" title="网络监控"></a>网络监控</h2><p>网络ping在问题时间段发送中断，网络没有流量。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219074012.png"></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219074030.png"></p>
<h2 id="磁盘IO监控"><a href="#磁盘IO监控" class="headerlink" title="磁盘IO监控"></a>磁盘IO监控</h2><p>在问题时间段磁盘IO有陡增</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219074123.png"></p>
<h2 id="CPU监控"><a href="#CPU监控" class="headerlink" title="CPU监控"></a>CPU监控</h2><p>CPU在问题时间段有飙高后回落</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219074154.png"></p>
<h2 id="内存信息"><a href="#内存信息" class="headerlink" title="内存信息"></a>内存信息</h2><p>内存信息没有采集到，由于当时网络中断了。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219074213.png"></p>
<h2 id="集群流量"><a href="#集群流量" class="headerlink" title="集群流量"></a>集群流量</h2><p>除了网络终端未采集到数据外，问题时间断之前只有6000左右的TPS；网络恢复后有个脉冲到11301，然而总体负载很低。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2020-03-16T17:54:05.037+08:00 bike_mq totalTps 6576</span><br><span class="line"></span><br><span class="line">2020-03-16T17:54:15.037+08:00 bike_mq totalTps 6375</span><br><span class="line"></span><br><span class="line">2020-03-16T17:54:25.037+08:00 bike_mq totalTps 6334</span><br><span class="line"></span><br><span class="line">2020-03-16T17:54:35.037+08:00 bike_mq totalTps 6048</span><br><span class="line"></span><br><span class="line">2020-03-16T17:54:45.037+08:00 bike_mq totalTps 6162</span><br><span class="line"></span><br><span class="line">2020-03-16T17:54:55.037+08:00 bike_mq totalTps 6123</span><br><span class="line"></span><br><span class="line">2020-03-16T17:56:50.208+08:00 bike_mq totalTps 5128</span><br><span class="line"></span><br><span class="line">2020-03-16T17:57:19.177+08:00 bike_mq totalTps 6240</span><br><span class="line"></span><br><span class="line">2020-03-16T17:57:24.44+08:00 bike_mq totalTps 11301</span><br><span class="line"></span><br><span class="line">2020-03-16T17:57:30.072+08:00 bike_mq totalTps 9577</span><br><span class="line"></span><br><span class="line">2020-03-16T17:57:31.334+08:00 bike_mq totalTps 9485</span><br><span class="line"></span><br><span class="line">2020-03-16T17:57:32.564+08:00 bike_mq totalTps 9190</span><br><span class="line"></span><br><span class="line">2020-03-16T17:57:33.79+08:00 bike_mq totalTps 7742</span><br><span class="line"></span><br><span class="line">2020-03-16T17:57:35.043+08:00 bike_mq totalTps 7323</span><br><span class="line"></span><br><span class="line">2020-03-16T17:57:36.269+08:00 bike_mq totalTps 7058</span><br><span class="line"></span><br><span class="line">2020-03-16T17:57:37.502+08:00 bike_mq totalTps 6697</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">备注：通过监控看到在问题时间段网络、CPU、磁盘IO都出现了问题；到底是磁盘IO引起CPU飙高的？进而影响网络的；还是CPU先飙高引起网络中断和磁盘IO的。机器上只有一个RocketMQ进程，而且当时流量负载并不高；所以由应用进程导致CPU、网络、磁盘IO等问题是解释不通的。那会不会阿里云抖动呢？但是如果阿里云抖动为何只影响RocketMQ集群的3个节点呢？其他RocketMQ集群没有问题；业务机器也没有发现网络等问题。</span><br></pre></td></tr></table></figure>



<h1 id="Linux系统日志分析"><a href="#Linux系统日志分析" class="headerlink" title="Linux系统日志分析"></a>Linux系统日志分析</h1><p>通过查看问题时间段日志，发现页分配失败“page allocation failure. order:0, mode:0x20”，也就Page不够了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2020-03-16T17:56:07.505715+08:00 VECS0xxxx kernel: &lt;IRQ&gt; [&lt;ffffffff81143c31&gt;] ? __alloc_pages_nodemask+0x7e1&#x2F;0x960</span><br><span class="line"></span><br><span class="line">2020-03-16T17:56:07.505717+08:00 VECS0xxxx kernel: java: page allocation failure. order:0, mode:0x20</span><br><span class="line"></span><br><span class="line">2020-03-16T17:56:07.505719+08:00 VECS0xxxx kernel: Pid: 12845, comm: java Not tainted 2.6.32-754.17.1.el6.x86_64 #1</span><br><span class="line"></span><br><span class="line">2020-03-16T17:56:07.505721+08:00 VECS0xxxx kernel: Call Trace:</span><br><span class="line"></span><br><span class="line">2020-03-16T17:56:07.505724+08:00 VECS0xxxx kernel: &lt;IRQ&gt; [&lt;ffffffff81143c31&gt;] ? __alloc_pages_nodemask+0x7e1&#x2F;0x960</span><br><span class="line"></span><br><span class="line">2020-03-16T17:56:07.505726+08:00 VECS0xxxx kernel: [&lt;ffffffff8148e700&gt;] ? dev_queue_xmit+0xd0&#x2F;0x360</span><br><span class="line"></span><br><span class="line">2020-03-16T17:56:07.505729+08:00 VECS0xxxx kernel: [&lt;ffffffff814cb3e2&gt;] ? ip_finish_output+0x192&#x2F;0x380</span><br><span class="line"></span><br><span class="line">2020-03-16T17:56:07.505732+08:00 VECS0xxxx kernel: [&lt;ffffffff811862e2&gt;] ?</span><br></pre></td></tr></table></figure>



<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="调整内核参数"><a href="#调整内核参数" class="headerlink" title="调整内核参数"></a>调整内核参数</h2><p>系统版本：CentOS 6.10 内核版本：Linux version 2.6.32-754.17.1.el6.x86_64</p>
<p>在sysctl.conf修改参数vm.zone_reclaim_mode和vm.min_free_kbytes。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;sysctl.conf</span><br><span class="line"></span><br><span class="line">vm.zone_reclaim_mode &#x3D; 1</span><br><span class="line"></span><br><span class="line">vm.min_free_kbytes &#x3D; 512000</span><br><span class="line"></span><br><span class="line">sysctl -p &#x2F;etc&#x2F;sysctl.conf</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">备注：修改以上系统参数后，通过两天的观察，内核没有再抛“page allocation failure. order:0, mode:0x20”。</span><br></pre></td></tr></table></figure>

<p>参考文章</p>
<p><a href="https://access.redhat.com/solutions/90883">https://access.redhat.com/solutions/90883</a></p>
<p><a href="https://billtian.github.io/digoal.blog/2017/10/24/03.html">https://billtian.github.io/digoal.blog/2017/10/24/03.html</a></p>
<h2 id="参数含义说明"><a href="#参数含义说明" class="headerlink" title="参数含义说明"></a>参数含义说明</h2><p><strong>min_free_kbytes</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">This is used to force the Linux VM to keep a minimum number</span><br><span class="line"></span><br><span class="line">of kilobytes free. The VM uses this number to compute a</span><br><span class="line"></span><br><span class="line">watermark[WMARK_MIN] value for each lowmem zone in the system.</span><br><span class="line"></span><br><span class="line">Each lowmem zone gets a number of reserved free pages based</span><br><span class="line"></span><br><span class="line">proportionally on its size.</span><br><span class="line"></span><br><span class="line">Some minimal amount of memory is needed to satisfy PF_MEMALLOC</span><br><span class="line"></span><br><span class="line">allocations; if you set this to lower than 1024KB, your system will</span><br><span class="line"></span><br><span class="line">become subtly broken, and prone to deadlock under high loads.</span><br><span class="line"></span><br><span class="line">Setting this too high will OOM your machine instantly.</span><br></pre></td></tr></table></figure>



<p><strong>zone_reclaim_mode</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Zone_reclaim_mode allows someone to set more or less aggressive approaches to</span><br><span class="line"></span><br><span class="line">reclaim memory when a zone runs out of memory. If it is set to zero then no</span><br><span class="line"></span><br><span class="line">zone reclaim occurs. Allocations will be satisfied from other zones &#x2F; nodes</span><br><span class="line"></span><br><span class="line">in the system.</span><br><span class="line"></span><br><span class="line">This is value ORed together of</span><br><span class="line"></span><br><span class="line">1 &#x3D; Zone reclaim on</span><br><span class="line"></span><br><span class="line">2 &#x3D; Zone reclaim writes dirty pages out</span><br><span class="line"></span><br><span class="line">4 &#x3D; Zone reclaim swaps pages</span><br><span class="line"></span><br><span class="line">zone_reclaim_mode is disabled by default. For file servers or workloads</span><br><span class="line"></span><br><span class="line">that benefit from having their data cached, zone_reclaim_mode should be</span><br><span class="line"></span><br><span class="line">left disabled as the caching effect is likely to be more important than</span><br><span class="line"></span><br><span class="line">data locality.</span><br><span class="line"></span><br><span class="line">zone_reclaim may be enabled if it&#39;s known that the workload is partitioned</span><br><span class="line"></span><br><span class="line">such that each partition fits within a NUMA node and that accessing remote</span><br><span class="line"></span><br><span class="line">memory would cause a measurable performance reduction. The page allocator</span><br><span class="line"></span><br><span class="line">will then reclaim easily reusable pages (those page cache pages that are</span><br><span class="line"></span><br><span class="line">currently not used) before allocating off node pages.</span><br><span class="line"></span><br><span class="line">Allowing zone reclaim to write out pages stops processes that are</span><br><span class="line"></span><br><span class="line">writing large amounts of data from dirtying pages on other nodes. Zone</span><br><span class="line"></span><br><span class="line">reclaim will write out dirty pages if a zone fills up and so effectively</span><br><span class="line"></span><br><span class="line">throttle the process. This may decrease the performance of a single process</span><br><span class="line"></span><br><span class="line">since it cannot use all of system memory to buffer the outgoing writes</span><br><span class="line"></span><br><span class="line">anymore but it preserve the memory on other nodes so that the performance</span><br><span class="line"></span><br><span class="line">of other processes running on other nodes will not be affected.</span><br><span class="line"></span><br><span class="line">Allowing regular swap effectively restricts allocations to the local</span><br><span class="line"></span><br><span class="line">node unless explicitly overridden by memory policies or cpuset</span><br><span class="line"></span><br><span class="line">configurations.</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">备注：zone_reclaim_mode默认为0即不启用zone_reclaim模式，1为打开zone_reclaim模式从本地节点回收内存；min_free_kbytesy允许内核使用的最小内存。</span><br></pre></td></tr></table></figure>

<h1 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h1><p>在系统空闲内存低于 watermark[low]时，开始启动内核线程kswapd进行内存回收，直到该zone的空闲内存数量达到watermark[high]后停止回收。如果上层申请内存的速度太快，导致空闲内存降至watermark[min]后，内核就会进行direct reclaim（直接回收），即直接在应用程序的进程上下文中进行回收，再用回收上来的空闲页满足内存申请，因此实际会阻塞应用程序，带来一定的响应延迟，而且可能会触发系统OOM。这是因为watermark[min]以下的内存属于系统的自留内存，用以满足特殊使用，所以不会给用户态的普通申请来用。</p>
<p><strong>min_free_kbytes大小的影响</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">min_free_kbytes设的越大，watermark的线越高，同时三个线之间的buffer量也相应会增加。这意味着会较早的启动kswapd进行回收，且会回收上来较多的内存（直至watermark[high]才会停止），这会使得系统预留过多的空闲内存，从而在一定程度上降低了应用程序可使用的内存量。极端情况下设置min_free_kbytes接近内存大小时，留给应用程序的内存就会太少而可能会频繁地导致OOM的发生。</span><br><span class="line"></span><br><span class="line">min_free_kbytes设的过小，则会导致系统预留内存过小。kswapd回收的过程中也会有少量的内存分配行为（会设上PF_MEMALLOC）标志，这个标志会允许kswapd使用预留内存；另外一种情况是被OOM选中杀死的进程在退出过程中，如果需要申请内存也可以使用预留部分。这两种情况下让他们使用预留内存可以避免系统进入deadlock状态。</span><br></pre></td></tr></table></figure>



<p><strong>三个watermark的计算方法</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">watermark[min] &#x3D; min_free_kbytes换算为page单位即可，假设为min_free_pages。（因为是每个zone各有一套watermark参数，实际计算效果是根据各个zone大小所占内存总大小的比例，而算出来的per zone min_free_pages） watermark[low] &#x3D; watermark[min] * 5 &#x2F; 4 watermark[high] &#x3D; watermark[min] * 3 &#x2F; 2</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">备注：摘自“内存管理参数min_free_kbytes分析”，链接：https:&#x2F;&#x2F;www.dazhuanlan.com</span><br></pre></td></tr></table></figure></div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ20# RocketMQ集群实现平滑扩缩容</title>
    <url>/posts/69ff2739/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="运维需求"><a href="#运维需求" class="headerlink" title="运维需求"></a>运维需求</h1><p>在RocketMQ集群的实践中，对集群扩容、缩容、节点下线等运维做到平滑、业务无感知、数据无丢失，这个对于集群运维的同学来说非常重要。</p>
<p>比如前些日子出现的问题，由于线上集群频繁出现CPU毛刺甚至直接挂掉并伴随着集群抖动，对内核参数的调整只能减缓毛刺却不能消除抖动。集群抖动业务使用会伴随着发送延迟告警，始终是个必须处理的隐患。最终决定更换操作系统即更换内核。</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">集群信息: RocketMQ版本4.5.2</span><br><span class="line"></span><br><span class="line">主从信息：4主4从 broker-a, broker-b, broker-c, broker-d,</span><br><span class="line"></span><br><span class="line">broker-a(slave), broker-b(slave), broker-c(slave), broker-d(slave)</span><br></pre></td></tr></table></figure>

<p>操作系统: centos6</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Linux version 2.6.32-754.18.2.el6.x86_64 (mockbuild@x86-01.bsys.centos.org) (gcc version 4.4.7 20120313 (Red Hat 4.4.7-23) (GCC) ) #1 SMP Wed Aug 14 16:26:59 UTC 2019</span><br></pre></td></tr></table></figure>

<p>目标系统：centos7</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Linux version 3.10.0-1062.4.1.el7.x86_64 (mockbuild@kbuilder.bsys.centos.org) (gcc version 4.8.5 20150623 (Red Hat 4.8.5-39) (GCC) ) #1 SMP Fri Oct 18 17:15:30 UTC 2019</span><br></pre></td></tr></table></figure>



<p>集群的部署如下下图所示：</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219080526.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">其需要简单概括如下，就是要将上述集群的操作系统内核从 Centos6 升级到 Centos7,但业务不能停。</span><br></pre></td></tr></table></figure>



<h1 id="平滑扩容"><a href="#平滑扩容" class="headerlink" title="平滑扩容"></a>平滑扩容</h1><h2 id="下线从节点"><a href="#下线从节点" class="headerlink" title="下线从节点"></a>下线从节点</h2><p>从节点正常关闭rocketmq，从节点下线对业务不会造成影响，如果配置，slaveReadEnable=true，从节点的通常在消息回溯延迟超过内存消息的40%时使用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh bin&#x2F;mqshutdown broker</span><br><span class="line"></span><br><span class="line">or</span><br><span class="line"></span><br><span class="line">kill pid</span><br></pre></td></tr></table></figure>



<p>从节点下线之后，集群的部署情况如下图所示：</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219080558.png"></p>
<p>直接停掉从节点，并不影响当前业务的使用，因为写，读都可以通过主节点，对业务无影响。</p>
<h2 id="重组主从模式"><a href="#重组主从模式" class="headerlink" title="重组主从模式"></a>重组主从模式</h2><p>新申请4台机器与原从节点重新组合成主从关系。</p>
<p>具体操作为将新申请的4台机器的内核全部升级为Centos7内核，并部署为 broker-a1,broker-b1,broker-c1,broker-d1，这里如果使用 broker-e,f,f,h 命名，会造成流量切斜，导致消费不均衡，原因在文末会给出，大家不妨思考一下。</p>
<p>然后将上一步下掉的从节点，其内核全部升级为 centos7的内核。并将这些节点设置为新增4个主节点的从，其部署结构如下图所示：</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219080619.png"></p>
<p>此时集群中变成8主，其中新增集群有从节点，即装有centor7内核的新机器构成了4主4从，接下来就只需要将内核为centos6的主节点的数据消费完成，并下线即可。</p>
<!--more-->



<h1 id="平滑缩容"><a href="#平滑缩容" class="headerlink" title="平滑缩容"></a>平滑缩容</h1><p>接下来主要是将装有centos6内核的旧机器从集群中移除，具体操作如下。</p>
<h2 id="关闭broker写权限"><a href="#关闭broker写权限" class="headerlink" title="关闭broker写权限"></a>关闭broker写权限</h2><p>逐台关闭 broker-a, broker-b, broker-c, broker-d 的写入权限，其中4表示只读权限，6表示读写权限。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin updateBrokerConfig -b x.x.x.x:10911 -n x.x.x.x:9876 -k brokerPermission -v 4</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option PermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">update broker config success, x.x.x.x:10911</span><br></pre></td></tr></table></figure>



<h2 id="验证broker流量情况"><a href="#验证broker流量情况" class="headerlink" title="验证broker流量情况"></a>验证broker流量情况</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin clusterList -n x.x.x.x:9876</span><br></pre></td></tr></table></figure>

<p>等待broker出入流量均归零</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219080712.png"></p>
<p>验证broker积压情况</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin brokerConsumeStats -b x.x.x.x:10911 -n x.x.x.x:9876</span><br></pre></td></tr></table></figure>



<p>观察最后一行Diff Total等于0时表示该节点已经没有积压，即全部消费完毕。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219080746.png"></p>
<h2 id="节点下线"><a href="#节点下线" class="headerlink" title="节点下线"></a>节点下线</h2><p>当节点流量和积压都为0时，节点可以下线了。如果broker一直有流量或者积压一直存在呢？通常线上集群的存储时间为2～3天；可以在过了存储时间后再安排下线。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh bin&#x2F;mqshutdown broker</span><br><span class="line"></span><br><span class="line">or</span><br><span class="line"></span><br><span class="line">kill pid</span><br></pre></td></tr></table></figure>



<h1 id="问题答疑"><a href="#问题答疑" class="headerlink" title="问题答疑"></a>问题答疑</h1><p>上文中有提到过扩容新增节点时命名时不要使用 broker-e, broker-f, broker-g, broker-h；而采用broker-a1, broker-b1, broker-c1, broker-d1。</p>
<p>按照默认平均分配消费算法，如果采用第一种命名，当关闭broker-a, broker-b, broker-c, broker-d的写入权限时，数据会全部集中在broker-e, broker-f, broker-g, broker-h节点，假如线上部署了四台消费机器，会有两台机器分到broker-a, broker-b, broker-c, broker-d的分区，而另外两台机器分到broker-e, broker-f, broker-g, broker-h的分区。</p>
<p>而broker-a, broker-b, broker-c, broker-d节点的写权限被关闭后，会造成其中两台节点无数据，数据全部分配到另外的消费机器上。</p>
<p>因为只是关闭了broker-a,b,c,d的写权限，读权限未关闭，但如果使用broker-a,a1，b,b1这种命名方式，就能平衡其流量，不至于连续出现大部分队列上无数据的情况，使消费者负载趋于均衡。</p>
<p>在不影响业务的情况下，把集群内所有的节点全部重新更新内核就是这么溜，欢迎留言与作者互动，共同交流。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ21# 为何建议关闭RocketMQ预热配置</title>
    <url>/posts/a46a67ee/</url>
    <content><![CDATA[<div id="vip-container"><p>RocketMQ提供了一个预热配置项warmMapedFileEnable默认为关闭状态。曾在文章RocketMQ存储–映射文件预热【源码笔记】分析过文件预热流程。在预热文件时会填充1个G的假值0作为占位符，提前分配物理内存，防止消息写入时发生缺页异常。如此特性正如文章标题所说，为何建议关闭RocketMQ预热配置呢？</p>
<a id="more"></a>



<h1 id="服务端监控"><a href="#服务端监控" class="headerlink" title="服务端监控"></a>服务端监控</h1><h2 id="日志监控"><a href="#日志监控" class="headerlink" title="日志监控"></a>日志监控</h2><p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219081057.png"></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219081114.png"></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219081131.png"></p>
<h2 id="CPU情况"><a href="#CPU情况" class="headerlink" title="CPU情况"></a>CPU情况</h2><p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219081205.png"></p>
<p>由服务端日志可以看出，在预热时broker会发生较长的耗时，10～30秒不等，CPU也会有小幅抖动，这会造成什么影响呢？接着看下文</p>
<!--more-->



<h1 id="客户端发送监控"><a href="#客户端发送监控" class="headerlink" title="客户端发送监控"></a>客户端发送监控</h1><p>在broker预热时，客户端耗时长达5秒。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219081226.png"></p>
<p>在broker预热时，客户端耗时长达6秒</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219081243.png"></p>
<p>在此时间段，业务应用伴随着大量超时报警。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>在broker预热时，往往伴随着磁盘写入耗时过长、CPU小幅抖动、业务具体表现为发送耗时过长，超时错误增多。关闭预热配置从集群TPS摸高情况来看并未有明显的差异，但是从稳定性角度关闭却很有必要。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ2# RocketMQ Consumer命令</title>
    <url>/posts/e790de00/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="创建订阅组"><a href="#创建订阅组" class="headerlink" title="创建订阅组"></a>创建订阅组</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin updateSubGroup -n localhost:9876 -c DefaultCluster -g zto-tst-consumer</span><br></pre></td></tr></table></figure>



<h1 id="删除订阅组"><a href="#删除订阅组" class="headerlink" title="删除订阅组"></a>删除订阅组</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin deleteSubGroup -n 192.168.1.x:9876 -c AdpMqCluster -g CODCANCELSIGN</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option PermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">delete subscription group [CODCANCELSIGN] from broker [192.168.1.x:10911] in cluster [AdpMqCluster] success.</span><br><span class="line"></span><br><span class="line">delete subscription group [CODCANCELSIGN] from broker [192.168.1.x:10911] in cluster [AdpMqCluster] success.</span><br><span class="line"></span><br><span class="line">delete subscription group [CODCANCELSIGN] from broker [192.168.1.x:10919] in cluster [AdpMqCluster] success.</span><br><span class="line"></span><br><span class="line">delete subscription group [CODCANCELSIGN] from broker [192.168.1.x:10915] in cluster [AdpMqCluster] success.</span><br><span class="line"></span><br><span class="line">delete subscription group [CODCANCELSIGN] from broker [192.168.1.x:10915] in cluster [AdpMqCluster] success.</span><br><span class="line"></span><br><span class="line">delete subscription group [CODCANCELSIGN] from broker [192.168.1.x:10919] in cluster [AdpMqCluster] success.</span><br><span class="line"></span><br><span class="line">delete topic [%RETRY%CODCANCELSIGN] from cluster [xMqCluster] success.</span><br><span class="line"></span><br><span class="line">delete topic [%RETRY%CODCANCELSIGN] from NameServer success.</span><br><span class="line"></span><br><span class="line">delete topic [%DLQ%CODCANCELSIGN] from cluster [xMqCluster] success.</span><br><span class="line"></span><br><span class="line">delete topic [%DLQ%CODCANCELSIGN] from NameServer success.</span><br></pre></td></tr></table></figure>



<a id="more"></a>



<h1 id="查看消费组情况及IP地址"><a href="#查看消费组情况及IP地址" class="headerlink" title="查看消费组情况及IP地址"></a>查看消费组情况及IP地址</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin consumerStatus -g TraceToCaiNiao -n 192.168.1.x:9876</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option PermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">001 192.168.12.122@25063 V3_5_8 1539756615406&#x2F;192.168.x.x@25063</span><br><span class="line"></span><br><span class="line">002 192.168.13.96@3351 V3_5_8 1539756615406&#x2F;192.168.x.x@3351</span><br><span class="line"></span><br><span class="line">003 192.168.x.x@13385 V3_5_8 1539756615406&#x2F;192.168.x.x@13385</span><br><span class="line"></span><br><span class="line">004 192.168.x.x@6691 V3_5_8 1539756615406&#x2F;192.168.x.x@6691</span><br></pre></td></tr></table></figure>



<h1 id="查看消费组情况"><a href="#查看消费组情况" class="headerlink" title="查看消费组情况"></a>查看消费组情况</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin consumerProgress -n 192.168.1.x:9876 -g SortComplementConsumer</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option PermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">Topic Broker Name QID Broker Offset Consumer Offset Diff LastTime</span><br><span class="line"></span><br><span class="line">%RETRY%SortComplementConsumer broker-a 0 1 1 0 2018-10-22 12:43:13</span><br><span class="line"></span><br><span class="line">%RETRY%SortComplementConsumer broker-b 0 2 2 0 2018-10-22 12:43:13</span><br><span class="line"></span><br><span class="line">%RETRY%SortComplementConsumer broker-c 0 2 2 0 2018-10-22 12:43:28</span><br><span class="line"></span><br><span class="line">%RETRY%SortComplementConsumer broker-d 0 2 2 0 2018-10-22 12:44:33</span><br><span class="line"></span><br><span class="line">SCANRECORD broker-a 0 39717505 39717502 3 2018-10-22 13:53:21</span><br><span class="line"></span><br><span class="line">SCANRECORD broker-a 1 39721504 39721502 2 2018-10-22 13:53:21</span><br><span class="line"></span><br><span class="line">SCANRECORD broker-a 2 39733704 39733703 1 2018-10-22 13:53:21</span><br></pre></td></tr></table></figure>





</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ22# RocketMQ内存传输及4.7消费线程参数设置</title>
    <url>/posts/fe0b8776/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>RocketMQ配置中有一个设置项为transferMsgByHeap，即是否通过堆内存传输数据。在文章“RocketMQ存储–同步刷盘和异步刷盘”中对其进行过梳理。那transferMsgByHeap是开启好呢？还是关闭好！第二个问题是可以设置消费的线程数，由于无界队列所以只需要设置最小线程数consumeThreadMin即可，那在rocket-client4.7版本中还能这么用吗？</p>
<a id="more"></a>

<h1 id="transferMsgByHeap误解"><a href="#transferMsgByHeap误解" class="headerlink" title="transferMsgByHeap误解"></a>transferMsgByHeap误解</h1><p>transferMsgByHeap设置为false时，通过堆外内存传输数据，相比堆内存传输减少了数据拷贝、零字节拷贝、效率更高，所以关闭transferMsgByHeap应该成为我们的优先选择，但是实践来看，你或许会改变想法，下面是transferMsgByHeap=false，客户端大量超时错误时的日志截图。</p>
<h2 id="Broker日志截图"><a href="#Broker日志截图" class="headerlink" title="Broker日志截图"></a>Broker日志截图</h2><p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219081609.png"></p>
<h2 id="CPU日志截图"><a href="#CPU日志截图" class="headerlink" title="CPU日志截图"></a>CPU日志截图</h2><p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219081632.png"></p>
<h2 id="系统日志截图"><a href="#系统日志截图" class="headerlink" title="系统日志截图"></a>系统日志截图</h2><p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219081704.png"></p>
<h2 id="源码报错截图"><a href="#源码报错截图" class="headerlink" title="源码报错截图"></a>源码报错截图</h2><p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219082807.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：你看到这里会发现，在关闭transferMsgByHeap时，可能造成堆外内存分配不够，触发系统内存回收和落盘操作。此时CPU会有一个陡坡，具体客户端表现为发送大量超时。解决方式开启transferMsgByHeap即可，让运行更加平稳。</span><br></pre></td></tr></table></figure>



<!--more-->



<h1 id="消费的最小线程数"><a href="#消费的最小线程数" class="headerlink" title="消费的最小线程数"></a>消费的最小线程数</h1><p>我们在使用rocketmq消费时，有两个参数consumeThreadMin和consumeThreadMax。在以往的版本中，我们只需要设置consumeThreadMin即可，例如consumeThreadMin=64。在rocket-client4.7版本中，如果设置consumeThreadMin=64会导致消费失败，下面看下原因。</p>
<h2 id="错误提示"><a href="#错误提示" class="headerlink" title="错误提示"></a>错误提示</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">org.apache.rocketmq.client.exception.MQClientException: consumeThreadMin (64) is larger than consumeThreadMax (20)</span><br></pre></td></tr></table></figure>



<h2 id="源码原因"><a href="#源码原因" class="headerlink" title="源码原因"></a>源码原因</h2><p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219082853.png"></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219082913.png"></p>
<p>小结：在rocketmq-client新版本中，增加了consumeThreadMax的判断。当consumeThreadMin大于20时需要同时设置consumeThreadMax，所以单独设置consumeThreadMin=64会抛出错误导致消费失败。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ23# RocketMQ消息存储概览</title>
    <url>/posts/96e2eb1a/</url>
    <content><![CDATA[<div id="vip-container"><p>先梳理消息存储主干流程。本分切分为两部分，第一部分消息存储流程概览，主要为校验流程；第二部分CommitLog存储概览，即消息存储流程。</p>
<h1 id="消息存储流程概览"><a href="#消息存储流程概览" class="headerlink" title="消息存储流程概览"></a>消息存储流程概览</h1><p>调用链</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">@1 SendMessageProcessor#sendMessage</span><br><span class="line"></span><br><span class="line"><span class="comment">//消息存储</span></span><br><span class="line"></span><br><span class="line">PutMessageResult putMessageResult = <span class="keyword">this</span>.brokerController.getMessageStore().putMessage(msgInner);</span><br><span class="line"></span><br><span class="line">@2 DefaultMessageStore#putMessage</span><br></pre></td></tr></table></figure>



<a id="more"></a>



<p>流程图</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219132807.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">备注：PageCache是否繁忙，内存锁定时间为1秒，在集群流量负载很高时可能出现system busy，broker buys等异常信息。</span><br></pre></td></tr></table></figure>

<p>源代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PutMessageResult <span class="title">putMessage</span><span class="params">(MessageExtBrokerInner msg)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果消息存储服务已关闭，则消息写入被拒绝</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.shutdown) &#123;</span><br><span class="line"></span><br><span class="line">log.warn(<span class="string">&quot;message store has shutdown, so putMessage is forbidden&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.SERVICE_NOT_AVAILABLE, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Slave不处理消息存储</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (BrokerRole.SLAVE == <span class="keyword">this</span>.messageStoreConfig.getBrokerRole()) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> value = <span class="keyword">this</span>.printTimes.getAndIncrement();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((value % <span class="number">50000</span>) == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">log.warn(<span class="string">&quot;message store is slave mode, so putMessage is forbidden &quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.SERVICE_NOT_AVAILABLE, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果消息存储服务不可写，则消息写入会被拒绝</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//出现该错误可能磁盘已满</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.runningFlags.isWriteable()) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> value = <span class="keyword">this</span>.printTimes.getAndIncrement();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((value % <span class="number">50000</span>) == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">log.warn(<span class="string">&quot;message store is not writeable, so putMessage is forbidden &quot;</span> + <span class="keyword">this</span>.runningFlags.getFlagBits());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.SERVICE_NOT_AVAILABLE, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.printTimes.set(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Topic长度的限制不能超过127个字节</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (msg.getTopic().length() &gt; Byte.MAX_VALUE) &#123;</span><br><span class="line"></span><br><span class="line">log.warn(<span class="string">&quot;putMessage message topic length too long &quot;</span> + msg.getTopic().length());</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消息属性长度检查不能超过32K</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (msg.getPropertiesString() != <span class="keyword">null</span> &amp;&amp; msg.getPropertiesString().length() &gt; Short.MAX_VALUE) &#123;</span><br><span class="line"></span><br><span class="line">log.warn(<span class="string">&quot;putMessage message properties length too long &quot;</span> + msg.getPropertiesString().length());</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.PROPERTIES_SIZE_EXCEEDED, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断PageCache是否繁忙：阀值[osPageCacheBusyTimeOutMills = 1000 ] 比较时间为当前时间与Commit Lock时间之差</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果返回true，意味着此时有消息在写入CommitLog，且那条消息的写入耗时较长（超过1s），则本条消息不再写入</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回内存页写入繁忙</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.isOSPageCacheBusy()) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.OS_PAGECACHE_BUSY, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> beginTime = <span class="keyword">this</span>.getSystemClock().now();</span><br><span class="line"></span><br><span class="line"><span class="comment">//将消息写入CommitLog</span></span><br><span class="line"></span><br><span class="line">PutMessageResult result = <span class="keyword">this</span>.commitLog.putMessage(msg);</span><br><span class="line"></span><br><span class="line"><span class="comment">//消息写入时间过长，发出警告</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> eclipseTime = <span class="keyword">this</span>.getSystemClock().now() - beginTime;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (eclipseTime &gt; <span class="number">500</span>) &#123;</span><br><span class="line"></span><br><span class="line">log.warn(<span class="string">&quot;putMessage not in lock eclipse time(ms)=&#123;&#125;, bodyLength=&#123;&#125;&quot;</span>, eclipseTime, msg.getBody().length);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对消息的存储耗时进行分级记录，并记录当前所有消息存储时的最大耗时</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.storeStatsService.setPutMessageEntireTimeMax(eclipseTime);</span><br><span class="line"></span><br><span class="line"><span class="comment">//记录存粗失败次数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> == result || !result.isOk()) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.storeStatsService.getPutMessageFailedTimes().incrementAndGet();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<!--more-->



<h1 id="CommitLog存储流程"><a href="#CommitLog存储流程" class="headerlink" title="CommitLog存储流程"></a>CommitLog存储流程</h1><p>调用链</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">@1 DefaultMessageStore#putMessage</span><br><span class="line"></span><br><span class="line"><span class="comment">//将消息写入CommitLog</span></span><br><span class="line"></span><br><span class="line">PutMessageResult result = <span class="keyword">this</span>.commitLog.putMessage(msg);</span><br><span class="line"></span><br><span class="line">@2 CommitLog#putMessage</span><br></pre></td></tr></table></figure>



<p>流程图</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219132948.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">备注：此时写入消息并没有写入磁盘，而是写入了writeBuffer或者mappedByteBuffer（PageCache或堆外内存）</span><br></pre></td></tr></table></figure>

<p>源代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public PutMessageResult putMessage(final MessageExtBrokerInner msg) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Set the storage time</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设置消息存储时间（存储到Broker的时间）</span><br><span class="line"></span><br><span class="line">msg.setStoreTimestamp(System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Set the message body BODY CRC (consider the most appropriate setting</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; on the client)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Message Body的循环冗余校验码，防止消息体内容被篡改</span><br><span class="line"></span><br><span class="line">msg.setBodyCRC(UtilAll.crc32(msg.getBody()));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Back to Results</span><br><span class="line"></span><br><span class="line">AppendMessageResult result &#x3D; null;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;统计存储耗时相关的Metric</span><br><span class="line"></span><br><span class="line">StoreStatsService storeStatsService &#x3D; this.defaultMessageStore.getStoreStatsService();</span><br><span class="line"></span><br><span class="line">String topic &#x3D; msg.getTopic();</span><br><span class="line"></span><br><span class="line">int queueId &#x3D; msg.getQueueId();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取消息类型</span><br><span class="line"></span><br><span class="line">final int tranType &#x3D; MessageSysFlag.getTransactionValue(msg.getSysFlag());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;不处理事务消息</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;重试(延时)消息发到SCHEDULE_TOPIC中</span><br><span class="line"></span><br><span class="line">if (tranType &#x3D;&#x3D; MessageSysFlag.TRANSACTION_NOT_TYPE&#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">|| tranType &#x3D;&#x3D; MessageSysFlag.TRANSACTION_COMMIT_TYPE) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Delay Delivery</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;延时投递时间级别</span><br><span class="line"></span><br><span class="line">if (msg.getDelayTimeLevel() &gt; 0) &#123;</span><br><span class="line"></span><br><span class="line">if (msg.getDelayTimeLevel() &gt; this.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel()) &#123;</span><br><span class="line"></span><br><span class="line">msg.setDelayTimeLevel(this.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将Topic更改为 SCHEDULE_TOPIC_XXXX</span><br><span class="line"></span><br><span class="line">topic &#x3D; ScheduleMessageService.SCHEDULE_TOPIC;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;根据延时级别获取延时消息新队列ID（queueId等于延时级别-1）</span><br><span class="line"></span><br><span class="line">queueId &#x3D; ScheduleMessageService.delayLevel2QueueId(msg.getDelayTimeLevel());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Backup real topic, queueId</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将消息中原topic和queueId存入到消息属性中</span><br><span class="line"></span><br><span class="line">MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_TOPIC, msg.getTopic());</span><br><span class="line"></span><br><span class="line">MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_QUEUE_ID, String.valueOf(msg.getQueueId()));</span><br><span class="line"></span><br><span class="line">msg.setPropertiesString(MessageDecoder.messageProperties2String(msg.getProperties()));</span><br><span class="line"></span><br><span class="line">msg.setTopic(topic);</span><br><span class="line"></span><br><span class="line">msg.setQueueId(queueId);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">long eclipseTimeInLock &#x3D; 0;</span><br><span class="line"></span><br><span class="line">MappedFile unlockMappedFile &#x3D; null;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取最新的日志文件CommitLog 内存映射文件 零拷贝</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;mappedFileQueue 管理这些连续的CommitLog文件</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;MappedFile 和 MappedFileQueue高性能的磁盘接口</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;mappedFileQueue可以理解为commitLog文件夹，而MappedFile对应文件夹下的文件</span><br><span class="line"></span><br><span class="line">MappedFile mappedFile &#x3D; this.mappedFileQueue.getLastMappedFile();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;加锁，默认使用自旋锁。</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;依赖于messageStoreConfig#useReentrantLockWhenPutMessage配置</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;putMessage会有多个工作线程并行处理，所以需要加锁。串行写入commitLog</span><br><span class="line"></span><br><span class="line">putMessageLock.lock(); &#x2F;&#x2F;spin or ReentrantLock ,depending on store config</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">long beginLockTimestamp &#x3D; this.defaultMessageStore.getSystemClock().now();</span><br><span class="line"></span><br><span class="line">this.beginTimeInLock &#x3D; beginLockTimestamp;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Here settings are stored timestamp, in order to ensure an orderly</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; global</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;再次设置时间戳全局有序</span><br><span class="line"></span><br><span class="line">msg.setStoreTimestamp(beginLockTimestamp);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;文件已满或者没有映射文件重新创建一个文件</span><br><span class="line"></span><br><span class="line">if (null &#x3D;&#x3D; mappedFile || mappedFile.isFull()) &#123;</span><br><span class="line"></span><br><span class="line">mappedFile &#x3D; this.mappedFileQueue.getLastMappedFile(0); &#x2F;&#x2F; Mark: NewFile may be cause noise</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建映射文件失败（可能磁盘已满）</span><br><span class="line"></span><br><span class="line">if (null &#x3D;&#x3D; mappedFile) &#123;</span><br><span class="line"></span><br><span class="line">log.error(&quot;create maped file1 error, topic: &quot; + msg.getTopic() + &quot; clientAddr: &quot; + msg.getBornHostString());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;消息写入完成后，先将beginTimeInLock设置为0，然后释放锁</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;该值用来计算消息写入耗时。写入新消息前，会根据该值来检查操作系统内存页写入是否繁忙</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;如果上一条消息在1s内没有成功写入，则本次消息不再写入</span><br><span class="line"></span><br><span class="line">beginTimeInLock &#x3D; 0;</span><br><span class="line"></span><br><span class="line">return new PutMessageResult(PutMessageStatus.CREATE_MAPEDFILE_FAILED, null);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;向映射文件中写入消息</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;注意：只是将消息写入映射文件中的writeBuffer&#x2F;mappedByteBuffer，没有刷盘</span><br><span class="line"></span><br><span class="line">result &#x3D; mappedFile.appendMessage(msg, this.appendMessageCallback);</span><br><span class="line"></span><br><span class="line">switch (result.getStatus()) &#123;</span><br><span class="line"></span><br><span class="line">case PUT_OK: &#x2F;&#x2F;消息成功写入</span><br><span class="line"></span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;文件已经到结尾了，重新建一个新的mappedFile.</span><br><span class="line"></span><br><span class="line">case END_OF_FILE: &#x2F;&#x2F;当前CommitLog可用空间不足</span><br><span class="line"></span><br><span class="line">unlockMappedFile &#x3D; mappedFile;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Create a new file, re-write the message</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建新的CommitLog，并重新写入消息</span><br><span class="line"></span><br><span class="line">mappedFile &#x3D; this.mappedFileQueue.getLastMappedFile(0);</span><br><span class="line"></span><br><span class="line">if (null &#x3D;&#x3D; mappedFile) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; XXX: warn and notify me</span><br><span class="line"></span><br><span class="line">log.error(&quot;create maped file2 error, topic: &quot; + msg.getTopic() + &quot; clientAddr: &quot; + msg.getBornHostString());</span><br><span class="line"></span><br><span class="line">beginTimeInLock &#x3D; 0;</span><br><span class="line"></span><br><span class="line">return new PutMessageResult(PutMessageStatus.CREATE_MAPEDFILE_FAILED, result);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result &#x3D; mappedFile.appendMessage(msg, this.appendMessageCallback);</span><br><span class="line"></span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">case MESSAGE_SIZE_EXCEEDED: &#x2F;&#x2F;消息长度超过了最大阀值</span><br><span class="line"></span><br><span class="line">case PROPERTIES_SIZE_EXCEEDED: &#x2F;&#x2F;消息属性超过了最大阀值</span><br><span class="line"></span><br><span class="line">beginTimeInLock &#x3D; 0;</span><br><span class="line"></span><br><span class="line">return new PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, result);</span><br><span class="line"></span><br><span class="line">case UNKNOWN_ERROR: &#x2F;&#x2F;未知错误</span><br><span class="line"></span><br><span class="line">beginTimeInLock &#x3D; 0;</span><br><span class="line"></span><br><span class="line">return new PutMessageResult(PutMessageStatus.UNKNOWN_ERROR, result);</span><br><span class="line"></span><br><span class="line">default:</span><br><span class="line"></span><br><span class="line">beginTimeInLock &#x3D; 0;</span><br><span class="line"></span><br><span class="line">return new PutMessageResult(PutMessageStatus.UNKNOWN_ERROR, result);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">eclipseTimeInLock &#x3D; this.defaultMessageStore.getSystemClock().now() - beginLockTimestamp;</span><br><span class="line"></span><br><span class="line">beginTimeInLock &#x3D; 0;</span><br><span class="line"></span><br><span class="line">&#125; finally &#123;</span><br><span class="line"></span><br><span class="line">putMessageLock.unlock(); &#x2F;&#x2F;释放锁</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (eclipseTimeInLock &gt; 500) &#123;</span><br><span class="line"></span><br><span class="line">log.warn(&quot;[NOTIFYME]putMessage in lock cost time(ms)&#x3D;&#123;&#125;, bodyLength&#x3D;&#123;&#125; AppendMessageResult&#x3D;&#123;&#125;&quot;, eclipseTimeInLock, msg.getBody().length, result);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (null !&#x3D; unlockMappedFile &amp;&amp; this.defaultMessageStore.getMessageStoreConfig().isWarmMapedFileEnable()) &#123;</span><br><span class="line"></span><br><span class="line">this.defaultMessageStore.unlockMappedFile(unlockMappedFile);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PutMessageResult putMessageResult &#x3D; new PutMessageResult(PutMessageStatus.PUT_OK, result);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Statistics Metrics指标</span><br><span class="line"></span><br><span class="line">storeStatsService.getSinglePutMessageTopicTimesTotal(msg.getTopic()).incrementAndGet();</span><br><span class="line"></span><br><span class="line">storeStatsService.getSinglePutMessageTopicSizeTotal(topic).addAndGet(result.getWroteBytes());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;同步刷盘或者异步刷盘</span><br><span class="line"></span><br><span class="line">handleDiskFlush(result, putMessageResult, msg);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;主从同步</span><br><span class="line"></span><br><span class="line">handleHA(result, putMessageResult, msg);</span><br><span class="line"></span><br><span class="line">return putMessageResult;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ24# RocketMQ存储--日志文件创建与映射流程</title>
    <url>/posts/9adc03fa/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>日志目录(可配置)/data/rocketmq/store/commitlog会有20位长度的日志文件。</p>
<p>1.日志文件什么时候创建的？</p>
<p>2.日志文件创建流程是什么？</p>
<p>3.日志文件和内存映射是怎么样的？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-rw-rw-r-- 1 baseuser baseuser 1073741824 Jun 27 22:50 00000117290188144640</span><br><span class="line"></span><br><span class="line">-rw-rw-r-- 1 baseuser baseuser 1073741824 Jun 27 22:52 00000117291261886464</span><br><span class="line"></span><br><span class="line">-rw-rw-r-- 1 baseuser baseuser 1073741824 Jun 27 22:54 00000117292335628288</span><br><span class="line"></span><br><span class="line">-rw-rw-r-- 1 baseuser baseuser 1073741824 Jun 27 22:56 00000117293409370112</span><br><span class="line"></span><br><span class="line">-rw-rw-r-- 1 baseuser baseuser 1073741824 Jun 27 22:57 00000117294483111936</span><br><span class="line"></span><br><span class="line">-rw-rw-r-- 1 baseuser baseuser 1073741824 Jun 27 22:56 00000117295556853760</span><br></pre></td></tr></table></figure>



<a id="more"></a>



<h1 id="日志映射相关类初始化"><a href="#日志映射相关类初始化" class="headerlink" title="日志映射相关类初始化"></a>日志映射相关类初始化</h1><p>在Broker启动时实例化了两个类DefaultMessageStore和AllocateMappedFileService。</p>
<p>AllocateMappedFileService是线程类继承了Runnable接口，该线程类持有DefaultMessageStore的引用（即：可操作管理DefaultMessageStore），并启动该线程类。</p>
<p>调用链</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;Broker启动时调用</span><br><span class="line"></span><br><span class="line">@1 BrokerStartup#main#createBrokerController()</span><br><span class="line"></span><br><span class="line">boolean initResult &#x3D; controller.initialize();</span><br><span class="line"></span><br><span class="line">@2 Controller#initialize()</span><br><span class="line"></span><br><span class="line">this.messageStore &#x3D; new DefaultMessageStore(this.messageStoreConfig, this.brokerStatsManager, this.messageArrivingListener, this.brokerConfig);</span><br><span class="line"></span><br><span class="line">@3 DefaultMessageStore#DefaultMessageStore()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将DefaultMessageStore自身引用传给AllocateMappedFileService</span><br><span class="line"></span><br><span class="line">this.allocateMappedFileService &#x3D; new AllocateMappedFileService(this);</span><br><span class="line"></span><br><span class="line">this.allocateMappedFileService.start();&#x2F;&#x2F;启动该线程类</span><br><span class="line"></span><br><span class="line">@4 class AllocateMappedFileService extends ServiceThread</span><br><span class="line"></span><br><span class="line">public AllocateMappedFileService(DefaultMessageStore messageStore) &#123;</span><br><span class="line"></span><br><span class="line">this.messageStore &#x3D; messageStore;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>线程类一直运行在干啥</strong></p>
<p>既然在Broker启动时该线程类AllocateMappedFileService就启动了，那么在做什么呢？run方法为while循环，即：<strong>只要服务不停止并且mmapOperation()返回true则一直运行</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;异步处理，调用mmapOperation完成请求的处理</span><br><span class="line"></span><br><span class="line">public void run() &#123;</span><br><span class="line"></span><br><span class="line">log.info(this.getServiceName() + &quot; service started&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;while循环，只要服务部停止即调用 mmapOperation方法</span><br><span class="line"></span><br><span class="line">while (!this.isStopped() &amp;&amp; this.mmapOperation()) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.info(this.getServiceName() + &quot; service end&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>mmapOperation方法流程图</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219133504.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：mmapOperation方法主要做了两件事：初始化MappedFile和预热MappedFile。只要服务不停止和线程不被中断，这个过程一直重复运行。</span><br></pre></td></tr></table></figure>



<h1 id="提交映射文件请求（AllocateRequest）"><a href="#提交映射文件请求（AllocateRequest）" class="headerlink" title="提交映射文件请求（AllocateRequest）"></a>提交映射文件请求（AllocateRequest）</h1><p>既然AllocateMappedFileService一直从容器（优先级队列和ConcurrentHashMap）中获取AllocateRequest。AllocateRequest是什么时候产生并放到容器中的呢？</p>
<p>RocketMQ消息存储概览【源码笔记】中写入commitLog流程，获取最新的日志文件。</p>
<p><strong>调用链</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@1 CommitLog#putMessage</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;文件已满或者没有映射文件重新创建一个文件</span><br><span class="line"></span><br><span class="line">if (null &#x3D;&#x3D; mappedFile || mappedFile.isFull()) &#123;</span><br><span class="line"></span><br><span class="line">mappedFile &#x3D; this.mappedFileQueue.getLastMappedFile(0);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Mark: NewFile may be cause noise</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@2 MappedFileQueue#getLastMappedFile</span><br></pre></td></tr></table></figure>



<p><strong>流程图</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219133550.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：MappedFileQueue#getLastMappedFile会向线程类AllocateMappedFileServic提交两个映射文件创建请求：分别为nextFilePath和nextNextFilePath；如果线程类AllocateMappedFileServic为null，则直接new一个MappedFile，此时只会创建一个文件</span><br></pre></td></tr></table></figure>

<p><strong>下面为AllocateMappedFileServic#putRequestAndReturnMappedFile提交两个映射文件请求流程</strong></p>
<p><strong>调用链</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@1 MappedFileQueue#getLastMappedFile</span><br><span class="line"></span><br><span class="line">if (this.allocateMappedFileService !&#x3D; null) &#123;</span><br><span class="line"></span><br><span class="line">mappedFile &#x3D; this.allocateMappedFileService.putRequestAndReturnMappedFile(nextFilePath,</span><br><span class="line"></span><br><span class="line">nextNextFilePath, this.mappedFileSize);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@2 AllocateMappedFileService#putRequestAndReturnMappedFile</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>流程图</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219133629.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：处理提交的映射文件请求指的是实例化两个AllocateRequest并把他们提交到requestTable（ConcurrentHashMap）和requestQueue（PriorityBlockingQueue）中，等待5秒，此段时间线程会从这两个容器中获取请求并创建MappedFile，并将结果返回。</span><br></pre></td></tr></table></figure>



<!--more-->



<h1 id="MappedFile初始化"><a href="#MappedFile初始化" class="headerlink" title="MappedFile初始化"></a>MappedFile初始化</h1><p>本段梳理下上文中mmapOperation方法流程图第5步初始化MappedFile的流程</p>
<p><strong>调用链</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@1 AllocateMappedFileService#mmapOperation</span><br><span class="line"></span><br><span class="line">mappedFile &#x3D; new MappedFile(req.getFilePath(), req.getFileSize());</span><br><span class="line"></span><br><span class="line">@2 MappedFile#init(fileName, fileSize);</span><br></pre></td></tr></table></figure>

<p><strong>流程图</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219133707.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：MappedFile主要干了两件事：1.创建日志文件。2.并将文件映射到内存中</span><br></pre></td></tr></table></figure>



<h1 id="6-总结"><a href="#6-总结" class="headerlink" title="6.总结"></a>6.总结</h1><p><strong>1.日志文件什么时候创建的？</strong></p>
<p>备注：在写入消息时，需要获取最新的日志文件（MappedFile），如果文件不存在或者已经写满，此时需要创建MappedFile。具体在MappedFile#init方法this.file = new File(fileName)进行创建。</p>
<p><strong>2.日志文件创建流程是什么？</strong></p>
<p>备注：将两个映射创建请求（nextReq和nextNextReq）提交到requestTable（ConcurrentHashMap）和requestQueue(PriorityBlockingQueue)容器中;由线程不断检查并从容器中取出创建日志文件（MappedFile）。</p>
<p><strong>3.日志文件和内存映射是怎么样的？</strong></p>
<p>备注：具体的映射时在MappedFile#init方法中通过this.mappedByteBuffer = this.fileChannel.map(MapMode.READ_WRITE, 0, fileSize);将日志文件映射到内存中的。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ27# RocketMQ存储--同步刷盘和异步刷盘</title>
    <url>/posts/b973d41f/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="问题思考"><a href="#问题思考" class="headerlink" title="问题思考"></a>问题思考</h1><p>1.同步刷盘是怎么工作的？</p>
<p>2.异步刷盘是怎么工作的？</p>
<p>3.上篇文章的疑问，写入堆外内存的消息如何落盘的？</p>
<a id="more"></a>



<h1 id="Broker启动刷盘有关调用链"><a href="#Broker启动刷盘有关调用链" class="headerlink" title="Broker启动刷盘有关调用链"></a>Broker启动刷盘有关调用链</h1><p><strong>调用链</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;初始化链条</span><br><span class="line"></span><br><span class="line">@1 BrokerStartup#main</span><br><span class="line"></span><br><span class="line">start(createBrokerController(args));</span><br><span class="line"></span><br><span class="line">@2 BrokerStartup#createBrokerController</span><br><span class="line"></span><br><span class="line">final BrokerController controller &#x3D; new BrokerController(...)</span><br><span class="line"></span><br><span class="line">boolean initResult &#x3D; controller.initialize();</span><br><span class="line"></span><br><span class="line">@3 BrokerController#initialize</span><br><span class="line"></span><br><span class="line">this.messageStore &#x3D; new DefaultMessageStore(...);</span><br><span class="line"></span><br><span class="line">@4 DefaultMessageStore#DefaultMessageStore()</span><br><span class="line"></span><br><span class="line">this.commitLog &#x3D; new CommitLog(this);</span><br><span class="line"></span><br><span class="line">@5 CommitLog#CommitLog()</span><br><span class="line"></span><br><span class="line">if (FlushDiskType.SYNC_FLUSH &#x3D;&#x3D; defaultMessageStore.getMessageStoreConfig()</span><br><span class="line"></span><br><span class="line">.getFlushDiskType()) &#123;</span><br><span class="line"></span><br><span class="line">this.flushCommitLogService &#x3D; new GroupCommitService();</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line"></span><br><span class="line">this.flushCommitLogService &#x3D; new FlushRealTimeService();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">this.commitLogService &#x3D; new CommitRealTimeService();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;启动链条</span><br><span class="line"></span><br><span class="line">@6 BrokerStartup#start</span><br><span class="line"></span><br><span class="line">controller.start();</span><br><span class="line"></span><br><span class="line">@7 BrokerController#start()</span><br><span class="line"></span><br><span class="line">this.messageStore.start();</span><br><span class="line"></span><br><span class="line">@8 DefaultMessageStore#start()</span><br><span class="line"></span><br><span class="line">this.commitLog.start();</span><br><span class="line"></span><br><span class="line">@9 CommitLog#start()</span><br><span class="line"></span><br><span class="line">this.flushCommitLogService.start();</span><br><span class="line"></span><br><span class="line">if (defaultMessageStore.getMessageStoreConfig()</span><br><span class="line"></span><br><span class="line">.isTransientStorePoolEnable()) &#123;</span><br><span class="line"></span><br><span class="line">this.commitLogService.start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><u>小结：由调用链可以看出，初始化并启动了以下线程类</u></p>
<p>* 同步刷盘 GroupCommitService</p>
<p>* 异步刷盘 FlushRealTimeService</p>
<p>* 如果开启堆外内存并且为异步刷盘 CommitRealTimeService</p>
<p><strong>线程类关系图</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219134925.png"></p>
<h1 id="线程类工作流程"><a href="#线程类工作流程" class="headerlink" title="线程类工作流程"></a>线程类工作流程</h1><p>既然线程类在Broker启动时就启动了，他们在做啥呢？</p>
<p><strong>堆外内存线程类</strong>CommitRealTimeService工作流程</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219134952.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：</span><br><span class="line">1.CommitRealTimeService主要工作是将写入堆外内存(writeBuffer)的消息，写入到fileChannel中，fileChannel为commitLog文件通道</span><br><span class="line">2.committedPosition用于记录将writeBuffer数据写入到fileChannel中的内存位点（相对偏移量offset）</span><br><span class="line">3.committedWhere用于记录写入fileChannel中的物理偏移量（文件名称+相对偏移量offset）</span><br></pre></td></tr></table></figure>



<p><strong>同步刷盘线程类GroupCommitService工作流程</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219135027.png"></p>
<p><strong>注1：</strong></p>
<p>* 执行onWaitEnd时交换读写容器，该线程类提供两个容器来装GroupCommitRequest</p>
<p>* requestsWrite和requestsRead，每次执行提交(刷盘)前都会进行容器交换</p>
<p>* 好处：读写请求容器分离，避免潜在的锁竞争</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void swapRequests() &#123;</span><br><span class="line"></span><br><span class="line">List&lt;GroupCommitRequest&gt; tmp &#x3D; this.requestsWrite;</span><br><span class="line"></span><br><span class="line">this.requestsWrite &#x3D; this.requestsRead;</span><br><span class="line"></span><br><span class="line">this.requestsRead &#x3D; tmp;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>注2:</strong></p>
<p>* flushedPosition 标记已经刷盘内存的位点。即刷盘相对偏移量，刷盘到什么位置了，下次从此处刷盘即可</p>
<p>* flushedWhere 标记已经刷盘的物理偏移量，根据此位置可精确查找到文件中消息的存储位置</p>
<p>flushedWhere = 当前刷盘文件名称（该日志文件的起始物理偏移量） + flushedPosition</p>
<p><strong>注3</strong></p>
<p>* 流程图中标记红色部分，将刷盘结果通知给等待线程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：同步刷盘线程类GroupCommitService主要工作</span><br><span class="line">1.将请求从读容器中取出并通过mappedByteBuffer.force()将数据落盘。</span><br></pre></td></tr></table></figure>



<p><strong>异步刷盘线程类FlushRealTimeService工作流程</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219135125.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：FlushRealTimeService主要工作</span><br><span class="line">1.不开启堆外外内存刷盘方式为mappedByteBuffer.force()</span><br><span class="line">2.开启堆外内存刷盘方式为fileChannel.force</span><br></pre></td></tr></table></figure>

<p><u><strong>疑问：同步刷盘线程类GroupCommitService每执行一次都会交换读写容器，那刷盘请求什么时候放到写容器（requestsWrite）呢？</strong></u></p>
<h1 id="消息追加与线程类的交互"><a href="#消息追加与线程类的交互" class="headerlink" title="消息追加与线程类的交互"></a>消息追加与线程类的交互</h1><p>分析完线程类后，把镜头切换到消息追加，看看消息进来后是如何跟线程类交互的？</p>
<p><strong>调用链</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@1 CommitLog#putMessage</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;同步刷盘或者异步刷盘</span><br><span class="line"></span><br><span class="line">handleDiskFlush(result, putMessageResult, msg);</span><br><span class="line"></span><br><span class="line">@2 CommitLog#handleDiskFlush</span><br></pre></td></tr></table></figure>



<p><strong>同步刷盘主要代码</strong></p>
<p>同步刷盘时构造刷盘请求，将请求提交给线程类GroupCommitService，service.putRequest(request)，并获取刷盘结果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (FlushDiskType.SYNC_FLUSH &#x3D;&#x3D; this.defaultMessageStore.getMessageStoreConfig().getFlushDiskType()) &#123;</span><br><span class="line"></span><br><span class="line">final GroupCommitService service &#x3D; (GroupCommitService) this.flushCommitLogService;</span><br><span class="line"></span><br><span class="line">GroupCommitRequest request &#x3D; new GroupCommitRequest(result.getWroteOffset() + result.getWroteBytes());</span><br><span class="line"></span><br><span class="line">service.putRequest(request);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;等待MappedFile刷盘成功状态通过countDownLatch来控制</span><br><span class="line"></span><br><span class="line">boolean flushOK &#x3D; request.waitForFlush(this.defaultMessageStore.getMessageStoreConfig().getSyncFlushTimeout());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>异步刷盘主要代码</strong></p>
<p>未开启堆外内存唤醒FlushRealTimeServicee，开启堆外内存唤醒CommitRealTimeService。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (!this.defaultMessageStore.getMessageStoreConfig()</span><br><span class="line"></span><br><span class="line">.isTransientStorePoolEnable()) &#123;</span><br><span class="line"></span><br><span class="line">flushCommitLogService.wakeup();</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line"></span><br><span class="line">commitLogService.wakeup();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<!--more-->



<h1 id="刷盘方式示意图"><a href="#刷盘方式示意图" class="headerlink" title="刷盘方式示意图"></a>刷盘方式示意图</h1><p><strong>同步刷盘示意图</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219135252.png"></p>
<p><strong>异步刷盘未开启堆外缓存示意图</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219135312.png"></p>
<p><strong>异步刷盘开启堆外缓存示意图</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219135332.png"></p>
<h1 id="文章总结"><a href="#文章总结" class="headerlink" title="文章总结"></a>文章总结</h1><p>1.同异步刷盘通过Broker属性flushDiskType来设置，默认为ASYNC_FLUSH，同步刷盘配置为SYNC_FLUSH</p>
<p>2.同步刷盘是怎么工作的？</p>
<p>注：见GroupCommitService工作流程及与消息追加交互</p>
<p>3.异步刷盘是怎么工作的？</p>
<p>注：见FlushRealTimeService和CommitRealTimeService工作流程及与消息追加交互</p>
<p>4.上篇文章的疑问，写入堆外内存的消息如何落盘的？</p>
<p>注：见异步刷盘开启堆外缓存示意图</p>
<h1 id="主要源码类清单"><a href="#主要源码类清单" class="headerlink" title="主要源码类清单"></a>主要源码类清单</h1><p>* CommitLog.java</p>
<p>* CommitLog#putMessage</p>
<p>* CommitLog#GroupCommitService</p>
<p>* CommitLog#FlushRealTimeService</p>
<p>* CommitLog#CommitRealTimeService</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ26# RocketMQ存储--消息追加</title>
    <url>/posts/52ef32ad/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>1.消息追加到何处了呢？</p>
<p>2.消息格式是怎么样的？</p>
<a id="more"></a>



<h1 id="调用链"><a href="#调用链" class="headerlink" title="调用链"></a>调用链</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@1 CommitLog#putMessage</span><br><span class="line"></span><br><span class="line">result &#x3D; mappedFile.appendMessage(msg, this.appendMessageCallback);</span><br><span class="line"></span><br><span class="line">@2 MaapedFile#appendMessagesInner</span><br><span class="line"></span><br><span class="line">result &#x3D; cb.doAppend</span><br><span class="line"></span><br><span class="line">@3 CommitLog#DefaultAppendMessageCallback#doAppend</span><br></pre></td></tr></table></figure>



<h1 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h1><p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219134505.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：在消息写入Buffer的过程中有3个坐标</span><br></pre></td></tr></table></figure>


<p><strong>1. wrotePosition</strong></p>
<p>* commitLog内存（ByteBuffer）写入位点，标记消息写到哪了，下次从该位置开始写。在消息写完后递增，递增大小为消息的长度</p>
<p><strong>2. wroteOffset</strong></p>
<p>* 物理偏移量，标记在commitlog物理文件中消息的位置</p>
<p>* 物理偏移量=文件名称（fileFromOffset）+ 内存相对位置byteBuffer.position(wrotePosition)</p>
<p><strong>3. queueOffset</strong></p>
<p>* topicQueue逻辑偏移量，标记消息在topic的分区中的消息的位置，在消息写入后递增，递增长度为1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">疑问？</span><br><span class="line">写入Buffer有两类，堆外内存Buffer(writeBuffer)和mmap映射Buffer(mappedByteBuffer)。mappedByteBuffer为commitLog日志文件的直接映射，而堆外内存writeBuffer是怎么落盘的呢？</span><br></pre></td></tr></table></figure>

<p>此处先记录疑问，分析刷盘时回头再看。</p>
<p>###### 四、消息格式</p>
<p>在追加单条消息时，第4步组织消息，格式如下表格：</p>
<p>| 序号 | 内容 | 所占空间 |</p>
<p>| — | — | — |</p>
<p>| 1 | msgLen消息长度 | 4个字节 |</p>
<p>| 2 | MAGIC_CODE 魔数 | 4个字节 |</p>
<p>| 3 | BodyCRC 校验码 | 4个字节 |</p>
<p>| 4 | QueueId 消息所在的分区|4个字节 |</p>
<p>| 5 | 消息Flag | 4个字节 |</p>
<p>| 6 | queueOffset 分区偏移量| 8个字节 |</p>
<p>| 7 | fileFromOffset + byteBuffer.position() 物理偏移量 | 8个字节 |</p>
<p>| 8 | SysFlag 系统标记压缩等| 4个字节 |</p>
<p>| 9 | BornTimestamp 发送时间| 8个字节 |</p>
<p>| 10 |BornHost 发送的机器IP| 8个字节 |</p>
<p>| 11 | StoreTimestamp 存储时间| 8个字节 |</p>
<p>| 12 | StoreHost 存储的broker|8个字节 |</p>
<p>| 13 | ReconsumeTimes 消费重试次数|4个字节 |</p>
<p>| 14 | PreparedTransactionOffset 事物消息偏移量| 8字节 |</p>
<p>| 15 | bodyLength 消息体长度 | |</p>
<p>| 16 | body 消息体内容 | |</p>
<p>| 17 | topicLength 主题长度| |</p>
<p>| 18 | topicData主题内容 | |</p>
<p>| 19 | propertiesLength 属性长度| |</p>
<p>| 20 | propertiesData 属性内容 | |</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">**小结：1到14项是每条消息都有的，所占空间为84个字节**</span><br></pre></td></tr></table></figure>



<!--more-->



<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>1.消息追加到何处了呢？</strong></p>
<p>注：消息追加内存Buffer中，分两类。堆外内存Buffer(writeBuffer)和mmap映射Buffer(mappedByteBuffer)</p>
<p><strong>2.消息格式是怎么样的？</strong></p>
<p>消息格式顺序见第四部分。</p>
<h1 id="附录源代码"><a href="#附录源代码" class="headerlink" title="附录源代码"></a>附录源代码</h1><p><strong>消息追加源代码</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public AppendMessageResult appendMessagesInner(final MessageExt messageExt, final AppendMessageCallback cb) &#123;</span><br><span class="line"></span><br><span class="line">assert messageExt !&#x3D; null;</span><br><span class="line"></span><br><span class="line">assert cb !&#x3D; null;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;当前MappedFile的写入位置</span><br><span class="line"></span><br><span class="line">int currentPos &#x3D; this.wrotePosition.get();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;文件还有剩余空间（小于1G继续写入）</span><br><span class="line"></span><br><span class="line">if (currentPos &lt; this.fileSize) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;仅当transientStorePoolEnable 为true，刷盘策略为异步刷盘（FlushDiskType为ASYNC_FLUSH）,并且broker为主节点时，才启用堆外分配内存。此时：writeBuffer不为null</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Buffer与同步和异步刷盘相关</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;writeBuffer&#x2F;mappedByteBuffer的position始终为0，而limit则始终等于capacity</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;slice创建一个新的buffer, 是根据position和limit来生成byteBuffer</span><br><span class="line"></span><br><span class="line">ByteBuffer byteBuffer &#x3D; writeBuffer !&#x3D; null ? writeBuffer.slice() : this.mappedByteBuffer.slice();</span><br><span class="line"></span><br><span class="line">byteBuffer.position(currentPos); &#x2F;&#x2F;设置写的起始位置</span><br><span class="line"></span><br><span class="line">AppendMessageResult result &#x3D; null;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;处理单个消息</span><br><span class="line"></span><br><span class="line">if (messageExt instanceof MessageExtBrokerInner) &#123;</span><br><span class="line"></span><br><span class="line">result &#x3D; cb.doAppend(this.getFileFromOffset(), byteBuffer, this.fileSize - currentPos, (MessageExtBrokerInner) messageExt);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;处理批量消息</span><br><span class="line"></span><br><span class="line">&#125; else if (messageExt instanceof MessageExtBatch) &#123;</span><br><span class="line"></span><br><span class="line">result &#x3D; cb.doAppend(this.getFileFromOffset(), byteBuffer, this.fileSize - currentPos, (MessageExtBatch)messageExt);</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line"></span><br><span class="line">return new AppendMessageResult(AppendMessageStatus.UNKNOWN_ERROR);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">this.wrotePosition.addAndGet(result.getWroteBytes());&#x2F;&#x2F;修改写的位置</span><br><span class="line"></span><br><span class="line">this.storeTimestamp &#x3D; result.getStoreTimestamp();</span><br><span class="line"></span><br><span class="line">return result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;写满会报错，正常不会进入该代码，调用该方法前有判断</span><br><span class="line"></span><br><span class="line">log.error(&quot;MappedFile.appendMessage return null, wrotePosition: &#123;&#125; fileSize: &#123;&#125;&quot;, currentPos, this.fileSize);</span><br><span class="line"></span><br><span class="line">return new AppendMessageResult(AppendMessageStatus.UNKNOWN_ERROR);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>消息格式源代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AppendMessageResult <span class="title">doAppend</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> fileFromOffset, <span class="keyword">final</span> ByteBuffer byteBuffer, <span class="keyword">final</span> <span class="keyword">int</span> maxBlank,</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">final</span> MessageExtBrokerInner msgInner)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// STORETIMESTAMP + STOREHOSTADDRESS + OFFSET &lt;br&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//fileFromOffset(起始位置): 一个commitLog文件（对应一个MappedFile）对应的偏移量（文件名就代表这个偏移量）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//byteBuffer.position()(相对位置):当前MappedFile(对应一个commitLog)的写位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//wroteOffset：绝对位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// PHY OFFSET</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> wroteOffset = fileFromOffset + byteBuffer.position();</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.resetByteBuffer(hostHolder, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据broker存储的地址和消息的物理绝对位置生成唯一的MessageId</span></span><br><span class="line"></span><br><span class="line">String msgId = MessageDecoder.createMessageId(<span class="keyword">this</span>.msgIdMemory, msgInner.getStoreHostBytes(hostHolder), wroteOffset);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Record ConsumeQueue information</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//消息队列（ConsumeQueue）逻辑偏移量</span></span><br><span class="line"></span><br><span class="line">keyBuilder.setLength(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">keyBuilder.append(msgInner.getTopic());</span><br><span class="line"></span><br><span class="line">keyBuilder.append(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line"></span><br><span class="line">keyBuilder.append(msgInner.getQueueId());</span><br><span class="line"></span><br><span class="line">String key = keyBuilder.toString();</span><br><span class="line"></span><br><span class="line">Long queueOffset = CommitLog.<span class="keyword">this</span>.topicQueueTable.get(key);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> == queueOffset) &#123;</span><br><span class="line"></span><br><span class="line">queueOffset = <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line">CommitLog.<span class="keyword">this</span>.topicQueueTable.put(key, queueOffset);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Transaction messages that require special handling</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> tranType = MessageSysFlag.getTransactionValue(msgInner.getSysFlag());</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (tranType) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prepared and Rollback message is not consumed, will not enter the</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// consumer queuec</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> MessageSysFlag.TRANSACTION_PREPARED_TYPE:</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> MessageSysFlag.TRANSACTION_ROLLBACK_TYPE:</span><br><span class="line"></span><br><span class="line">queueOffset = <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> MessageSysFlag.TRANSACTION_NOT_TYPE:</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> MessageSysFlag.TRANSACTION_COMMIT_TYPE:</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">byte</span>[] propertiesData =</span><br><span class="line"></span><br><span class="line">msgInner.getPropertiesString() == <span class="keyword">null</span> ? <span class="keyword">null</span> : msgInner.getPropertiesString().getBytes(MessageDecoder.CHARSET_UTF8);</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> propertiesLength = propertiesData == <span class="keyword">null</span> ? <span class="number">0</span> : propertiesData.length;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (propertiesLength &gt; Short.MAX_VALUE) &#123;</span><br><span class="line"></span><br><span class="line">log.warn(<span class="string">&quot;putMessage message properties length too long. length=&#123;&#125;&quot;</span>, propertiesData.length);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> AppendMessageResult(AppendMessageStatus.PROPERTIES_SIZE_EXCEEDED);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">byte</span>[] topicData = msgInner.getTopic().getBytes(MessageDecoder.CHARSET_UTF8);</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> topicLength = topicData.length;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> bodyLength = msgInner.getBody() == <span class="keyword">null</span> ? <span class="number">0</span> : msgInner.getBody().length;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算message大小</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> msgLen = calMsgLength(bodyLength, topicLength, propertiesLength);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Exceeds the maximum message</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (msgLen &gt; <span class="keyword">this</span>.maxMessageSize) &#123;</span><br><span class="line"></span><br><span class="line">CommitLog.log.warn(<span class="string">&quot;message size exceeded, msg total size: &quot;</span> + msgLen + <span class="string">&quot;, msg body size: &quot;</span> + bodyLength</span><br><span class="line"></span><br><span class="line">\+ <span class="string">&quot;, maxMessageSize: &quot;</span> + <span class="keyword">this</span>.maxMessageSize);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> AppendMessageResult(AppendMessageStatus.MESSAGE_SIZE_EXCEEDED);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//确定当前这个Commietlog文件是否有足够的可用空间存储</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//maxBlank:当前这个Commitlog文件（对应的MappedFile）的剩余空间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//一个Message不能跨越两个Commitlog</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//每个CommitLog文件都要确保预留8个字节来表示这个CommitLog文件结尾</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Determines whether there is sufficient free space</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((msgLen + END_FILE_MIN_BLANK_LENGTH) &gt; maxBlank) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.resetByteBuffer(<span class="keyword">this</span>.msgStoreItemMemory, maxBlank);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1 TOTALSIZE</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.msgStoreItemMemory.putInt(maxBlank);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 MAGICCODE</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//表示一个CommitLog文件结尾魔数，当读到这个魔数表示文件已结束</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.msgStoreItemMemory.putInt(CommitLog.BLANK_MAGIC_CODE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3 The remaining space may be any value</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Here the length of the specially set maxBlank</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">long</span> beginTimeMills = CommitLog.<span class="keyword">this</span>.defaultMessageStore.now();</span><br><span class="line"></span><br><span class="line"><span class="comment">//将消息内容存储在ByteBuffer中，此处存储在MappedFile对应的内存映射Buffer中，并没有写入到磁盘</span></span><br><span class="line"></span><br><span class="line">byteBuffer.put(<span class="keyword">this</span>.msgStoreItemMemory.array(), <span class="number">0</span>, maxBlank);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> AppendMessageResult(AppendMessageStatus.END_OF_FILE, wroteOffset, maxBlank, msgId, msgInner.getStoreTimestamp(),</span><br><span class="line"></span><br><span class="line">queueOffset, CommitLog.<span class="keyword">this</span>.defaultMessageStore.now() - beginTimeMills);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialization of storage space</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.resetByteBuffer(msgStoreItemMemory, msgLen);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1 TOTALSIZE 该消息条目长度，4个字节</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.msgStoreItemMemory.putInt(msgLen);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 MAGICCODE 魔数，4字节。固定值0xdaa320a7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.msgStoreItemMemory.putInt(CommitLog.MESSAGE_MAGIC_CODE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3 BODYCRC 消息体CRC校验码，4个字节</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.msgStoreItemMemory.putInt(msgInner.getBodyCRC());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4 QUEUEID 消息消费队列ID 4个字节</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.msgStoreItemMemory.putInt(msgInner.getQueueId());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5 FLAG 消息FLAG，RocketMQ不做处理，供应用程序使用，默认4个字节</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.msgStoreItemMemory.putInt(msgInner.getFlag());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6 QUEUEOFFSET 消息在消息消费队列的偏移量，8个字节</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.msgStoreItemMemory.putLong(queueOffset);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 7 PHYSICALOFFSET 消息在CommitLog文件中的偏移量，8字节</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.msgStoreItemMemory.putLong(fileFromOffset + byteBuffer.position());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 8 SYSFLAG 消息系统Flag，例如是否压缩、是否事务消息 4字节</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.msgStoreItemMemory.putInt(msgInner.getSysFlag());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 9 BORNTIMESTAMP 消息生产者调用消息发送API的时间戳，8个字节</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.msgStoreItemMemory.putLong(msgInner.getBornTimestamp());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 10 BORNHOST 消息发送者IP、端口号、8字节</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.resetByteBuffer(hostHolder, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.msgStoreItemMemory.put(msgInner.getBornHostBytes(hostHolder));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 11 STORETIMESTAMP 消息存储的时间戳，8字节</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.msgStoreItemMemory.putLong(msgInner.getStoreTimestamp());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 12 STOREHOSTADDRESS Broker服务器IP+端口号，8字节</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.resetByteBuffer(hostHolder, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.msgStoreItemMemory.put(msgInner.getStoreHostBytes(hostHolder));</span><br><span class="line"></span><br><span class="line"><span class="comment">//this.msgBatchMemory.put(msgInner.getStoreHostBytes());</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 13 RECONSUMETIMES 消息重试次数，4字节</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.msgStoreItemMemory.putInt(msgInner.getReconsumeTimes());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 14 Prepared Transaction Offset 事务消息物理偏移量，8字节</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.msgStoreItemMemory.putLong(msgInner.getPreparedTransactionOffset());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 15 BODY 消息体内容，长度为bodyLenth中存储的值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.msgStoreItemMemory.putInt(bodyLength);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (bodyLength &gt; <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.msgStoreItemMemory.put(msgInner.getBody());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 16 TOPIC 主题，长度为TopicLength中存储的值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.msgStoreItemMemory.put((<span class="keyword">byte</span>) topicLength);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.msgStoreItemMemory.put(topicData);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 17 PROPERTIES 消息属性长度，属性长度不能超过32767（short的最大值）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.msgStoreItemMemory.putShort((<span class="keyword">short</span>) propertiesLength);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (propertiesLength &gt; <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.msgStoreItemMemory.put(propertiesData);</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">long</span> beginTimeMills = CommitLog.<span class="keyword">this</span>.defaultMessageStore.now();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Write messages to the queue buffer</span></span><br><span class="line"></span><br><span class="line">byteBuffer.put(<span class="keyword">this</span>.msgStoreItemMemory.array(), <span class="number">0</span>, msgLen);</span><br><span class="line"></span><br><span class="line">AppendMessageResult result = <span class="keyword">new</span> AppendMessageResult(AppendMessageStatus.PUT_OK, wroteOffset, msgLen, msgId,</span><br><span class="line"></span><br><span class="line">msgInner.getStoreTimestamp(), queueOffset, CommitLog.<span class="keyword">this</span>.defaultMessageStore.now() - beginTimeMills);</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (tranType) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> MessageSysFlag.TRANSACTION_PREPARED_TYPE:</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> MessageSysFlag.TRANSACTION_ROLLBACK_TYPE:</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> MessageSysFlag.TRANSACTION_NOT_TYPE:</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> MessageSysFlag.TRANSACTION_COMMIT_TYPE:</span><br><span class="line"></span><br><span class="line"><span class="comment">// The next update ConsumeQueue information</span></span><br><span class="line"></span><br><span class="line">CommitLog.<span class="keyword">this</span>.topicQueueTable.put(key, ++queueOffset);</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ28# RocketMQ存储--主从同步</title>
    <url>/posts/72491306/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="问题思考"><a href="#问题思考" class="headerlink" title="问题思考"></a>问题思考</h1><p>1.消息存储在Master上了，如何同步到Slave上了呢？</p>
<p>2.同步复制和异步复制流程是怎么样的？</p>
<a id="more"></a>



<h1 id="Broker启动HA调用链"><a href="#Broker启动HA调用链" class="headerlink" title="Broker启动HA调用链"></a>Broker启动HA调用链</h1><p><strong>HA初始化调用链</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@1 BrokerStartup#main</span><br><span class="line"></span><br><span class="line">start(createBrokerController(args));</span><br><span class="line"></span><br><span class="line">@2 BrokerStartup#createBrokerController</span><br><span class="line"></span><br><span class="line">boolean initResult &#x3D; controller.initialize();</span><br><span class="line"></span><br><span class="line">@3 BrokerController#initialize</span><br><span class="line"></span><br><span class="line">this.messageStore &#x3D; new DefaultMessageStore</span><br><span class="line"></span><br><span class="line">@4 DefaultMessageStore#DefaultMessageStore()</span><br><span class="line"></span><br><span class="line">this.haService &#x3D; new HAService(this);</span><br><span class="line"></span><br><span class="line">this.defaultMessageStore &#x3D; defaultMessageStore;</span><br><span class="line"></span><br><span class="line">this.acceptSocketService &#x3D;</span><br><span class="line"></span><br><span class="line">new AcceptSocketService(defaultMessageStore.getMessageStoreConfig()</span><br><span class="line"></span><br><span class="line">.getHaListenPort());</span><br><span class="line"></span><br><span class="line">this.groupTransferService &#x3D; new GroupTransferService();</span><br><span class="line"></span><br><span class="line">this.haClient &#x3D; new HAClient();</span><br></pre></td></tr></table></figure>



<p><strong>启动调用链</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@1 BrokerStartup#start</span><br><span class="line"></span><br><span class="line">controller.start();</span><br><span class="line"></span><br><span class="line">@2 BrokerController#start</span><br><span class="line"></span><br><span class="line">this.messageStore.start();</span><br><span class="line"></span><br><span class="line">@3 DefaultMessageStore#start</span><br><span class="line"></span><br><span class="line">@4 this.haService.start();</span><br><span class="line"></span><br><span class="line">this.acceptSocketService.beginAccept();</span><br><span class="line"></span><br><span class="line">this.acceptSocketService.start();</span><br><span class="line"></span><br><span class="line">this.groupTransferService.start();</span><br><span class="line"></span><br><span class="line">this.haClient.start();</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：从初始化和启动调用链中可以看到，在Broker启动时，初始化并启动了三个线程类，分别为AcceptSocketService、GroupTransferService、HAClient。</span><br></pre></td></tr></table></figure>

<p><strong>问题：这三个线程类在干啥？</strong></p>
<!--more-->



<h1 id="线程类职责"><a href="#线程类职责" class="headerlink" title="线程类职责"></a>线程类职责</h1><p><strong>AcceptSocketService职责</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219135638.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：AcceptSocketService职责初始化TCP通道，监听新的连接并创建HAConnection。</span><br></pre></td></tr></table></figure>

<p><u>问题：HAConnection在做什么？</u></p>
<p><strong>HAConnection职责</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;构造方法</span><br><span class="line"></span><br><span class="line">public HAConnection(final HAService haService, final SocketChannel socketChannel) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">this.haService &#x3D; haService;</span><br><span class="line"></span><br><span class="line">this.socketChannel &#x3D; socketChannel;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取客户端请求地址</span><br><span class="line"></span><br><span class="line">this.clientAddr &#x3D; this.socketChannel.socket().getRemoteSocketAddress().toString();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将通道调整为非阻塞</span><br><span class="line"></span><br><span class="line">this.socketChannel.configureBlocking(false);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;关闭连接前将数据发送完毕</span><br><span class="line"></span><br><span class="line">this.socketChannel.socket().setSoLinger(false, -1);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将Nagle算法关闭，客户端每发送一次数据无论大小，都会将其发送出去</span><br><span class="line"></span><br><span class="line">this.socketChannel.socket().setTcpNoDelay(true);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设置接受缓存区为64K</span><br><span class="line"></span><br><span class="line">this.socketChannel.socket().setReceiveBufferSize(1024 * 64);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设置发包缓存区为64K</span><br><span class="line"></span><br><span class="line">this.socketChannel.socket().setSendBufferSize(1024 * 64);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;写数据线程类</span><br><span class="line"></span><br><span class="line">this.writeSocketService &#x3D; new WriteSocketService(this.socketChannel);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;读数据线程类</span><br><span class="line"></span><br><span class="line">this.readSocketService &#x3D; new ReadSocketService(this.socketChannel);</span><br><span class="line"></span><br><span class="line">this.haService.getConnectionCount().incrementAndGet();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;启动</span><br><span class="line"></span><br><span class="line">public void start() &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;启动读数据线程</span><br><span class="line"></span><br><span class="line">this.readSocketService.start();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;启动写数据线程</span><br><span class="line"></span><br><span class="line">this.writeSocketService.start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><u>疑问：HAConnection除了对通道做了一些设置外，启动了两个线程服务类，分别为readSocketService和writeSocketService，他们职责是什么呢？</u></p>
<p><strong>writeSocketService职责</strong></p>
<p>流程图</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219135721.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：writeSocketService主要职责，将数据不断写入socketChannel通道；写入数据的大小为nextTransferFromWhere与最大可读位置getReadPosition之间数据；每次写完传输指针自增this.nextTransferFromWhere +&#x3D; size；每隔5秒发送心跳包到socketChannel通道。</span><br></pre></td></tr></table></figure>

<p><strong>readSocketService职责</strong></p>
<p>流程图</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219135746.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：readSocketService主要职责解析slave发来的请求位点，并更新push2SlaveMaxOffset为该请求位点；唤醒groupTransferService线程。</span><br></pre></td></tr></table></figure>



<p><strong>GroupTransferService职责</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219135816.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：GroupTransferService职责判断主从同步是否完成，完成后唤醒消息发送线程</span><br></pre></td></tr></table></figure>



<p><strong>HAClient职责</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219135843.png"></p>
<p><u>小结：HAClient职责Slave封装实现类，负责与Master建立连接通道，并从通道中获取数据存储；</u></p>
<p><u>并向Master上报Slave存储的最大物理偏移量。</u></p>
<h1 id="主从同步示意图"><a href="#主从同步示意图" class="headerlink" title="主从同步示意图"></a>主从同步示意图</h1><p><strong>主从同步交互消息格式</strong></p>
<p>1.1 Slave上报物理偏移量reportOffset量格式</p>
<p>| 格式 | 说明 |</p>
<p>| — | — |</p>
<p>| 00000018516677754880 | 长度为8位的20位数字 |</p>
<p>1.2 Master写入Slave的信息由Header与Body构成</p>
<p>| 格式 | 说明 |</p>
<p>| — | — |</p>
<p>| 00000018516677754880+size | Header部分由8位物理偏移量+消息体大小构成</p>
<p>| 消息具体内容 | Slave请求的位点与Master可读位置之间的数据</p>
<p><strong>主从同步示意图</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219135921.png"></p>
<h1 id="源代码清单"><a href="#源代码清单" class="headerlink" title="源代码清单"></a>源代码清单</h1><p>* HAService.java</p>
<p>* HAService#AcceptSocketService</p>
<p>* HAService#GroupTransferService</p>
<p>* HAService#HAClient</p>
<p>* HAConnection.java</p>
<p>* HAConnection#ReadSocketService</p>
<p>* HAConnection#WriteSocketService</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ25# RocketMQ存储--映射文件预热</title>
    <url>/posts/708c22d7/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>1.为什么创建文件（commitLog）时要预热？</p>
<p>2.为什么要写入1G大小的假值（0）呢？</p>
<p>3.为什么要锁定内存？</p>
<p>4.预热流程是怎么样的？</p>
<a id="more"></a>

<h1 id="调用链"><a href="#调用链" class="headerlink" title="调用链"></a>调用链</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@1 AllocateMappedFileService#mmapOperation</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; pre write mappedFile</span><br><span class="line"></span><br><span class="line">if (mappedFile.getFileSize() &gt;&#x3D; this.messageStore.getMessageStoreConfig()</span><br><span class="line"></span><br><span class="line">.getMapedFileSizeCommitLog() &amp;&amp; this.messageStore.getMessageStoreConfig().isWarmMapedFileEnable()) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;预热</span><br><span class="line"></span><br><span class="line">mappedFile.warmMappedFile(</span><br><span class="line"></span><br><span class="line">this.messageStore.getMessageStoreConfig().getFlushDiskType(),</span><br><span class="line"></span><br><span class="line">this.messageStore.getMessageStoreConfig()</span><br><span class="line"></span><br><span class="line">.getFlushLeastPagesWhenWarmMapedFile()</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@2 MappedFilewarmMappedFile</span><br></pre></td></tr></table></figure>



<h1 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h1><p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219133918.png"></p>
<!--more-->



<h1 id="代码验证"><a href="#代码验证" class="headerlink" title="代码验证"></a>代码验证</h1><p>在文件预热时为什么将1G假值（0）写入文件呢？不写这些值会怎么样呢？</p>
<p>将预热代码改造下做个测试：分别映射空文件和将文件写入1G假值0，观察内存映射变化。</p>
<p><strong>1.文件映射测试代码</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String [] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">File file &#x3D; new File(args[0]);</span><br><span class="line"></span><br><span class="line">FileChannel fileChannel &#x3D; new RandomAccessFile(file, &quot;rw&quot;).getChannel();</span><br><span class="line"></span><br><span class="line">MappedByteBuffer mappedByteBuffer &#x3D; fileChannel.map(FileChannel.MapMode.READ_WRITE, 0, 1024 * 1024 * 1024);</span><br><span class="line"></span><br><span class="line">if(args.length &gt;1 &amp;&amp; args[1]!&#x3D;null &amp;&amp; Boolean.parseBoolean(args[1]))&#123;</span><br><span class="line"></span><br><span class="line">for (int i &#x3D; 0, j &#x3D; 0; i &lt; 1024 * 1024 * 1024; i +&#x3D; 1024 * 4, j++) &#123;</span><br><span class="line"></span><br><span class="line">mappedByteBuffer.put(i, (byte) 0);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final long address &#x3D; ((DirectBuffer) (mappedByteBuffer)).address();</span><br><span class="line"></span><br><span class="line">Pointer pointer &#x3D; new Pointer(address);</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">int ret &#x3D; LibC.INSTANCE.mlock(pointer, new NativeLong(1024 * 1024 * 102));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">int ret &#x3D; LibC.INSTANCE.madvise(pointer, new NativeLong(1024 * 1024 * 102), LibC.MADV_WILLNEED);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Thread.sleep(1000000000);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.映射空文件</strong></p>
<p>新建文件x.tmp，此文件为空，映射到内存会发生什么呢？</p>
<p>运行例子程序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -jar melontst2.jar x.tmp</span><br></pre></td></tr></table></figure>



<p>查看虚拟内存映射</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &#x2F;proc&#x2F;xxx-pid&#x2F;maps</span><br><span class="line"></span><br><span class="line">7f4c48000000-7f4c88000000 rw-s 00000000 fd:00 395167 &#x2F;home&#x2F;baseuser&#x2F;x.tmp</span><br></pre></td></tr></table></figure>



<p><u>小结：7f4c88000000-7f4c48000000 = 139966675943424 - 139965602201600</u></p>
<p><u>= 1024 * 1024 * 1024 = 1G。即：虽然是空文件，内存映射大小依然是1G大小</u></p>
<p><strong>3.映射1G文件</strong></p>
<p>新建文件y.tmp, 写入大小为1G字节0的数据，映射到内存会发生什么呢？</p>
<p>运行例子程序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -jar melontst2.jar y.tmp true</span><br></pre></td></tr></table></figure>



<p>查看虚拟内存映射</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &#x2F;proc&#x2F;xxx-pid&#x2F;maps</span><br><span class="line"></span><br><span class="line">7f36e4000000-7f3724000000 rw-s 00000000 fd:00 395900 &#x2F;home&#x2F;baseuser&#x2F;y.tmp</span><br></pre></td></tr></table></figure>



<p><u>小结：内存映射大小计算</u></p>
<p><u>7f3724000000-7f36e4000000=139874803908608-139873730166784=1073741824</u></p>
<p><u>= 1024 * 1024 * 1024 = 1G</u></p>
<p><u>内存分配了1G大小。</u></p>
<p><strong>4.思考</strong></p>
<p>既然空文件和写入1G字节虚拟内存映射都是1G大小，写入1G大小的意义呢？</p>
<p><strong>使用mmap()内存分配时，只是建立了进程虚拟地址空间，并没有分配虚拟内存对应的物理内存。当进程访问这些没有建立映射关系的虚拟内存时，处理器自动触发一个缺页异常，进而进入内核空间分配物理内存、更新进程缓存表，最后返回用户空间，回复进程运行</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：写入这些假值的意义在于实际分配物理内存，在消息写入时防止缺页异常</span><br></pre></td></tr></table></figure>

<p><strong>5.内存映射简图</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219134135.png"></p>
<p><strong>虚拟内存</strong></p>
<p>计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换</p>
<p>虚拟地址空间的内部又被分为内核空间和用户空间两部分，进程在用户态时，只能访问用户空间内存；只有进入内核态后，才可以访问内核空间内存</p>
<p><strong>MMU</strong></p>
<p>MMU是Memory Management Unit的缩写，中文名是内存管理单元，它是中央处理器（CPU）中用来管理虚拟存储器、物理存储器的控制线路，同时也负责虚拟地址映射为物理地址</p>
<p><strong>页表</strong></p>
<p>是虚拟内存系统用来存储逻辑地址和物理地址之间映射的数据结构</p>
<p><strong>内存映射mmap</strong></p>
<p>将虚拟地址映射到物理地址</p>
<h1 id="Native-API解释"><a href="#Native-API解释" class="headerlink" title="Native API解释"></a>Native API解释</h1><p><strong>mmap</strong></p>
<p>映射文件或设备到内存</p>
<p>void mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset);</p>
<p>The mmap() function asks to map length bytes starting at offset offset from the file (or other object) specified by the file descriptor fd into memory, preferably at address start. This latter address is a hint only, and is usually specified as 0. The actual place where the object is mapped is returned by mmap().</p>
<p><strong>mlock</strong></p>
<p>锁定内存</p>
<p>int mlock(const void *addr, size_t len);</p>
<p>mlock() locks pages in the address range starting at addr and continuing for len bytes. All pages that contain a part of the specified address range are guaranteed to be resident in RAM when the call returns successfully; the pages are guaranteed to stay in RAM until later unlocked.</p>
<p><strong>madvise</strong></p>
<p>提出建议关于使用内存</p>
<p>int madvise(void *start, size_t length, int advice);</p>
<p>The madvise() system call advises the kernel about how to handle paging input/output in the address range beginning at address start and with size length bytes. It allows an application to tell the kernel how it expects to use some mapped or shared memory areas, so that the kernel can choose appropriate read-ahead and caching techniques. This call does not influence the semantics of the application (except in the case ofMADV_DONTNEED), but may influence its performance. The kernel is free to ignore the advice。</p>
<p>MADV_WILLNEED模式（MappedFile预热使用该模式）</p>
<p>MADV_WILLNEED：Expect access in the near future. (Hence, it might be a good idea to read some pages ahead.)</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>1.Broker配置warmMapedFileEnable为false，开启预热需要设置true。</p>
<p>2.写入1G字节假值0是为了让系统分配物理内存空间，如果没有这些假值，系统不会实际分配物理内存，防止在写入消息时发生缺页异常。</p>
<p>3.mlock锁定内存，防止其被交换到swap空间。</p>
<p>4.madvise建议操作系统如何使用内存，MADV_WILLNEED提前预热，预读一些页面，提高性能。</p>
<p>5.文件预热使得内存提前分配，并锁定在内存中，在写入消息时不必再进行内存分配。</p>
<h1 id="附录源代码"><a href="#附录源代码" class="headerlink" title="附录源代码"></a>附录源代码</h1><p><strong>1.文件初始化源代码</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void init(final String fileName, final int fileSize) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">this.fileName &#x3D; fileName;</span><br><span class="line"></span><br><span class="line">this.fileSize &#x3D; fileSize;</span><br><span class="line"></span><br><span class="line">this.file &#x3D; new File(fileName);</span><br><span class="line"></span><br><span class="line">this.fileFromOffset &#x3D; Long.parseLong(this.file.getName());&#x2F;&#x2F;文件名代表该文件的起始偏移量</span><br><span class="line"></span><br><span class="line">boolean ok &#x3D; false;</span><br><span class="line"></span><br><span class="line">ensureDirOK(this.file.getParent());</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;通过RandomAccessFile创读写文件通道</span><br><span class="line"></span><br><span class="line">this.fileChannel &#x3D; new RandomAccessFile(this.file, &quot;rw&quot;).getChannel();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将文件内容通过NIO的内存映射Buffer,将文件映射到内存</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将磁盘文件读到内存中，每个文件大小为1G</span><br><span class="line"></span><br><span class="line">this.mappedByteBuffer &#x3D; this.fileChannel.map(MapMode.READ_WRITE, 0, fileSize);</span><br><span class="line"></span><br><span class="line">TOTAL_MAPPED_VIRTUAL_MEMORY.addAndGet(fileSize);</span><br><span class="line"></span><br><span class="line">TOTAL_MAPPED_FILES.incrementAndGet();</span><br><span class="line"></span><br><span class="line">ok &#x3D; true;</span><br><span class="line"></span><br><span class="line">&#125; catch (FileNotFoundException e) &#123;</span><br><span class="line"></span><br><span class="line">log.error(&quot;create file channel &quot; + this.fileName + &quot; Failed. &quot;, e);</span><br><span class="line"></span><br><span class="line">throw e;</span><br><span class="line"></span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line"></span><br><span class="line">log.error(&quot;map file &quot; + this.fileName + &quot; Failed. &quot;, e);</span><br><span class="line"></span><br><span class="line">throw e;</span><br><span class="line"></span><br><span class="line">&#125; finally &#123;</span><br><span class="line"></span><br><span class="line">if (!ok &amp;&amp; this.fileChannel !&#x3D; null) &#123;</span><br><span class="line"></span><br><span class="line">this.fileChannel.close();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>2.预热源代码</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void warmMappedFile(FlushDiskType type, int pages) &#123;</span><br><span class="line"></span><br><span class="line">long beginTime &#x3D; System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">ByteBuffer byteBuffer &#x3D; this.mappedByteBuffer.slice();</span><br><span class="line"></span><br><span class="line">int flush &#x3D; 0; &#x2F;&#x2F;记录上一次刷盘的字节数</span><br><span class="line"></span><br><span class="line">long time &#x3D; System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">for (int i &#x3D; 0, j &#x3D; 0; i &lt; this.fileSize; i +&#x3D; MappedFile.OS_PAGE_SIZE, j++) &#123;</span><br><span class="line"></span><br><span class="line">byteBuffer.put(i, (byte) 0);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; force flush when flush disk type is sync</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;当刷盘策略为同步刷盘时，执行强制刷盘</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;每修改pages个分页刷一次盘 内存页的大小为4K</span><br><span class="line"></span><br><span class="line">if (type &#x3D;&#x3D; FlushDiskType.SYNC_FLUSH) &#123;</span><br><span class="line"></span><br><span class="line">if ((i &#x2F; OS_PAGE_SIZE) - (flush &#x2F; OS_PAGE_SIZE) &gt;&#x3D; pages) &#123;</span><br><span class="line"></span><br><span class="line">flush &#x3D; i;</span><br><span class="line"></span><br><span class="line">mappedByteBuffer.force();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; prevent gc</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Linux CPU调度策略基于时间片 Thread.sleep 当前线程主动放弃CPU资源，立即进入就绪状态</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;防止一直抢占CPU资源不释放</span><br><span class="line"></span><br><span class="line">if (j % 1000 &#x3D;&#x3D; 0) &#123;</span><br><span class="line"></span><br><span class="line">log.info(&quot;j&#x3D;&#123;&#125;, costTime&#x3D;&#123;&#125;&quot;, j, System.currentTimeMillis() - time);</span><br><span class="line"></span><br><span class="line">time &#x3D; System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">Thread.sleep(0);</span><br><span class="line"></span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">e.printStackTrace();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; force flush when prepare load finished</span><br><span class="line"></span><br><span class="line">if (type &#x3D;&#x3D; FlushDiskType.SYNC_FLUSH) &#123;</span><br><span class="line"></span><br><span class="line">log.info(&quot;mapped file warm-up done, force to disk, mappedFile&#x3D;&#123;&#125;, costTime&#x3D;&#123;&#125;&quot;,</span><br><span class="line"></span><br><span class="line">this.getFileName(), System.currentTimeMillis() - beginTime);</span><br><span class="line"></span><br><span class="line">mappedByteBuffer.force();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.info(&quot;mapped file warm-up done. mappedFile&#x3D;&#123;&#125;, costTime&#x3D;&#123;&#125;&quot;, this.getFileName(),</span><br><span class="line"></span><br><span class="line">System.currentTimeMillis() - beginTime);</span><br><span class="line"></span><br><span class="line">this.mlock();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>3.内存锁定代码</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void mlock() &#123;</span><br><span class="line"></span><br><span class="line">final long beginTime &#x3D; System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">final long address &#x3D; ((DirectBuffer) (this.mappedByteBuffer)).address();</span><br><span class="line"></span><br><span class="line">Pointer pointer &#x3D; new Pointer(address);</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;锁死</span><br><span class="line"></span><br><span class="line">int ret &#x3D; LibC.INSTANCE.mlock(pointer, new NativeLong(this.fileSize));</span><br><span class="line"></span><br><span class="line">log.info(&quot;mlock &#123;&#125; &#123;&#125; &#123;&#125; ret &#x3D; &#123;&#125; time consuming &#x3D; &#123;&#125;&quot;, address, this.fileName, this.fileSize, ret, System.currentTimeMillis() - beginTime);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">int ret &#x3D; LibC.INSTANCE.madvise(pointer, new NativeLong(this.fileSize), LibC.MADV_WILLNEED);</span><br><span class="line"></span><br><span class="line">log.info(&quot;madvise &#123;&#125; &#123;&#125; &#123;&#125; ret &#x3D; &#123;&#125; time consuming &#x3D; &#123;&#125;&quot;, address, this.fileName, this.fileSize, ret, System.currentTimeMillis() - beginTime);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ29# RocketMQ客户端PUSH消费概览</title>
    <url>/posts/3b8a1c43/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>PUSH消费整体流程是怎么样的？</p>
<a id="more"></a>



<h1 id="PUSH消费流程概览"><a href="#PUSH消费流程概览" class="headerlink" title="PUSH消费流程概览"></a>PUSH消费流程概览</h1><p><strong>从客户端示例开始</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DefaultMQPushConsumer consumer &#x3D; new DefaultMQPushConsumer(&quot;CID_JODIE_1&quot;);</span><br><span class="line"></span><br><span class="line">consumer.subscribe(&quot;Jodie_topic_1023&quot;, &quot;*&quot;); consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;wrong time format 2017_0422_221800</span><br><span class="line"></span><br><span class="line">consumer.setConsumeTimestamp(&quot;20170422221800&quot;);</span><br><span class="line"></span><br><span class="line">consumer.registerMessageListener(new MessageListenerConcurrently() &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line"></span><br><span class="line">public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context) &#123;</span><br><span class="line"></span><br><span class="line">System.out.printf(Thread.currentThread().getName() + &quot; Receive New Messages: &quot; + msgs + &quot;%n&quot;);</span><br><span class="line"></span><br><span class="line">return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">consumer.start();</span><br><span class="line"></span><br><span class="line">System.out.printf(&quot;Consumer Started.%n&quot;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>客户端PUSH消费流程概览</strong></p>
<p><strong>概览流程1</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219140443.png"></p>
<!--more-->



<p><strong>概览流程2</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219140501.png"></p>
<p><u>小结：PUSH消费的主要内容实例化DefaultMQPushConsumer，注册MessageQueue分配策略；</u></p>
<p><u>初始化订阅数据并存入缓存；注册消费监听用于回调处理消息；创建并启动MQClientInstance实例；向Broker发送心跳等工作。</u></p>
<p><strong>参数校验哪些内容？</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219140542.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：参数校验中MessageListener只能为顺序消费或者并发消费两种模式；消费最小线程consumeThreadMin取值需要小于1000即最多1000个消费线程；由于为无界队consumeThreadMax设置无效。</span><br></pre></td></tr></table></figure>



<p><strong>MQClientInstance初始化与启动</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219140622.png"></p>
<p><u>小结：MQClientInstance初始化启动连带一系列线程类的启动。例如：PullMessageService、RebalanceService等以及通过Netty建立TCP通道。</u></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本篇文章主要对PUSH消费启动有个整体的印象，在分析消息拉取/并发消费/顺序消费/负载均衡时再来看各个类的具体职责。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ3# RocketMQ Cluster命令</title>
    <url>/posts/a3779249/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="查看集群信息"><a href="#查看集群信息" class="headerlink" title="查看集群信息"></a>查看集群信息</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin clusterList -n localhost:9876</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option PermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">Cluster Name Broker Name BID Addr Version InTPS OutTPS</span><br><span class="line"></span><br><span class="line">AdpMqCluster broker-a 0 192.168.1.x:10911 V3_4_6 2819.22 1077.39</span><br><span class="line"></span><br><span class="line">AdpMqCluster broker-b 0 192.168.1.x:10911 V3_4_6 2839.42 1070.89</span><br><span class="line"></span><br><span class="line">AdpMqCluster broker-c 0 192.168.1.x:10919 V3_4_6 2800.12 1058.39</span><br><span class="line"></span><br><span class="line">AdpMqCluster broker-d 0 192.168.1.x:10915 V3_4_6 2897.04 1126.04</span><br><span class="line"></span><br><span class="line">AdpMqCluster broker-e 0 192.168.1.x:10919 V3_4_6 2987.20 1181.88</span><br><span class="line"></span><br><span class="line">AdpMqCluster broker-f 0 192.168.1.x:10915 V3_4_6 3010.40 1187.08</span><br></pre></td></tr></table></figure>



<a id="more"></a>



<h1 id="创建Topic"><a href="#创建Topic" class="headerlink" title="创建Topic"></a>创建Topic</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin updateTopic -n localhost:9876 -c DefaultCluster -t zto-example</span><br></pre></td></tr></table></figure>



<h1 id="删除Topic"><a href="#删除Topic" class="headerlink" title="删除Topic"></a>删除Topic</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin deleteTopic -n localhost:9876 -c DefaultCluster -t zto-example</span><br></pre></td></tr></table></figure></div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ30# RocketMQ客户端PUSH消费--并发消费与顺序消费</title>
    <url>/posts/55c56ee4/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="消息拉取与处理"><a href="#消息拉取与处理" class="headerlink" title="消息拉取与处理"></a>消息拉取与处理</h1><p><strong>消息拉取</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219140825.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：PullMessageService处理拉取消息请求。通过组织RequetHeader需要包含从哪里开始拉取（ConsumerGroup、Topic，Queue，queueOffset）等信息，向Broker发起请求，取回消息后对消息进行处理。当该Queue的消息数量超过1000，或者最小与最大偏移量之间的差距超过默认2000也会触发限流，即：延迟50毫秒放入请求队列。也可以通过挂起消费线程来延迟（1秒）消息拉取，从而达到消费限流作用。</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p><strong>消息处理</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219140851.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：PullMessageService处理消息部分流程：将消息提交给了processQueue红黑树缓存；同时将消息提交给consumeMessageService来处理具体的消息内容。</span><br></pre></td></tr></table></figure>



<!--more-->



<h1 id="并发消费流程"><a href="#并发消费流程" class="headerlink" title="并发消费流程"></a>并发消费流程</h1><p><strong>ConsumeMessageConcurrentlyService职责</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219140921.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：ConsumeMessageService并发消费（ConsumeMessageConcurrentlyService）主要工作交给Listener（客户端传入）进行处理，并对处理结果进行统计和处理；对于失败消息，广播消费会丢弃，集群消费会发回Broker重新消费；清理ProcessQueue并更新缓存（offsetTable）消费进度。</span><br></pre></td></tr></table></figure>



<h1 id="顺序消费流程"><a href="#顺序消费流程" class="headerlink" title="顺序消费流程"></a>顺序消费流程</h1><p><strong>ConsumeMessageOrderlyService职责</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219140952.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：顺序消费流程跟并发消费最大的区别在于，对要处理的队列加锁，确保同一队列，同一时间，只允许一个消费线程处理。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">疑问：</span><br><span class="line"></span><br><span class="line">1.为什么顺序消费时需要对Broker发请求对要处理的队列加锁？</span><br><span class="line"></span><br><span class="line">2.对Broker端队列加锁流程是怎么样的？</span><br><span class="line"></span><br><span class="line">3.既然加锁了需要解锁吗？</span><br><span class="line"></span><br><span class="line">4.会存在Broker加锁过期了客户端还在处理该队列的情况吗？</span><br></pre></td></tr></table></figure>



<p><strong>Broker端队列加锁流程</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219141026.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：顺序消费时对Broker端队列加锁防止该队列在特定时间内（一次默认60秒）被分配给其他clientId处理；Broker端加锁了不需要解锁，一次加锁失效时长为60秒；不存在Broker加锁过期了客户端还在处理该队列的情况，Broker加锁时长为60秒，而客户端加锁时长为30秒，当客户端加锁时长失效时会重新请求Broker加锁并更新时间戳，从而可以持续延长加锁时间。</span><br></pre></td></tr></table></figure>



<h1 id="交互示意图"><a href="#交互示意图" class="headerlink" title="交互示意图"></a>交互示意图</h1><p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219141054.png"></p>
<h1 id="源码清单"><a href="#源码清单" class="headerlink" title="源码清单"></a>源码清单</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.PullMessageService.java</span><br><span class="line"></span><br><span class="line">2.ConsumeMessageConcurrentlyService.java</span><br><span class="line"></span><br><span class="line">3.ConsumeMessageOrderlyService.java</span><br><span class="line"></span><br><span class="line">4.RebalanceLockManager.java</span><br><span class="line"></span><br></pre></td></tr></table></figure>



</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ31# RocketMQ客户端PUSH消费--负载均衡</title>
    <url>/posts/dd191b8b/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="问题思考"><a href="#问题思考" class="headerlink" title="问题思考"></a>问题思考</h1><p>1.主题队列是如何分配的？</p>
<p>2.什么时候会进行负载均衡？</p>
<p>3.负载均衡后是否会导致消息重复消费？</p>
<a id="more"></a>

<h1 id="调用链条"><a href="#调用链条" class="headerlink" title="调用链条"></a>调用链条</h1><p><strong>初始化链条</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@1 DefaultMQPushConsumerImpl#start</span><br><span class="line"></span><br><span class="line">this.mQClientFactory</span><br><span class="line"></span><br><span class="line">&#x3D; MQClientManager.getInstance().getAndCreateMQClientInstance</span><br><span class="line"></span><br><span class="line">@2 MQClientManager#getAndCreateMQClientInstance</span><br><span class="line"></span><br><span class="line">instance &#x3D; new MQClientInstance</span><br><span class="line"></span><br><span class="line">@3 MQClientInstance#MQClientInstance</span><br><span class="line"></span><br><span class="line">this.rebalanceService &#x3D; new RebalanceService</span><br></pre></td></tr></table></figure>



<p><strong>启动链条</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@1 DefaultMQPushConsumerImpl#start</span><br><span class="line"></span><br><span class="line">mQClientFactory.start()</span><br><span class="line"></span><br><span class="line">@2 MQClientInstance#start</span><br><span class="line"></span><br><span class="line">this.rebalanceService.start</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：从初始化链和调用链可以看出RebalanceService为线程类，随着消费启动时而启动，消费不退出则一直运行着。</span><br></pre></td></tr></table></figure>



<h1 id="负载均衡流程"><a href="#负载均衡流程" class="headerlink" title="负载均衡流程"></a>负载均衡流程</h1><p><strong>负载均衡链条</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@1 RebalanceService#run</span><br><span class="line"></span><br><span class="line">mqClientFactory.doRebalance()</span><br><span class="line"></span><br><span class="line">@2 MQClientInstance#doRebalance</span><br><span class="line"></span><br><span class="line">impl.doRebalance()</span><br><span class="line"></span><br><span class="line">@3 DefaultMQPushConsumerImpl#doRebalance</span><br><span class="line"></span><br><span class="line">this.rebalanceImpl.doRebalance</span><br><span class="line"></span><br><span class="line">@4 RebalanceImpl#doRebalance</span><br><span class="line"></span><br><span class="line">rebalanceByTopic</span><br></pre></td></tr></table></figure>



<p><strong>负载均衡流程</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219141402.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：在负载均衡时，会循环该消费组订阅的所有Topic都会执行负载均衡。</span><br></pre></td></tr></table></figure>



<p><strong>更新缓存processQueue流程</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219141423.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：</span><br><span class="line">1. 更新缓存时如果消费组订阅的队列不在新分配的队列集合中或者队列拉取时间超时失效，则将快照ProcessQueue设置为丢弃。</span><br><span class="line">2. 消费拉取时判断ProcessQueue为丢弃，则不再对该队列拉取。</span><br><span class="line">3. 顺序消费时如果获取消费锁成功，表明此队列空闲没有被消费，此时向Broker发起解锁请求，解锁成功后将该队列从缓存（processQueueTable）移除。</span><br><span class="line">4. 顺序消费时获取锁失败，表明正在消费则不从processQueueTable移除，由于ProcessQueue设置为丢弃，在顺序消费下次拉取时会退出该队列的拉取请求。</span><br></pre></td></tr></table></figure>



<!--more-->



<p><strong>向Broker发送心跳流程</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219141446.png"></p>
<p><strong>队列分配算法</strong></p>
<p>负载均衡流程图中对clientId和分区队列的分配提交给分区算法执行，那该算法是如何运作的呢？</p>
<p>接口AllocateMessageQueueStrategy队列分配策略提供五种分配算法实现：</p>
<p>* 1.平均分配策略AllocateMessageQueueAveragely</p>
<p>* 2.环形分配策略AllocateMessageQueueAveragelyByCircle</p>
<p>* 3.机房分配策略AllocateMessageQueueByMachineRoom</p>
<p>* 4.一致性Hash分配策略AllocateMessageQueueConsistentHash</p>
<p>* 5.配置文件分配策略AllocateMessageQueueByConfig</p>
<p>除此之外可以自定义分配算法，实现接口接口即可，默认使用平均分配算法，也是最常用的，下面以该算法看看如何工作的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public List&lt;MessageQueue&gt; allocate</span><br><span class="line"></span><br><span class="line">(String consumerGroup, String currentCID, List&lt;MessageQueue&gt; mqAll,</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; cidAll) &#123;</span><br><span class="line"></span><br><span class="line">List&lt;MessageQueue&gt; result &#x3D; new ArrayList&lt;MessageQueue&gt;();</span><br><span class="line"></span><br><span class="line">int index &#x3D; cidAll.indexOf(currentCID);</span><br><span class="line"></span><br><span class="line">int mod &#x3D; mqAll.size() % cidAll.size();</span><br><span class="line"></span><br><span class="line">int averageSize &#x3D; mqAll.size() &lt;&#x3D; cidAll.size() ?</span><br><span class="line"></span><br><span class="line">1 : (mod &gt; 0 &amp;&amp; index &lt; mod ?</span><br><span class="line"></span><br><span class="line">mqAll.size() &#x2F; cidAll.size() + 1 : mqAll.size() &#x2F; cidAll.size());</span><br><span class="line"></span><br><span class="line">int startIndex &#x3D; (mod &gt; 0 &amp;&amp; index &lt; mod) ? index * averageSize : index * averageSize + mod;</span><br><span class="line"></span><br><span class="line">int range &#x3D; Math.min(averageSize, mqAll.size() - startIndex);</span><br><span class="line"></span><br><span class="line">for (int i &#x3D; 0; i &lt; range; i++) &#123;</span><br><span class="line"></span><br><span class="line">result.add(mqAll.get((startIndex + i) % mqAll.size()));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>代码不是很好阅读，看下面验证结果即可。</p>
<p><strong>平均分配算法验证</strong></p>
<p>* 只有一个clientId时分配情况</p>
<p>会把1个Broker的16个分区全部分配给该客户端，每隔20秒触发一次负载均衡。</p>
<p>currentCID=2.0.1.138@consumer01分到的队列为0～15</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">----------2019-08-04 22:10:15-----------</span><br><span class="line"></span><br><span class="line">currentCID&#x3D;2.0.1.138@consumer01</span><br><span class="line"></span><br><span class="line">index&#x3D;0</span><br><span class="line"></span><br><span class="line">mod&#x3D;0</span><br><span class="line"></span><br><span class="line">averageSize&#x3D;16</span><br><span class="line"></span><br><span class="line">startIndex&#x3D;0</span><br><span class="line"></span><br><span class="line">range&#x3D;16</span><br><span class="line"></span><br><span class="line">result&#x3D;[MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;0], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;1], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;2], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;3], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;4], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;5], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;6], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;7], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;8], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;9], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;10], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;11], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;12], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;13], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;14], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;15]]</span><br><span class="line"></span><br><span class="line">----------2019-08-04 22:10:35-----------</span><br><span class="line"></span><br><span class="line">currentCID&#x3D;2.0.1.138@consumer01</span><br><span class="line"></span><br><span class="line">index&#x3D;0</span><br><span class="line"></span><br><span class="line">mod&#x3D;0</span><br><span class="line"></span><br><span class="line">averageSize&#x3D;16</span><br><span class="line"></span><br><span class="line">startIndex&#x3D;0</span><br><span class="line"></span><br><span class="line">range&#x3D;16</span><br><span class="line"></span><br><span class="line">result&#x3D;[MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;0], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;1], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;2], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;3], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;4], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;5], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;6], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;7], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;8], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;9], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;10], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;11], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;12], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;13], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;14], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;15]]</span><br></pre></td></tr></table></figure>



<p>* 新加入第二个client时</p>
<p>此时有两个clinetId分别为2.0.1.138@consumer01和2.0.1.138@consumer02，1个 Broker16个分区的分配情况。</p>
<p>currentCID=2.0.1.138@consumer01分到的分区为0～7</p>
<p>currentCID=2.0.1.138@consumer02分到的分区为8～16</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">----------2019-08-04 22:12:25-----------</span><br><span class="line"></span><br><span class="line">currentCID&#x3D;2.0.1.138@consumer01</span><br><span class="line"></span><br><span class="line">index&#x3D;0</span><br><span class="line"></span><br><span class="line">mod&#x3D;0</span><br><span class="line"></span><br><span class="line">averageSize&#x3D;8</span><br><span class="line"></span><br><span class="line">startIndex&#x3D;0</span><br><span class="line"></span><br><span class="line">range&#x3D;8</span><br><span class="line"></span><br><span class="line">result&#x3D;[MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;0], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;1], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;2], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;3], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;4], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;5], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;6], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;7]]</span><br><span class="line"></span><br><span class="line">----------2019-08-04 22:12:45-----------</span><br><span class="line"></span><br><span class="line">currentCID&#x3D;2.0.1.138@consumer02</span><br><span class="line"></span><br><span class="line">index&#x3D;1</span><br><span class="line"></span><br><span class="line">mod&#x3D;0</span><br><span class="line"></span><br><span class="line">averageSize&#x3D;8</span><br><span class="line"></span><br><span class="line">startIndex&#x3D;8</span><br><span class="line"></span><br><span class="line">range&#x3D;8</span><br><span class="line"></span><br><span class="line">result&#x3D;[MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;8], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;9], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;10], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;11], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;12], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;13], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;14], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;15]]</span><br></pre></td></tr></table></figure>



<p>* 新加入第三个client时</p>
<p>此时有三个客户端2.0.1.138@consumer01、2.0.1.138@consumer02、2.0.1.138@consumer03，1个Broker的16个队列的分配情况。</p>
<p>currentCID=2.0.1.138@consumer01分到的队列0～5</p>
<p>currentCID=2.0.1.138@consumer02分到的队列6～10</p>
<p>currentCID=2.0.1.138@consumer03分到的队列11～15</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">----------2019-08-04 22:13:58-----------</span><br><span class="line"></span><br><span class="line">currentCID&#x3D;2.0.1.138@consumer01</span><br><span class="line"></span><br><span class="line">index&#x3D;0</span><br><span class="line"></span><br><span class="line">mod&#x3D;1</span><br><span class="line"></span><br><span class="line">averageSize&#x3D;6</span><br><span class="line"></span><br><span class="line">startIndex&#x3D;0</span><br><span class="line"></span><br><span class="line">range&#x3D;6</span><br><span class="line"></span><br><span class="line">result&#x3D;[MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;0], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;1], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;2], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;3], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;4], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;5]]</span><br><span class="line"></span><br><span class="line">----------2019-08-04 22:14:18-----------</span><br><span class="line"></span><br><span class="line">currentCID&#x3D;2.0.1.138@consumer02</span><br><span class="line"></span><br><span class="line">index&#x3D;1</span><br><span class="line"></span><br><span class="line">mod&#x3D;1</span><br><span class="line"></span><br><span class="line">averageSize&#x3D;5</span><br><span class="line"></span><br><span class="line">startIndex&#x3D;6</span><br><span class="line"></span><br><span class="line">range&#x3D;5</span><br><span class="line"></span><br><span class="line">result&#x3D;[MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;6], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;7], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;8], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;9], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;10]]</span><br><span class="line"></span><br><span class="line">----------2019-08-04 22:14:39-----------</span><br><span class="line"></span><br><span class="line">currentCID&#x3D;2.0.1.138@consumer03</span><br><span class="line"></span><br><span class="line">index&#x3D;2</span><br><span class="line"></span><br><span class="line">mod&#x3D;1</span><br><span class="line"></span><br><span class="line">averageSize&#x3D;5</span><br><span class="line"></span><br><span class="line">startIndex&#x3D;11</span><br><span class="line"></span><br><span class="line">range&#x3D;5</span><br><span class="line"></span><br><span class="line">result&#x3D;[MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;11], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;12], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;13], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;14], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;15]]</span><br></pre></td></tr></table></figure>



<h1 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h1><p>1.主题队列是如何分配的？</p>
<p>备注：见队列分配算法，通常使用平均分配算法。</p>
<p>2.什么时候会进行负载均衡？</p>
<p>备注：负载均衡线程每隔20秒执行一次，当有新客户端退出或者加入或者新的Broker加入或掉线都会触发重新负载均衡。</p>
<p>3.负载均衡后是否会导致消息重复消费？</p>
<p>备注：</p>
<p>并发消费可能导致消息被重复消费，看以下代码。如果负载均衡前已分配的队列不在负载均衡后的新队列集合中，会丢弃该队列即：processQueue.isDropped()。而该队列可能已经被消费完了，在处理结果时被丢弃了，消费进度没有更新。别的消费客户端重新拉取该队列时造成重复消费。</p>
<p>顺序消费不会导致消息被重复消费。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;并发消费对结果的处理</span><br><span class="line"></span><br><span class="line">ConsumeMessageConcurrentlyService#ConsumeRequest</span><br><span class="line"></span><br><span class="line">if (!processQueue.isDropped()) &#123; ConsumeMessageConcurrentlyService.this.processConsumeResult(status, context, this);</span><br><span class="line"></span><br><span class="line">&#125; else &#123; &#x2F;&#x2F;被丢弃，消费进度不会更新</span><br><span class="line"></span><br><span class="line">log.warn(&quot;processQueue is dropped without process consume result. messageQueue&#x3D;&#123;&#125;, msgs&#x3D;&#123;&#125;&quot;, messageQueue, msgs);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ32# RocketMQ客户端消费--ProcessQueue处理队列</title>
    <url>/posts/87a2ceec/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="问题思考"><a href="#问题思考" class="headerlink" title="问题思考"></a>问题思考</h1><p>在消费消息时处处能看到处理队列ProcessQueue的身影，既然随处可见也一定很重要，那有必要分析下为何重要了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.ProcessQueue提供哪些方法？</span><br><span class="line"></span><br><span class="line">2.这些方法的作用是什么？</span><br><span class="line"></span><br><span class="line">3.哪里调用了这些方法？</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h1 id="ProcessQueue方法梳理"><a href="#ProcessQueue方法梳理" class="headerlink" title="ProcessQueue方法梳理"></a>ProcessQueue方法梳理</h1><h2 id="isLockExpired方法"><a href="#isLockExpired方法" class="headerlink" title="isLockExpired方法"></a>isLockExpired方法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean isLockExpired() &#123;</span><br><span class="line"></span><br><span class="line">	return (System.currentTimeMillis() - this.lastLockTimestamp) &gt; REBALANCE_LOCK_MAX_LIVE_TIME;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>lastLockTimestamp(最新加锁时间戳)</strong></p>
<p>lastLockTimestamp属性调用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@1 RebalanceImpl#lock</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;请求broker对该消费队列进行加锁</span><br><span class="line"></span><br><span class="line">Set&lt;MessageQueue&gt; lockedMq &#x3D; this.mQClientFactory.getMQClientAPIImpl().lockBatchMQ</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">processQueue.setLocked(true);&#x2F;&#x2F;加锁</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设置加锁时间戳</span><br><span class="line"></span><br><span class="line">processQueue.setLastLockTimestamp(System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@2 RebalanceImpl#lockAll</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;向broker发送该clientId所对应的messageQueue锁定请求</span><br><span class="line"></span><br><span class="line">Set&lt;MessageQueue&gt; lockOKMQSet &#x3D;</span><br><span class="line"></span><br><span class="line">this.mQClientFactory.getMQClientAPIImpl().lockBatchMQ</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">processQueue.setLocked(true);</span><br><span class="line"></span><br><span class="line">processQueue.setLastLockTimestamp(System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>isLockExpired方法调用</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@1 ConsumeMessageOrderlyService#ConsumeRequest</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;集群顺序消费时需要判断processQueue加锁是否过期</span><br><span class="line"></span><br><span class="line">if (MessageModel.BROADCASTING.equals(ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.messageModel())</span><br><span class="line"></span><br><span class="line">|| (this.processQueue.isLocked() &amp;&amp; !this.processQueue.isLockExpired()))</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：@1&amp;@2中可以看出lastLockTimestamp在顺序消费时向Broker请求对队列加锁成功后设置的时间戳；REBALANCE_LOCK_MAX_LIVE_TIME由参数rocketmq.client.rebalance.lockMaxLiveTime设置默认为30秒；lastLockTimestamp的含义为加锁的有效时间为30秒，超过该时间则失效；顺序消费在判断过期时延迟拉取。</span><br></pre></td></tr></table></figure>



<h2 id="isPullExpired方法"><a href="#isPullExpired方法" class="headerlink" title="isPullExpired方法"></a>isPullExpired方法</h2><p><strong>isPullExpired方法代码</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean isPullExpired() &#123;</span><br><span class="line"></span><br><span class="line">return (System.currentTimeMillis() - this.lastPullTimestamp) &gt; PULL_MAX_IDLE_TIME;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<!--more-->



<p><strong>lastPullTimestamp属性调用</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@1 DefaultMQPushConsumerImpl#pullMessage</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;每次消息拉取后更新最后一次拉取时间戳</span><br><span class="line"></span><br><span class="line">pullRequest.getProcessQueue()</span><br><span class="line"></span><br><span class="line">.setLastPullTimestamp(System.currentTimeMillis());</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@1 RebalanceImpl#updateProcessQueueTableInRebalance</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;在负载均衡时如果拉取时间失效会将ProceeQueue丢弃</span><br><span class="line"></span><br><span class="line">else if (pq.isPullExpired()) &#123;</span><br><span class="line"></span><br><span class="line">case CONSUME_ACTIVELY:</span><br><span class="line"></span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">case CONSUME_PASSIVELY:</span><br><span class="line"></span><br><span class="line">pq.setDropped(true);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：lastPullTimestamp每次拉取消息都会更新时间戳；PULL_MAX_IDLE_TIME由rocketmq.client.pull.pullMaxIdleTime设置默认为120秒；方法在负载均衡更新ProcessQueueTable时调用如果拉取失效ProcessQueue将被丢弃。</span><br></pre></td></tr></table></figure>



<h2 id="putMessage方法"><a href="#putMessage方法" class="headerlink" title="putMessage方法"></a>putMessage方法</h2><p>putMessage方法代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"></span><br><span class="line">\* 消息丢入红黑树</span><br><span class="line"></span><br><span class="line">\* @param msgs</span><br><span class="line"></span><br><span class="line">\* @return</span><br><span class="line"></span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">public boolean putMessage(final List&lt;MessageExt&gt; msgs) &#123;</span><br><span class="line"></span><br><span class="line">boolean dispatchToConsume &#x3D; false;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">this.lockTreeMap.writeLock().lockInterruptibly();</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">int validMsgCnt &#x3D; 0;</span><br><span class="line"></span><br><span class="line">for (MessageExt msg : msgs) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;消息存入红黑树key为queueOffset,value为消息</span><br><span class="line"></span><br><span class="line">MessageExt old &#x3D; msgTreeMap.put(msg.getQueueOffset(), msg);</span><br><span class="line"></span><br><span class="line">if (null &#x3D;&#x3D; old) &#123;</span><br><span class="line"></span><br><span class="line">validMsgCnt++;&#x2F;&#x2F;递增消息数量</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;记录最大queueOffset</span><br><span class="line"></span><br><span class="line">this.queueOffsetMax &#x3D; msg.getQueueOffset();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;统计消息数量</span><br><span class="line"></span><br><span class="line">msgCount.addAndGet(validMsgCnt);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;消息集合有数据可继续消费</span><br><span class="line"></span><br><span class="line">if (!msgTreeMap.isEmpty() &amp;&amp; !this.consuming) &#123;</span><br><span class="line"></span><br><span class="line">dispatchToConsume &#x3D; true;</span><br><span class="line"></span><br><span class="line">this.consuming &#x3D; true;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (!msgs.isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;取出这批消息集合中的最后一条消息</span><br><span class="line"></span><br><span class="line">MessageExt messageExt &#x3D; msgs.get(msgs.size() - 1);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取分区最大的消息offet</span><br><span class="line"></span><br><span class="line">String property &#x3D; messageExt.getProperty(MessageConst.PROPERTY_MAX_OFFSET);</span><br><span class="line"></span><br><span class="line">if (property !&#x3D; null) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;计算还有多少消息未被消费</span><br><span class="line"></span><br><span class="line">long accTotal &#x3D; Long.parseLong(property) - messageExt.getQueueOffset();</span><br><span class="line"></span><br><span class="line">if (accTotal &gt; 0) &#123;</span><br><span class="line"></span><br><span class="line">this.msgAccCnt &#x3D; accTotal;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; finally &#123;</span><br><span class="line"></span><br><span class="line">this.lockTreeMap.writeLock().unlock();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">log.error(&quot;putMessage exception&quot;, e);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return dispatchToConsume;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>putMessage方法调用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@1 DefaultMQPushConsumerImpl#pullMessage</span><br><span class="line"></span><br><span class="line">boolean dispathToConsume &#x3D; processQueue.putMessage(pullResult.getMsgFoundList())</span><br><span class="line"></span><br><span class="line">@2 ConsumeMessageOrderlyService#submitConsumeRequest</span><br><span class="line"></span><br><span class="line">if (dispathToConsume) &#123; &#x2F;&#x2F;dispathToConsume顺序消费返回结果为true</span><br><span class="line"></span><br><span class="line">ConsumeRequest consumeRequest &#x3D;</span><br><span class="line"></span><br><span class="line">new ConsumeRequest(processQueue, messageQueue);</span><br><span class="line"></span><br><span class="line">this.consumeExecutor.submit(consumeRequest);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@3 PullConsumerImpl#registerPullTaskCallback</span><br><span class="line"></span><br><span class="line">pq.putMessage(pullResult.getMsgFoundList());</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：在拉取消息后处理消息时，提交给ProcessQueue#putMessage中红黑树msgTreeMap存储一份数据，并统计消息的数量以及还有多少消息未被拉取；返回结果dispatchToConsume如果true表明消费集合有数据，顺序消息会据此构造消费请求继续处理。</span><br></pre></td></tr></table></figure>



<h2 id="getMaxSpan方法"><a href="#getMaxSpan方法" class="headerlink" title="getMaxSpan方法"></a>getMaxSpan方法</h2><p>getMaxSpan方法代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"></span><br><span class="line">\* 获取当前消息最大间隔</span><br><span class="line"></span><br><span class="line">\* 消息队列第一条消息与最后一条消息的偏移量差值</span><br><span class="line"></span><br><span class="line">\* @return</span><br><span class="line"></span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">public long getMaxSpan() &#123;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">this.lockTreeMap.readLock().lockInterruptibly();</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">if (!this.msgTreeMap.isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line">return this.msgTreeMap.lastKey() - this.msgTreeMap.firstKey();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; finally &#123;</span><br><span class="line"></span><br><span class="line">this.lockTreeMap.readLock().unlock();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">log.error(&quot;getMaxSpan exception&quot;, e);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>getMaxSpan方法调用</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@1 DefaultMQPushConsumerImpl#pullMessage</span><br><span class="line"></span><br><span class="line">f (!this.consumeOrderly) &#123;&#x2F;&#x2F;非顺序消费</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;并发处理的消息跨度不能超过2000，超过2000，延迟50秒进行拉去</span><br><span class="line"></span><br><span class="line">if (processQueue.getMaxSpan() &gt; this.defaultMQPushConsumer.getConsumeConcurrentlyMaxSpan()) &#123;</span><br><span class="line"></span><br><span class="line">this.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL);</span><br><span class="line"></span><br><span class="line">if ((flowControlTimes2++ % 1000) &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F;每出发1000次打印流控日志</span><br><span class="line"></span><br><span class="line">log.warn(</span><br><span class="line"></span><br><span class="line">&quot;the queue&#39;s messages, span too long, so do flow control, minOffset&#x3D;&#123;&#125;, maxOffset&#x3D;&#123;&#125;, maxSpan&#x3D;&#123;&#125;, pullRequest&#x3D;&#123;&#125;, flowControlTimes&#x3D;&#123;&#125;&quot;,</span><br><span class="line"></span><br><span class="line">processQueue.getMsgTreeMap().firstKey(), processQueue.getMsgTreeMap().lastKey(), processQueue.getMaxSpan(),</span><br><span class="line"></span><br><span class="line">pullRequest, flowControlTimes2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：getMaxSpan方法计算已拉取消息队列第一条消息与最后一条消息的偏移量差值，即拉取消息的数量跨度，在并发消息时调用，如果该跨度大于2000则延迟50秒再拉取数据。</span><br></pre></td></tr></table></figure>



<h2 id="removeMessage方法"><a href="#removeMessage方法" class="headerlink" title="removeMessage方法"></a>removeMessage方法</h2><p>removeMessage方法代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"></span><br><span class="line">\* 将消息从红黑树msgTreeMap中移除</span><br><span class="line"></span><br><span class="line">\* @param msgs</span><br><span class="line"></span><br><span class="line">\* @return</span><br><span class="line"></span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">public long removeMessage(final List&lt;MessageExt&gt; msgs) &#123;</span><br><span class="line"></span><br><span class="line">long result &#x3D; -1;</span><br><span class="line"></span><br><span class="line">final long now &#x3D; System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">this.lockTreeMap.writeLock().lockInterruptibly();</span><br><span class="line"></span><br><span class="line">this.lastConsumeTimestamp &#x3D; now;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">if (!msgTreeMap.isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line">result &#x3D; this.queueOffsetMax + 1;</span><br><span class="line"></span><br><span class="line">int removedCnt &#x3D; 0;</span><br><span class="line"></span><br><span class="line">for (MessageExt msg : msgs) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;移除消息</span><br><span class="line"></span><br><span class="line">MessageExt prev &#x3D; msgTreeMap.remove(msg.getQueueOffset());</span><br><span class="line"></span><br><span class="line">if (prev !&#x3D; null) &#123;</span><br><span class="line"></span><br><span class="line">removedCnt--;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">msgCount.addAndGet(removedCnt);&#x2F;&#x2F;消息总数扣除</span><br><span class="line"></span><br><span class="line">if (!msgTreeMap.isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line">result &#x3D; msgTreeMap.firstKey(); &#x2F;&#x2F;第一条消息的偏移量</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; finally &#123;</span><br><span class="line"></span><br><span class="line">this.lockTreeMap.writeLock().unlock();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; catch (Throwable t) &#123;</span><br><span class="line"></span><br><span class="line">log.error(&quot;removeMessage exception&quot;, t);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>removeMessage方法调用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@1 ConsumeMessageConcurrentlyService#processConsumeResult</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;消费完毕后从ProcessQueue中清除这批消息</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;offset为清除这批偏移量后processQueue.msgTreeMap中最小的偏移量</span><br><span class="line"></span><br><span class="line">long offset &#x3D; consumeRequest.getProcessQueue().removeMessage(consumeRequest.getMsgs());</span><br></pre></td></tr></table></figure>



<p>```</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：removeMessage方法在并发消费后进行调用，消息处理完了将ProcessQueue中红黑树这批消息移除。</span><br></pre></td></tr></table></figure>

<h2 id="cleanExpiredMsg方法"><a href="#cleanExpiredMsg方法" class="headerlink" title="cleanExpiredMsg方法"></a>cleanExpiredMsg方法</h2><p>cleanExpiredMsg方法代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"></span><br><span class="line">\* @param pushConsumer</span><br><span class="line"></span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">public void cleanExpiredMsg(DefaultMQPushConsumer pushConsumer) &#123;</span><br><span class="line"></span><br><span class="line">if (pushConsumer.getDefaultMQPushConsumerImpl().isConsumeOrderly()) &#123;</span><br><span class="line"></span><br><span class="line">return;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;每次调用最多清理16条</span><br><span class="line"></span><br><span class="line">int loop &#x3D; msgTreeMap.size() &lt; 16 ? msgTreeMap.size() : 16;</span><br><span class="line"></span><br><span class="line">for (int i &#x3D; 0; i &lt; loop; i++) &#123;</span><br><span class="line"></span><br><span class="line">MessageExt msg &#x3D; null;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">this.lockTreeMap.readLock().lockInterruptibly();</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;默认超过15分钟未消费的消息将延迟3个延迟级别再消费</span><br><span class="line"></span><br><span class="line">if (!msgTreeMap.isEmpty() &amp;&amp; System.currentTimeMillis() - Long.parseLong(MessageAccessor.getConsumeStartTimeStamp(msgTreeMap.firstEntry().getValue())) &gt; pushConsumer.getConsumeTimeout() * 60 * 1000) &#123;</span><br><span class="line"></span><br><span class="line">msg &#x3D; msgTreeMap.firstEntry().getValue();</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line"></span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; finally &#123;</span><br><span class="line"></span><br><span class="line">this.lockTreeMap.readLock().unlock();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">log.error(&quot;getExpiredMsg exception&quot;, e);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;返回broker，延迟3个级别消费</span><br><span class="line"></span><br><span class="line">pushConsumer.sendMessageBack(msg, 3);</span><br><span class="line"></span><br><span class="line">log.info(&quot;send expire msg back. topic&#x3D;&#123;&#125;, msgId&#x3D;&#123;&#125;, storeHost&#x3D;&#123;&#125;, queueId&#x3D;&#123;&#125;, queueOffset&#x3D;&#123;&#125;&quot;, msg.getTopic(), msg.getMsgId(), msg.getStoreHost(), msg.getQueueId(), msg.getQueueOffset());</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">this.lockTreeMap.writeLock().lockInterruptibly();</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">if (!msgTreeMap.isEmpty() &amp;&amp; msg.getQueueOffset() &#x3D;&#x3D; msgTreeMap.firstKey()) &#123;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将消息移出</span><br><span class="line"></span><br><span class="line">msgTreeMap.remove(msgTreeMap.firstKey());</span><br><span class="line"></span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">log.error(&quot;send expired msg exception&quot;, e);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; finally &#123;</span><br><span class="line"></span><br><span class="line">this.lockTreeMap.writeLock().unlock();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">log.error(&quot;getExpiredMsg exception&quot;, e);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">log.error(&quot;send expired msg exception&quot;, e);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>cleanExpiredMsg方法调用</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@1 ConsumeMessageConcurrentlyService#start()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;定时任务15分钟运行一次</span><br><span class="line"></span><br><span class="line">public void start() &#123;</span><br><span class="line"></span><br><span class="line">this.cleanExpireMsgExecutors.scheduleAtFixedRate(new Runnable() &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line"></span><br><span class="line">public void run() &#123;</span><br><span class="line"></span><br><span class="line">cleanExpireMsg();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;, this.defaultMQPushConsumer.getConsumeTimeout(), this.defaultMQPushConsumer.getConsumeTimeout(), TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void cleanExpireMsg() &#123;</span><br><span class="line"></span><br><span class="line">Iterator&lt;Map.Entry&lt;MessageQueue, ProcessQueue&gt;&gt; it &#x3D; this.defaultMQPushConsumerImpl.getRebalanceImpl().getProcessQueueTable().entrySet().iterator();</span><br><span class="line"></span><br><span class="line">while (it.hasNext()) &#123;</span><br><span class="line"></span><br><span class="line">Map.Entry&lt;MessageQueue, ProcessQueue&gt; next &#x3D; it.next();</span><br><span class="line"></span><br><span class="line">ProcessQueue pq &#x3D; next.getValue();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;清理过期消息</span><br><span class="line"></span><br><span class="line">pq.cleanExpiredMsg(this.defaultMQPushConsumer);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：cleanExpiredMsg方法在并发消费中调用，每个15分钟执行一次；该方法会对超过15分钟未被消费的数据进行清理，每次最多清理16条。</span><br></pre></td></tr></table></figure>



<h2 id="takeMessags方法"><a href="#takeMessags方法" class="headerlink" title="takeMessags方法"></a>takeMessags方法</h2><p>takeMessags方法代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"></span><br><span class="line">\* 从ProcessQueue中取出batchSize条消息</span><br><span class="line"></span><br><span class="line">\* @param batchSize</span><br><span class="line"></span><br><span class="line">\* @return</span><br><span class="line"></span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">public List&lt;MessageExt&gt; takeMessags(final int batchSize) &#123;</span><br><span class="line"></span><br><span class="line">List&lt;MessageExt&gt; result &#x3D; new ArrayList&lt;MessageExt&gt;(batchSize);</span><br><span class="line"></span><br><span class="line">final long now &#x3D; System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">this.lockTreeMap.writeLock().lockInterruptibly();</span><br><span class="line"></span><br><span class="line">this.lastConsumeTimestamp &#x3D; now;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">if (!this.msgTreeMap.isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line">for (int i &#x3D; 0; i &lt; batchSize; i++) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;消息从红黑树中取出</span><br><span class="line"></span><br><span class="line">Map.Entry&lt;Long, MessageExt&gt; entry &#x3D; this.msgTreeMap.pollFirstEntry();</span><br><span class="line"></span><br><span class="line">if (entry !&#x3D; null) &#123;</span><br><span class="line"></span><br><span class="line">result.add(entry.getValue());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;取出的消息在msgTreeMapTemp中存储一份</span><br><span class="line"></span><br><span class="line">msgTreeMapTemp.put(entry.getKey(), entry.getValue());</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line"></span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (result.isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line">consuming &#x3D; false;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; finally &#123;</span><br><span class="line"></span><br><span class="line">this.lockTreeMap.writeLock().unlock();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">log.error(&quot;take Messages exception&quot;, e);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>takeMessags方法调用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@1 ConsumeMessageOrderlyService#ConsumeRequest</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;取出消息</span><br><span class="line"></span><br><span class="line">List&lt;MessageExt&gt; msgs &#x3D; this.processQueue.takeMessags(consumeBatchSize);</span><br><span class="line"></span><br><span class="line">if (!msgs.isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;客户端消费消息</span><br><span class="line"></span><br><span class="line">status &#x3D; messageListener.consumeMessage(Collections.unmodifiableList(msgs), context);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：顺序消费时通过ProcessQueue#takeMessags获取特定数量的消息（默认1条）并传给客户端Listener进行处理。</span><br></pre></td></tr></table></figure>



<h2 id="rollback方法"><a href="#rollback方法" class="headerlink" title="rollback方法"></a>rollback方法</h2><p>rollback方法代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"></span><br><span class="line">\* 将msgTreeMapTmp中所有消息重新放入到msgTreeMap并清除msgTreeMapTmp</span><br><span class="line"></span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">public void rollback() &#123;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">this.lockTreeMap.writeLock().lockInterruptibly();</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">this.msgTreeMap.putAll(this.msgTreeMapTemp);</span><br><span class="line"></span><br><span class="line">this.msgTreeMapTemp.clear();</span><br><span class="line"></span><br><span class="line">&#125; finally &#123;</span><br><span class="line"></span><br><span class="line">this.lockTreeMap.writeLock().unlock();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">log.error(&quot;rollback exception&quot;, e);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>rollback方法调用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@1 ConsumeMessageOrderlyService#processConsumeResult</span><br><span class="line"></span><br><span class="line">case ROLLBACK:</span><br><span class="line"></span><br><span class="line">consumeRequest.getProcessQueue().rollback();</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：在顺序消费客户端处理消息后，如果消息处理结果的状态为ROLLBACK，此时调用ProcessQueue#rollback方法；将msgTreeMapTmp中的消息重新写回红黑树msgTreeMap中；ROLLBACK此状态在顺序消费时已不建议使用。</span><br></pre></td></tr></table></figure>



<h2 id="commit方法"><a href="#commit方法" class="headerlink" title="commit方法"></a>commit方法</h2><p>commit方法代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"></span><br><span class="line">\* 将msgTreeMapTmp中的消息清除，表示成功处理了该批消息</span><br><span class="line"></span><br><span class="line">\* @return</span><br><span class="line"></span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">public long commit() &#123;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">this.lockTreeMap.writeLock().lockInterruptibly();</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">Long offset &#x3D; this.msgTreeMapTemp.lastKey();</span><br><span class="line"></span><br><span class="line">msgCount.addAndGet(this.msgTreeMapTemp.size() * (-1));</span><br><span class="line"></span><br><span class="line">this.msgTreeMapTemp.clear();</span><br><span class="line"></span><br><span class="line">if (offset !&#x3D; null) &#123;</span><br><span class="line"></span><br><span class="line">return offset + 1; &#x2F;&#x2F;返回下一条消息offset</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; finally &#123;</span><br><span class="line"></span><br><span class="line">this.lockTreeMap.writeLock().unlock();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">log.error(&quot;commit exception&quot;, e);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return -1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>commit方法调用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@1 ConsumeMessageOrderlyService#processConsumeResult</span><br><span class="line"></span><br><span class="line">case SUCCESS:</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;清空msgTreeMapTemp</span><br><span class="line"></span><br><span class="line">commitOffset &#x3D; consumeRequest.getProcessQueue().commit();</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：在顺序消费客户端处理消息状态为成功时，内存中消费偏移量提交即ProcessQueue#commit清空msgTreeMapTemp临时红黑树中的数据。</span><br></pre></td></tr></table></figure>



<h2 id="makeMessageToCosumeAgain方法"><a href="#makeMessageToCosumeAgain方法" class="headerlink" title="makeMessageToCosumeAgain方法"></a>makeMessageToCosumeAgain方法</h2><p>makeMessageToCosumeAgain方法代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"></span><br><span class="line">\* 重新消费该批消息</span><br><span class="line"></span><br><span class="line">\* @param msgs</span><br><span class="line"></span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">public void makeMessageToCosumeAgain(List&lt;MessageExt&gt; msgs) &#123;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">this.lockTreeMap.writeLock().lockInterruptibly();</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">for (MessageExt msg : msgs) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将消息从msgTreeMapTemp移除</span><br><span class="line"></span><br><span class="line">this.msgTreeMapTemp.remove(msg.getQueueOffset());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将该批消息重新放入msgTreeMap</span><br><span class="line"></span><br><span class="line">this.msgTreeMap.put(msg.getQueueOffset(), msg);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; finally &#123;</span><br><span class="line"></span><br><span class="line">this.lockTreeMap.writeLock().unlock();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">log.error(&quot;makeMessageToCosumeAgain exception&quot;, e);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>makeMessageToCosumeAgain方法调用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">case SUSPEND_CURRENT_QUEUE_A_MOMENT:</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;重新消费该批信息</span><br><span class="line"></span><br><span class="line">onsumeRequest.getProcessQueue().makeMessageToCosumeAgain(msgs);</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：akeMessageToCosumeAgain在顺序消费客户端返回消息状态为SUSPEND_CURRENT_QUEUE_A_MOMENT时调用；将消息从msgTreeMapTemp移除，并将该批消息重新放入msgTreeMap。</span><br></pre></td></tr></table></figure>



<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>ProcessQueue作为MessageQueue在消费端的镜像，从负载均衡、消息拉取、消费状态处理、offset提交，控制着整个消费的脉搏，尤其在顺序消费中参与更多。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ33# RocketMQ消费--Broker端处理逻辑</title>
    <url>/posts/9c431d59/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="问题思考"><a href="#问题思考" class="headerlink" title="问题思考"></a>问题思考</h1><p>1.Broker是如何处理消费流程的？</p>
<p>2.消费进度是如何流转的？</p>
<p>说明：本文分析均为PUSH消费模式</p>
<a id="more"></a>



<h1 id="Broker处理消费流程"><a href="#Broker处理消费流程" class="headerlink" title="Broker处理消费流程"></a>Broker处理消费流程</h1><p>本部分将消费的切分成三块梳理：Broker消费处理流程概览、查找消息流程、以及消息查询结果处理流程。</p>
<h2 id="Broker消费处理流程概览"><a href="#Broker消费处理流程概览" class="headerlink" title="Broker消费处理流程概览"></a>Broker消费处理流程概览</h2><p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219143006.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：在拉取消息时会进行Broker和主题读权限的判断，实战中若有必要可以封锁Broker的拉取权限从而禁止从该broker进行消费；或者封锁某主题的读权限禁止消费组从该主题消费消息。</span><br></pre></td></tr></table></figure>



<h2 id="查找消息流程"><a href="#查找消息流程" class="headerlink" title="查找消息流程"></a>查找消息流程</h2><p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219143030.png"></p>
<p><u>小结：如果需要从磁盘拉取消息则一次默认最多拉取8条，一次消息的消息大小最大为64K。</u></p>
<p><u>如果从缓存中拉取默认最多32条，一次拉取的消息大小最大256K。使用tagcode会在查找消息前进行过滤，使用SQL92过滤再消息查找出来后进行过滤。</u></p>
<!--more-->



<h2 id="消息查询结果处理流程"><a href="#消息查询结果处理流程" class="headerlink" title="消息查询结果处理流程"></a>消息查询结果处理流程</h2><p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219143112.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：建议开启slaveReadEnable&#x3D;true，当拉取的消息超过Broker内存40%时会从Slave节点消费，Master不必从磁盘重新读取数据；transferMsgByHeap默认为true即消息先拉取到堆空间再返回到客户端；如果设置为false则使用Netty#FileRegion，可用零字节拷贝不必再拷贝到堆内存提高性能。</span><br></pre></td></tr></table></figure>



<h1 id="消费进度流转"><a href="#消费进度流转" class="headerlink" title="消费进度流转"></a>消费进度流转</h1><h2 id="客户端上报消费进度"><a href="#客户端上报消费进度" class="headerlink" title="客户端上报消费进度"></a>客户端上报消费进度</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;@1 顺序消费&#x2F;并发消费流程相同</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;ConsumeMessageOrderlyService#processConsumeResult</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;ConsumeMessageConcurrentlyService#processConsumeResult</span><br><span class="line"></span><br><span class="line">if (offset &gt;&#x3D; 0 &amp;&amp; !consumeRequest.getProcessQueue().isDropped()) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;更新消费进度偏移量</span><br><span class="line"></span><br><span class="line">this.defaultMQPushConsumerImpl.getOffsetStore().updateOffset(consumeRequest.getMessageQueue(), offset, true);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@2 RemoteBrokerOffsetStore#updateOffset</span><br><span class="line"></span><br><span class="line">AtomicLong offsetOld &#x3D; this.offsetTable.get(mq);</span><br><span class="line"></span><br><span class="line">MixAll.compareAndIncreaseOnly(offsetOld, offset);</span><br><span class="line"></span><br><span class="line">@3 offsetTable存储结构：key为MessageQueue value为消费的偏移量进度</span><br><span class="line"></span><br><span class="line">ConcurrentMap&lt;MessageQueue, AtomicLong&gt; offsetTable &#x3D;</span><br><span class="line"></span><br><span class="line">new ConcurrentHashMap&lt;MessageQueue, AtomicLong&gt;()</span><br><span class="line"></span><br><span class="line">@4 定时同步消费进度</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;持久化消息消费进度，默认5秒保存一次</span><br><span class="line"></span><br><span class="line">this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line"></span><br><span class="line">public void run() &#123;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">MQClientInstance.this.persistAllConsumerOffset();</span><br><span class="line"></span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">log.error(&quot;ScheduledTask persistAllConsumerOffset exception&quot;, e);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;, 1000 * 10, this.clientConfig.getPersistConsumerOffsetInterval(), TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">@5 RemoteBrokerOffsetStore#persistAll</span><br><span class="line"></span><br><span class="line">for (Map.Entry&lt;MessageQueue, AtomicLong&gt; entry : this.offsetTable.entrySet())</span><br><span class="line"></span><br><span class="line">this.updateConsumeOffsetToBroker(mq, offset.get());</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：PUSH消费中消费进度存储在offsetTable中，定时任务每5秒钟上报Broker一次。</span><br></pre></td></tr></table></figure>



<h2 id="Broker端处理消费进度"><a href="#Broker端处理消费进度" class="headerlink" title="Broker端处理消费进度"></a>Broker端处理消费进度</h2><p><strong>处理客户端定时上报消费进度</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;@1 ConsumerManageProcessor#processRequest#updateConsumerOffset</span><br><span class="line"></span><br><span class="line">this.brokerController.getConsumerOffsetManager().commitOffset</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@2 ConsumerOffsetManager#commitOffset</span><br><span class="line"></span><br><span class="line">String key &#x3D; topic + TOPIC_GROUP_SEPARATOR + group;</span><br><span class="line"></span><br><span class="line">this.commitOffset(clientHost, key, queueId, offset);</span><br><span class="line"></span><br><span class="line">Long storeOffset &#x3D; map.put(queueId, offset);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@3 消费进度缓存结构</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;key&#x3D;topic@group</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;value&#x3D;ConcurrentMap&lt;Integer&#x2F;* queueId*&#x2F;, Long&#x2F;*offset*&#x2F;&gt;&gt;</span><br><span class="line"></span><br><span class="line">offsetTable &#x3D; new ConcurrentHashMap&lt;String, ConcurrentMap&lt;Integer, Long&gt;&gt;(512);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@4 5秒钟一次存储消费进度</span><br><span class="line"></span><br><span class="line">this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line"></span><br><span class="line">public void run() &#123;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">BrokerController.this.consumerOffsetManager.persist();</span><br><span class="line"></span><br><span class="line">&#125; catch (Throwable e) &#123;</span><br><span class="line"></span><br><span class="line">log.error(&quot;schedule persist consumerOffset error.&quot;, e);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;, 1000 * 10, this.brokerConfig.getFlushConsumerOffsetInterval(), TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@5 consumerOffset.json文件格式</span><br><span class="line"></span><br><span class="line">&quot;zeus-package-mismatch-topic@autosort-packagelog&quot;:&#123;0:9055300,1:9055157,2:9055304,3:9055232&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：Broker接到客户端消费进度上报后更新缓存offsetTable，每隔5秒中定时任务将offsetTable消费进度存储在磁盘文件consumerOffset.json中。</span><br></pre></td></tr></table></figure>

<p><strong>消息拉取后实时更新消费进度</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;@1 PullMessageProcessor#processRequest</span><br><span class="line"></span><br><span class="line">if (storeOffsetEnable) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;更新消费进度</span><br><span class="line"></span><br><span class="line">this.brokerController.getConsumerOffsetManager().commitOffset(RemotingHelper.parseChannelRemoteAddr(channel),</span><br><span class="line"></span><br><span class="line">requestHeader.getConsumerGroup(), requestHeader.getTopic(), requestHeader.getQueueId(), requestHeader.getCommitOffset());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：PUSH消费客户端拉取消息后会实时更新消费的进度。</span><br></pre></td></tr></table></figure>



<h2 id="消费进度流转示意图"><a href="#消费进度流转示意图" class="headerlink" title="消费进度流转示意图"></a>消费进度流转示意图</h2><p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219143256.png"></p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ34# RocketMQ--ConsumeQueue文件与Index文件</title>
    <url>/posts/c4a1b302/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="问题思考"><a href="#问题思考" class="headerlink" title="问题思考"></a>问题思考</h1><p>消息消费时先从ConsumeQueue中获取物理偏移量，再根据物理偏移量从commitLog中获取具体消息；消息检索时会用到索引文件，其中值得思考的问题：</p>
<p>1.ConsumeQueue构建流程是怎样的？</p>
<p>2.ConsumeQueue数据结构是怎样的？</p>
<p>3.Index索引文件构建流程怎样的？</p>
<p>4.Index数据结构时怎么样的？</p>
<a id="more"></a>

<h1 id="ConsumeQueue-Index构建概览"><a href="#ConsumeQueue-Index构建概览" class="headerlink" title="ConsumeQueue/Index构建概览"></a>ConsumeQueue/Index构建概览</h1><h2 id="调用链条"><a href="#调用链条" class="headerlink" title="调用链条"></a>调用链条</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;Broker启动初始化</span><br><span class="line"></span><br><span class="line">@1 BrokerStartup#main</span><br><span class="line"></span><br><span class="line">start(createBrokerController(args))</span><br><span class="line"></span><br><span class="line">boolean initResult &#x3D; controller.initialize()</span><br><span class="line"></span><br><span class="line">@2 BrokerController#initialize</span><br><span class="line"></span><br><span class="line">this.messageStore &#x3D; new DefaultMessageStore</span><br><span class="line"></span><br><span class="line">@3 DefaultMessageStore#DefaultMessageStore()</span><br><span class="line"></span><br><span class="line">this.reputMessageService &#x3D; new ReputMessageService();</span><br><span class="line"></span><br><span class="line">this.dispatcherList &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">this.dispatcherList.addLast(new CommitLogDispatcherBuildConsumeQueue());</span><br><span class="line"></span><br><span class="line">this.dispatcherList.addLast(new CommitLogDispatcherBuildIndex());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;存储服务启动</span><br><span class="line"></span><br><span class="line">@4 DefaultMessageStore#start()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;允许重复转发reputFromOffset设置为CommitLog的提交指针</span><br><span class="line"></span><br><span class="line">if (this.getMessageStoreConfig().isDuplicationEnable()) &#123;this.reputMessageService.setReputFromOffset(this.commitLog.getConfirmOffset());</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;不允许重复转发reputFromOffset设置为CommitLog内存中最大偏移量 this.reputMessageService.setReputFromOffset(this.commitLog.getMaxOffset();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">this.reputMessageService.start();</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：@1中分别为dispatcherList添加了CommitLogDispatcherBuildConsumeQueue和CommitLogDispatcherBuildIndex；@4中duplicationEnable默认为false即不允许重复，从CommitLog中的最大偏移量开始转发，reputMessageService线程类在Broker启动时启动，主要负责构建consumeQueue与index文件。</span><br></pre></td></tr></table></figure>

<h2 id="ReputMessageService线程类职责"><a href="#ReputMessageService线程类职责" class="headerlink" title="ReputMessageService线程类职责"></a>ReputMessageService线程类职责</h2><p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219143536.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：ReputMessageServicee根据构建进度reputFromOffset查找可构建的消息数据，然后逐条解析组成构建请求，并构建consumeQueue和index文件构建；如果当前Broker为Master并且长轮询模式上通过消息到达监听器通知客户端。</span><br></pre></td></tr></table></figure>



<h1 id="ConsumeQueue构建流程及数据结构"><a href="#ConsumeQueue构建流程及数据结构" class="headerlink" title="ConsumeQueue构建流程及数据结构"></a>ConsumeQueue构建流程及数据结构</h1><p>在Broker启动时初始化了dispatcherList, 添加了分别负责ConsumeQueue文件和Index文件构建类；这部分关注ConsumeQueue构建。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.dispatcherList &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;构建ConsumeQueue</span><br><span class="line"></span><br><span class="line">this.dispatcherList.addLast(new CommitLogDispatcherBuildConsumeQueue());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;构建Index</span><br><span class="line"></span><br><span class="line">this.dispatcherList.addLast(new CommitLogDispatcherBuildIndex());</span><br><span class="line"></span><br><span class="line">public void doDispatch(DispatchRequest req) &#123;</span><br><span class="line"></span><br><span class="line">for (CommitLogDispatcher dispatcher : this.dispatcherList) &#123;</span><br><span class="line"></span><br><span class="line">dispatcher.dispatch(req);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<!--more-->



<h2 id="ConsumeQueue文件构建流程"><a href="#ConsumeQueue文件构建流程" class="headerlink" title="ConsumeQueue文件构建流程"></a>ConsumeQueue文件构建流程</h2><p><strong>调用链</strong></p>
<p>```</p>
<p>@1 DefaultMessageStore#putMessagePositionInfo</p>
<p>@2 ConsumeQueue#putMessagePositionInfoWrapper</p>
<p>```</p>
<p><strong>流程图</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219143645.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：ConsumeQueue构建主要流程为构建ConsumeQueue数据结构并将其写入fileChannel落盘；第一次创建ConsumeQueue文件时进行补位，用0填充，可促使系统实际分配内存起到预热作用。</span><br></pre></td></tr></table></figure>

<p><strong>补位代码</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void fillPreBlank(final MappedFile mappedFile, final long untilWhere) &#123;</span><br><span class="line"></span><br><span class="line">ByteBuffer byteBuffer &#x3D; ByteBuffer.allocate(CQ_STORE_UNIT_SIZE);</span><br><span class="line"></span><br><span class="line">byteBuffer.putLong(0L);</span><br><span class="line"></span><br><span class="line">byteBuffer.putInt(Integer.MAX_VALUE);</span><br><span class="line"></span><br><span class="line">byteBuffer.putLong(0L);</span><br><span class="line"></span><br><span class="line">int until &#x3D; (int) (untilWhere % this.mappedFileQueue.getMappedFileSize());</span><br><span class="line"></span><br><span class="line">for (int i &#x3D; 0; i &lt; until; i +&#x3D; CQ_STORE_UNIT_SIZE) &#123;</span><br><span class="line"></span><br><span class="line">mappedFile.appendMessage(byteBuffer.array());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="ConsumeQueue数据结构"><a href="#ConsumeQueue数据结构" class="headerlink" title="ConsumeQueue数据结构"></a>ConsumeQueue数据结构</h2><p><strong>数据结构代码</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.byteBufferIndex.flip();</span><br><span class="line"></span><br><span class="line">this.byteBufferIndex.limit(CQ_STORE_UNIT_SIZE); &#x2F;&#x2F;限定每个条目大小</span><br><span class="line"></span><br><span class="line">this.byteBufferIndex.putLong(offset); &#x2F;&#x2F;写入消息偏移量</span><br><span class="line"></span><br><span class="line">this.byteBufferIndex.putInt(size); &#x2F;&#x2F;写入消息长度</span><br><span class="line"></span><br><span class="line">this.byteBufferIndex.putLong(tagsCode); &#x2F;&#x2F;写入tag hashcode</span><br></pre></td></tr></table></figure>



<p><strong>数据结构图示</strong></p>
<p>ConsumeQueue文件中每个条目占20位。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219143751.png"></p>
<h1 id="Index构建流程及数据结构"><a href="#Index构建流程及数据结构" class="headerlink" title="Index构建流程及数据结构"></a>Index构建流程及数据结构</h1><p>在Broker启动时初始化了dispatcherList, 添加了分别负责ConsumeQueue文件和Index文件构建类；这部分关注Index构建。</p>
<p>IndexService初始化时初始化两个参数Hash槽数量hashSlotNum=5000000，索引的最大数量maxIndexNum=5000000 * 4=20000000。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.dispatcherList &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;构建ConsumeQueue</span><br><span class="line"></span><br><span class="line">this.dispatcherList.addLast(new CommitLogDispatcherBuildConsumeQueue());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;构建Index</span><br><span class="line"></span><br><span class="line">this.dispatcherList.addLast(new CommitLogDispatcherBuildIndex());</span><br><span class="line"></span><br><span class="line">public void doDispatch(DispatchRequest req) &#123;</span><br><span class="line"></span><br><span class="line">for (CommitLogDispatcher dispatcher : this.dispatcherList) &#123;</span><br><span class="line"></span><br><span class="line">dispatcher.dispatch(req);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;IndexService初始化</span><br><span class="line"></span><br><span class="line">public IndexService(final DefaultMessageStore store) &#123;</span><br><span class="line"></span><br><span class="line">this.defaultMessageStore &#x3D; store;</span><br><span class="line"></span><br><span class="line">this.hashSlotNum &#x3D; store.getMessageStoreConfig().getMaxHashSlotNum();</span><br><span class="line"></span><br><span class="line">this.indexNum &#x3D; store.getMessageStoreConfig().getMaxIndexNum();</span><br><span class="line"></span><br><span class="line">this.storePath &#x3D;</span><br><span class="line"></span><br><span class="line">StorePathConfigHelper.getStorePathIndex(store.getMessageStoreConfig().getStorePathRootDir());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Index文件构建流程"><a href="#Index文件构建流程" class="headerlink" title="Index文件构建流程"></a>Index文件构建流程</h2><p><strong>调用链条</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@1 DefaultMessageStore#CommitLogDispatcherBuildIndex#dispatch</span><br><span class="line"></span><br><span class="line">@2 IdexService#buildIndex</span><br></pre></td></tr></table></figure>



<p><strong>流程图</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219143915.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：Index文件写入流程概要：先获取索引文件并将未写入文件的内存数据通过守护线程写入磁盘；计算要写入索引所在hash槽的位置取出原来的值；构建索引条目填充数据；最后更新索引文件头部信息。</span><br></pre></td></tr></table></figure>



<h2 id="Index数据结构"><a href="#Index数据结构" class="headerlink" title="Index数据结构"></a>Index数据结构</h2><p><strong>写入索引数据到mappedByteBuffer代码</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;计算索引数据需要放在哪个位置</span><br><span class="line"></span><br><span class="line">int absIndexPos &#x3D;</span><br><span class="line"></span><br><span class="line">IndexHeader.INDEX_HEADER_SIZE + this.hashSlotNum * hashSlotSize</span><br><span class="line"></span><br><span class="line">\+ this.indexHeader.getIndexCount() * indexSize;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将hashcode存储在MappedByteBuffer中</span><br><span class="line"></span><br><span class="line">this.mappedByteBuffer.putInt(absIndexPos, keyHash);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将物理偏移量存储在MappedByteBuffer中</span><br><span class="line"></span><br><span class="line">this.mappedByteBuffer.putLong(absIndexPos + 4, phyOffset);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;落地时间-当前索引的起始时间差值写入MappedByteBuffer</span><br><span class="line"></span><br><span class="line">this.mappedByteBuffer.putInt(absIndexPos + 4 + 8, (int) timeDiff);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;记录前一条hash桶对应的值（Index条目下标）；注意此处用于解决Hash冲突</span><br><span class="line"></span><br><span class="line">this.mappedByteBuffer.putInt(absIndexPos + 4 + 8 + 4, slotValue);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将当前index中包含的条目数量存入到Hash槽中，将覆盖原先的值</span><br><span class="line"></span><br><span class="line">this.mappedByteBuffer.putInt(absSlotPos,this.indexHeader.getIndexCount());</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：上述代码描述索引条目的构建流程及数据结构，通过记录上一条冲突的槽值形成链表结构。</span><br></pre></td></tr></table></figure>



<h2 id="Index数据结构图示"><a href="#Index数据结构图示" class="headerlink" title="Index数据结构图示"></a>Index数据结构图示</h2><p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219144023.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：Index索引有三部分组成IndexHeader、Hash槽位、索引条目；每块内容和所占大小如图所示；如果有Hash冲突，在每个索引条目最后记录了原来Hash槽里的值，从而形成链表结构。</span><br></pre></td></tr></table></figure></div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ35# RocketMQ NameServe</title>
    <url>/posts/a0b01b06/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="NameServer启动"><a href="#NameServer启动" class="headerlink" title="NameServer启动"></a>NameServer启动</h1><p>* 从生产环境实践来看，NameServer启动使用默认配置即可，运行良好。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">启动命令：nohup sh bin&#x2F;mqnamesrv &amp;</span><br></pre></td></tr></table></figure>

<p>* NamesrvStartup.java 启动入口类，NameServer 启动默认端口9876</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nettyServerConfig.setListenPort(9876)</span><br></pre></td></tr></table></figure>

<p>* 每10秒钟扫描一次，移除失效的broker，同时移除缓存元数据</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;初始化NameServer</span><br><span class="line"></span><br><span class="line">boolean initResult &#x3D; controller.initialize();</span><br><span class="line"></span><br><span class="line">public boolean initialize() &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;加载KV配置</span><br><span class="line"></span><br><span class="line">this.kvConfigManager.load();</span><br><span class="line"></span><br><span class="line">this.remotingServer &#x3D; new NettyRemotingServer(this.nettyServerConfig, this.brokerHousekeepingService);</span><br><span class="line"></span><br><span class="line">this.remotingExecutor &#x3D;</span><br><span class="line"></span><br><span class="line">Executors.newFixedThreadPool(nettyServerConfig.getServerWorkerThreads(), new ThreadFactoryImpl(&quot;RemotingExecutorThread_&quot;));</span><br><span class="line"></span><br><span class="line">this.registerProcessor();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;每10秒钟扫描一次，移除失效的broker</span><br><span class="line"></span><br><span class="line">this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line"></span><br><span class="line">public void run() &#123;</span><br><span class="line"></span><br><span class="line">NamesrvController.this.routeInfoManager.scanNotActiveBroker();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;, 5, 10, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;每隔10秒钟打印一次KV配置信息</span><br><span class="line"></span><br><span class="line">this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line"></span><br><span class="line">public void run() &#123;</span><br><span class="line"></span><br><span class="line">NamesrvController.this.kvConfigManager.printAllPeriodically();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;, 1, 10, TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">return true;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>* 失效时间为2分钟，即：Broker在2分钟内未上报心跳会被移除</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;失效时间为2分钟，即：Broker在2分钟内未上报心跳会被移除</span><br><span class="line"></span><br><span class="line">public void scanNotActiveBroker() &#123;</span><br><span class="line"></span><br><span class="line">Iterator&lt;Entry&lt;String, BrokerLiveInfo&gt;&gt; it &#x3D; this.brokerLiveTable.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">while (it.hasNext()) &#123;</span><br><span class="line"></span><br><span class="line">Entry&lt;String, BrokerLiveInfo&gt; next &#x3D; it.next();</span><br><span class="line"></span><br><span class="line">long last &#x3D; next.getValue().getLastUpdateTimestamp();</span><br><span class="line"></span><br><span class="line">if ((last + BROKER_CHANNEL_EXPIRED_TIME) &lt; System.currentTimeMillis()) &#123;</span><br><span class="line"></span><br><span class="line">RemotingUtil.closeChannel(next.getValue().getChannel());</span><br><span class="line"></span><br><span class="line">it.remove();</span><br><span class="line"></span><br><span class="line">log.warn(&quot;The broker channel expired, &#123;&#125; &#123;&#125;ms&quot;, next.getKey(), BROKER_CHANNEL_EXPIRED_TIME);</span><br><span class="line"></span><br><span class="line">this.onChannelDestroy(next.getKey(), next.getValue().getChannel());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private final static long BROKER_CHANNEL_EXPIRED_TIME &#x3D; 1000 * 60 * 2;</span><br></pre></td></tr></table></figure>



<h1 id="DefaultRequestProcessor"><a href="#DefaultRequestProcessor" class="headerlink" title="DefaultRequestProcessor"></a>DefaultRequestProcessor</h1><p>* 用于响应客户端、Broker的请求。主要向NameServer发送心跳包、获取Cluster、Broker、Topic元数据信息。</p>
<p>* 调用链：在NameServer启动时注册，NamesrvController.initialize()-&gt;registerProcessor()。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public RemotingCommand processRequest(ChannelHandlerContext ctx, RemotingCommand request) throws RemotingCommandException &#123;</span><br><span class="line"></span><br><span class="line">if (log.isDebugEnabled()) &#123;</span><br><span class="line"></span><br><span class="line">log.debug(&quot;receive request, &#123;&#125; &#123;&#125; &#123;&#125;&quot;,</span><br><span class="line"></span><br><span class="line">request.getCode(),</span><br><span class="line"></span><br><span class="line">RemotingHelper.parseChannelRemoteAddr(ctx.channel()),</span><br><span class="line"></span><br><span class="line">request);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">switch (request.getCode()) &#123;</span><br><span class="line"></span><br><span class="line">case RequestCode.PUT_KV_CONFIG:&#x2F;&#x2F;增加NameServer配置信息；由DefaultMQAdminExt使用</span><br><span class="line"></span><br><span class="line">return this.putKVConfig(ctx, request);</span><br><span class="line"></span><br><span class="line">case RequestCode.GET_KV_CONFIG:&#x2F;&#x2F;根据NameSpace和key获取NameServer配置信息；由DefaultMQAdminExt使用</span><br><span class="line"></span><br><span class="line">return this.getKVConfig(ctx, request);</span><br><span class="line"></span><br><span class="line">case RequestCode.DELETE_KV_CONFIG: &#x2F;&#x2F;据NameSapce和Key删除NameServerr配置信息</span><br><span class="line"></span><br><span class="line">return this.deleteKVConfig(ctx, request);</span><br><span class="line"></span><br><span class="line">case RequestCode.REGISTER_BROKER: &#x2F;&#x2F;注册Broker信息；由BrokerOuterAPI.registerBroker使用，在BrokerController启动时调用</span><br><span class="line"></span><br><span class="line">Version brokerVersion &#x3D; MQVersion.value2Version(request.getVersion());</span><br><span class="line"></span><br><span class="line">if (brokerVersion.ordinal() &gt;&#x3D; MQVersion.Version.V3_0_11.ordinal()) &#123;</span><br><span class="line"></span><br><span class="line">return this.registerBrokerWithFilterServer(ctx, request);</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line"></span><br><span class="line">return this.registerBroker(ctx, request);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">case RequestCode.UNREGISTER_BROKER:&#x2F;&#x2F;移除注销broker信息；由BrokerOuterAPI.unregisterBroker使用，在BrokerController.shutdown时调用</span><br><span class="line"></span><br><span class="line">return this.unregisterBroker(ctx, request);</span><br><span class="line"></span><br><span class="line">case RequestCode.GET_ROUTEINTO_BY_TOPIC: &#x2F;&#x2F;获取Topic路由信息 TopicRouteData</span><br><span class="line"></span><br><span class="line">return this.getRouteInfoByTopic(ctx, request);</span><br><span class="line"></span><br><span class="line">case RequestCode.GET_BROKER_CLUSTER_INFO:&#x2F;&#x2F;获取Cluster及Broker信息</span><br><span class="line"></span><br><span class="line">return this.getBrokerClusterInfo(ctx, request);</span><br><span class="line"></span><br><span class="line">case RequestCode.WIPE_WRITE_PERM_OF_BROKER: &#x2F;&#x2F;去除该broker上所有topic的写权限</span><br><span class="line"></span><br><span class="line">return this.wipeWritePermOfBroker(ctx, request);</span><br><span class="line"></span><br><span class="line">case RequestCode.GET_ALL_TOPIC_LIST_FROM_NAMESERVER: &#x2F;&#x2F;获取所有的Topic列表</span><br><span class="line"></span><br><span class="line">return getAllTopicListFromNameserver(ctx, request);</span><br><span class="line"></span><br><span class="line">case RequestCode.DELETE_TOPIC_IN_NAMESRV: &#x2F;&#x2F;从nameServer中删除topic</span><br><span class="line"></span><br><span class="line">return deleteTopicInNamesrv(ctx, request);</span><br><span class="line"></span><br><span class="line">case RequestCode.GET_KVLIST_BY_NAMESPACE: &#x2F;&#x2F;获取配置信息 configTable</span><br><span class="line"></span><br><span class="line">return this.getKVListByNamespace(ctx, request);</span><br><span class="line"></span><br><span class="line">case RequestCode.GET_TOPICS_BY_CLUSTER: &#x2F;&#x2F;获取该集群下的所有topic list</span><br><span class="line"></span><br><span class="line">return this.getTopicsByCluster(ctx, request);</span><br><span class="line"></span><br><span class="line">case RequestCode.GET_SYSTEM_TOPIC_LIST_FROM_NS: &#x2F;&#x2F; 此处意思为：系统会将集群名称、broker名称作为默认topic创建。现在获取这类topic</span><br><span class="line"></span><br><span class="line">return this.getSystemTopicListFromNs(ctx, request);</span><br><span class="line"></span><br><span class="line">case RequestCode.GET_UNIT_TOPIC_LIST: &#x2F;&#x2F;暂无使用</span><br><span class="line"></span><br><span class="line">return this.getUnitTopicList(ctx, request);</span><br><span class="line"></span><br><span class="line">case RequestCode.GET_HAS_UNIT_SUB_TOPIC_LIST: &#x2F;&#x2F;暂无使用</span><br><span class="line"></span><br><span class="line">return this.getHasUnitSubTopicList(ctx, request);</span><br><span class="line"></span><br><span class="line">case RequestCode.GET_HAS_UNIT_SUB_UNUNIT_TOPIC_LIST:&#x2F;&#x2F;暂无使用</span><br><span class="line"></span><br><span class="line">return this.getHasUnitSubUnUnitTopicList(ctx, request);</span><br><span class="line"></span><br><span class="line">case RequestCode.UPDATE_NAMESRV_CONFIG: &#x2F;&#x2F;更新properties请求</span><br><span class="line"></span><br><span class="line">return this.updateConfig(ctx, request);</span><br><span class="line"></span><br><span class="line">case RequestCode.GET_NAMESRV_CONFIG: &#x2F;&#x2F;获取properties内容</span><br><span class="line"></span><br><span class="line">return this.getConfig(ctx, request);</span><br><span class="line"></span><br><span class="line">default:</span><br><span class="line"></span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return null;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<!--more-->



<h1 id="注册broker信息"><a href="#注册broker信息" class="headerlink" title="注册broker信息"></a><strong>注册broker信息</strong></h1><p>* Broker每隔30秒向所有的NameServer上报Topic注册信息</p>
<p>* Broker调用链：BrokerController.start()-&gt;this.registerBrokerAll()-&gt;this.brokerOuterAPI.registerBrokerAll()</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;每隔30秒向所有的NameServer上报Topic注册信息</span><br><span class="line"></span><br><span class="line">this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line"></span><br><span class="line">public void run() &#123;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">BrokerController.this.registerBrokerAll(true, false);</span><br><span class="line"></span><br><span class="line">&#125; catch (Throwable e) &#123;</span><br><span class="line"></span><br><span class="line">log.error(&quot;registerBrokerAll Exception&quot;, e);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;, 1000 * 10, 1000 * 30, TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure>



<p>* 服务端处理主要包括：注册集群信息clusterAddrTable、注册broker信息brokerAddrTable、注册topic信息topicQueueTable、</p>
<p>broker心跳包brokerLiveTable</p>
<p>* NameServer处理链：DefaultRequestProcessor-&gt;processRequest-&gt;RequestCode.REGISTER_BROKER-&gt;this.registerBroker-&gt;</p>
<p>RouteInfoManager.registerBroker()</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public RegisterBrokerResult registerBroker(</span><br><span class="line"></span><br><span class="line">final String clusterName,</span><br><span class="line"></span><br><span class="line">final String brokerAddr,</span><br><span class="line"></span><br><span class="line">final String brokerName,</span><br><span class="line"></span><br><span class="line">final long brokerId,</span><br><span class="line"></span><br><span class="line">final String haServerAddr,</span><br><span class="line"></span><br><span class="line">final TopicConfigSerializeWrapper topicConfigWrapper,</span><br><span class="line"></span><br><span class="line">final List&lt;String&gt; filterServerList,</span><br><span class="line"></span><br><span class="line">final Channel channel) &#123;</span><br><span class="line"></span><br><span class="line">RegisterBrokerResult result &#x3D; new RegisterBrokerResult();</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;加写锁，防止并发修改</span><br><span class="line"></span><br><span class="line">this.lock.writeLock().lockInterruptibly();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;注册集群信息</span><br><span class="line"></span><br><span class="line">Set&lt;String&gt; brokerNames &#x3D; this.clusterAddrTable.get(clusterName);</span><br><span class="line"></span><br><span class="line">if (null &#x3D;&#x3D; brokerNames) &#123;</span><br><span class="line"></span><br><span class="line">brokerNames &#x3D; new HashSet&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">this.clusterAddrTable.put(clusterName, brokerNames);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">brokerNames.add(brokerName);</span><br><span class="line"></span><br><span class="line">boolean registerFirst &#x3D; false;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;注册broker信息</span><br><span class="line"></span><br><span class="line">BrokerData brokerData &#x3D; this.brokerAddrTable.get(brokerName);</span><br><span class="line"></span><br><span class="line">if (null &#x3D;&#x3D; brokerData) &#123;</span><br><span class="line"></span><br><span class="line">registerFirst &#x3D; true;</span><br><span class="line"></span><br><span class="line">brokerData &#x3D; new BrokerData(clusterName, brokerName, new HashMap&lt;Long, String&gt;());</span><br><span class="line"></span><br><span class="line">this.brokerAddrTable.put(brokerName, brokerData);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String oldAddr &#x3D; brokerData.getBrokerAddrs().put(brokerId, brokerAddr);</span><br><span class="line"></span><br><span class="line">registerFirst &#x3D; registerFirst || (null &#x3D;&#x3D; oldAddr);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Topic配置变化了；Master Broker第一次注册或者Topic dataVersion不相同时更新路由信息</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;有Topic新增时dataVersion会递增</span><br><span class="line"></span><br><span class="line">if (null !&#x3D; topicConfigWrapper &#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">&amp;&amp; MixAll.MASTER_ID &#x3D;&#x3D; brokerId) &#123;</span><br><span class="line"></span><br><span class="line">if (this.isBrokerTopicConfigChanged(brokerAddr, topicConfigWrapper.getDataVersion())&#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">|| registerFirst) &#123;</span><br><span class="line"></span><br><span class="line">ConcurrentMap&lt;String, TopicConfig&gt; tcTable &#x3D;</span><br><span class="line"></span><br><span class="line">topicConfigWrapper.getTopicConfigTable();</span><br><span class="line"></span><br><span class="line">if (tcTable !&#x3D; null) &#123;</span><br><span class="line"></span><br><span class="line">for (Map.Entry&lt;String, TopicConfig&gt; entry : tcTable.entrySet()) &#123;</span><br><span class="line"></span><br><span class="line">this.createAndUpdateQueueData(brokerName, entry.getValue()); &#x2F;&#x2F;更新topicQueueTable</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;更新broker心跳信息</span><br><span class="line"></span><br><span class="line">BrokerLiveInfo prevBrokerLiveInfo &#x3D; this.brokerLiveTable.put(brokerAddr,</span><br><span class="line"></span><br><span class="line">new BrokerLiveInfo(</span><br><span class="line"></span><br><span class="line">System.currentTimeMillis(),</span><br><span class="line"></span><br><span class="line">topicConfigWrapper.getDataVersion(),</span><br><span class="line"></span><br><span class="line">channel,</span><br><span class="line"></span><br><span class="line">haServerAddr));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;新broker注册时会有日志输出</span><br><span class="line"></span><br><span class="line">if (null &#x3D;&#x3D; prevBrokerLiveInfo) &#123;</span><br><span class="line"></span><br><span class="line">log.info(&quot;new broker registerd, &#123;&#125; HAServer: &#123;&#125;&quot;, brokerAddr, haServerAddr);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;更新filterServer信息</span><br><span class="line"></span><br><span class="line">if (filterServerList !&#x3D; null) &#123;</span><br><span class="line"></span><br><span class="line">if (filterServerList.isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line">this.filterServerTable.remove(brokerAddr);</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line"></span><br><span class="line">this.filterServerTable.put(brokerAddr, filterServerList);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Slave设置MasterAddr和HaServerAddr</span><br><span class="line"></span><br><span class="line">if (MixAll.MASTER_ID !&#x3D; brokerId) &#123;</span><br><span class="line"></span><br><span class="line">String masterAddr &#x3D; brokerData.getBrokerAddrs().get(MixAll.MASTER_ID);</span><br><span class="line"></span><br><span class="line">if (masterAddr !&#x3D; null) &#123;</span><br><span class="line"></span><br><span class="line">BrokerLiveInfo brokerLiveInfo &#x3D; this.brokerLiveTable.get(masterAddr);</span><br><span class="line"></span><br><span class="line">if (brokerLiveInfo !&#x3D; null) &#123;</span><br><span class="line"></span><br><span class="line">result.setHaServerAddr(brokerLiveInfo.getHaServerAddr());</span><br><span class="line"></span><br><span class="line">result.setMasterAddr(masterAddr);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; finally &#123;</span><br><span class="line"></span><br><span class="line">this.lock.writeLock().unlock();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">log.error(&quot;registerBroker Exception&quot;, e);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h1 id="NameServer缓存元数据结构"><a href="#NameServer缓存元数据结构" class="headerlink" title="NameServer缓存元数据结构"></a>NameServer缓存元数据结构</h1><p>* 注册集群信息clusterAddrTable</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Broker集群信息; key为集群名称，value为所有的broker名称集合</span><br><span class="line"></span><br><span class="line">private final HashMap&lt;String&#x2F;* clusterName *&#x2F;, Set&lt;String&#x2F;* brokerName *&#x2F;&gt;&gt; clusterAddrTable;</span><br></pre></td></tr></table></figure>

<p>* 注册broker信息brokerAddrTable</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"></span><br><span class="line">\* Broker信息；key为brokerName，value为BrokerData</span><br><span class="line"></span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">private final HashMap&lt;String&#x2F;* brokerName *&#x2F;, BrokerData&gt; brokerAddrTable;</span><br><span class="line"></span><br><span class="line">public class BrokerData implements Comparable&lt;BrokerData&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"></span><br><span class="line">\* Cluster名称</span><br><span class="line"></span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">private String cluster;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"></span><br><span class="line">\* broker名称</span><br><span class="line"></span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">private String brokerName;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"></span><br><span class="line">\* 0-&gt;ip:port</span><br><span class="line"></span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">private HashMap&lt;Long&#x2F;* brokerId *&#x2F;, String&#x2F;* broker address *&#x2F;&gt; brokerAddrs;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>* 注册topic信息topicQueueTable</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;消息队列路由信息；key为topic，value为QueueData</span><br><span class="line"></span><br><span class="line">private final HashMap&lt;String&#x2F;* topic *&#x2F;, List&lt;QueueData&gt;&gt; topicQueueTable;</span><br><span class="line"></span><br><span class="line">public class QueueData implements Comparable&lt;QueueData&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Broker名称</span><br><span class="line"></span><br><span class="line">private String brokerName;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;读队列个数，默认4个</span><br><span class="line"></span><br><span class="line">private int readQueueNums;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;写队列个数，默认4个</span><br><span class="line"></span><br><span class="line">private int writeQueueNums;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 队列权限</span><br><span class="line"></span><br><span class="line">private int perm;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;配置的,同步复制还是异步复制标记,对应TopicConfig.topicSysFlag</span><br><span class="line"></span><br><span class="line">private int topicSynFlag;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>* Broker心跳包brokerLiveTable</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;Broker状态信息，NameServer每次收到心跳包会替换该信息，每隔30秒更新一次</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;brokerAddr: ip:port-&gt;&#123;&#125;</span><br><span class="line"></span><br><span class="line">private final HashMap&lt;String&#x2F;* brokerAddr *&#x2F;, BrokerLiveInfo&gt; brokerLiveTable;</span><br><span class="line"></span><br><span class="line">class BrokerLiveInfo &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 存储上次收到心跳包的时间,每隔30秒更新一次</span><br><span class="line"></span><br><span class="line">private long lastUpdateTimestamp;</span><br><span class="line"></span><br><span class="line">private DataVersion dataVersion;</span><br><span class="line"></span><br><span class="line">private Channel channel;</span><br><span class="line"></span><br><span class="line">private String haServerAddr;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ36# RocketMQ Topic创建</title>
    <url>/posts/ee41af7f/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="Topic创建的方式"><a href="#Topic创建的方式" class="headerlink" title="Topic创建的方式"></a>Topic创建的方式</h1><p>Topic的创建分为自动创建和通过命令行创建两种。通过broker配置参数autoCreateTopicEnable设置。 通常可以在非生产环境开启自动创建，生产环境待审批后再进行创建。</p>
<p>* 命令行创建</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh bin&#x2F;mqadmin updateTopic -c DefaultCluster -n localhost:9876 -t threezto-test -r 12 -w 12</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h1 id="客户端发起Topic创建请求"><a href="#客户端发起Topic创建请求" class="headerlink" title="客户端发起Topic创建请求"></a>客户端发起Topic创建请求</h1><p>* 客户端工作：向集群中各个broker主节点通知topic配置变更</p>
<p>* 参数设定：通过参数指定读队列数量、写队列数量、权限、当指定-c时，在该集群的所有broker都会创建</p>
<p>* 调用链</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UpdateTopicSubCommand.execute()-&gt;defaultMQAdminExtImpl.createAndUpdateTopicConfig-&gt;MQClientAPIImpl.createTopic</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;-c指定，集群中每个broker主节点都会创建</span><br><span class="line"></span><br><span class="line">Set&lt;String&gt; masterSet &#x3D;</span><br><span class="line"></span><br><span class="line">CommandUtil.fetchMasterAddrByClusterName(defaultMQAdminExt, clusterName);</span><br><span class="line"></span><br><span class="line">for (String addr : masterSet) &#123;</span><br><span class="line"></span><br><span class="line">defaultMQAdminExt.createAndUpdateTopicConfig(addr, topicConfig);</span><br><span class="line"></span><br><span class="line">System.out.printf(&quot;create topic to %s success.%n&quot;, addr);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<!--more-->



<h1 id="Broker处理Topic创建"><a href="#Broker处理Topic创建" class="headerlink" title="Broker处理Topic创建"></a>Broker处理Topic创建</h1><p>* Broker处理请求</p>
<p>1.更改本地topic配置缓存topicConfigTable</p>
<p>2.将缓存topicConfigTable配置信息写入磁盘</p>
<p>3.向NameServer上报变更信息</p>
<p>4.主从同步变更信息</p>
<p>* 调用链</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AdminBrokerProcessor.processRequest()-&gt;RequestCode.UPDATE_AND_CREATE_TOPIC-&gt;updateAndCreateTopic</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private RemotingCommand updateAndCreateTopic(ChannelHandlerContext ctx, RemotingCommand request) throws RemotingCommandException &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;省略代码</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;更改broker缓存topicConfigTable信息并落盘存储</span><br><span class="line"></span><br><span class="line">this.brokerController.getTopicConfigManager().updateTopicConfig(topicConfig);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;向nameSrv上报变更信息，主从同步</span><br><span class="line"></span><br><span class="line">this.brokerController.registerBrokerAll(false, true);</span><br><span class="line"></span><br><span class="line">return null;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>* 更改本地topic配置缓存topicConfigTable以及持久化磁盘</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void updateTopicConfig(final TopicConfig topicConfig) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;更新Topic缓存配置</span><br><span class="line"></span><br><span class="line">TopicConfig old &#x3D; this.topicConfigTable.put(topicConfig.getTopicName(), topicConfig);</span><br><span class="line"></span><br><span class="line">if (old !&#x3D; null) &#123;</span><br><span class="line"></span><br><span class="line">LOG.info(&quot;update topic config, old:[&#123;&#125;] new:[&#123;&#125;]&quot;, old, topicConfig);</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line"></span><br><span class="line">LOG.info(&quot;create new topic [&#123;&#125;]&quot;, topicConfig);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;递增版本</span><br><span class="line"></span><br><span class="line">this.dataVersion.nextVersion();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;存储本地磁盘</span><br><span class="line"></span><br><span class="line">this.persist();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"></span><br><span class="line">\* 持久化磁盘</span><br><span class="line"></span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">public synchronized void persist() &#123;</span><br><span class="line"></span><br><span class="line">String jsonString &#x3D; this.encode(true);</span><br><span class="line"></span><br><span class="line">if (jsonString !&#x3D; null) &#123;</span><br><span class="line"></span><br><span class="line">String fileName &#x3D; this.configFilePath();</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">MixAll.string2File(jsonString, fileName);</span><br><span class="line"></span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line"></span><br><span class="line">PLOG.error(&quot;persist file Exception, &quot; + fileName, e);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>* Topic配置存储的磁盘格式config/topics.json</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;topic_online_test&quot;:&#123;</span><br><span class="line"></span><br><span class="line">&quot;order&quot;:false,</span><br><span class="line"></span><br><span class="line">&quot;perm&quot;:6,</span><br><span class="line"></span><br><span class="line">&quot;readQueueNums&quot;:4,</span><br><span class="line"></span><br><span class="line">&quot;topicFilterType&quot;:&quot;SINGLE_TAG&quot;,</span><br><span class="line"></span><br><span class="line">&quot;topicName&quot;:&quot;topic_online_test&quot;,</span><br><span class="line"></span><br><span class="line">&quot;topicSysFlag&quot;:0,</span><br><span class="line"></span><br><span class="line">&quot;writeQueueNums&quot;:4</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>* 向NameServer上报变更信息，主从同步.</p>
<p>NameServer收到请求处理见：<a href="https://www.jianshu.com/p/db5ed97fd19d">RocketMQ NameServer源码梳理笔记</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public synchronized void registerBrokerAll(final boolean checkOrderConfig, boolean oneway) &#123;</span><br><span class="line"></span><br><span class="line">TopicConfigSerializeWrapper topicConfigWrapper &#x3D; this.getTopicConfigManager().buildTopicConfigSerializeWrapper();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Broker只有读或者写权限时, Topic设置为与broker相同的权限</span><br><span class="line"></span><br><span class="line">if (!PermName.isWriteable(this.getBrokerConfig().getBrokerPermission())</span><br><span class="line"></span><br><span class="line">|| !PermName.isReadable(this.getBrokerConfig().getBrokerPermission())) &#123;</span><br><span class="line"></span><br><span class="line">ConcurrentHashMap&lt;String, TopicConfig&gt; topicConfigTable &#x3D; new ConcurrentHashMap&lt;String, TopicConfig&gt;();</span><br><span class="line"></span><br><span class="line">for (TopicConfig topicConfig : topicConfigWrapper.getTopicConfigTable().values()) &#123;</span><br><span class="line"></span><br><span class="line">TopicConfig tmp &#x3D;</span><br><span class="line"></span><br><span class="line">new TopicConfig(topicConfig.getTopicName(), topicConfig.getReadQueueNums(), topicConfig.getWriteQueueNums(),</span><br><span class="line"></span><br><span class="line">this.brokerConfig.getBrokerPermission());</span><br><span class="line"></span><br><span class="line">topicConfigTable.put(topicConfig.getTopicName(), tmp);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">topicConfigWrapper.setTopicConfigTable(topicConfigTable);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;向所有NameServer节点注册Topic信息</span><br><span class="line"></span><br><span class="line">RegisterBrokerResult registerBrokerResult &#x3D; this.brokerOuterAPI.registerBrokerAll(</span><br><span class="line"></span><br><span class="line">this.brokerConfig.getBrokerClusterName(),</span><br><span class="line"></span><br><span class="line">this.getBrokerAddr(),</span><br><span class="line"></span><br><span class="line">this.brokerConfig.getBrokerName(),</span><br><span class="line"></span><br><span class="line">this.brokerConfig.getBrokerId(),</span><br><span class="line"></span><br><span class="line">this.getHAServerAddr(),</span><br><span class="line"></span><br><span class="line">topicConfigWrapper,</span><br><span class="line"></span><br><span class="line">this.filterServerManager.buildNewFilterServerList(),</span><br><span class="line"></span><br><span class="line">oneway,</span><br><span class="line"></span><br><span class="line">this.brokerConfig.getRegisterBrokerTimeoutMills());</span><br><span class="line"></span><br><span class="line">if (registerBrokerResult !&#x3D; null) &#123;</span><br><span class="line"></span><br><span class="line">if (this.updateMasterHAServerAddrPeriodically &amp;&amp; registerBrokerResult.getHaServerAddr() !&#x3D; null) &#123;</span><br><span class="line"></span><br><span class="line">this.messageStore.updateHaMasterAddress(registerBrokerResult.getHaServerAddr());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Slave同步Master信息 每分钟定时同步</span><br><span class="line"></span><br><span class="line">this.slaveSynchronize.setMasterAddr(registerBrokerResult.getMasterAddr());</span><br><span class="line"></span><br><span class="line">if (checkOrderConfig) &#123;</span><br><span class="line"></span><br><span class="line">this.getTopicConfigManager().updateOrderTopicConfig(registerBrokerResult.getKvTable());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ38# RocketMQ消息发送（二）</title>
    <url>/posts/bfe41dca/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="发送接口分类"><a href="#发送接口分类" class="headerlink" title="发送接口分类"></a>发送接口分类</h1><p>* 按照发送方式分类</p>
<ol>
<li><p>同步发送：等待返回结果</p>
</li>
<li><p>异步发送：异步回调发送结果</p>
</li>
<li><p>一次发送：无结果返回</p>
</li>
</ol>
<p>* 按一次发送消息数量分类</p>
<ol>
<li><p>单条消息发送</p>
</li>
<li><p>批量消息发送</p>
</li>
</ol>
<p>* 按照是否指定MessageQueue分类</p>
<ol>
<li><p>随机选择发送</p>
</li>
<li><p>指定特定MessageQueue</p>
</li>
<li><p>自定义MessageQueue选择器</p>
</li>
</ol>
<a id="more"></a>

<p><strong>详细接口</strong></p>
<p>|接口 |描述 |</p>
<p>| — | — |</p>
<p>| send(final Message msg) |同步单条消息发送 |</p>
<p>| send(final Message msg, final long timeout) |同步单条消息发送（超时设置） |</p>
<p>| send(final Message msg, final SendCallback sendCallback) | 异步单条消息发送 |</p>
<p>| send(final Message msg, final SendCallback sendCallback, final long timeout) |异步单条消息发送（超时） |</p>
<p>|sendOneway(final Message msg) | 一次单条消息发送 |</p>
<p>| send(final Message msg, final MessageQueue mq) | 同步单条发送指定Queue |</p>
<p>| send(final Message msg, final MessageQueue mq, final long timeout) | 同步单条发送指定 Queue（超时设置） |</p>
<p>| send(final Message msg, final MessageQueue mq, final SendCallback sendCallback) |异步单条发送指定 Queue |</p>
<p>| send(final Message msg, final MessageQueue mq, final SendCallback sendCallback, long timeout) |异步单条发送指定 Queue（超时设置） |</p>
<p>| sendOneway(final Message msg, final MessageQueue mq) |一次单条发送指定 Queue |</p>
<p>| send(final Message msg, final MessageQueueSelector selector, final Object arg) |同步单条发送自定义实现Queue选择器 |</p>
<p>| send(final Message msg, final MessageQueueSelector selector, final Object arg,final long timeout) |同步单条发送自定义实现Queue选择器（超时设置） |</p>
<p>| send(final Message msg, final MessageQueueSelector selector, final Object arg, final SendCallback sendCallback) |异步单条发送自定义实现Queue选择器 |</p>
<p>| send(final Message msg, final MessageQueueSelector selector, final Object arg,final SendCallback sendCallback, final long timeout) |异步单条发送自定义实现Queue选择器（超时设置） |</p>
<p>|sendOneway(final Message msg, final MessageQueueSelector selector, final Object arg) |一次单条发送自定义实现Queue选择器 |</p>
<p>|send(final Collection<Message> msgs) |批量同步发送 |</p>
<p>|send(final Collection<Message> msgs, final long timeout) |批量同步发送（超时设置） |</p>
<p>|send(final Collection<Message> msgs, final MessageQueue mq) |批量同步指定Queue发送 |</p>
<p>|send(final Collection<Message> msgs, final MessageQueue mq, final long timeout)|批量同步指定Queue发送（超时设置）|</p>
<h1 id="随机发送与自定义MessageQueue选择器"><a href="#随机发送与自定义MessageQueue选择器" class="headerlink" title="随机发送与自定义MessageQueue选择器"></a>随机发送与自定义MessageQueue选择器</h1><p>* 随机发送：消息发往topic的哪个Queue是不确定的</p>
<p>* 自定义MessageQueue发送：按照指定的算法路由到特定的MessageQueue，最常见需求，相同的key路由到相同的队列，实现发送分区有序</p>
<p><strong>随机发送</strong></p>
<p>* 通过自增数取模消息队列数选择队列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> MessageQueue <span class="title">selectOneMessageQueue</span><span class="params">(<span class="keyword">final</span> TopicPublishInfo tpInfo, <span class="keyword">final</span> String lastBrokerName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开启高可用(开启故障延迟机制)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.sendLatencyFaultEnable) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自增序号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> index = tpInfo.getSendWhichQueue().getAndIncrement();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tpInfo.getMessageQueueList().size(); i++) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//取模消息队列数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pos = Math.abs(index++) % tpInfo.getMessageQueueList().size();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pos &lt; <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">pos = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">MessageQueue mq = tpInfo.getMessageQueueList().get(pos);</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断队列是否为可用的</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (latencyFaultTolerance.isAvailable(mq.getBrokerName())) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//正常情况下lastBrokerName==null;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在消息重试（上次发送失败重新发送时）上次选择broker可用，优先选择</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> == lastBrokerName || mq.getBrokerName().equals(lastBrokerName))</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> mq;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> String notBestBroker = latencyFaultTolerance.pickOneAtLeast();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> writeQueueNums = tpInfo.getQueueIdByBroker(notBestBroker);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (writeQueueNums &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> MessageQueue mq = tpInfo.selectOneMessageQueue();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (notBestBroker != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">mq.setBrokerName(notBestBroker);</span><br><span class="line"></span><br><span class="line">mq.setQueueId(tpInfo.getSendWhichQueue().getAndIncrement() % writeQueueNums);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> mq;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">latencyFaultTolerance.remove(notBestBroker);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">log.error(<span class="string">&quot;Error occurred when selecting message queue&quot;</span>, e);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> tpInfo.selectOneMessageQueue();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不开启高可用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> tpInfo.selectOneMessageQueue(lastBrokerName);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> MessageQueue <span class="title">selectOneMessageQueue</span><span class="params">(<span class="keyword">final</span> String lastBrokerName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//轮询消息队列的过程</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (lastBrokerName == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> selectOneMessageQueue();</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> index = <span class="keyword">this</span>.sendWhichQueue.getAndIncrement();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.messageQueueList.size(); i++) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pos = Math.abs(index++) % <span class="keyword">this</span>.messageQueueList.size();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pos &lt; <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">pos = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">MessageQueue mq = <span class="keyword">this</span>.messageQueueList.get(pos);</span><br><span class="line"></span><br><span class="line"><span class="comment">//规避上次发送失败的broker</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!mq.getBrokerName().equals(lastBrokerName)) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> mq;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> selectOneMessageQueue();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>自定义Queue选择器</strong></p>
<p>* 分区有序：根据key进行路由选择，相同的key会路由到相同MessageQueue</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static MessageQueueSelector hashSelector &#x3D; new MessageQueueSelector() &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line"></span><br><span class="line">public MessageQueue select(List&lt;MessageQueue&gt; mqs, Message msg, Object arg) &#123;</span><br><span class="line"></span><br><span class="line">int id &#x3D; msg.getKeys().hashCode() % mqs.size();</span><br><span class="line"></span><br><span class="line">if (id &lt; 0) &#123;</span><br><span class="line"></span><br><span class="line">return mqs.get(-id);</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line"></span><br><span class="line">return mqs.get(id);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<!--more-->



<h1 id="发送Broker容错处理"><a href="#发送Broker容错处理" class="headerlink" title="发送Broker容错处理"></a>发送Broker容错处理</h1><p><strong>两种Broker规避时长</strong></p>
<p>* 正常发送规避时长为发送前后时间差值(endTimestamp-beginTimestampPrev)</p>
<p>* 异常发送规避时长为30秒.</p>
<p>为何是30秒呢? NameSrv每10秒中清理下线broker，在启动时每30秒清理broker本地缓存表</p>
<p>* 开启故障延迟需要设置producer.setSendLatencyFaultEnable(true)，默认为false不开启</p>
<p><strong>正常发送入参isolation为false</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">beginTimestampPrev &#x3D; System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">sendResult &#x3D; this.sendKernelImpl(msg, mq, communicationMode, sendCallback, topicPublishInfo, timeout);</span><br><span class="line"></span><br><span class="line">endTimestamp &#x3D; System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">this.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, false);</span><br></pre></td></tr></table></figure>



<p><strong>异常发送时入参isolation为true</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#125; catch (RemotingException e) &#123;</span><br><span class="line"></span><br><span class="line">endTimestamp &#x3D; System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">this.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, true);</span><br><span class="line"></span><br><span class="line">log.warn(String.format(&quot;sendKernelImpl exception, resend at once, InvokeID: %s, RT: %sms, Broker: %s&quot;, invokeID, endTimestamp - beginTimestampPrev, mq), e);</span><br><span class="line"></span><br><span class="line">log.warn(msg.toString());</span><br><span class="line"></span><br><span class="line">exception &#x3D; e;</span><br><span class="line"></span><br><span class="line">continue;</span><br><span class="line"></span><br><span class="line">&#125; catch (MQClientException e) &#123;</span><br><span class="line"></span><br><span class="line">endTimestamp &#x3D; System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">this.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, true);</span><br><span class="line"></span><br><span class="line">log.warn(String.format(&quot;sendKernelImpl exception, resend at once, InvokeID: %s, RT: %sms, Broker: %s&quot;, invokeID, endTimestamp - beginTimestampPrev, mq), e);</span><br><span class="line"></span><br><span class="line">log.warn(msg.toString());</span><br><span class="line"></span><br><span class="line">exception &#x3D; e;</span><br><span class="line"></span><br><span class="line">continue;</span><br><span class="line"></span><br><span class="line">&#125; catch (MQBrokerException e) &#123;</span><br></pre></td></tr></table></figure>



<p><strong>容错接口方法</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;代码位置：MQFaultStrategy-&gt;updateFaultItem</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"></span><br><span class="line">\* @param brokerName</span><br><span class="line"></span><br><span class="line">\* @param currentLatency 本次消息延迟时间（发送产生异常时的时间戳-开始发送消息时的时间戳）</span><br><span class="line"></span><br><span class="line">\* @param isolation 是否隔离，true 使用默认30s来计算Broker规避时长；如果false则使用本次消息发送延迟时间来计算Broker规避时长</span><br><span class="line"></span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">public void updateFaultItem(final String brokerName, final long currentLatency, boolean isolation) &#123;</span><br><span class="line"></span><br><span class="line">if (this.sendLatencyFaultEnable) &#123;</span><br><span class="line"></span><br><span class="line">long duration &#x3D; computeNotAvailableDuration(isolation ? 30000 : currentLatency);</span><br><span class="line"></span><br><span class="line">this.latencyFaultTolerance.updateFaultItem(brokerName, currentLatency, duration);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void updateFaultItem(final String name, final long currentLatency, final long notAvailableDuration) &#123;</span><br><span class="line"></span><br><span class="line">FaultItem old &#x3D; this.faultItemTable.get(name);</span><br><span class="line"></span><br><span class="line">if (null &#x3D;&#x3D; old) &#123;</span><br><span class="line"></span><br><span class="line">final FaultItem faultItem &#x3D; new FaultItem(name);</span><br><span class="line"></span><br><span class="line">faultItem.setCurrentLatency(currentLatency);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;startTimeStamp &#x3D; 当前系统时间+需要规避的时间</span><br><span class="line"></span><br><span class="line">faultItem.setStartTimestamp(System.currentTimeMillis() + notAvailableDuration);</span><br><span class="line"></span><br><span class="line">old &#x3D; this.faultItemTable.putIfAbsent(name, faultItem);</span><br><span class="line"></span><br><span class="line">if (old !&#x3D; null) &#123;</span><br><span class="line"></span><br><span class="line">old.setCurrentLatency(currentLatency);</span><br><span class="line"></span><br><span class="line">old.setStartTimestamp(System.currentTimeMillis() + notAvailableDuration);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line"></span><br><span class="line">old.setCurrentLatency(currentLatency);</span><br><span class="line"></span><br><span class="line">old.setStartTimestamp(System.currentTimeMillis() + notAvailableDuration);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>发送时的容错判断</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;代码位置：MQFaultStrategy-&gt;selectOneMessageQueue</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;判断队列是否为可用的</span><br><span class="line"></span><br><span class="line">if (latencyFaultTolerance.isAvailable(mq.getBrokerName())) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;正常情况下lastBrokerName&#x3D;&#x3D;null;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;在消息重试（上次发送失败重新发送时）上次选择broker可用，优先选择</span><br><span class="line"></span><br><span class="line">if (null &#x3D;&#x3D; lastBrokerName || mq.getBrokerName().equals(lastBrokerName))</span><br><span class="line"></span><br><span class="line">return mq;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean isAvailable(final String name) &#123;</span><br><span class="line"></span><br><span class="line">final FaultItem faultItem &#x3D; this.faultItemTable.get(name);</span><br><span class="line"></span><br><span class="line">if (faultItem !&#x3D; null) &#123;</span><br><span class="line"></span><br><span class="line">return faultItem.isAvailable();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return true;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean isAvailable() &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;判断broker是否可用，startTimestamp在设置时：&#x3D; 当前系统时间+需要规避的时间</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;所以此处判断当前时间与startTimestamp的大小即可</span><br><span class="line"></span><br><span class="line">return (System.currentTimeMillis() - startTimestamp) &gt;&#x3D; 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="发送失败时的重试次数"><a href="#发送失败时的重试次数" class="headerlink" title="发送失败时的重试次数"></a>发送失败时的重试次数</h1><p>* 同步发送和异步发送在发送失败时，会进行消息重试。一次发送没有消息重试。</p>
<p>* 重试次数由retryTimesWhenSendFailed和retryTimesWhenSendAsyncFailed参数决定，默认2. 总共重试3次。超过次数依然失败返回异常错误</p>
<p><strong>同步发送重试次数代码块</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;代码位置：DefaultMQProducerImpl-&gt;sendDefaultImpl()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;同步发送默认3(1+2)次 其他1次</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;异步发送通过retryTimesWhenSendAsyncFailed来控制，在发送结果返回后再处理</span><br><span class="line"></span><br><span class="line">int timesTotal &#x3D; communicationMode &#x3D;&#x3D; CommunicationMode.SYNC ? 1 + this.defaultMQProducer.getRetryTimesWhenSendFailed() : 1;</span><br><span class="line"></span><br><span class="line">int times &#x3D; 0;</span><br><span class="line"></span><br><span class="line">String[] brokersSent &#x3D; new String[timesTotal];</span><br><span class="line"></span><br><span class="line">for (; times &lt; timesTotal; times++) &#123;</span><br><span class="line"></span><br><span class="line">String lastBrokerName &#x3D; null &#x3D;&#x3D; mq ? null : mq.getBrokerName();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;选一个MessageQueue进行发送</span><br><span class="line"></span><br><span class="line">MessageQueue tmpmq &#x3D; this.selectOneMessageQueue(topicPublishInfo, lastBrokerName);</span><br><span class="line"></span><br><span class="line">if (tmpmq !&#x3D; null) &#123;</span><br><span class="line"></span><br><span class="line">mq &#x3D; tmpmq;</span><br><span class="line"></span><br><span class="line">brokersSent[times] &#x3D; mq.getBrokerName();</span><br><span class="line"></span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>异步发送重试次数代码块</strong></p>
<p>* 由if (needRetry &amp;&amp; tmp &lt;= timesTotal) 判断是否达到重试的阀值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;代码位置：MQClientAPIImpl.java</span><br><span class="line"></span><br><span class="line">private void sendMessageAsync(&#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">final String addr, &#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">final String brokerName, &#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">final Message msg, &#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">final long timeoutMillis, &#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">final RemotingCommand request, &#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">final SendCallback sendCallback, &#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">final TopicPublishInfo topicPublishInfo, &#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">final MQClientInstance instance, &#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">final int retryTimesWhenSendFailed, &#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">final AtomicInteger times, &#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">final SendMessageContext context, &#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">final DefaultMQProducerImpl producer &#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">) throws InterruptedException, RemotingException &#123;</span><br><span class="line"></span><br><span class="line">this.remotingClient.invokeAsync(addr, request, timeoutMillis, new InvokeCallback() &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line"></span><br><span class="line">public void operationComplete(ResponseFuture responseFuture) &#123;</span><br><span class="line"></span><br><span class="line">RemotingCommand response &#x3D; responseFuture.getResponseCommand();</span><br><span class="line"></span><br><span class="line">if (null &#x3D;&#x3D; sendCallback &amp;&amp; response !&#x3D; null) &#123;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">SendResult sendResult &#x3D; MQClientAPIImpl.this.processSendResponse(brokerName, msg, response);</span><br><span class="line"></span><br><span class="line">if (context !&#x3D; null &amp;&amp; sendResult !&#x3D; null) &#123;</span><br><span class="line"></span><br><span class="line">context.setSendResult(sendResult);</span><br><span class="line"></span><br><span class="line">context.getProducer().executeSendMessageHookAfter(context);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; catch (Throwable e) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">producer.updateFaultItem(brokerName, System.currentTimeMillis() - responseFuture.getBeginTimestamp(), false);</span><br><span class="line"></span><br><span class="line">return;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (response !&#x3D; null) &#123;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">SendResult sendResult &#x3D; MQClientAPIImpl.this.processSendResponse(brokerName, msg, response);</span><br><span class="line"></span><br><span class="line">assert sendResult !&#x3D; null;</span><br><span class="line"></span><br><span class="line">if (context !&#x3D; null) &#123;</span><br><span class="line"></span><br><span class="line">context.setSendResult(sendResult);</span><br><span class="line"></span><br><span class="line">context.getProducer().executeSendMessageHookAfter(context);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">sendCallback.onSuccess(sendResult);</span><br><span class="line"></span><br><span class="line">&#125; catch (Throwable e) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">producer.updateFaultItem(brokerName, System.currentTimeMillis() - responseFuture.getBeginTimestamp(), false);</span><br><span class="line"></span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">producer.updateFaultItem(brokerName, System.currentTimeMillis() - responseFuture.getBeginTimestamp(), true);</span><br><span class="line"></span><br><span class="line">onExceptionImpl(brokerName, msg, 0L, request, sendCallback, topicPublishInfo, instance,</span><br><span class="line"></span><br><span class="line">retryTimesWhenSendFailed, times, e, context, false, producer);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line"></span><br><span class="line">producer.updateFaultItem(brokerName, System.currentTimeMillis() - responseFuture.getBeginTimestamp(), true);</span><br><span class="line"></span><br><span class="line">if (!responseFuture.isSendRequestOK()) &#123;</span><br><span class="line"></span><br><span class="line">MQClientException ex &#x3D; new MQClientException(&quot;send request failed&quot;, responseFuture.getCause());</span><br><span class="line"></span><br><span class="line">onExceptionImpl(brokerName, msg, 0L, request, sendCallback, topicPublishInfo, instance,</span><br><span class="line"></span><br><span class="line">retryTimesWhenSendFailed, times, ex, context, true, producer);</span><br><span class="line"></span><br><span class="line">&#125; else if (responseFuture.isTimeout()) &#123;</span><br><span class="line"></span><br><span class="line">MQClientException ex &#x3D; new MQClientException(&quot;wait response timeout &quot; + responseFuture.getTimeoutMillis() + &quot;ms&quot;,</span><br><span class="line"></span><br><span class="line">responseFuture.getCause());</span><br><span class="line"></span><br><span class="line">onExceptionImpl(brokerName, msg, 0L, request, sendCallback, topicPublishInfo, instance,</span><br><span class="line"></span><br><span class="line">retryTimesWhenSendFailed, times, ex, context, true, producer);</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line"></span><br><span class="line">MQClientException ex &#x3D; new MQClientException(&quot;unknow reseaon&quot;, responseFuture.getCause());</span><br><span class="line"></span><br><span class="line">onExceptionImpl(brokerName, msg, 0L, request, sendCallback, topicPublishInfo, instance,</span><br><span class="line"></span><br><span class="line">retryTimesWhenSendFailed, times, ex, context, true, producer);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void onExceptionImpl(final String brokerName, &#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">final Message msg, &#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">final long timeoutMillis, &#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">final RemotingCommand request, &#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">final SendCallback sendCallback, &#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">final TopicPublishInfo topicPublishInfo, &#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">final MQClientInstance instance, &#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">final int timesTotal, &#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">final AtomicInteger curTimes, &#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">final Exception e, &#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">final SendMessageContext context, &#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">final boolean needRetry, &#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">final DefaultMQProducerImpl producer &#x2F;&#x2F; 12</span><br><span class="line"></span><br><span class="line">) &#123;</span><br><span class="line"></span><br><span class="line">int tmp &#x3D; curTimes.incrementAndGet();</span><br><span class="line"></span><br><span class="line">if (needRetry &amp;&amp; tmp &lt;&#x3D; timesTotal) &#123;</span><br><span class="line"></span><br><span class="line">String retryBrokerName &#x3D; brokerName;&#x2F;&#x2F;by default, it will send to the same broker</span><br><span class="line"></span><br><span class="line">if (topicPublishInfo !&#x3D; null) &#123; &#x2F;&#x2F;select one message queue accordingly, in order to determine which broker to send</span><br><span class="line"></span><br><span class="line">MessageQueue mqChosen &#x3D; producer.selectOneMessageQueue(topicPublishInfo, brokerName);</span><br><span class="line"></span><br><span class="line">retryBrokerName &#x3D; mqChosen.getBrokerName();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String addr &#x3D; instance.findBrokerAddressInPublish(retryBrokerName);</span><br><span class="line"></span><br><span class="line">log.info(&quot;async send msg by retry &#123;&#125; times. topic&#x3D;&#123;&#125;, brokerAddr&#x3D;&#123;&#125;, brokerName&#x3D;&#123;&#125;&quot;, tmp, msg.getTopic(), addr,</span><br><span class="line"></span><br><span class="line">retryBrokerName);</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">request.setOpaque(RemotingCommand.createNewRequestId());</span><br><span class="line"></span><br><span class="line">sendMessageAsync(addr, retryBrokerName, msg, timeoutMillis, request, sendCallback, topicPublishInfo, instance,</span><br><span class="line"></span><br><span class="line">timesTotal, curTimes, context, producer);</span><br><span class="line"></span><br><span class="line">&#125; catch (InterruptedException e1) &#123;</span><br><span class="line"></span><br><span class="line">onExceptionImpl(retryBrokerName, msg, timeoutMillis, request, sendCallback, topicPublishInfo, instance, timesTotal, curTimes, e1,</span><br><span class="line"></span><br><span class="line">context, false, producer);</span><br><span class="line"></span><br><span class="line">&#125; catch (RemotingConnectException e1) &#123;</span><br><span class="line"></span><br><span class="line">producer.updateFaultItem(brokerName, 3000, true);</span><br><span class="line"></span><br><span class="line">onExceptionImpl(retryBrokerName, msg, timeoutMillis, request, sendCallback, topicPublishInfo, instance, timesTotal, curTimes, e1,</span><br><span class="line"></span><br><span class="line">context, true, producer);</span><br><span class="line"></span><br><span class="line">&#125; catch (RemotingTooMuchRequestException e1) &#123;</span><br><span class="line"></span><br><span class="line">onExceptionImpl(retryBrokerName, msg, timeoutMillis, request, sendCallback, topicPublishInfo, instance, timesTotal, curTimes, e1,</span><br><span class="line"></span><br><span class="line">context, false, producer);</span><br><span class="line"></span><br><span class="line">&#125; catch (RemotingException e1) &#123;</span><br><span class="line"></span><br><span class="line">producer.updateFaultItem(brokerName, 3000, true);</span><br><span class="line"></span><br><span class="line">onExceptionImpl(retryBrokerName, msg, timeoutMillis, request, sendCallback, topicPublishInfo, instance, timesTotal, curTimes, e1,</span><br><span class="line"></span><br><span class="line">context, true, producer);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line"></span><br><span class="line">if (context !&#x3D; null) &#123;</span><br><span class="line"></span><br><span class="line">context.setException(e);</span><br><span class="line"></span><br><span class="line">context.getProducer().executeSendMessageHookAfter(context);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">sendCallback.onException(e);</span><br><span class="line"></span><br><span class="line">&#125; catch (Exception ignored) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ39# RocketMQ消息发送Broker端流程处理</title>
    <url>/posts/9126d179/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="Broker处理消息的入口类SendMessageProcessor"><a href="#Broker处理消息的入口类SendMessageProcessor" class="headerlink" title="Broker处理消息的入口类SendMessageProcessor"></a>Broker处理消息的入口类SendMessageProcessor</h1><p>processRequest方法主要三件事情：</p>
<p>1.处理consumer发回broker的消息重试</p>
<p>2.处理批量发送</p>
<p>3.处理单条消息发送</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line"></span><br><span class="line">public RemotingCommand processRequest(ChannelHandlerContext ctx, RemotingCommand request) throws RemotingCommandException &#123;</span><br><span class="line"></span><br><span class="line">SendMessageContext mqtraceContext;</span><br><span class="line"></span><br><span class="line">switch (request.getCode()) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;处理消息重试</span><br><span class="line"></span><br><span class="line">case RequestCode.CONSUMER_SEND_MSG_BACK:</span><br><span class="line"></span><br><span class="line">return this.consumerSendMsgBack(ctx, request);</span><br><span class="line"></span><br><span class="line">default:</span><br><span class="line"></span><br><span class="line">SendMessageRequestHeader requestHeader &#x3D; parseRequestHeader(request);</span><br><span class="line"></span><br><span class="line">if (requestHeader &#x3D;&#x3D; null) &#123;</span><br><span class="line"></span><br><span class="line">return null;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mqtraceContext &#x3D; buildMsgContext(ctx, requestHeader);</span><br><span class="line"></span><br><span class="line">this.executeSendMessageHookBefore(ctx, request, mqtraceContext);</span><br><span class="line"></span><br><span class="line">RemotingCommand response;</span><br><span class="line"></span><br><span class="line">if (requestHeader.isBatch()) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;批量发送</span><br><span class="line"></span><br><span class="line">response &#x3D; this.sendBatchMessage(ctx, request, mqtraceContext, requestHeader);</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;处理消息发送</span><br><span class="line"></span><br><span class="line">response &#x3D; this.sendMessage(ctx, request, mqtraceContext, requestHeader);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">this.executeSendMessageHookAfter(response, mqtraceContext);</span><br><span class="line"></span><br><span class="line">return response;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="单条处理流程"><a href="#单条处理流程" class="headerlink" title="单条处理流程"></a>单条处理流程</h1><p>批处理流程与单条处理基本一致</p>
<p>SendMessageProcessor.sendMessage主要流程：</p>
<p>1.broker可以在指定的时间开始服务通过startAcceptSendRequestTimeStamp设定</p>
<p>2.消息校验：</p>
<p>* broker没有写入权限并且topic为顺序topic则拒绝服务</p>
<p>* 检查Topic不能和系统保留Topic[TBW102]冲突</p>
<p>* 若Topic未创建，Broker开启自动创建</p>
<p>* queueId校验，不能大于队列最大值</p>
<p>3.判断是否超过消费次数（16次），决定是否写入死信队列</p>
<p>4.消息内容组织</p>
<p>* 设置Message扩展字段</p>
<p>* 设置Message在客户端生成的时间</p>
<p>* 设置发送Message机器的地址</p>
<p>* 设置存储Message的Broker地址</p>
<p>* 设置消费重试消息的次数</p>
<p>5.消息存储（单独梳理）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private RemotingCommand sendMessage(final ChannelHandlerContext ctx, &#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">final RemotingCommand request, &#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">final SendMessageContext sendMessageContext, &#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">final SendMessageRequestHeader requestHeader) throws RemotingCommandException &#123;</span><br><span class="line"></span><br><span class="line">final RemotingCommand response &#x3D; RemotingCommand.createResponseCommand(SendMessageResponseHeader.class);</span><br><span class="line"></span><br><span class="line">final SendMessageResponseHeader responseHeader &#x3D; (SendMessageResponseHeader) response.readCustomHeader();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;标识RPC的SeqNumber</span><br><span class="line"></span><br><span class="line">response.setOpaque(request.getOpaque());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;埋点不清楚用处</span><br><span class="line"></span><br><span class="line">response.addExtField(MessageConst.PROPERTY_MSG_REGION, this.brokerController.getBrokerConfig().getRegionId());</span><br><span class="line"></span><br><span class="line">response.addExtField(MessageConst.PROPERTY_TRACE_SWITCH, String.valueOf(this.brokerController.getBrokerConfig().isTraceOn()));</span><br><span class="line"></span><br><span class="line">log.debug(&quot;receive SendMessage request command, &#123;&#125;&quot;, request);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Broker启动后在设定的时间处理请求，通过startAcceptSendRequestTimeStamp来设置</span><br><span class="line"></span><br><span class="line">final long startTimstamp &#x3D; this.brokerController.getBrokerConfig().getStartAcceptSendRequestTimeStamp();</span><br><span class="line"></span><br><span class="line">if (this.brokerController.getMessageStore().now() &lt; startTimstamp) &#123;</span><br><span class="line"></span><br><span class="line">response.setCode(ResponseCode.SYSTEM_ERROR);</span><br><span class="line"></span><br><span class="line">response.setRemark(String.format(&quot;broker unable to service, until %s&quot;, UtilAll.timeMillisToHumanString2(startTimstamp)));</span><br><span class="line"></span><br><span class="line">return response;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">response.setCode(-1);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建Topic</span><br><span class="line"></span><br><span class="line">super.msgCheck(ctx, requestHeader, response);</span><br><span class="line"></span><br><span class="line">if (response.getCode() !&#x3D; -1) &#123;</span><br><span class="line"></span><br><span class="line">return response;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final byte[] body &#x3D; request.getBody();</span><br><span class="line"></span><br><span class="line">int queueIdInt &#x3D; requestHeader.getQueueId();</span><br><span class="line"></span><br><span class="line">TopicConfig topicConfig &#x3D; this.brokerController.getTopicConfigManager().selectTopicConfig(requestHeader.getTopic());</span><br><span class="line"></span><br><span class="line">if (queueIdInt &lt; 0) &#123;</span><br><span class="line"></span><br><span class="line">queueIdInt &#x3D; Math.abs(this.random.nextInt() % 99999999) % topicConfig.getWriteQueueNums();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MessageExtBrokerInner msgInner &#x3D; new MessageExtBrokerInner();</span><br><span class="line"></span><br><span class="line">msgInner.setTopic(requestHeader.getTopic());</span><br><span class="line"></span><br><span class="line">msgInner.setQueueId(queueIdInt);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;判断是否超过消费次数（16次），决定是否写入死信队列</span><br><span class="line"></span><br><span class="line">if (!handleRetryAndDLQ(requestHeader, response, request, msgInner, topicConfig)) &#123;</span><br><span class="line"></span><br><span class="line">return response;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">msgInner.setBody(body);</span><br><span class="line"></span><br><span class="line">msgInner.setFlag(requestHeader.getFlag());</span><br><span class="line"></span><br><span class="line">MessageAccessor.setProperties(msgInner, MessageDecoder.string2messageProperties(requestHeader.getProperties()));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Message扩展字段，比如：Unikey, Keys, Tag都在这里面</span><br><span class="line"></span><br><span class="line">msgInner.setPropertiesString(requestHeader.getProperties());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Message在客户端生成的时间</span><br><span class="line"></span><br><span class="line">msgInner.setBornTimestamp(requestHeader.getBornTimestamp());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;发送Message机器的地址</span><br><span class="line"></span><br><span class="line">msgInner.setBornHost(ctx.channel().remoteAddress());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;存储Message的Broker地址</span><br><span class="line"></span><br><span class="line">msgInner.setStoreHost(this.getStoreHost());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;重试消息的次数</span><br><span class="line"></span><br><span class="line">msgInner.setReconsumeTimes(requestHeader.getReconsumeTimes() &#x3D;&#x3D; null ? 0 : requestHeader.getReconsumeTimes());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;判断broker是否拒绝事物消息[rejectTransactionMessage]默认false</span><br><span class="line"></span><br><span class="line">if (this.brokerController.getBrokerConfig().isRejectTransactionMessage()) &#123;</span><br><span class="line"></span><br><span class="line">String traFlag &#x3D; msgInner.getProperty(MessageConst.PROPERTY_TRANSACTION_PREPARED);</span><br><span class="line"></span><br><span class="line">if (traFlag !&#x3D; null) &#123;</span><br><span class="line"></span><br><span class="line">response.setCode(ResponseCode.NO_PERMISSION);</span><br><span class="line"></span><br><span class="line">response.setRemark(</span><br><span class="line"></span><br><span class="line">&quot;the broker[&quot; + this.brokerController.getBrokerConfig().getBrokerIP1() + &quot;] sending transaction message is forbidden&quot;);</span><br><span class="line"></span><br><span class="line">return response;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;消息存储</span><br><span class="line"></span><br><span class="line">PutMessageResult putMessageResult &#x3D; this.brokerController.getMessageStore().putMessage(msgInner);</span><br><span class="line"></span><br><span class="line">return handlePutMessageResult(putMessageResult, response, request, msgInner, responseHeader, sendMessageContext, ctx, queueIdInt);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<!--more-->



<h1 id="处理消费重试消息"><a href="#处理消费重试消息" class="headerlink" title="处理消费重试消息"></a>处理消费重试消息</h1><p>SendMessageProcess.consumerSendMsgBack</p>
<p>处理流程：</p>
<p>1.如果broker没有写入权限则返回拒绝写入</p>
<p>2.如果重试队列不存在则创建（%RETRY%+consumergroup）</p>
<p>3.根据offset（来自requestHeader）从commitlog中查找该条重试消息</p>
<p>4.将该该消息中Property中RETRY_TOPIC为空，将原Topic设置到该属性中</p>
<p>5.超过消费重试次数或者delayLevel为负数，进入死信队列</p>
<p>6.新消息构建</p>
<p>* 设置新的Topic没有超过重试次数为%RETRY%+consumergroup，超过重试次数%DLQ%+consumergroup</p>
<p>* 设置延迟级别delayLevel，每次重试逐级递增，首次为3 + msgExt.getReconsumeTimes()</p>
<p>* 设置消息体、tagcode、queueId、sysFlag、BornTimestamp、BornHost、StoreHost、ReconsumeTimes</p>
<p>* 将原msgId存储到property中的ORIGIN_MESSAGE_ID属性</p>
<p>7.消息存储</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private RemotingCommand consumerSendMsgBack(final ChannelHandlerContext ctx, final RemotingCommand request)</span><br><span class="line"></span><br><span class="line">throws RemotingCommandException &#123;</span><br><span class="line"></span><br><span class="line">final RemotingCommand response &#x3D; RemotingCommand.createResponseCommand(null);</span><br><span class="line"></span><br><span class="line">final ConsumerSendMsgBackRequestHeader requestHeader &#x3D;</span><br><span class="line"></span><br><span class="line">(ConsumerSendMsgBackRequestHeader) request.decodeCommandCustomHeader(ConsumerSendMsgBackRequestHeader.class);</span><br><span class="line"></span><br><span class="line">if (this.hasConsumeMessageHook() &amp;&amp; !UtilAll.isBlank(requestHeader.getOriginMsgId())) &#123;</span><br><span class="line"></span><br><span class="line">ConsumeMessageContext context &#x3D; new ConsumeMessageContext();</span><br><span class="line"></span><br><span class="line">context.setConsumerGroup(requestHeader.getGroup());</span><br><span class="line"></span><br><span class="line">context.setTopic(requestHeader.getOriginTopic());</span><br><span class="line"></span><br><span class="line">context.setCommercialRcvStats(BrokerStatsManager.StatsType.SEND_BACK);</span><br><span class="line"></span><br><span class="line">context.setCommercialRcvTimes(1);</span><br><span class="line"></span><br><span class="line">context.setCommercialOwner(request.getExtFields().get(BrokerStatsManager.COMMERCIAL_OWNER));</span><br><span class="line"></span><br><span class="line">this.executeConsumeMessageHookAfter(context);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;消费组配置信息</span><br><span class="line"></span><br><span class="line">SubscriptionGroupConfig subscriptionGroupConfig &#x3D;</span><br><span class="line"></span><br><span class="line">this.brokerController.getSubscriptionGroupManager().findSubscriptionGroupConfig(requestHeader.getGroup());</span><br><span class="line"></span><br><span class="line">if (null &#x3D;&#x3D; subscriptionGroupConfig) &#123;</span><br><span class="line"></span><br><span class="line">response.setCode(ResponseCode.SUBSCRIPTION_GROUP_NOT_EXIST);</span><br><span class="line"></span><br><span class="line">response.setRemark(&quot;subscription group not exist, &quot; + requestHeader.getGroup() + &quot; &quot;</span><br><span class="line"></span><br><span class="line">\+ FAQUrl.suggestTodo(FAQUrl.SUBSCRIPTION_GROUP_NOT_EXIST));</span><br><span class="line"></span><br><span class="line">return response;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (!PermName.isWriteable(this.brokerController.getBrokerConfig().getBrokerPermission())) &#123;</span><br><span class="line"></span><br><span class="line">response.setCode(ResponseCode.NO_PERMISSION);</span><br><span class="line"></span><br><span class="line">response.setRemark(&quot;the broker[&quot; + this.brokerController.getBrokerConfig().getBrokerIP1() + &quot;] sending message is forbidden&quot;);</span><br><span class="line"></span><br><span class="line">return response;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (subscriptionGroupConfig.getRetryQueueNums() &lt;&#x3D; 0) &#123; &#x2F;&#x2F;重试队列数量需要大于等于1</span><br><span class="line"></span><br><span class="line">response.setCode(ResponseCode.SUCCESS);</span><br><span class="line"></span><br><span class="line">response.setRemark(null);</span><br><span class="line"></span><br><span class="line">return response;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String newTopic &#x3D; MixAll.getRetryTopic(requestHeader.getGroup()); &#x2F;&#x2F;重试队列</span><br><span class="line"></span><br><span class="line">int queueIdInt &#x3D; Math.abs(this.random.nextInt() % 99999999) % subscriptionGroupConfig.getRetryQueueNums(); &#x2F;&#x2F;随机队列</span><br><span class="line"></span><br><span class="line">int topicSysFlag &#x3D; 0;</span><br><span class="line"></span><br><span class="line">if (requestHeader.isUnitMode()) &#123;</span><br><span class="line"></span><br><span class="line">topicSysFlag &#x3D; TopicSysFlag.buildSysFlag(false, true);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建重试队列</span><br><span class="line"></span><br><span class="line">TopicConfig topicConfig &#x3D; this.brokerController.getTopicConfigManager().createTopicInSendMessageBackMethod(&#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">newTopic, &#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">subscriptionGroupConfig.getRetryQueueNums(), &#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">PermName.PERM_WRITE | PermName.PERM_READ, topicSysFlag);</span><br><span class="line"></span><br><span class="line">if (null &#x3D;&#x3D; topicConfig) &#123;</span><br><span class="line"></span><br><span class="line">response.setCode(ResponseCode.SYSTEM_ERROR);</span><br><span class="line"></span><br><span class="line">response.setRemark(&quot;topic[&quot; + newTopic + &quot;] not exist&quot;);</span><br><span class="line"></span><br><span class="line">return response;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (!PermName.isWriteable(topicConfig.getPerm())) &#123;</span><br><span class="line"></span><br><span class="line">response.setCode(ResponseCode.NO_PERMISSION);</span><br><span class="line"></span><br><span class="line">response.setRemark(String.format(&quot;the topic[%s] sending message is forbidden&quot;, newTopic));</span><br><span class="line"></span><br><span class="line">return response;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;从commitLog中查找消息</span><br><span class="line"></span><br><span class="line">MessageExt msgExt &#x3D; this.brokerController.getMessageStore().lookMessageByOffset(requestHeader.getOffset());</span><br><span class="line"></span><br><span class="line">if (null &#x3D;&#x3D; msgExt) &#123;</span><br><span class="line"></span><br><span class="line">response.setCode(ResponseCode.SYSTEM_ERROR);</span><br><span class="line"></span><br><span class="line">response.setRemark(&quot;look message by offset failed, &quot; + requestHeader.getOffset());</span><br><span class="line"></span><br><span class="line">return response;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final String retryTopic &#x3D; msgExt.getProperty(MessageConst.PROPERTY_RETRY_TOPIC);</span><br><span class="line"></span><br><span class="line">if (null &#x3D;&#x3D; retryTopic) &#123;</span><br><span class="line"></span><br><span class="line">MessageAccessor.putProperty(msgExt, MessageConst.PROPERTY_RETRY_TOPIC, msgExt.getTopic());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">msgExt.setWaitStoreMsgOK(false);</span><br><span class="line"></span><br><span class="line">int delayLevel &#x3D; requestHeader.getDelayLevel();</span><br><span class="line"></span><br><span class="line">int maxReconsumeTimes &#x3D; subscriptionGroupConfig.getRetryMaxTimes();</span><br><span class="line"></span><br><span class="line">if (request.getVersion() &gt;&#x3D; MQVersion.Version.V3_4_9.ordinal()) &#123;</span><br><span class="line"></span><br><span class="line">maxReconsumeTimes &#x3D; requestHeader.getMaxReconsumeTimes();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;超过重试次数或者delayLevel为负数，进入死信队列人工干预</span><br><span class="line"></span><br><span class="line">if (msgExt.getReconsumeTimes() &gt;&#x3D; maxReconsumeTimes&#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">|| delayLevel &lt; 0) &#123;</span><br><span class="line"></span><br><span class="line">newTopic &#x3D; MixAll.getDLQTopic(requestHeader.getGroup());</span><br><span class="line"></span><br><span class="line">queueIdInt &#x3D; Math.abs(this.random.nextInt() % 99999999) % DLQ_NUMS_PER_GROUP;</span><br><span class="line"></span><br><span class="line">topicConfig &#x3D; this.brokerController.getTopicConfigManager().createTopicInSendMessageBackMethod(newTopic, &#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">DLQ_NUMS_PER_GROUP, &#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">PermName.PERM_WRITE, 0</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">if (null &#x3D;&#x3D; topicConfig) &#123;</span><br><span class="line"></span><br><span class="line">response.setCode(ResponseCode.SYSTEM_ERROR);</span><br><span class="line"></span><br><span class="line">response.setRemark(&quot;topic[&quot; + newTopic + &quot;] not exist&quot;);</span><br><span class="line"></span><br><span class="line">return response;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line"></span><br><span class="line">if (0 &#x3D;&#x3D; delayLevel) &#123;</span><br><span class="line"></span><br><span class="line">delayLevel &#x3D; 3 + msgExt.getReconsumeTimes();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">msgExt.setDelayTimeLevel(delayLevel);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;构建新消息，会有新的消息Id</span><br><span class="line"></span><br><span class="line">MessageExtBrokerInner msgInner &#x3D; new MessageExtBrokerInner();</span><br><span class="line"></span><br><span class="line">msgInner.setTopic(newTopic);</span><br><span class="line"></span><br><span class="line">msgInner.setBody(msgExt.getBody());</span><br><span class="line"></span><br><span class="line">msgInner.setFlag(msgExt.getFlag());</span><br><span class="line"></span><br><span class="line">MessageAccessor.setProperties(msgInner, msgExt.getProperties());</span><br><span class="line"></span><br><span class="line">msgInner.setPropertiesString(MessageDecoder.messageProperties2String(msgExt.getProperties()));</span><br><span class="line"></span><br><span class="line">msgInner.setTagsCode(MessageExtBrokerInner.tagsString2tagsCode(null, msgExt.getTags()));</span><br><span class="line"></span><br><span class="line">msgInner.setQueueId(queueIdInt);</span><br><span class="line"></span><br><span class="line">msgInner.setSysFlag(msgExt.getSysFlag());</span><br><span class="line"></span><br><span class="line">msgInner.setBornTimestamp(msgExt.getBornTimestamp());</span><br><span class="line"></span><br><span class="line">msgInner.setBornHost(msgExt.getBornHost());</span><br><span class="line"></span><br><span class="line">msgInner.setStoreHost(this.getStoreHost());</span><br><span class="line"></span><br><span class="line">msgInner.setReconsumeTimes(msgExt.getReconsumeTimes() + 1);</span><br><span class="line"></span><br><span class="line">String originMsgId &#x3D; MessageAccessor.getOriginMessageId(msgExt); &#x2F;&#x2F;设置原来的messageId ORIGIN_MESSAGE_ID</span><br><span class="line"></span><br><span class="line">MessageAccessor.setOriginMessageId(msgInner, UtilAll.isBlank(originMsgId) ? msgExt.getMsgId() : originMsgId);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;消息存储</span><br><span class="line"></span><br><span class="line">PutMessageResult putMessageResult &#x3D; this.brokerController.getMessageStore().putMessage(msgInner);</span><br><span class="line"></span><br><span class="line">if (putMessageResult !&#x3D; null) &#123;</span><br><span class="line"></span><br><span class="line">switch (putMessageResult.getPutMessageStatus()) &#123;</span><br><span class="line"></span><br><span class="line">case PUT_OK:</span><br><span class="line"></span><br><span class="line">String backTopic &#x3D; msgExt.getTopic();</span><br><span class="line"></span><br><span class="line">String correctTopic &#x3D; msgExt.getProperty(MessageConst.PROPERTY_RETRY_TOPIC);</span><br><span class="line"></span><br><span class="line">if (correctTopic !&#x3D; null) &#123;</span><br><span class="line"></span><br><span class="line">backTopic &#x3D; correctTopic;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">this.brokerController.getBrokerStatsManager().incSendBackNums(requestHeader.getGroup(), backTopic);</span><br><span class="line"></span><br><span class="line">response.setCode(ResponseCode.SUCCESS);</span><br><span class="line"></span><br><span class="line">response.setRemark(null);</span><br><span class="line"></span><br><span class="line">return response;</span><br><span class="line"></span><br><span class="line">default:</span><br><span class="line"></span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">response.setCode(ResponseCode.SYSTEM_ERROR);</span><br><span class="line"></span><br><span class="line">response.setRemark(putMessageResult.getPutMessageStatus().name());</span><br><span class="line"></span><br><span class="line">return response;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">response.setCode(ResponseCode.SYSTEM_ERROR);</span><br><span class="line"></span><br><span class="line">response.setRemark(&quot;putMessageResult is null&quot;);</span><br><span class="line"></span><br><span class="line">return response;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ4# 查看RocketMQ Tps命令</title>
    <url>/posts/ba08ed95/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="查看所有Topic吞吐Tps"><a href="#查看所有Topic吞吐Tps" class="headerlink" title="查看所有Topic吞吐Tps"></a>查看所有Topic吞吐Tps</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin statsAll -n localhost:9876</span><br><span class="line"></span><br><span class="line">Topic Consumer Group InTPS OutTPS InMsg24Hour OutMsg24Hour</span><br><span class="line"></span><br><span class="line">T_SCANRECORD_NEW_groy 0.00 0 NO_CONSUMER</span><br><span class="line"></span><br><span class="line">T_SCANRECORD_NEW internationalScanRecordAll 5480.10 0.00 310165682 0</span><br><span class="line"></span><br><span class="line">T_SCANRECORD_NEW realnameConsumer 5480.10 79.98 310165682 29896917</span><br><span class="line"></span><br><span class="line">T_SCANRECORD_NEW AdpMqCluster_consumer2 5480.10 0.00 310165682 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<a id="more"></a>





<h1 id="查看特定Topic的吞吐Tps"><a href="#查看特定Topic的吞吐Tps" class="headerlink" title="查看特定Topic的吞吐Tps"></a>查看特定Topic的吞吐Tps</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin statsAll -t SCANRECORD -n 192.168.1.x:9876</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option PermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">Topic Consumer Group Accumulation InTPS OutTPS InMsg24Hour OutMsg24Hour</span><br><span class="line"></span><br><span class="line">SCANRECORD ZtoSignGroup 5826 2086.33 44.00 246409321 29988099</span><br><span class="line"></span><br><span class="line">SCANRECORD newOpenPartnerDeadlineJob 5447 2086.33 44.00 246409321 29988099</span><br><span class="line"></span><br><span class="line">SCANRECORD smartidivision-scanrecord-dis 3523 2086.33 14.32 246409321 31212557</span><br></pre></td></tr></table></figure></div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ40# RocketMQ一次消费性能问题排查</title>
    <url>/posts/302db5ac/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="需求描述"><a href="#需求描述" class="headerlink" title="需求描述"></a>需求描述</h1><p>在容器推广中，为了测试容器的性能，需要消息SDK与ECS上在发送和消费的性能对比；在对比消费性能时，发现容器中的消费性能居然是ECS的2倍。容器并发消费的20个线程TPS在3万左右，ECS中20个消费线程TPS在1.5万左右。</p>
<p>问题：配置均采用8C16G，容器中的性能几乎是ECS的两倍，这不科学，事出反常必有妖。</p>
<a id="more"></a>

<h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><h2 id="tcpdump网络情况"><a href="#tcpdump网络情况" class="headerlink" title="tcpdump网络情况"></a>tcpdump网络情况</h2><p>tcpdump显示在消费的机器存在频繁的域名解析过程；10.x.x.185向DNS服务器100.x.x.136.domain和10.x.x.138.domain请求解析。而10.x.x.185这台机器又是消息发送者的机器IP，测试的发送和消费分别部署在两台机器上。</p>
<p>问题：消费时为何会有消息发送方的IP呢？而且该IP还不断进行域名解析。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219150223.png"></p>
<!--more-->



<h2 id="查看消费线程堆栈"><a href="#查看消费线程堆栈" class="headerlink" title="查看消费线程堆栈"></a>查看消费线程堆栈</h2><p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219150247.png"></p>
<h1 id="消费代码定位"><a href="#消费代码定位" class="headerlink" title="消费代码定位"></a>消费代码定位</h1><p>在消费时有通过MessageExt.bornHost.getBornHostNameString获取消费这信息；问题由此引起。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MessageExt extends Message &#123;</span><br><span class="line"></span><br><span class="line">private static final long serialVersionUID &#x3D; 5720810158625748049L;</span><br><span class="line"></span><br><span class="line">private int queueId;</span><br><span class="line"></span><br><span class="line">private int storeSize;</span><br><span class="line"></span><br><span class="line">private long queueOffset;</span><br><span class="line"></span><br><span class="line">private int sysFlag;</span><br><span class="line"></span><br><span class="line">private long bornTimestamp;</span><br><span class="line"></span><br><span class="line">private SocketAddress bornHost;</span><br><span class="line"></span><br><span class="line">private long storeTimestamp;</span><br><span class="line"></span><br><span class="line">private SocketAddress storeHost;</span><br><span class="line"></span><br><span class="line">private String msgId;</span><br><span class="line"></span><br><span class="line">private long commitLogOffset;</span><br><span class="line"></span><br><span class="line">private int bodyCRC;</span><br><span class="line"></span><br><span class="line">private int reconsumeTimes;</span><br><span class="line"></span><br><span class="line">private long preparedTransactionOffset;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>调用GetBornHostNameString获取HostName时会根据IP反查DNS服务器；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">InetSocketAddress inetSocketAddress &#x3D; (InetSocketAddress)this.bornHost;</span><br><span class="line"></span><br><span class="line">return inetSocketAddress.getAddress().getHostName();</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>将getBornHostNameString注释或者直接返回IP，ECS的消费性能基本稳定在3万左右。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ42# RocketMQ消息轨迹</title>
    <url>/posts/ea80cc10/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="Broker配置"><a href="#Broker配置" class="headerlink" title="Broker配置"></a>Broker配置</h1><p>首先看下broker.conf配置的两个属性</p>
<p>| 属性 |默认值 |</p>
<p>| — | — |</p>
<p>|traceTopicEnable |false |</p>
<p>| msgTraceTopicName | RMQ_SYS_TRACE_TOPIC |</p>
<p>在一个集群中可以配置一台机器专门负责消息轨迹的收集工作，该台机器上配置traceTopicEnable = true,</p>
<p>borker启动的时候自动创建默认轨迹topic</p>
<p>TopicConfigManager.java构造方法，BrokerController在启动的时候，会初始化TopicConfigManager实现trace topic的创建工作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.brokerController.getBrokerConfig().isTraceTopicEnable()) &#123;</span><br><span class="line"></span><br><span class="line">String topic = <span class="keyword">this</span>.brokerController.getBrokerConfig().getMsgTraceTopicName();</span><br><span class="line"></span><br><span class="line">TopicConfig topicConfig = <span class="keyword">new</span> TopicConfig(topic);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.systemTopicList.add(topic);</span><br><span class="line"></span><br><span class="line">topicConfig.setReadQueueNums(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">topicConfig.setWriteQueueNums(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.topicConfigTable.put(topicConfig.getTopicName(), topicConfig);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h1 id="客户端发送实现"><a href="#客户端发送实现" class="headerlink" title="客户端发送实现"></a><strong>客户端发送实现</strong></h1><p>客户端发送</p>
<p>DefaultMQProducer producer = new DefaultMQProducer(“ProducerGroupName”,true);</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public DefaultMQProducer(final String producerGroup, RPCHook rpcHook, boolean enableMsgTrace,final String customizedTraceTopic) &#123;</span><br><span class="line"></span><br><span class="line">this.producerGroup &#x3D; producerGroup;</span><br><span class="line"></span><br><span class="line">defaultMQProducerImpl &#x3D; new DefaultMQProducerImpl(this, rpcHook);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;if client open the message trace feature</span><br><span class="line"></span><br><span class="line">if (enableMsgTrace) &#123;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">AsyncTraceDispatcher dispatcher &#x3D; new AsyncTraceDispatcher(customizedTraceTopic, rpcHook);</span><br><span class="line"></span><br><span class="line">dispatcher.setHostProducer(this.getDefaultMQProducerImpl());</span><br><span class="line"></span><br><span class="line">traceDispatcher &#x3D; dispatcher;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;为消息轨迹注册hook,在消息发送前执行</span><br><span class="line"></span><br><span class="line">this.getDefaultMQProducerImpl().registerSendMessageHook(</span><br><span class="line"></span><br><span class="line">new SendMessageTraceHookImpl(traceDispatcher));</span><br><span class="line"></span><br><span class="line">&#125; catch (Throwable e) &#123;</span><br><span class="line"></span><br><span class="line">log.error(&quot;system mqtrace hook init failed ,maybe can&#39;t send msg trace data&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SendMessageTraceHookImpl 实现了SendMessageHook接口，在消息发送前后会被调用</p>
<p>AsyncTraceDispatcher 主要负责消息的发送工作；内部队列，由线程池批量（100条）发送</p>
<h1 id="Hook调用"><a href="#Hook调用" class="headerlink" title="Hook调用"></a><strong>Hook调用</strong></h1><p>发送前hook调用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;如果有hook在消息发送前执行，消息轨迹通过这种方式记录</span><br><span class="line"></span><br><span class="line">if (this.hasSendMessageHook()) &#123;</span><br><span class="line"></span><br><span class="line">context &#x3D; new SendMessageContext();</span><br><span class="line"></span><br><span class="line">context.setProducer(this); &#x2F;&#x2F;发送对象</span><br><span class="line"></span><br><span class="line">context.setProducerGroup(this.defaultMQProducer.getProducerGroup()); &#x2F;&#x2F;生产组</span><br><span class="line"></span><br><span class="line">context.setCommunicationMode(communicationMode); &#x2F;&#x2F;发送模式</span><br><span class="line"></span><br><span class="line">context.setBornHost(this.defaultMQProducer.getClientIP()); &#x2F;&#x2F;客户端IP</span><br><span class="line"></span><br><span class="line">context.setBrokerAddr(brokerAddr); &#x2F;&#x2F;发往broker的地址</span><br><span class="line"></span><br><span class="line">context.setMessage(msg); &#x2F;&#x2F;消息内容</span><br><span class="line"></span><br><span class="line">context.setMq(mq); &#x2F;&#x2F;消息 Queue</span><br><span class="line"></span><br><span class="line">String isTrans &#x3D; msg.getProperty(MessageConst.PROPERTY_TRANSACTION_PREPARED);</span><br><span class="line"></span><br><span class="line">if (isTrans !&#x3D; null &amp;&amp; isTrans.equals(&quot;true&quot;)) &#123;</span><br><span class="line"></span><br><span class="line">context.setMsgType(MessageType.Trans_Msg_Half);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (msg.getProperty(&quot;__STARTDELIVERTIME&quot;) !&#x3D; null || msg.getProperty(MessageConst.PROPERTY_DELAY_TIME_LEVEL) !&#x3D; null) &#123;</span><br><span class="line"></span><br><span class="line">context.setMsgType(MessageType.Delay_Msg);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">this.executeSendMessageHookBefore(context); &#x2F;&#x2F;执行自定义个hook业务</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>发送后hook调用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;消息发送后执行的hook，消息轨迹会调用</span><br><span class="line"></span><br><span class="line">if (this.hasSendMessageHook()) &#123;</span><br><span class="line"></span><br><span class="line">context.setSendResult(sendResult);</span><br><span class="line"></span><br><span class="line">this.executeSendMessageHookAfter(context);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="发送轨迹"><a href="#发送轨迹" class="headerlink" title="发送轨迹"></a><strong>发送轨迹</strong></h1><p>Producer启动时注册钩子，该钩子持有负责消息发送的AsyncTraceDispatcher实例，消息发送后进而发送消息轨迹</p>
<p><strong>发送轨迹的消息格式</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219151653.png"></p>
<h1 id="客户端消费轨迹实现"><a href="#客户端消费轨迹实现" class="headerlink" title="客户端消费轨迹实现"></a>客户端消费轨迹实现</h1><p>消费轨迹：与消息发送的轨迹实现思路相同</p>
<p>DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(“CID_JODIE_1”,true);</p>
<p><strong>注册消费钩子</strong></p>
<p>ConsumeMessageTraceHookImpl实现了ConsumeMessageHook，在消费的前后会进行回调</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public DefaultMQPushConsumer(final String consumerGroup, RPCHook rpcHook,</span><br><span class="line"></span><br><span class="line">AllocateMessageQueueStrategy allocateMessageQueueStrategy, boolean enableMsgTrace, final String customizedTraceTopic) &#123;</span><br><span class="line"></span><br><span class="line">this.consumerGroup &#x3D; consumerGroup;</span><br><span class="line"></span><br><span class="line">this.allocateMessageQueueStrategy &#x3D; allocateMessageQueueStrategy;</span><br><span class="line"></span><br><span class="line">defaultMQPushConsumerImpl &#x3D; new DefaultMQPushConsumerImpl(this, rpcHook);</span><br><span class="line"></span><br><span class="line">if (enableMsgTrace) &#123;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">AsyncTraceDispatcher dispatcher &#x3D; new AsyncTraceDispatcher(customizedTraceTopic, rpcHook);</span><br><span class="line"></span><br><span class="line">dispatcher.setHostConsumer(this.getDefaultMQPushConsumerImpl());</span><br><span class="line"></span><br><span class="line">traceDispatcher &#x3D; dispatcher;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;注册消费hook</span><br><span class="line"></span><br><span class="line">this.getDefaultMQPushConsumerImpl().registerConsumeMessageHook(</span><br><span class="line"></span><br><span class="line">new ConsumeMessageTraceHookImpl(traceDispatcher));</span><br><span class="line"></span><br><span class="line">&#125; catch (Throwable e) &#123;</span><br><span class="line"></span><br><span class="line">log.error(&quot;system mqtrace hook init failed ,maybe can&#39;t send msg trace data&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ConsumeMessageConcurrentlyService.ConsumeRequest.run消费前执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;消费前执行hook 消费轨迹会执行</span><br><span class="line"></span><br><span class="line">ConsumeMessageContext consumeMessageContext &#x3D; null;</span><br><span class="line"></span><br><span class="line">if (ConsumeMessageConcurrentlyService.this.defaultMQPushConsumerImpl.hasHook()) &#123;</span><br><span class="line"></span><br><span class="line">consumeMessageContext &#x3D; new ConsumeMessageContext();</span><br><span class="line"></span><br><span class="line">consumeMessageContext.setConsumerGroup(defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line"></span><br><span class="line">consumeMessageContext.setProps(new HashMap&lt;String, String&gt;());</span><br><span class="line"></span><br><span class="line">consumeMessageContext.setMq(messageQueue);</span><br><span class="line"></span><br><span class="line">consumeMessageContext.setMsgList(msgs);</span><br><span class="line"></span><br><span class="line">consumeMessageContext.setSuccess(false); &#x2F;&#x2F;消费状态</span><br><span class="line"></span><br><span class="line">ConsumeMessageConcurrentlyService.this.defaultMQPushConsumerImpl.executeHookBefore(consumeMessageContext);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>消费后执行</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (ConsumeMessageConcurrentlyService.this.defaultMQPushConsumerImpl.hasHook()) &#123;</span><br><span class="line"></span><br><span class="line">consumeMessageContext.setStatus(status.toString());</span><br><span class="line"></span><br><span class="line">consumeMessageContext.setSuccess(ConsumeConcurrentlyStatus.CONSUME_SUCCESS &#x3D;&#x3D; status);</span><br><span class="line"></span><br><span class="line">ConsumeMessageConcurrentlyService.this.defaultMQPushConsumerImpl.executeHookAfter(consumeMessageContext);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>消费轨迹格式</strong></p>
<p>分为两部分，一部分为消费前，一部分为消费后</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219151820.png"></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219151831.png"></p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ5# RocketMQ Broker命令</title>
    <url>/posts/138ff78c/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="查看broker状态信息"><a href="#查看broker状态信息" class="headerlink" title="查看broker状态信息"></a>查看broker状态信息</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin brokerStatus -b 192.168.1.x:10911 -n 192.168.1.x:9876</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option PermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">bootTimestamp : 1535597348792</span><br><span class="line"></span><br><span class="line">brokerVersion : 232</span><br><span class="line"></span><br><span class="line">brokerVersionDesc : V4_1_0_SNAPSHOT</span><br><span class="line"></span><br><span class="line">commitLogDirCapacity : Total : 8.7 TiB, Free : 7.7 TiB.</span><br><span class="line"></span><br><span class="line">commitLogDiskRatio : 0.11147464487710743</span><br><span class="line"></span><br><span class="line">commitLogMaxOffset : 6652182757965</span><br><span class="line"></span><br><span class="line">commitLogMinOffset : 5676873023488</span><br><span class="line"></span><br><span class="line">consumeQueueDiskRatio : 0.11147464487710743</span><br><span class="line"></span><br><span class="line">dispatchBehindBytes : 0</span><br><span class="line"></span><br><span class="line">dispatchMaxBuffer : 0</span><br><span class="line"></span><br><span class="line">earliestMessageTimeStamp : 1539290831130</span><br><span class="line"></span><br><span class="line">getFoundTps : 24229.27707229277 24670.716261707163 24323.07766631239</span><br><span class="line"></span><br><span class="line">getMessageEntireTimeMax : 4895</span><br><span class="line"></span><br><span class="line">getMissTps : 23384.56154384562 24047.195280471955 23735.196223133637</span><br><span class="line"></span><br><span class="line">getTotalTps : 47613.83861613839 48717.91154217912 48058.27388944603</span><br><span class="line"></span><br><span class="line">getTransferedTps : 28046.395360463954 28519.931340199313 28905.699949690646</span><br><span class="line"></span><br><span class="line">msgGetTotalTodayMorning : 30682264110</span><br><span class="line"></span><br><span class="line">msgGetTotalTodayNow : 31750490006</span><br><span class="line"></span><br><span class="line">msgGetTotalYesterdayMorning : 29219504313</span><br><span class="line"></span><br><span class="line">msgPutTotalTodayMorning : 7329767893</span><br><span class="line"></span><br><span class="line">msgPutTotalTodayNow : 7523090457</span><br><span class="line"></span><br><span class="line">msgPutTotalYesterdayMorning : 7031035625</span><br><span class="line"></span><br><span class="line">pageCacheLockTimeMills : 0</span><br><span class="line"></span><br><span class="line">pullThreadPoolQueueCapacity : 100000</span><br><span class="line"></span><br><span class="line">pullThreadPoolQueueHeadWaitTimeMills: 0</span><br><span class="line"></span><br><span class="line">pullThreadPoolQueueSize : 0</span><br><span class="line"></span><br><span class="line">putMessageAverageSize : 807.2943103360182</span><br><span class="line"></span><br><span class="line">putMessageDistributeTime : [&lt;&#x3D;0ms]:229497 [0~10ms]:1275 [10~50ms]:4 [50~100ms]:0 [100~200ms]:0 [200~500ms]:0 [500ms~1s]:0 [1~2s]:0 [2~3s]:0 [3~4s]:0 [4~5s]:0 [5~10s]:0 [10s~]:0</span><br><span class="line"></span><br><span class="line">putMessageEntireTimeMax : 10885</span><br><span class="line"></span><br><span class="line">putMessageSizeTotal : 6073348121272</span><br><span class="line"></span><br><span class="line">putMessageTimesTotal : 7523090456</span><br><span class="line"></span><br><span class="line">putTps : 4424.957504249575 4466.0700596607 4577.724617932119</span><br><span class="line"></span><br><span class="line">remainHowManyDataToCommit : 6.9 KiB</span><br><span class="line"></span><br><span class="line">remainHowManyDataToFlush : 0 B</span><br><span class="line"></span><br><span class="line">remainTransientStoreBufferNumbs : 3</span><br><span class="line"></span><br><span class="line">runtime : [ 48 days, 7 hours, 52 minutes, 34 seconds ]</span><br><span class="line"></span><br><span class="line">scheduleMessageOffset_1 : 5169358,5169358</span><br><span class="line"></span><br><span class="line">scheduleMessageOffset_10 : 8161108,8171531</span><br><span class="line"></span><br><span class="line">scheduleMessageOffset_11 : 7864781,7877885</span><br><span class="line"></span><br><span class="line">scheduleMessageOffset_12 : 7584977,7601110</span><br><span class="line"></span><br><span class="line">scheduleMessageOffset_13 : 7278660,7297334</span><br><span class="line"></span><br><span class="line">scheduleMessageOffset_14 : 7123700,7146082</span><br><span class="line"></span><br><span class="line">scheduleMessageOffset_15 : 7013493,7063463</span><br><span class="line"></span><br><span class="line">scheduleMessageOffset_16 : 6864847,6950753</span><br><span class="line"></span><br><span class="line">scheduleMessageOffset_17 : 6549491,6803414</span><br><span class="line"></span><br><span class="line">scheduleMessageOffset_18 : 12887811,12894744</span><br><span class="line"></span><br><span class="line">scheduleMessageOffset_3 : 13667462,13667752</span><br><span class="line"></span><br><span class="line">scheduleMessageOffset_4 : 9780224,9781009</span><br><span class="line"></span><br><span class="line">scheduleMessageOffset_5 : 63142105,63144981</span><br><span class="line"></span><br><span class="line">scheduleMessageOffset_6 : 9185173,9188251</span><br><span class="line"></span><br><span class="line">scheduleMessageOffset_7 : 9002046,9006727</span><br><span class="line"></span><br><span class="line">scheduleMessageOffset_8 : 8834782,8841531</span><br><span class="line"></span><br><span class="line">scheduleMessageOffset_9 : 1112865066,1112879874</span><br><span class="line"></span><br><span class="line">sendThreadPoolQueueCapacity : 10000</span><br><span class="line"></span><br><span class="line">sendThreadPoolQueueHeadWaitTimeMills: 0</span><br><span class="line"></span><br><span class="line">sendThreadPoolQueueSize : 0</span><br><span class="line"></span><br><span class="line">startAcceptSendRequestTimeStamp : 0</span><br><span class="line"></span><br><span class="line">You have mail in &#x2F;var&#x2F;spool&#x2F;mail&#x2F;root</span><br></pre></td></tr></table></figure>



<a id="more"></a>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin brokerConsumeStats -b 192.168.1.x:10911 -n 192.168.1.x:9876</span><br><span class="line"></span><br><span class="line">zeus-package-mismatch-topic zeus-package-mismatch-consumer broker-a 0 698533 698532 1 2018-10-17 18:35:58</span><br><span class="line"></span><br><span class="line">zeus-package-mismatch-topic zeus-package-mismatch-consumer broker-a 1 698521 698520 1 2018-10-17 18:36:01</span><br><span class="line"></span><br><span class="line">zeus-package-mismatch-topic zeus-package-mismatch-consumer broker-a 2 698514 698513 1 2018-10-17 18:36:01</span><br><span class="line"></span><br><span class="line">zeus-package-mismatch-topic zeus-package-mismatch-consumer broker-a 3 698495 698494 1 2018-10-17 18:36:01</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h1 id="清除废弃的ConsumeQueue"><a href="#清除废弃的ConsumeQueue" class="headerlink" title="清除废弃的ConsumeQueue"></a>清除废弃的ConsumeQueue</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin cleanExpiredCQ -b 192.168.1.x:10911 -n 192.168.1.x:9876</span><br></pre></td></tr></table></figure>



<h1 id="清除废弃的Topic"><a href="#清除废弃的Topic" class="headerlink" title="清除废弃的Topic"></a>清除废弃的Topic</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin cleanUnusedTopic -b 192.168.1.x:10911 -n 192.168.1.x:9876</span><br></pre></td></tr></table></figure>



<h1 id="获取broker配置信息"><a href="#获取broker配置信息" class="headerlink" title="获取broker配置信息"></a>获取broker配置信息</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin getBrokerConfig -b 192.168.1.x:10911 -n 192.168.1.x:9876</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option PermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;192.168.1.x:10911&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">autoCreateSubscriptionGroup &#x3D; false</span><br><span class="line"></span><br><span class="line">brokerName &#x3D; broker-a</span><br><span class="line"></span><br><span class="line">haListenPort &#x3D; 10912</span><br><span class="line"></span><br><span class="line">clientManagerThreadPoolQueueCapacity &#x3D; 1000000</span><br><span class="line"></span><br><span class="line">flushCommitLogThoroughInterval &#x3D; 10000</span><br><span class="line"></span><br><span class="line">flushCommitLogLeastPages &#x3D; 4</span><br><span class="line"></span><br><span class="line">clientCallbackExecutorThreads &#x3D; 48</span><br><span class="line"></span><br><span class="line">notifyConsumerIdsChangedEnable &#x3D; true</span><br><span class="line"></span><br><span class="line">cleanResourceInterval &#x3D; 10000</span><br><span class="line"></span><br><span class="line">channelNotActiveInterval &#x3D; 60000</span><br><span class="line"></span><br><span class="line">diskMaxUsedSpaceRatio &#x3D; 88</span><br><span class="line"></span><br><span class="line">debugLockEnable &#x3D; false</span><br><span class="line"></span><br><span class="line">messageDelayLevel &#x3D; 1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h</span><br><span class="line"></span><br><span class="line">clusterTopicEnable &#x3D; true</span><br><span class="line"></span><br><span class="line">messageIndexEnable &#x3D; true</span><br><span class="line"></span><br><span class="line">serverPooledByteBufAllocatorEnable &#x3D; true</span><br><span class="line"></span><br><span class="line">shortPollingTimeMills &#x3D; 1000</span><br><span class="line"></span><br><span class="line">commercialEnable &#x3D; true</span><br><span class="line"></span><br><span class="line">redeleteHangedFileInterval &#x3D; 120000</span><br><span class="line"></span><br><span class="line">flushConsumerOffsetInterval &#x3D; 5000</span><br><span class="line"></span><br><span class="line">flushCommitLogTimed &#x3D; false</span><br><span class="line"></span><br><span class="line">maxMessageSize &#x3D; 65536</span><br><span class="line"></span><br><span class="line">brokerId &#x3D; 0</span><br><span class="line"></span><br><span class="line">syncFlushTimeout &#x3D; 5000</span><br><span class="line"></span><br><span class="line">flushConsumeQueueThoroughInterval &#x3D; 60000</span><br><span class="line"></span><br><span class="line">clientChannelMaxIdleTimeSeconds &#x3D; 120</span><br><span class="line"></span><br><span class="line">flushDelayOffsetInterval &#x3D; 10000</span><br><span class="line"></span><br><span class="line">serverSocketRcvBufSize &#x3D; 131072</span><br><span class="line"></span><br><span class="line">flushDiskType &#x3D; ASYNC_FLUSH</span><br><span class="line"></span><br><span class="line">maxTransferBytesOnMessageInMemory &#x3D; 262144</span><br><span class="line"></span><br><span class="line">clientManageThreadPoolNums &#x3D; 32</span><br><span class="line"></span><br><span class="line">serverChannelMaxIdleTimeSeconds &#x3D; 120</span><br><span class="line"></span><br><span class="line">serverCallbackExecutorThreads &#x3D; 0</span><br><span class="line"></span><br><span class="line">transientStorePoolSize &#x3D; 5</span><br><span class="line"></span><br><span class="line">maxTransferBytesOnMessageInDisk &#x3D; 65536</span><br><span class="line"></span><br><span class="line">pullMessageThreadPoolNums &#x3D; 128</span><br><span class="line"></span><br><span class="line">clientCloseSocketIfTimeout &#x3D; false</span><br><span class="line"></span><br><span class="line">fetchNamesrvAddrByAddressServer &#x3D; false</span><br><span class="line"></span><br><span class="line">sendThreadPoolQueueCapacity &#x3D; 10000</span><br><span class="line"></span><br><span class="line">diskFallRecorded &#x3D; true</span><br><span class="line"></span><br><span class="line">transientStorePoolEnable &#x3D; true</span><br><span class="line"></span><br><span class="line">offsetCheckInSlave &#x3D; false</span><br><span class="line"></span><br><span class="line">disableConsumeIfConsumerReadSlowly &#x3D; false</span><br><span class="line"></span><br><span class="line">commitCommitLogThoroughInterval &#x3D; 200</span><br><span class="line"></span><br><span class="line">consumerManagerThreadPoolQueueCapacity &#x3D; 1000000</span><br><span class="line"></span><br><span class="line">flushIntervalConsumeQueue &#x3D; 1000</span><br><span class="line"></span><br><span class="line">clientOnewaySemaphoreValue &#x3D; 65535</span><br><span class="line"></span><br><span class="line">warmMapedFileEnable &#x3D; true</span><br><span class="line"></span><br><span class="line">slaveReadEnable &#x3D; false</span><br><span class="line"></span><br><span class="line">transferMsgByHeap &#x3D; true</span><br><span class="line"></span><br><span class="line">consumerFallbehindThreshold &#x3D; 17179869184</span><br><span class="line"></span><br><span class="line">serverAsyncSemaphoreValue &#x3D; 64</span><br><span class="line"></span><br><span class="line">startAcceptSendRequestTimeStamp &#x3D; 0</span><br><span class="line"></span><br><span class="line">flushConsumerOffsetHistoryInterval &#x3D; 60000</span><br><span class="line"></span><br><span class="line">brokerIP2 &#x3D; 192.168.1.x</span><br><span class="line"></span><br><span class="line">maxTransferCountOnMessageInDisk &#x3D; 8</span><br><span class="line"></span><br><span class="line">brokerIP1 &#x3D; 192.168.1.x</span><br><span class="line"></span><br><span class="line">deleteCommitLogFilesInterval &#x3D; 100</span><br><span class="line"></span><br><span class="line">adminBrokerThreadPoolNums &#x3D; 16</span><br><span class="line"></span><br><span class="line">storePathCommitLog &#x3D; &#x2F;data&#x2F;rocketmq&#x2F;store&#x2F;commitlog</span><br><span class="line"></span><br><span class="line">filterServerNums &#x3D; 0</span><br><span class="line"></span><br><span class="line">deleteConsumeQueueFilesInterval &#x3D; 100</span><br><span class="line"></span><br><span class="line">checkCRCOnRecover &#x3D; true</span><br><span class="line"></span><br><span class="line">serverOnewaySemaphoreValue &#x3D; 256</span><br><span class="line"></span><br><span class="line">defaultQueryMaxNum &#x3D; 32</span><br><span class="line"></span><br><span class="line">clientWorkerThreads &#x3D; 4</span><br><span class="line"></span><br><span class="line">clientSocketRcvBufSize &#x3D; 131072</span><br><span class="line"></span><br><span class="line">maxDelayTime &#x3D; 40</span><br><span class="line"></span><br><span class="line">connectTimeoutMillis &#x3D; 3000</span><br><span class="line"></span><br><span class="line">clientPooledByteBufAllocatorEnable &#x3D; false</span><br><span class="line"></span><br><span class="line">commercialTimerCount &#x3D; 1</span><br><span class="line"></span><br><span class="line">serverSocketSndBufSize &#x3D; 131072</span><br><span class="line"></span><br><span class="line">regionId &#x3D; DefaultRegion</span><br><span class="line"></span><br><span class="line">duplicationEnable &#x3D; false</span><br><span class="line"></span><br><span class="line">cleanFileForciblyEnable &#x3D; true</span><br><span class="line"></span><br><span class="line">fastFailIfNoBufferInStorePool &#x3D; false</span><br><span class="line"></span><br><span class="line">rejectTransactionMessage &#x3D; false</span><br><span class="line"></span><br><span class="line">serverSelectorThreads &#x3D; 3</span><br><span class="line"></span><br><span class="line">consumerManageThreadPoolNums &#x3D; 32</span><br><span class="line"></span><br><span class="line">haSendHeartbeatInterval &#x3D; 5000</span><br><span class="line"></span><br><span class="line">mapedFileSizeConsumeQueue &#x3D; 50000000</span><br><span class="line"></span><br><span class="line">storeCheckpoint &#x3D; &#x2F;data&#x2F;rocketmq&#x2F;store&#x2F;checkpoint</span><br><span class="line"></span><br><span class="line">commitCommitLogLeastPages &#x3D; 4</span><br><span class="line"></span><br><span class="line">longPollingEnable &#x3D; true</span><br><span class="line"></span><br><span class="line">flushConsumeQueueLeastPages &#x3D; 2</span><br><span class="line"></span><br><span class="line">storePathRootDir &#x3D; &#x2F;data&#x2F;rocketmq&#x2F;store</span><br><span class="line"></span><br><span class="line">defaultTopicQueueNums &#x3D; 4</span><br><span class="line"></span><br><span class="line">highSpeedMode &#x3D; false</span><br><span class="line"></span><br><span class="line">commercialBaseCount &#x3D; 1</span><br><span class="line"></span><br><span class="line">checkTransactionMessageEnable &#x3D; false</span><br><span class="line"></span><br><span class="line">accessMessageInMemoryMaxRatio &#x3D; 40</span><br><span class="line"></span><br><span class="line">autoCreateTopicEnable &#x3D; false</span><br><span class="line"></span><br><span class="line">commitIntervalCommitLog &#x3D; 200</span><br><span class="line"></span><br><span class="line">brokerTopicEnable &#x3D; true</span><br><span class="line"></span><br><span class="line">namesrvAddr &#x3D; 192.168.1.x:9876;192.168.1.x:9876</span><br><span class="line"></span><br><span class="line">clientAsyncSemaphoreValue &#x3D; 65535</span><br><span class="line"></span><br><span class="line">maxMsgsNumBatch &#x3D; 64</span><br><span class="line"></span><br><span class="line">storePathConsumeQueue &#x3D; &#x2F;data&#x2F;rocketmq&#x2F;store&#x2F;consumequeue</span><br><span class="line"></span><br><span class="line">fileReservedTime &#x3D; 120</span><br><span class="line"></span><br><span class="line">deleteWhen &#x3D; 04</span><br><span class="line"></span><br><span class="line">waitTimeMillsInSendQueue &#x3D; 200</span><br><span class="line"></span><br><span class="line">commercialTransCount &#x3D; 1</span><br><span class="line"></span><br><span class="line">osPageCacheBusyTimeOutMills &#x3D; 1000</span><br><span class="line"></span><br><span class="line">abortFile &#x3D; &#x2F;data&#x2F;rocketmq&#x2F;store&#x2F;abort</span><br><span class="line"></span><br><span class="line">maxIndexNum &#x3D; 20000000</span><br><span class="line"></span><br><span class="line">registerBrokerTimeoutMills &#x3D; 6000</span><br><span class="line"></span><br><span class="line">messageIndexSafe &#x3D; false</span><br><span class="line"></span><br><span class="line">putMsgIndexHightWater &#x3D; 600000</span><br><span class="line"></span><br><span class="line">listenPort &#x3D; 10911</span><br><span class="line"></span><br><span class="line">serverWorkerThreads &#x3D; 8</span><br><span class="line"></span><br><span class="line">clientSocketSndBufSize &#x3D; 131072</span><br><span class="line"></span><br><span class="line">traceOn &#x3D; true</span><br><span class="line"></span><br><span class="line">maxHashSlotNum &#x3D; 5000000</span><br><span class="line"></span><br><span class="line">brokerRole &#x3D; ASYNC_MASTER</span><br><span class="line"></span><br><span class="line">storePathIndex &#x3D; &#x2F;data&#x2F;rocketmq&#x2F;store&#x2F;index</span><br><span class="line"></span><br><span class="line">rocketmqHome &#x3D; &#x2F;home&#x2F;baseuser&#x2F;rocketmq</span><br><span class="line"></span><br><span class="line">useReentrantLockWhenPutMessage &#x3D; false</span><br><span class="line"></span><br><span class="line">haHousekeepingInterval &#x3D; 20000</span><br><span class="line"></span><br><span class="line">brokerPermission &#x3D; 6</span><br><span class="line"></span><br><span class="line">maxTransferCountOnMessageInMemory &#x3D; 1000</span><br><span class="line"></span><br><span class="line">useEpollNativeSelector &#x3D; false</span><br><span class="line"></span><br><span class="line">haSlaveFallbehindMax &#x3D; 268435456</span><br><span class="line"></span><br><span class="line">haTransferBatchSize &#x3D; 32768</span><br><span class="line"></span><br><span class="line">messageStorePlugIn &#x3D;</span><br><span class="line"></span><br><span class="line">pullThreadPoolQueueCapacity &#x3D; 100000</span><br><span class="line"></span><br><span class="line">brokerClusterName &#x3D; ZmsClusterB</span><br><span class="line"></span><br><span class="line">destroyMapedFileIntervalForcibly &#x3D; 120000</span><br><span class="line"></span><br><span class="line">mapedFileSizeCommitLog &#x3D; 1073741824</span><br><span class="line"></span><br><span class="line">commercialBigCount &#x3D; 1</span><br><span class="line"></span><br><span class="line">flushLeastPagesWhenWarmMapedFile &#x3D; 4096</span><br><span class="line"></span><br><span class="line">sendMessageThreadPoolNums &#x3D; 1</span><br><span class="line"></span><br><span class="line">flushIntervalCommitLog &#x3D; 500</span><br></pre></td></tr></table></figure>





<h1 id="发送消息到broker"><a href="#发送消息到broker" class="headerlink" title="发送消息到broker"></a>发送消息到broker</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin sendMsgStatus -b 192.168.1.x:10911 -n 192.168.1.x:9876</span><br></pre></td></tr></table></figure>



<h1 id="更新broker信息"><a href="#更新broker信息" class="headerlink" title="更新broker信息"></a>更新broker信息</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin updateBrokerConfig -b 192.168.1.x:10911 -n 192.168.1.x:9876 -k key -v value</span><br></pre></td></tr></table></figure></div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ6# RocketMQ NameSrv命令</title>
    <url>/posts/7ee60e46/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="获取namesrv配置"><a href="#获取namesrv配置" class="headerlink" title="获取namesrv配置"></a>获取namesrv配置</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[baseuser@HZPL00xxxx rocketmq]$ sh bin&#x2F;mqadmin getNamesrvConfig -n 192.168.1.x:9876</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option PermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;192.168.1.x:9876&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">serverChannelMaxIdleTimeSeconds &#x3D; 120</span><br><span class="line"></span><br><span class="line">listenPort &#x3D; 9876</span><br><span class="line"></span><br><span class="line">serverCallbackExecutorThreads &#x3D; 0</span><br><span class="line"></span><br><span class="line">serverAsyncSemaphoreValue &#x3D; 64</span><br><span class="line"></span><br><span class="line">serverSocketSndBufSize &#x3D; 4096</span><br><span class="line"></span><br><span class="line">rocketmqHome &#x3D; &#x2F;home&#x2F;baseuser&#x2F;rocketmq</span><br><span class="line"></span><br><span class="line">clusterTest &#x3D; false</span><br><span class="line"></span><br><span class="line">serverSelectorThreads &#x3D; 3</span><br><span class="line"></span><br><span class="line">useEpollNativeSelector &#x3D; false</span><br><span class="line"></span><br><span class="line">orderMessageEnable &#x3D; false</span><br><span class="line"></span><br><span class="line">serverPooledByteBufAllocatorEnable &#x3D; true</span><br><span class="line"></span><br><span class="line">kvConfigPath &#x3D; &#x2F;home&#x2F;baseuser&#x2F;namesrv&#x2F;kvConfig.json</span><br><span class="line"></span><br><span class="line">serverWorkerThreads &#x3D; 8</span><br><span class="line"></span><br><span class="line">serverSocketRcvBufSize &#x3D; 4096</span><br><span class="line"></span><br><span class="line">productEnvName &#x3D; center</span><br><span class="line"></span><br><span class="line">serverOnewaySemaphoreValue &#x3D; 256</span><br><span class="line"></span><br><span class="line">configStorePath &#x3D; &#x2F;home&#x2F;baseuser&#x2F;namesrv&#x2F;namesrv.properties</span><br></pre></td></tr></table></figure>



<a id="more"></a>



<h1 id="删除nameSrv配置"><a href="#删除nameSrv配置" class="headerlink" title="删除nameSrv配置"></a>删除nameSrv配置</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh bin&#x2F;mqadmin deleteKvConfig -n 192.168.1.x:9876 -s namesapce -k key</span><br><span class="line"></span><br><span class="line">Delete KV config.</span><br><span class="line"></span><br><span class="line">-s set the namespace</span><br><span class="line"></span><br><span class="line">-k key set the key name</span><br></pre></td></tr></table></figure>



<h1 id="更新了nameSrv配置"><a href="#更新了nameSrv配置" class="headerlink" title="更新了nameSrv配置"></a>更新了nameSrv配置</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh bin&#x2F;mqadmin updateKvConfig -n 192.168.1.x:9876 -s namesapce -k key</span><br><span class="line"></span><br><span class="line">update KV config.</span><br><span class="line"></span><br><span class="line">-s set the namespace</span><br><span class="line"></span><br><span class="line">-k key set the key name</span><br><span class="line"></span><br><span class="line">-v value set the key value</span><br></pre></td></tr></table></figure>



<h1 id="更新nameSrv配置"><a href="#更新nameSrv配置" class="headerlink" title="更新nameSrv配置"></a>更新nameSrv配置</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh bin&#x2F;mqadmin updateNamesrvConfig -n 192.168.1.x:9876 -s namesapce -k key</span><br><span class="line"></span><br><span class="line">update KV config.</span><br><span class="line"></span><br><span class="line">-k key set the key name</span><br><span class="line"></span><br><span class="line">-v value set the key value</span><br></pre></td></tr></table></figure>



<h1 id="取消Broker写权限"><a href="#取消Broker写权限" class="headerlink" title="取消Broker写权限"></a>取消Broker写权限</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh bin&#x2F;mqadmin wipeWritePerm -n 192.168.1.x:9876 -b brokerAddr</span><br><span class="line"></span><br><span class="line">Wipe write perm of broker in all name server</span><br><span class="line"></span><br><span class="line">-b brokerName</span><br></pre></td></tr></table></figure>

</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ44# RocketMQ最近几个经常被问的问题</title>
    <url>/posts/f75406c8/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="常见问题一"><a href="#常见问题一" class="headerlink" title="常见问题一"></a>常见问题一</h1><p><strong>问：</strong> RocketMQ消费者订阅了tag，但却收不到消息无法消费，并且根据 msgid 去查询，发现这条消息的状态为 CONSUMED_BUT_FILTERED，那这是为什么？</p>
<p><strong>答：</strong> 在RocketMQ中，一个消费组能同时订阅多个 tag，但一个消费组的不同消费者不能分开订阅不同的tag，即同一个消费组的订阅关系必须保持一样。例如：常见错误使用方式同一个项目中，一段消费代码订阅tagA，然后拷贝到这段代码再更改为tagB。</p>
<a id="more"></a>

<p><strong>正确用法</strong> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">()</span></span>&#123;</span><br><span class="line">	DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">&quot;melon_online_test_consumer&quot;</span>);</span><br><span class="line">	consumer.subscribe(<span class="string">&quot;melon_online_test&quot;</span>,<span class="string">&quot;tag1 || tag2 || tag3&quot;</span>);</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p><strong>错误用法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubscribeTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribeA</span><span class="params">()</span></span>&#123;</span><br><span class="line">    DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">&quot;melon_online_test_consumer&quot;</span>);</span><br><span class="line">    consumer.subscribe(<span class="string">&quot;melon_online_test&quot;</span>,<span class="string">&quot;tag1&quot;</span>);</span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribeB</span><span class="params">()</span></span>&#123;</span><br><span class="line">    DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">&quot;melon_online_test_consumer&quot;</span>);</span><br><span class="line">    consumer.subscribe(<span class="string">&quot;melon_online_test&quot;</span>,<span class="string">&quot;tag2&quot;</span>);</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="常见问题二"><a href="#常见问题二" class="headerlink" title="常见问题二"></a>常见问题二</h1><p><strong>问：</strong> 发现大量的RocketMQ client 大量的info日志输出，我不关心，如何禁用呢？</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210125093344.png"></p>
<p><strong>答：</strong> 尝试以下设置，项目中使用了Slf4j<br>@1 可以配置RocketmqClient的logger设置优先级为warn</p>
<p>@2 也可以通过-Drocketmq.client.logUseSlf4j=false 和 -Drocketmq.client.logLevel=WARN 关闭MQ客户端使用Slf4j并提高日志等级</p>
<p>项目中没有使用Slf4j，可以通过-Drocketmq.client.logLevel=WARN调高日志等级。</p>
<h1 id="常见问题三"><a href="#常见问题三" class="headerlink" title="常见问题三"></a>常见问题三</h1><p><strong>问：</strong> 我的服务消费后需要调用第三方接口，别人的接口调用有限制，Rocketmq消费可以限流吗？</p>
<p><strong>答：</strong> RocketMQ本身没有类似每秒消费多少条数据的精确限流，我们可以结合Sentienl来实现，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> String KEY = <span class="string">&quot;melon_topic:melon_consumer&quot;</span>; <span class="comment">// 资源名称由topic和消费组构成</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, MQClientException </span>&#123;</span><br><span class="line">    initFlowControlRule(); <span class="comment">// Sentinel流控规则</span></span><br><span class="line">    DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">&quot;melon_consumer&quot;</span>);</span><br><span class="line">    consumer.setNamesrvAddr(<span class="string">&quot;localhost:9876&quot;</span>);</span><br><span class="line">    consumer.subscribe(<span class="string">&quot;melon_topic&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">    consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class="line">    consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">                Entry entry = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ContextUtil.enter(KEY); <span class="comment">// 定义资源</span></span><br><span class="line">                    entry = SphU.entry(KEY, EntryType.OUT);</span><br><span class="line">                    System.out.printf(<span class="string">&quot;%s Receive New Messages: %s %n&quot;</span>, Thread.currentThread().getName(), msg);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BlockException ex) &#123;</span><br><span class="line">                    <span class="comment">// Blocked.被限流后消息重试</span></span><br><span class="line">                    <span class="keyword">return</span> ConsumeConcurrentlyStatus.RECONSUME_LATER;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (entry != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        entry.exit();</span><br><span class="line">                    &#125;</span><br><span class="line">                    ContextUtil.exit();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    consumer.start();</span><br><span class="line">    System.out.printf(<span class="string">&quot;Consumer Started.%n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initFlowControlRule</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FlowRule rule = <span class="keyword">new</span> FlowRule();</span><br><span class="line">    rule.setResource(KEY);</span><br><span class="line">    rule.setCount(<span class="number">5</span>);<span class="comment">// 每秒通过5条消息</span></span><br><span class="line">    rule.setGrade(RuleConstant.FLOW_GRADE_QPS);</span><br><span class="line">    rule.setControlBehavior(RuleConstant.CONTROL_BEHAVIOR_RATE_LIMITER);</span><br><span class="line">    rule.setMaxQueueingTimeMs(<span class="number">5</span> * <span class="number">1000</span>); <span class="comment">// 排队超时时间5秒</span></span><br><span class="line">    FlowRuleManager.loadRules(Collections.singletonList(rule));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<!--more-->



<h1 id="常见问题四"><a href="#常见问题四" class="headerlink" title="常见问题四"></a>常见问题四</h1><p><strong>问：</strong>RocketMQ默认延迟等级有18个，我可以扩增吗？</p>
<p><strong>答：</strong> 可以的，但是不建议扩增太多等级，可以通过修改broker属性messageDelayLevel来实现，注意修改了后需要重启broker。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">messageDelayLevel = 1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h <span class="number">1d</span> <span class="number">3d</span> <span class="number">7d</span> <span class="number">14d</span> <span class="number">21d</span></span><br></pre></td></tr></table></figure>







</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ7# RocketMQ Message相关命令</title>
    <url>/posts/40c12a8c/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="发送测试消息"><a href="#发送测试消息" class="headerlink" title="发送测试消息"></a>发送测试消息</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin checkMsgSendRT -n 192.168.x.x:9876 -t topic_online_test -s 1024</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option PermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize&#x3D;128m; support was removed in 8.0Broker Name           QID #Send Result      RTbroker-a             0   true          314broker-a             1   true          0broker-a             2   true          0</span><br><span class="line"></span><br><span class="line">broker-a             3   true          0</span><br><span class="line"></span><br><span class="line">broker-b             0   true          2</span><br><span class="line"></span><br><span class="line">broker-b             1   true          1</span><br><span class="line"></span><br><span class="line">broker-b             2   true          1</span><br><span class="line"></span><br><span class="line">broker-b             3   true          0</span><br><span class="line"></span><br><span class="line">broker-a             0   true          1</span><br><span class="line"></span><br><span class="line">broker-a             1   true          0</span><br><span class="line"></span><br><span class="line">broker-a             2   true          0</span><br><span class="line"></span><br><span class="line">broker-a             3   true          1</span><br><span class="line"></span><br><span class="line">broker-b             0   true          4</span><br><span class="line"></span><br><span class="line">-t topic topic name</span><br><span class="line"></span><br><span class="line">-a amount message amout | default 100</span><br><span class="line"></span><br><span class="line">-s size message size | default 128 Byte</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h1 id="print-message-by-queue"><a href="#print-message-by-queue" class="headerlink" title="print message by queue"></a>print message by queue</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin printMsgByQueue -n 192.168.1.x:9876 -b 192.168.1.x -i 0</span><br></pre></td></tr></table></figure>





<h1 id="打印topic中的信息"><a href="#打印topic中的信息" class="headerlink" title="打印topic中的信息"></a>打印topic中的信息</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin printMsg -n 192.168.1.x:9876 -t SCANRECORD</span><br><span class="line"></span><br><span class="line">&quot;t&quot;, &quot;topic&quot;, true, &quot;topic name&quot;</span><br><span class="line"></span><br><span class="line">&quot;c&quot;, &quot;charsetName &quot;, true, &quot;CharsetName(eg: UTF-8,GBK)&quot;</span><br><span class="line"></span><br><span class="line">&quot;s&quot;, &quot;subExpression &quot;, true, &quot;Subscribe Expression(eg: TagA || TagB)&quot;</span><br><span class="line"></span><br><span class="line">&quot;b&quot;, &quot;beginTimestamp &quot;, true,  Begin timestamp[currentTimeMillis|yyyy-MM-dd#HH:mm:ss:SSS]</span><br><span class="line"></span><br><span class="line">&quot;e&quot;, &quot;endTimestamp &quot;, true, End timestamp[currentTimeMillis|yyyy-MM-dd#HH:mm:ss:SSS]</span><br><span class="line"></span><br><span class="line">&quot;d&quot;, &quot;printBody &quot;, true,&quot;print body&quot;</span><br><span class="line"></span><br><span class="line">MSGID: C0A81F8166832F2C9B1953831616FB45 MessageExt [queueId&#x3D;20, storeSize&#x3D;686, queueOffset&#x3D;35052080, sysFlag&#x3D;0, bornTimestamp&#x3D;1539724299798, bornHost&#x3D;&#x2F;192.168.x.x:29781, storeTimestamp&#x3D;1539724299179, storeHost&#x3D;&#x2F;192.168.x.x:10911, msgId&#x3D;C0A801B400002A9F000005F308F9B3A5, commitLogOffset&#x3D;6541385773989, bodyCRC&#x3D;1167936923, reconsumeTimes&#x3D;0, preparedTransactionOffset&#x3D;0, toString()&#x3D;Message [topic&#x3D;SCANRECORD, flag&#x3D;0, properties&#x3D;&#123;MIN_OFFSET&#x3D;35046369, MAX_OFFSET&#x3D;40298522, KEYS&#x3D;1dd04932-b7d9-43ee-8b31-39d16dd043d4, UNIQ_KEY&#x3D;C0A81F8166832F2C9B1953831616FB45, WAIT&#x3D;true, TAGS&#x3D;2&#125;, body&#x3D;484]] BODY: &#123;&quot;billCode&quot;:&quot;640010206680&quot;,&quot;blReturnBillId&quot;:0,&quot;blUntreadPieceId&quot;:0,&quot;clazz&quot;:&quot;2&quot;,&quot;dataFrom&quot;:&quot;2&quot;,&quot;dispatchId&quot;:0,&quot;ownerBagNo&quot;:&quot;3783585805&quot;,&quot;pdaCode&quot;:&quot;S50117101164&quot;,&quot;piece&quot;:1,&quot;preOrNexStaId&quot;:14761,&quot;preOrNextStation&quot;:&quot;\u6F6E\u6C55\u4E2D\u5FC3&quot;,&quot;prepProvinceId&quot;:440000,&quot;registerDate&quot;:1539724298000,&quot;scanDate&quot;:1539724241000,&quot;scanMan&quot;:&quot;\u9648\u4E9A\u5973&quot;,&quot;scanManCode&quot;:&quot;020019.0865&quot;,&quot;scanProvinceId&quot;:440000,&quot;scanSite&quot;:&quot;\u5E7F\u5DDE\u5E7F\u56ED&quot;,&quot;scanSiteId&quot;:1051037,&quot;scanType&quot;:&quot;\u53D1\u4EF6&quot;&#125;</span><br></pre></td></tr></table></figure>



<h1 id="通过messageId查询消息"><a href="#通过messageId查询消息" class="headerlink" title="通过messageId查询消息"></a>通过messageId查询消息</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin queryMsgById -n 192.168.x.x:9876 -i C0A801B400002A9F000005F308F9B3A5</span><br><span class="line"></span><br><span class="line">&quot;i&quot;, &quot;msgId&quot;, true, &quot;Message Id&quot;</span><br><span class="line"></span><br><span class="line">&quot;consumerGroup&quot;, true, &quot;consumer group name&quot;</span><br><span class="line"></span><br><span class="line">&quot;clientId&quot;, true, &quot;The consumer&#39;s client id&quot;</span><br><span class="line"></span><br><span class="line">&quot;sendMessage&quot;, true, &quot;resend message&quot;</span><br><span class="line"></span><br><span class="line">&quot;unitName&quot;, true, &quot;unit name&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin queryMsgById -n 192.168.x.x:9876 -i C0A801B400002A9F000005F308F9B3A5</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option PermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">OffsetID:      C0A801B400002A9F000005F308F9B3A5</span><br><span class="line"></span><br><span class="line">OffsetID:      C0A801B400002A9F000005F308F9B3A5</span><br><span class="line"></span><br><span class="line">Topic:        SCANRECORD</span><br><span class="line"></span><br><span class="line">Tags:        [2]</span><br><span class="line"></span><br><span class="line">Keys:        [1dd04932-b7d9-43ee-8b31-39d16dd043d4]</span><br><span class="line"></span><br><span class="line">Queue ID:      20</span><br><span class="line"></span><br><span class="line">Queue Offset:    35052080</span><br><span class="line"></span><br><span class="line">CommitLog Offset:  6541385773989</span><br><span class="line"></span><br><span class="line">Reconsume Times:   0</span><br><span class="line"></span><br><span class="line">Born Timestamp:   2018-10-17 05:11:39,798</span><br><span class="line"></span><br><span class="line">Store Timestamp:   2018-10-17 05:11:39,179</span><br><span class="line"></span><br><span class="line">Born Host:      192.168.31.129:29781</span><br><span class="line"></span><br><span class="line">Store Host:     192.168.1.180:10911</span><br><span class="line"></span><br><span class="line">System Flag:     0</span><br><span class="line"></span><br><span class="line">Properties:     &#123;KEYS&#x3D;1dd04932-b7d9-43ee-8b31-39d16dd043d4, UNIQ_KEY&#x3D;C0A81F8166832F2C9B1953831616FB45, WAIT&#x3D;true, TAGS&#x3D;2&#125;</span><br><span class="line"></span><br><span class="line">Message Body Path:  &#x2F;tmp&#x2F;rocketmq&#x2F;msgbodys&#x2F;C0A81F8166832F2C9B1953831616FB45</span><br><span class="line"></span><br><span class="line">MessageTrack [consumerGroup&#x3D;ZtoSignGroup, trackType&#x3D;CONSUMED_BUT_FILTERED, exceptionDesc&#x3D;null]MessageTrack [consumerGroup&#x3D;newOpenPartnerDeadlineJob, trackType&#x3D;CONSUMED_BUT_FILTERED, exceptionDesc&#x3D;null]MessageTrack [consumerGroup&#x3D;smartidivision-scanrecord-dis, trackType&#x3D;CONSUMED_BUT_FILTERED, exceptionDesc&#x3D;null]MessageTrack [consumerGroup&#x3D;PanguRecordGroup, trackType&#x3D;CONSUMED, exceptionDesc&#x3D;null]MessageTrack [consumerGroup&#x3D;code-send-consumer, trackType&#x3D;CONSUMED_BUT_FILTERED, exceptionDesc&#x3D;null]MessageTrack [consumerGroup&#x3D;shenZhouOneSiteKpiConsumer, trackType&#x3D;CONSUMED, exceptionDesc&#x3D;null]MessageTrack [consumerGroup&#x3D;SortComplementConsumer, trackType&#x3D;CONSUMED_BUT_FILTERED, exceptionDesc&#x3D;null]MessageTrack [consumerGroup&#x3D;tf_wonder_waybill_center_scanrecord, trackType&#x3D;CONSUMED_BUT_FILTERED, exceptionDesc&#x3D;null]MessageTrack [consumerGroup&#x3D;dpmComScanRecordConsumer, trackType&#x3D;UNKNOWN, exceptionDesc&#x3D;org.apache.rocketmq.client.exception.MQClientException: CODE: 17 DESC: No topic route info in name server for the topic: %RETRY%dpmComScanRecordConsumer</span><br><span class="line"></span><br><span class="line">See [http:&#x2F;&#x2F;rocketmq.apache.org&#x2F;docs&#x2F;faq&#x2F;](http:&#x2F;&#x2F;rocketmq.apache.org&#x2F;docs&#x2F;faq&#x2F;) for further details., org.apache.rocketmq.client.impl.MQClientAPIImpl.getTopicRouteInfoFromNameServer(MQClientAPIImpl.java:1212)]MessageTrack</span><br></pre></td></tr></table></figure>



<h1 id="根据key查询存储消息"><a href="#根据key查询存储消息" class="headerlink" title="根据key查询存储消息"></a>根据key查询存储消息</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin queryMsgByKey -n 192.168.x.x:9876 -t SCANRECORD -k 1dd04932-b7d9-43ee-8b31-39d16dd043d4</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option PermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">Message ID                    QID                 Offset</span><br><span class="line"></span><br><span class="line">C0A81F8166832F2C9B1953831616FB45           20                 35052080</span><br></pre></td></tr></table></figure>



<h1 id="根据offset查询储存消息"><a href="#根据offset查询储存消息" class="headerlink" title="根据offset查询储存消息"></a>根据offset查询储存消息</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin queryMsgByOffset -n 192.168.x.x:9876 -t SCANRECORD -b broker-a -i 20 -o 35052080</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option PermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">OffsetID:      C0A801B400002A9F000005F308F9B3A5</span><br><span class="line"></span><br><span class="line">OffsetID:      C0A801B400002A9F000005F308F9B3A5</span><br><span class="line"></span><br><span class="line">Topic:        SCANRECORD</span><br><span class="line"></span><br><span class="line">Tags:        [2]</span><br><span class="line"></span><br><span class="line">Keys:        [1dd04932-b7d9-43ee-8b31-39d16dd043d4]</span><br><span class="line"></span><br><span class="line">Queue ID:      20</span><br><span class="line"></span><br><span class="line">Queue Offset:    35052080</span><br><span class="line"></span><br><span class="line">CommitLog Offset:  6541385773989</span><br><span class="line"></span><br><span class="line">Reconsume Times:   0</span><br><span class="line"></span><br><span class="line">Born Timestamp:   2018-10-17 05:11:39,798</span><br><span class="line"></span><br><span class="line">Store Timestamp:   2018-10-17 05:11:39,179</span><br><span class="line"></span><br><span class="line">Born Host:      192.168.31.129:29781</span><br><span class="line"></span><br><span class="line">Store Host:     192.168.1.180:10911</span><br><span class="line"></span><br><span class="line">System Flag:     0</span><br><span class="line"></span><br><span class="line">Properties:     &#123;MIN_OFFSET&#x3D;35046369, MAX_OFFSET&#x3D;40342481, KEYS&#x3D;1dd04932-b7d9-43ee-8b31-39d16dd043d4, UNIQ_KEY&#x3D;C0A81F8166832F2C9B1953831616FB45, WAIT&#x3D;true, TAGS&#x3D;2&#125;</span><br><span class="line"></span><br><span class="line">Message Body Path:  &#x2F;tmp&#x2F;rocketmq&#x2F;msgbodys&#x2F;C0A81F8166832F2C9B1953831616FB45</span><br><span class="line"></span><br><span class="line">MessageTrack [consumerGroup&#x3D;ZtoSignGroup, trackType&#x3D;CONSUMED_BUT_FILTERED, exceptionDesc&#x3D;null]MessageTrack [consumerGroup&#x3D;newOpenPartnerDeadlineJob, trackType&#x3D;CONSUMED_BUT_FILTERED, exceptionDesc&#x3D;null]MessageTrack [consumerGroup&#x3D;smartidivision-scanrecord-dis, trackType&#x3D;CONSUMED_BUT_FILTERED, exceptionDesc&#x3D;null]MessageTrack [consumerGroup&#x3D;PanguRecordGroup, trackType&#x3D;CONSUMED, exceptionDesc&#x3D;null]MessageTrack [consumerGroup&#x3D;code-send-consumer, trackType&#x3D;CONSUMED_BUT_FILTERED, exceptionDesc&#x3D;null]MessageTrack [consumerGroup&#x3D;shenZhouOneSiteKpiConsumer, trackType&#x3D;CONSUMED, exceptionDesc&#x3D;null]MessageTrack [consumerGroup&#x3D;SortComplementConsumer, trackType&#x3D;CONSUMED_BUT_FILTERED, exceptionDesc&#x3D;null]MessageTrack [consumerGroup&#x3D;tf_wonder_waybill_center_scanrecord, trackType&#x3D;CONSUMED_BUT_FILTERED, exceptionDesc&#x3D;null]MessageTrack [consumerGroup&#x3D;dpmComScanRecordConsumer, trackType&#x3D;UNKNOWN, exceptionDesc&#x3D;org.apache.rocketmq.client.exception.MQClientException: CODE: 17 DESC: No topic route info in name server for the topic: %RETRY%dpmComScanRecordConsumer</span><br><span class="line"></span><br><span class="line">See [http:&#x2F;&#x2F;rocketmq.apache.org&#x2F;docs&#x2F;faq&#x2F;](http:&#x2F;&#x2F;rocketmq.apache.org&#x2F;docs&#x2F;faq&#x2F;) for further details., org.apache.rocketmq.client.impl.MQClientAPIImpl.getTopicRouteInfoFromNameServer(MQClientAPIImpl.java:1212)]MessageTrack [</span><br><span class="line"></span><br><span class="line">&quot;t&quot;, &quot;topic&quot;, true, &quot;topic name&quot;</span><br><span class="line"></span><br><span class="line">&quot;b&quot;, &quot;brokerName&quot;, true, &quot;Broker Name&quot;</span><br><span class="line"></span><br><span class="line">&quot;i&quot;, &quot;queueId&quot;, true, &quot;Queue Id&quot;</span><br><span class="line"></span><br><span class="line">&quot;o&quot;, &quot;offset&quot;, true, &quot;Queue Offset&quot;</span><br></pre></td></tr></table></figure>



<h1 id="通过UniqueKey查询消息内容"><a href="#通过UniqueKey查询消息内容" class="headerlink" title="通过UniqueKey查询消息内容"></a>通过UniqueKey查询消息内容</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin queryMsgByUniqueKey -n 192.168.x.x:9876 -t SCANRECORD -i C0A801B400002A9F000005F308F9B3A5</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option PermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">Topic:        SCANRECORD</span><br><span class="line"></span><br><span class="line">Tags:        [2]</span><br><span class="line"></span><br><span class="line">Keys:        [1dd04932-b7d9-43ee-8b31-39d16dd043d4]</span><br><span class="line"></span><br><span class="line">Queue ID:      20</span><br><span class="line"></span><br><span class="line">Queue Offset:    35052080</span><br><span class="line"></span><br><span class="line">CommitLog Offset:  6541385773989</span><br><span class="line"></span><br><span class="line">Reconsume Times:   0</span><br><span class="line"></span><br><span class="line">Born Timestamp:   2018-10-17 05:11:39,798</span><br><span class="line"></span><br><span class="line">Store Timestamp:   2018-10-17 05:11:39,179</span><br><span class="line"></span><br><span class="line">Born Host:      192.168.31.129:29781</span><br><span class="line"></span><br><span class="line">Store Host:     192.168.1.180:10911</span><br><span class="line"></span><br><span class="line">System Flag:     0</span><br><span class="line"></span><br><span class="line">Properties:     &#123;KEYS&#x3D;1dd04932-b7d9-43ee-8b31-39d16dd043d4, UNIQ_KEY&#x3D;C0A81F8166832F2C9B1953831616FB45, WAIT&#x3D;true, TAGS&#x3D;2&#125;</span><br><span class="line"></span><br><span class="line">Message Body Path:  &#x2F;tmp&#x2F;rocketmq&#x2F;msgbodys&#x2F;C0A81F8166832F2C9B1953831616FB45</span><br><span class="line"></span><br><span class="line">MessageTrack [consumerGroup&#x3D;ZtoSignGroup, trackType&#x3D;CONSUMED_BUT_FILTERED, exceptionDesc&#x3D;null]MessageTrack [consumerGroup&#x3D;newOpenPartnerDeadlineJob, trackType&#x3D;CONSUMED_BUT_FILTERED, exceptionDesc&#x3D;null]MessageTrack [consumerGroup&#x3D;smartidivision-scanrecord-dis, trackType&#x3D;CONSUMED_BUT_FILTERED, exceptionDesc&#x3D;null]MessageTrack [consumerGroup&#x3D;PanguRecordGroup, trackType&#x3D;CONSUMED, exceptionDesc&#x3D;null]MessageTrack [consumerGroup&#x3D;code-send-consumer, trackType&#x3D;CONSUMED_BUT_FILTERED, exceptionDesc&#x3D;null]MessageTrack [consumerGroup&#x3D;shenZhouOneSiteKpiConsumer, trackType&#x3D;CONSUMED, exceptionDesc&#x3D;null]MessageTrack [consumerGroup&#x3D;SortComplementConsumer, trackType&#x3D;CONSUMED_BUT_FILTERED, exceptionDesc&#x3D;null]MessageTrack [consumerGroup&#x3D;tf_wonder_waybill_center_scanrecord, trackType&#x3D;CONSUMED_BUT_FILTERED, exceptionDesc&#x3D;null]MessageTrack [consumerGroup&#x3D;dpmComScanRecordConsumer, trackType&#x3D;UNKNOWN, exceptionDesc&#x3D;org.apache.rocketmq.client.exception.MQClientException: CODE: 17 DESC: No topic route info in name server for the topic: %RETRY%dpmComScanRecordConsumer</span><br><span class="line"></span><br><span class="line">See [http:&#x2F;&#x2F;rocketmq.apache.org&#x2F;docs&#x2F;faq&#x2F;](http:&#x2F;&#x2F;rocketmq.apache.org&#x2F;docs&#x2F;faq&#x2F;) for further details., org.apache.rocketmq.client.impl.MQClientAPIImpl.getTopicRouteInfoFromNameServer(MQClientAPIImpl.java:1212)]MessageTrack </span><br><span class="line"></span><br><span class="line">&quot;i&quot;, &quot;msgId&quot;, true, &quot;Message Id&quot;</span><br><span class="line"></span><br><span class="line">&quot;g&quot;, &quot;consumerGroup&quot;, true, &quot;consumer group name&quot;</span><br><span class="line"></span><br><span class="line">&quot;d&quot;, &quot;clientId&quot;, true, &quot;The consumer&#39;s client id&quot;</span><br><span class="line"></span><br><span class="line">&quot;t&quot;, &quot;topic&quot;, true, &quot;The topic of msg&quot;</span><br></pre></td></tr></table></figure>

</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ8# RocketMQ Topic相关命令</title>
    <url>/posts/48072e7/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="分配MQ"><a href="#分配MQ" class="headerlink" title="分配MQ"></a>分配MQ</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin allocateMQ -n localhost:9876 -t tst-topic -i ipList</span><br><span class="line"></span><br><span class="line">ipList 以逗号分隔</span><br></pre></td></tr></table></figure>



<h1 id="删除topic"><a href="#删除topic" class="headerlink" title="删除topic"></a>删除topic</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin deleteTopic -n localhost:9876 -t zto-example -c DefultCluster</span><br></pre></td></tr></table></figure>



<a id="more"></a>



<h1 id="获取topic的cluster"><a href="#获取topic的cluster" class="headerlink" title="获取topic的cluster"></a>获取topic的cluster</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin topicClusterList -n 192.168.1.x:9876 -t SCANRECORD</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option PermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">ZmsClusterB</span><br></pre></td></tr></table></figure>



<h1 id="查看Topic列表信息"><a href="#查看Topic列表信息" class="headerlink" title="查看Topic列表信息"></a>查看Topic列表信息</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin topicList -n localhost:9876</span><br></pre></td></tr></table></figure>



<h1 id="查看Topic路由信息"><a href="#查看Topic路由信息" class="headerlink" title="查看Topic路由信息"></a>查看Topic路由信息</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin topicRoute -n 192.168.1.x:9876 -t SCANRECORD</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option PermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&quot;brokerDatas&quot;:[</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&quot;brokerAddrs&quot;:&#123;0:&quot;192.168.1.x:10911&quot;,1:&quot;192.168.1.x:10920&quot;</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&quot;brokerName&quot;:&quot;broker-d&quot;</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&quot;brokerAddrs&quot;:&#123;0:&quot;192.168.1.x:10911&quot;,1:&quot;192.168.1.x:10920&quot;</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&quot;brokerName&quot;:&quot;broker-b&quot;</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&quot;brokerAddrs&quot;:&#123;0:&quot;192.168.1.x:10911&quot;,1:&quot;192.168.1.x:10915&quot;</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&quot;brokerName&quot;:&quot;broker-c&quot;</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&quot;brokerAddrs&quot;:&#123;0:&quot;192.168.1.x:10911&quot;,1:&quot;192.168.1.x:10915&quot;</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&quot;brokerName&quot;:&quot;broker-a&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">],</span><br><span class="line"></span><br><span class="line">&quot;filterServerTable&quot;:&#123;&#125;,</span><br><span class="line"></span><br><span class="line">&quot;queueDatas&quot;:[</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&quot;brokerName&quot;:&quot;broker-b&quot;,</span><br><span class="line"></span><br><span class="line">&quot;perm&quot;:6,</span><br><span class="line"></span><br><span class="line">&quot;readQueueNums&quot;:64,</span><br><span class="line"></span><br><span class="line">&quot;topicSynFlag&quot;:0,</span><br><span class="line"></span><br><span class="line">&quot;writeQueueNums&quot;:64</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&quot;brokerName&quot;:&quot;broker-a&quot;,</span><br><span class="line"></span><br><span class="line">&quot;perm&quot;:6,</span><br><span class="line"></span><br><span class="line">&quot;readQueueNums&quot;:64,</span><br><span class="line"></span><br><span class="line">&quot;topicSynFlag&quot;:0,</span><br><span class="line"></span><br><span class="line">&quot;writeQueueNums&quot;:64</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&quot;brokerName&quot;:&quot;broker-c&quot;,</span><br><span class="line"></span><br><span class="line">&quot;perm&quot;:6,</span><br><span class="line"></span><br><span class="line">&quot;readQueueNums&quot;:64,</span><br><span class="line"></span><br><span class="line">&quot;topicSynFlag&quot;:0,</span><br><span class="line"></span><br><span class="line">&quot;writeQueueNums&quot;:64</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&quot;brokerName&quot;:&quot;broker-d&quot;,</span><br><span class="line"></span><br><span class="line">&quot;perm&quot;:6,</span><br><span class="line"></span><br><span class="line">&quot;readQueueNums&quot;:64,</span><br><span class="line"></span><br><span class="line">&quot;topicSynFlag&quot;:0,</span><br><span class="line"></span><br><span class="line">&quot;writeQueueNums&quot;:64</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="查看topic状态"><a href="#查看topic状态" class="headerlink" title="查看topic状态"></a>查看topic状态</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin topicStatus -n 192.168.1.174:9876 -t SCANRECORD</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option PermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">Broker Name QID Min Offset Max Offset Last Updated</span><br><span class="line"></span><br><span class="line">broker-a 0 34757063 39718709 2018-10-22 13:54:32,526</span><br><span class="line"></span><br><span class="line">broker-a 1 34760194 39722786 2018-10-22 13:54:32,149</span><br><span class="line"></span><br><span class="line">broker-a 2 34765030 39734966 2018-10-22 13:54:32,537</span><br><span class="line"></span><br><span class="line">broker-a 3 34775398 39758820 2018-10-22 13:54:32,507</span><br><span class="line"></span><br><span class="line">broker-a 4 34804472 39800334 2018-10-22 13:54:32,511</span><br><span class="line"></span><br><span class="line">broker-a 5 34835232 39854584 2018-10-22 13:54:32,528</span><br><span class="line"></span><br><span class="line">broker-a 6 34863554 39910095 2018-10-22 13:54:32,528</span><br></pre></td></tr></table></figure>



<h1 id="更新orderConf"><a href="#更新orderConf" class="headerlink" title="更新orderConf"></a>更新orderConf</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh bin&#x2F;mqadmin updateOrderConf -t SCANRECORD -m put -n 192.168.1.x:9876</span><br><span class="line"></span><br><span class="line">-m option type [eg. put|get|delete</span><br></pre></td></tr></table></figure>



<h1 id="更改Topic权限"><a href="#更改Topic权限" class="headerlink" title="更改Topic权限"></a>更改Topic权限</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin updateTopicPerm -t SCANRECORD -p put -n 192.168.1.x:9876</span><br><span class="line"></span><br><span class="line">-p : set topic&#39;s permission(2|4|6), intro[2:W; 4:R; 6:RW]</span><br><span class="line"></span><br><span class="line">bin&#x2F;mqadmin updateTopicPerm -c ZmsClusterB -t %DLQ%starunion-freight -p 6 -n 192.168.1.x:9876</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option PermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">update topic perm from 2 to 6 in 192.168.1.x:10911 success.</span><br><span class="line"></span><br><span class="line">update topic perm from 2 to 6 in 192.168.1.x:10911 success.</span><br><span class="line"></span><br><span class="line">update topic perm from 2 to 6 in 192.168.1.x:10911 success.</span><br><span class="line"></span><br><span class="line">update topic perm from 2 to 6 in 192.168.1.x:10911 success.</span><br></pre></td></tr></table></figure>









<h1 id="创建-修改Topic"><a href="#创建-修改Topic" class="headerlink" title="创建/修改Topic"></a>创建/修改Topic</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh bin&#x2F;mqadmin updateTopic -c DefaultCluster -n localhost:9876 -t threezto-test -r 12 -w 12</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option PermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">create topic to x.x.x.40:10911 success.</span><br><span class="line"></span><br><span class="line">TopicConfig [topicName&#x3D;threezto-test, readQueueNums&#x3D;12, writeQueueNums&#x3D;12, perm&#x3D;RW-, topicFilterType&#x3D;SINGLE_TAG, topicSysFlag&#x3D;0, order&#x3D;false]</span><br><span class="line"></span><br><span class="line">-b brokerAddr create topic to which broker</span><br><span class="line"></span><br><span class="line">-c clusterName create topic to which cluster</span><br><span class="line"></span><br><span class="line">-t topic topic name</span><br><span class="line"></span><br><span class="line">-r readQueueNums set read queue nums</span><br><span class="line"></span><br><span class="line">-w writeQueueNums set write queue nums</span><br><span class="line"></span><br><span class="line">-p perm set topic&#39;s permission(2|4|6), intro[2:W 4:R; 6:RW]</span><br><span class="line"></span><br><span class="line">-o order set topic&#39;s order(true|false</span><br><span class="line"></span><br><span class="line">-u unit is unit topic (true|false</span><br><span class="line"></span><br><span class="line">-s hasUnitSub has unit sub (true|false</span><br></pre></td></tr></table></figure>

</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ9# RocketMQ Offset 相关命令</title>
    <url>/posts/5c6eeeec/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="克隆消费组的offset（同一个集群）"><a href="#克隆消费组的offset（同一个集群）" class="headerlink" title="克隆消费组的offset（同一个集群）"></a>克隆消费组的offset（同一个集群）</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin cloneGroupOffset -n 192.168.1.x:9876 -s SCANRECORD_GROUP -d my-tst-cloneoffset -t SCANRECORD</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option PermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">clone group offset success. srcGroup[SCANRECORD_GROUP], destGroup&#x3D;[my-tst-cloneoffset], topic[SCANRECORD][baseuser@HZPL001180 rocketmq]$</span><br></pre></td></tr></table></figure>



<a id="more"></a>



<h1 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin statsAll -t SCANRECORD -n 192.168.1.x:9876</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option PermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">Topic Consumer Group Accumulation InTPS OutTPS InMsg24Hour OutMsg24Hour</span><br><span class="line"></span><br><span class="line">SCANRECORD ZtoSignGroup 2290 3063.95 522.72 233588408 29106863</span><br><span class="line"></span><br><span class="line">SCANRECORD newOpenPartnerDeadlineJob 2641 3063.95 522.72 233588408 29052057</span><br><span class="line"></span><br><span class="line">SCANRECORD smartidivision-scanrecord-dis 3110 3063.95 399.03 233588408 30052791</span><br><span class="line"></span><br><span class="line">SCANRECORD PanguRecordGroup 574 3063.95 2041.17 233588408 174462813</span><br><span class="line"></span><br><span class="line">SCANRECORD code-send-consumer 881 3063.95 1162.63 233588408 60072932</span><br><span class="line"></span><br><span class="line">SCANRECORD shenZhouOneSiteKpiConsumer 669 3063.95 1798.57 233588408 137543100</span><br><span class="line"></span><br><span class="line">SCANRECORD SortComplementConsumer 2746 3063.95 522.72 233588408 11466488</span><br><span class="line"></span><br><span class="line">SCANRECORD **my-tst-cloneoffset** 0 3063.95 0.00 233588408 0</span><br><span class="line"></span><br><span class="line">SCANRECORD tf_wonder_waybill_center_scanrec 2516 3063.95 522.72 233588408 29056664</span><br><span class="line"></span><br><span class="line">SCANRECORD dpmComScanRecordConsumer 0 3063.95 0.00 233588408 0</span><br><span class="line"></span><br><span class="line">SCANRECORD zms_syncer_SCANRECORD 286 3063.95 3063.73 233588408 233588419</span><br></pre></td></tr></table></figure>





<h1 id="根据时间重置消费位点"><a href="#根据时间重置消费位点" class="headerlink" title="根据时间重置消费位点"></a>根据时间重置消费位点</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin resetOffsetByTime -n 192.168.1.x:9876 -g ReceiveOrderGroupNew -t SCANRECORD -s now</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option PermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">rollback consumer offset by specified group[ReceiveOrderGroupNew], topic[SCANRECORD], force[true], timestamp(string)[now], timestamp(long)[1540196941761]</span><br><span class="line"></span><br><span class="line">brokerName queueId offset</span><br><span class="line"></span><br><span class="line">broker-a 20 40375806</span><br><span class="line"></span><br><span class="line">broker-b 55 40209057</span><br><span class="line"></span><br><span class="line">broker-c 24 40151853</span><br><span class="line"></span><br><span class="line">broker-b 22 40284014</span><br><span class="line"></span><br><span class="line">broker-a 53 40321569</span><br><span class="line"></span><br><span class="line">broker-d 59 39980239</span><br><span class="line"></span><br><span class="line">bin&#x2F;mqadmin resetOffsetByTime -n 192.168.1.x:9876 -g ReceiveOrderGroupNew -t SCANRECORD -s 1540196941761</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option PermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">rollback consumer offset by specified group[ReceiveOrderGroupNew], topic[SCANRECORD], force[true], timestamp(string)[1540196941761], timestamp(long)[1540196941761]</span><br><span class="line"></span><br><span class="line">brokerName queueId offset</span><br><span class="line"></span><br><span class="line">broker-a 20 40375806</span><br><span class="line"></span><br><span class="line">broker-b 55 40209057</span><br><span class="line"></span><br><span class="line">broker-c 24 40151853</span><br><span class="line"></span><br><span class="line">broker-b 22 40284014</span><br><span class="line"></span><br><span class="line">&quot;g&quot;, &quot;group&quot;, true, &quot;set the consumer group&quot;</span><br><span class="line"></span><br><span class="line">&quot;s&quot;, &quot;timestamp&quot;, true, &quot;set the timestamp[now|currentTimeMillis|yyyy-MM-dd#HH:mm:ss:SSS]&quot;</span><br><span class="line"></span><br><span class="line">&quot;f&quot;, &quot;force&quot;, true, &quot;set the force rollback by timestamp switch[true|false]&quot;</span><br><span class="line"></span><br><span class="line">&quot;c&quot;, &quot;cplus&quot;, false, &quot;reset c++ client offset&quot;</span><br></pre></td></tr></table></figure>

</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>Nacos10# 健康检查类型与场景</title>
    <url>/posts/fb19022a/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>Nacos支持众多健康检查类型，心跳、HTTP、TCP、MySQL等类型，这些都作用于什么场景？他们又是如何事项的呢？本文就撸一撸这个。</p>
<h1 id="内容提要"><a href="#内容提要" class="headerlink" title="内容提要"></a>内容提要</h1><h3 id="临时节点续约"><a href="#临时节点续约" class="headerlink" title="临时节点续约"></a>临时节点续约</h3><ul>
<li>临时节点续约通过gRPC连接保鲜实现</li>
<li>执行频率5秒一次</li>
<li>检查结果健康刷新保鲜时间</li>
<li>检查结果不可用标记节点不健康</li>
<li>当节点不健康时重新连接时会从server列表选择下一个节点连接</li>
</ul>
<h3 id="持久节点心跳检测"><a href="#持久节点心跳检测" class="headerlink" title="持久节点心跳检测"></a>持久节点心跳检测</h3><ul>
<li>心跳执行器通过每隔五秒中向Nacos Server发起HTTP请求</li>
<li>如果返回的server not found会向Nacos Server发起注册请求重新注册</li>
</ul>
<h3 id="持久节点探活"><a href="#持久节点探活" class="headerlink" title="持久节点探活"></a>持久节点探活</h3><ul>
<li>Nacos探活只有在持久节点注册时才会支持</li>
<li>探活支持HTTP、TCP、Mysql三种探活类型</li>
<li>HTTP通过检测返回200状态码标记是否健康</li>
<li>TPC通过Channel连接方式标记是否健康</li>
<li>Mysql则保证当前节点为主节点，可用于主从切换场景</li>
</ul>
<a id="more"></a>



<h1 id="临时节点续约-1"><a href="#临时节点续约-1" class="headerlink" title="临时节点续约"></a>临时节点续约</h1><p>在《Nacos2# 服务注册与发现客户端示例与源码解析（二）》分析gRPC Client启动逻辑时有分析连接健康检查逻辑。具体代码在RpcClient#start()中，下面再次聚焦下。</p>
<h3 id="client连接心跳检查"><a href="#client连接心跳检查" class="headerlink" title="client连接心跳检查"></a>client连接心跳检查</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">clientEventExecutor.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 获取重定向连接上下文，指重新连接到其他server节点</span></span><br><span class="line">                ReconnectContext reconnectContext = reconnectionSignal</span><br><span class="line">                        .poll(keepAliveTime, TimeUnit.MILLISECONDS);</span><br><span class="line">                <span class="keyword">if</span> (reconnectContext == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// check alive time.</span></span><br><span class="line">                    <span class="comment">// client活动时间超过5秒钟，向Nacos Server发起健康检测</span></span><br><span class="line">                    <span class="keyword">if</span> (System.currentTimeMillis() - lastActiveTimeStamp &gt;= keepAliveTime) &#123;</span><br><span class="line">                        <span class="comment">// 发送健康检查</span></span><br><span class="line">                        <span class="keyword">boolean</span> isHealthy = healthCheck();</span><br><span class="line">                        <span class="comment">// 非健康节点</span></span><br><span class="line">                        <span class="keyword">if</span> (!isHealthy) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (currentConnection == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            LoggerUtils.printIfInfoEnabled(LOGGER,</span><br><span class="line">                                    <span class="string">&quot;[&#123;&#125;]Server healthy check fail,currentConnection=&#123;&#125;&quot;</span>, name,</span><br><span class="line">                                    currentConnection.getConnectionId());</span><br><span class="line">                            <span class="comment">// 标记客户端状态为unhealthy</span></span><br><span class="line">                            rpcClientStatus.set(RpcClientStatus.UNHEALTHY);</span><br><span class="line">                            <span class="comment">// 重置ReconnectContext移除serverInfo</span></span><br><span class="line">                            reconnectContext = <span class="keyword">new</span> ReconnectContext(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 健康连接更新时间戳</span></span><br><span class="line">                            lastActiveTimeStamp = System.currentTimeMillis();</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 心跳保鲜未过期，跳过本次检测</span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">               <span class="comment">// ...</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">                <span class="comment">//Do nothing</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h3 id="服务端响应"><a href="#服务端响应" class="headerlink" title="服务端响应"></a>服务端响应</h3><p>代码翻到GrpcRequestAcceptor#request部分，执行RequestHandler逻辑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Response response = requestHandler.handleRequest(request, requestMeta);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TpsControl(pointName = &quot;HealthCheck&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HealthCheckResponse <span class="title">handle</span><span class="params">(HealthCheckRequest request, RequestMeta meta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HealthCheckResponse();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当服务端收到健康检查请求时，通过HealthCheckRequestHandler#handle返回HealthCheckResponse。</p>
<h3 id="节点选择"><a href="#节点选择" class="headerlink" title="节点选择"></a>节点选择</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (startUpRetryTimes &gt; <span class="number">0</span> &amp;&amp; connectToServer == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        startUpRetryTimes--;</span><br><span class="line">        ServerInfo serverInfo = nextRpcServer(); <span class="comment">// 需连接的节点</span></span><br><span class="line"></span><br><span class="line">        LoggerUtils.printIfInfoEnabled(LOGGER, <span class="string">&quot;[&#123;&#125;] Try to connect to server on start up, server: &#123;&#125;&quot;</span>, name,</span><br><span class="line">                serverInfo);</span><br><span class="line"></span><br><span class="line">        connectToServer = connectToServer(serverInfo); <span class="comment">// 发起rpc连接，连接到集群中其他节点</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        LoggerUtils.printIfWarnEnabled(LOGGER,</span><br><span class="line">                <span class="string">&quot;[&#123;&#125;]Fail to connect to server on start up, error message=&#123;&#125;, start up retry times left: &#123;&#125;&quot;</span>,</span><br><span class="line">                name, e.getMessage(), startUpRetryTimes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在选择节点时从server地址列表中自增选择下一个。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">genNextServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = currentIndex.incrementAndGet() % getServerList().size(); <span class="comment">// 获取集群中下一个节点</span></span><br><span class="line">    <span class="keyword">return</span> getServerList().get(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="清理无效连接"><a href="#清理无效连接" class="headerlink" title="清理无效连接"></a>清理无效连接</h3><p>详见：RpcScheduledExecutor#start()；定时任务会清理无效连接</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定时任务每3秒执行一次</span></span><br><span class="line">RpcScheduledExecutor.COMMON_SERVER_EXECUTOR.scheduleWithFixedDelay(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 超过保鲜时间的连接，重新异步发起连接</span></span><br><span class="line">        connection.asyncRequest(clientDetectionRequest, <span class="keyword">new</span> RequestCallBack() &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 刷新激活时间</span></span><br><span class="line">        connection.freshActiveTime();</span><br><span class="line">        successConnections.add(outDateConnectionId);</span><br><span class="line">          </span><br><span class="line">        <span class="comment">//当失效时（保鲜时间超过20秒），注销关闭connection</span></span><br><span class="line">        unregister(outDateConnectionId);</span><br><span class="line">   	&#125;</span><br><span class="line"> &#125;, <span class="number">1000L</span>, <span class="number">3000L</span>, TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure>



<p><strong>小结：</strong> 在临时节点注册时，客户端gRPC启动时会启动一个守护线程用户健康检查；健康检查的频率为5秒执行一次；当检查结果健康则刷新保鲜时间；检查结果不可用标记gRPC客户端状态为unhealthy；不健康节点在发起连接时会从server地址列表中选择下一个发起连接；</p>
<p>服务端也会定时清理超过保鲜时间连接。</p>
<h1 id="永久节点心跳检测"><a href="#永久节点心跳检测" class="headerlink" title="永久节点心跳检测"></a>永久节点心跳检测</h1><p>永久节点心跳检测在《Nacos2# 服务注册与发现客户端示例与源码解析（二）》HTTP心跳检测器有详细分析，这里把内容要点摘录如下：</p>
<ul>
<li>HTTP心跳检测只适用于注册的节点持久节点，临时节点会使用grpc代理</li>
<li>心跳执行器通过每隔五秒中向Nacos Server发起HTTP请求</li>
<li>如果返回的server not found会向Nacos Server发起注册请求重新注册</li>
</ul>
<h1 id="持久节点探活-1"><a href="#持久节点探活-1" class="headerlink" title="持久节点探活"></a>持久节点探活</h1><p>持久节点探活支持HTTP、TCP和Mysql几种类型，下面以HTTP为例分析其运行逻辑。</p>
<h3 id="探活示例"><a href="#探活示例" class="headerlink" title="探活示例"></a>探活示例</h3><p>当注册时节点设置为不健康即Healthy设置为false，当服务端探活正常后将节点设置为健康即Healthy为true。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BootApplication</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  SpringApplication.run(BootApplication.class, args);</span><br><span class="line">  System.setProperty(<span class="string">&quot;serverAddr&quot;</span>, <span class="string">&quot;127.0.0.1:8848&quot;</span>);</span><br><span class="line">  System.setProperty(<span class="string">&quot;namespace&quot;</span>, <span class="string">&quot;public&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">  properties.setProperty(<span class="string">&quot;serverAddr&quot;</span>, System.getProperty(<span class="string">&quot;serverAddr&quot;</span>));</span><br><span class="line">  properties.setProperty(<span class="string">&quot;namespace&quot;</span>, System.getProperty(<span class="string">&quot;namespace&quot;</span>));</span><br><span class="line"></span><br><span class="line">  Instance instance = <span class="keyword">new</span> Instance();</span><br><span class="line">  instance.setClusterName(<span class="string">&quot;clusterDemo3&quot;</span>);</span><br><span class="line">  instance.setHealthy(<span class="keyword">false</span>);<span class="comment">//默认健康检查通过后，才认为是真正的健康</span></span><br><span class="line">  instance.setIp(getIpAddress());</span><br><span class="line">  instance.setPort(<span class="number">8282</span>);</span><br><span class="line">  instance.setWeight(<span class="number">100</span>);</span><br><span class="line">  instance.setServiceName(<span class="string">&quot;AppNacosDemo3&quot;</span>);</span><br><span class="line">  instance.setEphemeral(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">  Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">  map.put(<span class="string">&quot;unit&quot;</span>, <span class="string">&quot;shunit&quot;</span>);</span><br><span class="line">  instance.setMetadata(map);</span><br><span class="line"></span><br><span class="line">  NamingService naming = NamingFactory.createNamingService(properties);</span><br><span class="line">  naming.registerInstance(<span class="string">&quot;AppNacosDemo3&quot;</span>, instance);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getIpAddress</span><span class="params">()</span> <span class="keyword">throws</span> SocketException </span>&#123;</span><br><span class="line">  Enumeration&lt;NetworkInterface&gt; allNetInterfaces = NetworkInterface.getNetworkInterfaces();</span><br><span class="line">  <span class="keyword">while</span> (allNetInterfaces.hasMoreElements()) &#123;</span><br><span class="line">    NetworkInterface netInterface = allNetInterfaces.nextElement();</span><br><span class="line">    <span class="keyword">if</span> (!netInterface.isLoopback() &amp;&amp; !netInterface.isVirtual() &amp;&amp; netInterface.isUp()) &#123;</span><br><span class="line">      Enumeration&lt;InetAddress&gt; addresses = netInterface.getInetAddresses();</span><br><span class="line">      <span class="keyword">while</span> (addresses.hasMoreElements()) &#123;</span><br><span class="line">        InetAddress ip = addresses.nextElement();</span><br><span class="line">        <span class="keyword">final</span> String hostAddress = ip.getHostAddress();</span><br><span class="line">        <span class="keyword">if</span> (ip <span class="keyword">instanceof</span> Inet4Address) &#123;</span><br><span class="line">          <span class="keyword">return</span> hostAddress;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/bike&quot;,method = RequestMethod.GET)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;receive message from server.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="探活地址设置"><a href="#探活地址设置" class="headerlink" title="探活地址设置"></a>探活地址设置</h3><p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210714202054.png"></p>
<p>探活输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">receive message from server.</span><br><span class="line">receive message from server.</span><br></pre></td></tr></table></figure>



<p><strong>小结：</strong> 启动时注册节点为非健康节点，Nacos通过检查路径请求返回200正确后将节点设置为健康状态。</p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>当持久节点注册时，会请求到InstanceController#register方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerInstance</span><span class="params">(String namespaceId, String serviceName, Instance instance)</span></span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> ephemeral = instance.isEphemeral();</span><br><span class="line">  String clientId = IpPortBasedClient.getClientId(instance.toInetAddr(), ephemeral);</span><br><span class="line">  createIpPortClientIfAbsent(clientId, ephemeral); <span class="comment">// 创建IpPortClient</span></span><br><span class="line">  Service service = getService(namespaceId, serviceName, ephemeral);</span><br><span class="line">  clientOperationService.registerInstance(service, instance, clientId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">IpPortBasedClient</span><span class="params">(String clientId, <span class="keyword">boolean</span> ephemeral)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.ephemeral = ephemeral;</span><br><span class="line">    <span class="keyword">this</span>.clientId = clientId;</span><br><span class="line">    <span class="keyword">this</span>.responsibleId = getResponsibleTagFromId();</span><br><span class="line">    <span class="keyword">if</span> (ephemeral) &#123;</span><br><span class="line">        beatCheckTask = <span class="keyword">new</span> ClientBeatCheckTaskV2(<span class="keyword">this</span>);</span><br><span class="line">        HealthCheckReactor.scheduleCheck(beatCheckTask);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      	<span class="comment">// 持久节点创建HealthCheckTaskV2并定时任务调度</span></span><br><span class="line">        healthCheckTaskV2 = <span class="keyword">new</span> HealthCheckTaskV2(<span class="keyword">this</span>);</span><br><span class="line">        HealthCheckReactor.scheduleCheck(healthCheckTaskV2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doHealthCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 获取Client的service列表</span></span><br><span class="line">    <span class="keyword">for</span> (Service each : client.getAllPublishedService()) &#123;</span><br><span class="line">      <span class="comment">// 开启健康检查</span></span><br><span class="line">      <span class="keyword">if</span> (switchDomain.isHealthCheckEnabled(each.getGroupedServiceName())) &#123;</span><br><span class="line">        <span class="comment">// 注册节点信息</span></span><br><span class="line">        InstancePublishInfo instancePublishInfo = client.getInstancePublishInfo(each);</span><br><span class="line">        ClusterMetadata metadata = getClusterMetadata(each, instancePublishInfo);</span><br><span class="line">        <span class="comment">// 调用</span></span><br><span class="line">        ApplicationUtils.getBean(HealthCheckProcessorV2Delegate.class).process(<span class="keyword">this</span>, each, metadata);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">   	</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!cancelled) &#123;</span><br><span class="line">      <span class="comment">// 下一轮调度</span></span><br><span class="line">      HealthCheckReactor.scheduleCheck(<span class="keyword">this</span>);</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.getCheckRtWorst() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">// ...</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>备注：定时任务调度，不断向服务的注册节点发送探活请求。</p>
<p><strong>探活处理器选择</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210714191750.png"></p>
<p>备注：由运行时缓存情况可以看出，支持TPC、HTTP、MYSQL三种类型探活处理。</p>
<p><strong>HTTP探活</strong> </p>
<p>代码坐标HttpHealthCheckProcessor#process</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(HealthCheckTaskV2 task, Service service, ClusterMetadata metadata)</span> </span>&#123;</span><br><span class="line">    HealthCheckInstancePublishInfo instance = (HealthCheckInstancePublishInfo) task.getClient()</span><br><span class="line">            .getInstancePublishInfo(service);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == instance) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// TODO handle marked(white list) logic like v1.x.</span></span><br><span class="line">        <span class="keyword">if</span> (!instance.tryStartCheck()) &#123;</span><br><span class="line">           	<span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Http healthChecker = (Http) metadata.getHealthChecker();</span><br><span class="line">        <span class="comment">// 默认使用注册实例端口</span></span><br><span class="line">        <span class="keyword">int</span> ckPort = metadata.isUseInstancePortForCheck() ? instance.getPort() : metadata.getHealthyCheckPort();</span><br><span class="line">        <span class="comment">// 组织url请求</span></span><br><span class="line">        URL host = <span class="keyword">new</span> URL(<span class="string">&quot;http://&quot;</span> + instance.getIp() + <span class="string">&quot;:&quot;</span> + ckPort);</span><br><span class="line">        URL target = <span class="keyword">new</span> URL(host, healthChecker.getPath());</span><br><span class="line">        Map&lt;String, String&gt; customHeaders = healthChecker.getCustomHeaders();</span><br><span class="line">        Header header = Header.newInstance();</span><br><span class="line">        header.addAll(customHeaders);</span><br><span class="line">        <span class="comment">// 发送HTTP请求</span></span><br><span class="line">        ASYNC_REST_TEMPLATE.get(target.toString(), header, Query.EMPTY, String.class,</span><br><span class="line">                <span class="keyword">new</span> HttpHealthCheckCallback(instance, task, service));</span><br><span class="line">        MetricsMonitor.getHttpHealthCheckMonitor().incrementAndGet();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        instance.setCheckRt(switchDomain.getHttpHealthParams().getMax());</span><br><span class="line">        healthCheckCommon.checkFail(task, service, <span class="string">&quot;http:error:&quot;</span> + e.getMessage());</span><br><span class="line">        healthCheckCommon.reEvaluateCheckRT(switchDomain.getHttpHealthParams().getMax(), task,</span><br><span class="line">                switchDomain.getHttpHealthParams());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(RestResult&lt;String&gt; result)</span> </span>&#123;</span><br><span class="line">    instance.setCheckRt(System.currentTimeMillis() - startTime);</span><br><span class="line">    <span class="keyword">int</span> httpCode = result.getCode();</span><br><span class="line">    <span class="comment">// 返回200</span></span><br><span class="line">    <span class="keyword">if</span> (HttpURLConnection.HTTP_OK == httpCode) &#123;</span><br><span class="line">        <span class="comment">// 将节点变更为健康</span></span><br><span class="line">        healthCheckCommon.checkOk(task, service, <span class="string">&quot;http:&quot;</span> + httpCode);</span><br><span class="line">        healthCheckCommon.reEvaluateCheckRT(System.currentTimeMillis() - startTime, task,</span><br><span class="line">                switchDomain.getHttpHealthParams());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (HttpURLConnection.HTTP_UNAVAILABLE == httpCode</span><br><span class="line">            || HttpURLConnection.HTTP_MOVED_TEMP == httpCode) &#123;</span><br><span class="line">       </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkOk</span><span class="params">(HealthCheckTaskV2 task, Service service, String msg)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 节点设置为健康状态</span></span><br><span class="line">   healthStatusSynchronizer.instanceHealthStatusChange(<span class="keyword">true</span>, task.getClient(), service, instance);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>备注：向节点发起HTTP请求，返回状态码为200表示，将节点标志为健康状态；否则标记非健康状态。</p>
<p><strong>TCP探活</strong></p>
<p>TPC探活的代码详见TcpHealthCheckProcessor，不再详细分析。大体逻辑为通过与注册实例建立channel，不断ping 注册实例的端口是否可用，从而判断服务是否健康。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210715192801.png"></p>
<h3 id="MYSQL探活"><a href="#MYSQL探活" class="headerlink" title="MYSQL探活"></a>MYSQL探活</h3><p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210715173009.png"></p>
<p>备注：主要检查当前节点为主库，不能访问到从库，可能在主从切换中使用。</p>
<p><strong>总结：</strong> 本文就临时节点续约、持久节点心跳、持久节点的探活代码实现做了熟练。相信通过代码走查，对其使用场景和实现不再陌生。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>Nacos</category>
      </categories>
      <tags>
        <tag>Nacos</tag>
      </tags>
  </entry>
  <entry>
    <title>Nacos11# 图解|注册发现核心原理提点</title>
    <url>/posts/183278ff/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>通过对Nacos注册与发现源码阅读，将其核心原理归纳提炼。包含：注册、发现、节点之间通信、健康检查类型。</p>
<h1 id="服务注册原理"><a href="#服务注册原理" class="headerlink" title="服务注册原理"></a>服务注册原理</h1><p>当客户端发起注册时，注册原理逻辑见下图，进一步简化主要有：</p>
<ul>
<li>将新注册的实例信息推送给订阅该服务的订阅者</li>
<li>将新注册的实例信息增量同步给集群中的其他节点</li>
</ul>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210716135220.png"></p>
<a id="more"></a>



<h1 id="服务发现原理"><a href="#服务发现原理" class="headerlink" title="服务发现原理"></a>服务发现原理</h1><p>服务发现的逻辑进一步简化为：</p>
<ul>
<li>定时从注册中心查询最新服务实例列表信息</li>
<li>定时频率通常为6秒，发生异常为60秒</li>
</ul>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210716135323.png"></p>
<h1 id="集群节点通信原理"><a href="#集群节点通信原理" class="headerlink" title="集群节点通信原理"></a>集群节点通信原理</h1><p>集群中节点通信原理可以进一步简化为：</p>
<ul>
<li><p>每个节点用于全量的注册快照信息</p>
</li>
<li><p>新节点加入集群时会从集群中某节点发起全量同步</p>
</li>
<li><p>节点之间每隔5秒校验缓存的注册快照信息</p>
</li>
<li><p>节点之间每隔2秒进行一轮健康检查用于关闭/新建/刷新gRPC连接</p>
</li>
</ul>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210716135412.png"></p>
<h1 id="健康检查类型与场景"><a href="#健康检查类型与场景" class="headerlink" title="健康检查类型与场景"></a>健康检查类型与场景</h1><p>健康检查类型与场景进一步可以简化为：</p>
<ul>
<li><p>临时节点通过gRPC连接保鲜实现，保鲜频率为5秒</p>
</li>
<li><p>临时节点注册使用Distro协议，持久节点注册使用Raft协议</p>
</li>
<li><p>持久节点支持客户端心跳和服务端探活两种方式</p>
</li>
<li><p>持久节点探活支持HTTP、TCP等探活类型</p>
</li>
</ul>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210716135453.png"></p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>Nacos</category>
      </categories>
      <tags>
        <tag>Nacos</tag>
      </tags>
  </entry>
  <entry>
    <title>Nacos12# 随机权重负载均衡算法</title>
    <url>/posts/bef6941/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>Nacos在Client选择节点时提供了一种基于权重的随机算法，通过源码分析掌握其实现原理，方便实战中加以运用。</p>
<h1 id="内容提要"><a href="#内容提要" class="headerlink" title="内容提要"></a>内容提要</h1><p>下面以图示的方式贯穿下随机权重负载均衡算法的流程：</p>
<p><strong>节点列表</strong> </p>
<p>假设注册了5个节点，每个节点的权重如下。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/%E7%A4%BA%E4%BE%8B%E6%B3%A8%E5%86%8C%E8%8A%82%E7%82%B9%E5%88%97%E8%A1%A8.png"></p>
<a id="more"></a>



<p><strong>组织递增数组</strong> </p>
<p>目的在于形成weights数组，该数组元素取值[0~1]范围，元素逐个递增，计算过程如下图示。另外注意非健康节点或者权重小于等于0的不会被选择。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/%E7%BB%84%E7%BB%87%E9%80%92%E5%A2%9E%E6%95%B0%E7%BB%84.png"></p>
<p><strong>随机算法</strong> </p>
<p>通过生成[0~1]范围的随机数，通过二分法查找递增数组weights[]接近的index，再从注册节点列表中返回节点。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/%E6%9D%83%E9%87%8D%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95%20(1).png"></p>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>随机权重负载均衡算法是在NacosNamingService#selectOneHealthyInstance提供，一起走查下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Instance <span class="title">selectOneHealthyInstance</span><span class="params">(String serviceName, String groupName, <span class="keyword">boolean</span> subscribe)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> selectOneHealthyInstance(serviceName, groupName, <span class="keyword">new</span> ArrayList&lt;String&gt;(), subscribe);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Instance <span class="title">selectOneHealthyInstance</span><span class="params">(String serviceName, String groupName, List&lt;String&gt; clusters,</span></span></span><br><span class="line"><span class="function"><span class="params">                                         <span class="keyword">boolean</span> subscribe)</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">  String clusterString = StringUtils.join(clusters, <span class="string">&quot;,&quot;</span>);</span><br><span class="line">  <span class="comment">// 注解@1</span></span><br><span class="line">  <span class="keyword">if</span> (subscribe) &#123;</span><br><span class="line">    ServiceInfo serviceInfo = serviceInfoHolder.getServiceInfo(serviceName, groupName, clusterString);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == serviceInfo) &#123;</span><br><span class="line">      serviceInfo = clientProxy.subscribe(serviceName, groupName, clusterString);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Balancer.RandomByWeight.selectHost(serviceInfo);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 注解@2</span></span><br><span class="line">    ServiceInfo serviceInfo = clientProxy</span><br><span class="line">      .queryInstancesOfService(serviceName, groupName, clusterString, <span class="number">0</span>, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">return</span> Balancer.RandomByWeight.selectHost(serviceInfo);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@1</strong> 已订阅「从缓存获取注册节点列表」，默认subscribe为true。</p>
<p><strong>注解@2</strong> 从 「从服务器获取注册节点列表」</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> Instance <span class="title">getHostByRandomWeight</span><span class="params">(List&lt;Instance&gt; hosts)</span> </span>&#123;</span><br><span class="line">  NAMING_LOGGER.debug(<span class="string">&quot;entry randomWithWeight&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (hosts == <span class="keyword">null</span> || hosts.size() == <span class="number">0</span>) &#123;</span><br><span class="line">    NAMING_LOGGER.debug(<span class="string">&quot;hosts == null || hosts.size() == 0&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  NAMING_LOGGER.debug(<span class="string">&quot;new Chooser&quot;</span>);</span><br><span class="line">  List&lt;Pair&lt;Instance&gt;&gt; hostsWithWeight = <span class="keyword">new</span> ArrayList&lt;Pair&lt;Instance&gt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (Instance host : hosts) &#123;</span><br><span class="line">    <span class="keyword">if</span> (host.isHealthy()) &#123;  <span class="comment">// 注解@3</span></span><br><span class="line">      hostsWithWeight.add(<span class="keyword">new</span> Pair&lt;Instance&gt;(host, host.getWeight()));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  NAMING_LOGGER.debug(<span class="string">&quot;for (Host host : hosts)&quot;</span>);</span><br><span class="line">  Chooser&lt;String, Instance&gt; vipChooser = <span class="keyword">new</span> Chooser&lt;String, Instance&gt;(<span class="string">&quot;www.taobao.com&quot;</span>);</span><br><span class="line">  <span class="comment">// 注解@4</span></span><br><span class="line">  vipChooser.refresh(hostsWithWeight);</span><br><span class="line">  NAMING_LOGGER.debug(<span class="string">&quot;vipChooser.refresh&quot;</span>);</span><br><span class="line">  <span class="comment">// 注解@5</span></span><br><span class="line">  <span class="keyword">return</span> vipChooser.randomWithWeight();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@3</strong> 非健康节点不会被选中，组装Pair的列表，包含健康节点的权重和Host信息</p>
<p><strong>注解@4</strong> 刷新需要的数据，具体包括三部分：所有健康节点权重求和、计算每个健康节点权重占比、组织递增数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Double originWeightSum = (<span class="keyword">double</span>) <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 注解@4.1</span></span><br><span class="line">    <span class="keyword">for</span> (Pair&lt;T&gt; item : itemsWithWeight) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> weight = item.weight();</span><br><span class="line">        <span class="comment">// ignore item which weight is zero.see test_randomWithWeight_weight0 in ChooserTest</span></span><br><span class="line">        <span class="comment">// weight小于等于 0的将会剔除</span></span><br><span class="line">        <span class="keyword">if</span> (weight &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        items.add(item.item());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 值如果无穷大</span></span><br><span class="line">        <span class="keyword">if</span> (Double.isInfinite(weight)) &#123;</span><br><span class="line">            weight = <span class="number">10000.0D</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 值如果为非数字值</span></span><br><span class="line">        <span class="keyword">if</span> (Double.isNaN(weight)) &#123;</span><br><span class="line">            weight = <span class="number">1.0D</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 累加权重总和</span></span><br><span class="line">        originWeightSum += weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注解@4.2</span></span><br><span class="line">    <span class="keyword">double</span>[] exactWeights = <span class="keyword">new</span> <span class="keyword">double</span>[items.size()];</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Pair&lt;T&gt; item : itemsWithWeight) &#123;</span><br><span class="line">        <span class="keyword">double</span> singleWeight = item.weight();</span><br><span class="line">        <span class="comment">//ignore item which weight is zero.see test_randomWithWeight_weight0 in ChooserTest</span></span><br><span class="line">        <span class="keyword">if</span> (singleWeight &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 每个节点权重的占比</span></span><br><span class="line">        exactWeights[index++] = singleWeight / originWeightSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注解@4.3</span></span><br><span class="line">    weights = <span class="keyword">new</span> <span class="keyword">double</span>[items.size()];</span><br><span class="line">    <span class="keyword">double</span> randomRange = <span class="number">0D</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">        weights[i] = randomRange + exactWeights[i];</span><br><span class="line">        randomRange += exactWeights[i];</span><br><span class="line">    &#125;</span><br><span class="line">		</span><br><span class="line">    <span class="keyword">double</span> doublePrecisionDelta = <span class="number">0.0001</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index == <span class="number">0</span> || (Math.abs(weights[index - <span class="number">1</span>] - <span class="number">1</span>) &lt; doublePrecisionDelta)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">            <span class="string">&quot;Cumulative Weight caculate wrong , the sum of probabilities does not equals 1.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@4.1</strong> 所有健康节点权重求和originWeightSum</p>
<p><strong>注解@4.2</strong> 计算每个健康节点权重占比exactWeights数组</p>
<p><strong>注解@4.3</strong> 组织递增数组weights，每个元素值为数组前面元素之和</p>
<p>以一个例子来表示这个过程，假设有5个节点：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.2.3.4 100</span><br><span class="line">1.2.3.5 100</span><br><span class="line">1.2.3.6	100</span><br><span class="line">1.2.3.7	80</span><br><span class="line">1.2.3.8	60</span><br></pre></td></tr></table></figure>

<p><strong>步骤一  计算节点权重求和</strong> </p>
<p>originWeightSum = 100 + 100 + 100 + 80 + 60 = 440</p>
<p><strong>步骤二 计算每个节点权重占比</strong> </p>
<p>exactWeights[0] = 0.2272</p>
<p>exactWeights[1] = 0.2272</p>
<p>exactWeights[2] = 0.2272</p>
<p>exactWeights[3] = 0.1818</p>
<p>exactWeights[4] = 0.1363</p>
<p><strong>步骤三 组织递增数组weights</strong> </p>
<p>weights[0] = 0.2272</p>
<p>weights[1] = 0.4544</p>
<p>weights[2] = 0.6816</p>
<p>weights[3] = 0.8634</p>
<p>weights[4] = 1</p>
<p><strong>注解@5</strong> 随机选取一个，逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">randomWithWeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Ref&lt;T&gt; ref = <span class="keyword">this</span>.ref;</span><br><span class="line">    <span class="comment">// 注解@5.1</span></span><br><span class="line">    <span class="keyword">double</span> random = ThreadLocalRandom.current().nextDouble(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 注解@5.2</span></span><br><span class="line">    <span class="keyword">int</span> index = Arrays.binarySearch(ref.weights, random);</span><br><span class="line">    <span class="comment">// 注解@5.3</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        index = -index - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 注解@5.4</span></span><br><span class="line">        <span class="keyword">return</span> ref.items.get(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回选中的元素</span></span><br><span class="line">    <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt; ref.weights.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (random &lt; ref.weights[index]) &#123;</span><br><span class="line">            <span class="keyword">return</span> ref.items.get(index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This should never happen, but it ensures we will return a correct</span></span><br><span class="line"><span class="comment">     * object in case there is some floating point inequality problem</span></span><br><span class="line"><span class="comment">     * wrt the cumulative probabilities. */</span></span><br><span class="line">    <span class="keyword">return</span> ref.items.get(ref.items.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@5.1</strong> 产生0到1区间的随机数</p>
<p><strong>注解@5.2</strong> 二分法查找数组中接近的值</p>
<p><strong>注解@5.3</strong>  没有命中返回插入数组理想索引值</p>
<p><strong>注解@5.4</strong> 命中直接返回选中节点</p>
<p><strong>小结：</strong> 一种基于权重的随机算法的实现过程，扒开看也不复杂。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>Nacos</category>
      </categories>
      <tags>
        <tag>Nacos</tag>
      </tags>
  </entry>
  <entry>
    <title>Nacos14# 配置管理服务端流程</title>
    <url>/posts/6e152957/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在上文分析中客户端会有长轮询，不断轮询阻塞队列「listenExecutebell」去比较客户端和服务端配置内容md5是否一致，不一致则通知我们注册的Listener完成回调。当阻塞队里有元素时会立即执行，没有元素等待5秒钟执行。那都在什么时候往队列中添加元素的从而触发立即执行。</p>
<h1 id="内容提要"><a href="#内容提要" class="headerlink" title="内容提要"></a>内容提要</h1><h3 id="长轮询回顾"><a href="#长轮询回顾" class="headerlink" title="长轮询回顾"></a>长轮询回顾</h3><ul>
<li>监听配置内容的变更通过长轮询实现</li>
<li>具体实现为轮询阻塞队列</li>
</ul>
<h3 id="阻塞队列添加时机"><a href="#阻塞队列添加时机" class="headerlink" title="阻塞队列添加时机"></a>阻塞队列添加时机</h3><ul>
<li>客户端添加Listener时添加</li>
<li>客户端删除Listener时添加</li>
<li>服务端通知内容变更时添加</li>
<li>建立gRPC连接时添加</li>
</ul>
<h3 id="服务端变更发布流程"><a href="#服务端变更发布流程" class="headerlink" title="服务端变更发布流程"></a>服务端变更发布流程</h3><ul>
<li>通过配置中心发起变更请求</li>
<li>配置变更内容被写入数据库</li>
<li>向本节点连接的Client发送变更通知</li>
<li>向集群中的其他节点发送变更通知</li>
</ul>
<h3 id="向Client发送变更通知"><a href="#向Client发送变更通知" class="headerlink" title="向Client发送变更通知"></a>向Client发送变更通知</h3><ul>
<li>首先构建DumpTask</li>
<li>处理DumpTask时发布ConfigDumpEvent事件</li>
<li>处理ConfigDumpEvent时发布LocalDataChangeEvent事件</li>
<li>处理LocalDataChangeEvent事件：@1 先从缓存中拿出注册Client列表 @2 根据client从缓存获取gRPC连接 @3 构建ConfigChangeNotifyRequest @4 通过gRPC向客户端发送变更通知</li>
<li>客户端处理变更通知，客户端接到请求后向阻塞队列添加new Object元素，详细客户端的长轮询流程见上篇</li>
</ul>
<h3 id="向其他节点发送变更通知"><a href="#向其他节点发送变更通知" class="headerlink" title="向其他节点发送变更通知"></a>向其他节点发送变更通知</h3><ul>
<li>通过gRPC向集群中其他节点发送变更通知</li>
<li>集群节点收到变更通知后再下发给连接自己的Client</li>
</ul>
<a id="more"></a>



<h1 id="长轮询回顾-1"><a href="#长轮询回顾-1" class="headerlink" title="长轮询回顾"></a>长轮询回顾</h1><p><strong>长轮询判断</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">    executor.schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123; <span class="comment">// 一直运行</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 最长等待5秒</span></span><br><span class="line">                    listenExecutebell.poll(<span class="number">5L</span>, TimeUnit.SECONDS);</span><br><span class="line">                    executeConfigListen();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    LOGGER.error(<span class="string">&quot;[ rpc listen execute ] [rpc listen] exception&quot;</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">0L</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>队列添加元素</strong> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyListenConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    listenExecutebell.offer(bellItem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>备注：</strong> 配置内容变更机制是通过长轮询实现的。</p>
<h1 id="阻塞队列添加时机-1"><a href="#阻塞队列添加时机-1" class="headerlink" title="阻塞队列添加时机"></a><strong>阻塞队列添加时机</strong></h1><p><strong>1.客户端添加Listener时添加</strong> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addListeners</span><span class="params">(String dataId, String group, List&lt;? extends Listener&gt; listeners)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  	<span class="comment">// 通过队列中增加一个对象，长轮询立即执行</span></span><br><span class="line">  	agent.notifyListenConfig();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.客户端删除Listener时添加</strong> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeListener</span><span class="params">(String dataId, String group, Listener listener)</span> </span>&#123;</span><br><span class="line">    group = null2defaultGroup(group);</span><br><span class="line">    CacheData cache = getCache(dataId, group);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != cache) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (cache) &#123;</span><br><span class="line">            cache.removeListener(listener);</span><br><span class="line">            <span class="keyword">if</span> (cache.getListeners().isEmpty()) &#123;</span><br><span class="line">                cache.setSyncWithServer(<span class="keyword">false</span>);</span><br><span class="line">                agent.removeCache(dataId, group);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeCache</span><span class="params">(String dataId, String group)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Notify to rpc un listen ,and remove cache if success.</span></span><br><span class="line">  notifyListenConfig();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.服务端通知内容变更时添加</strong> </p>
<p>在与服务端建立gRPC通道时会添加Handler用于处理服务端推送的请求，收到推送请求后向阻塞队列添加元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initRpcClientHandler</span><span class="params">(<span class="keyword">final</span> RpcClient rpcClientInner)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Register Config Change /Config ReSync Handler</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    rpcClientInner.registerServerRequestHandler((request) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (request <span class="keyword">instanceof</span> ConfigChangeNotifyRequest) &#123;</span><br><span class="line">            ConfigChangeNotifyRequest configChangeNotifyRequest = (ConfigChangeNotifyRequest) request;</span><br><span class="line">            LOGGER.info(<span class="string">&quot;[&#123;&#125;] [server-push] config changed. dataId=&#123;&#125;, group=&#123;&#125;,tenant=&#123;&#125;&quot;</span>,</span><br><span class="line">                    rpcClientInner.getName(), configChangeNotifyRequest.getDataId(),</span><br><span class="line">                    configChangeNotifyRequest.getGroup(), configChangeNotifyRequest.getTenant());</span><br><span class="line">            String groupKey = GroupKey</span><br><span class="line">                    .getKeyTenant(configChangeNotifyRequest.getDataId(), configChangeNotifyRequest.getGroup(),</span><br><span class="line">                            configChangeNotifyRequest.getTenant());</span><br><span class="line"></span><br><span class="line">            CacheData cacheData = cacheMap.get().get(groupKey);</span><br><span class="line">            <span class="keyword">if</span> (cacheData != <span class="keyword">null</span>) &#123;</span><br><span class="line">                cacheData.setSyncWithServer(<span class="keyword">false</span>);</span><br><span class="line">                notifyListenConfig(); <span class="comment">// 向阻塞队列中添加元素</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConfigChangeNotifyResponse();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">  	<span class="comment">// ....</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>4.建立gRPC连接时添加</strong></p>
<p>在建立gRPC连接时会向阻塞队列中添加元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">rpcClientInner.registerConnectionListener(<span class="keyword">new</span> ConnectionEventListener() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onConnected</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">&quot;[&#123;&#125;] Connected,notify listen context...&quot;</span>, rpcClientInner.getName());</span><br><span class="line">        notifyListenConfig(); <span class="comment">// 向队列中添加元素</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDisConnect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String taskId = rpcClientInner.getLabels().get(<span class="string">&quot;taskId&quot;</span>);</span><br><span class="line">        LOGGER.info(<span class="string">&quot;[&#123;&#125;] DisConnected,clear listen context...&quot;</span>, rpcClientInner.getName());</span><br><span class="line">        Collection&lt;CacheData&gt; values = cacheMap.get().values();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (CacheData cacheData : values) &#123;</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isNotBlank(taskId)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (Integer.valueOf(taskId).equals(cacheData.getTaskId())) &#123;</span><br><span class="line">                    cacheData.setSyncWithServer(<span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cacheData.setSyncWithServer(<span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>备注：</strong> 阻塞队列添加元素的四种情况，添加后长轮询立即执行配置内容校验。</p>
<h1 id="服务端变更发布流程-1"><a href="#服务端变更发布流程-1" class="headerlink" title="服务端变更发布流程"></a><strong>服务端变更发布流程</strong></h1><p><strong>1.发布配置变更请求</strong> </p>
<p>服务端的发布内容变更，通过变更请求跟踪下，后端处理请求通过ConfigController#publishConfig()实现。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210730172935.png"></p>
<p><strong>2.处理配置变更请求</strong> </p>
<ul>
<li>将变更配置更新到数据库</li>
<li>发布ConfigDataChangeEvent事件</li>
</ul>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210730174331.png"></p>
<p><strong>3.订阅ConfigDataChangeEvent</strong> </p>
<p>翻到订阅该事件的处理逻辑，看看其干了什么事情，AsyncNotifyService构造函数中的onEvent()方法。从代码中可以看出当收到ConfigDataChangeEvent时，逻辑如下：</p>
<ul>
<li>获取集群中所有节点列表</li>
<li>每个节点封装NotifySingleRpcTask</li>
<li>异步向各个节点通知配置信息变更</li>
</ul>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210730193829.png"></p>
<p><strong>4.NotifySingleRpcTask逻辑</strong> </p>
<p>在代码AsyncNotifyService#AsyncRpcTask部分查看逻辑框架，任务运行主要干了两件事：</p>
<ul>
<li>向连接本节点的<em>Client</em>发送配置变更通知</li>
<li>向集群中的其他节点发送变更通知</li>
</ul>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210731111536.png"></p>
<p><strong>小结：</strong> 当我们从Nacos配置中心界面提交变更配置时：1.入库； 2.向本节点连接的Client发送变更通知；3.向集群中的其他节点发送变更通知。</p>
<h1 id="向Client发送变更通知-1"><a href="#向Client发送变更通知-1" class="headerlink" title="向Client发送变更通知"></a>向Client发送变更通知</h1><p><strong>1.首先构建DumpTask</strong> </p>
<p>代码坐标DumpService#dump()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dump</span><span class="params">(String dataId, String group, String tenant, String tag, <span class="keyword">long</span> lastModified, String handleIp,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> isBeta)</span> </span>&#123;</span><br><span class="line">    String groupKey = GroupKey2.getKey(dataId, group, tenant);</span><br><span class="line">    dumpTaskMgr.addTask(groupKey, <span class="keyword">new</span> DumpTask(groupKey, tag, lastModified, handleIp, isBeta));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.处理DumpTask时发布ConfigDumpEvent事件</strong> </p>
<p>代码坐标DumpProcessor#process()</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210731193633.png"></p>
<p><strong>3.处理ConfigDumpEvent时发布LocalDataChangeEvent事件</strong> </p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210731194211.png"></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210731194350.png"></p>
<p><strong>4.处理LocalDataChangeEvent事件</strong> </p>
<p>关注RpcConfigChangeNotifier#onEvent处理过程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(LocalDataChangeEvent event)</span> </span>&#123;</span><br><span class="line">    String groupKey = event.groupKey;</span><br><span class="line">    <span class="keyword">boolean</span> isBeta = event.isBeta;</span><br><span class="line">    List&lt;String&gt; betaIps = event.betaIps;</span><br><span class="line">    String[] strings = GroupKey.parseKey(groupKey);</span><br><span class="line">    String dataId = strings[<span class="number">0</span>];</span><br><span class="line">    String group = strings[<span class="number">1</span>];</span><br><span class="line">    String tenant = strings.length &gt; <span class="number">2</span> ? strings[<span class="number">2</span>] : <span class="string">&quot;&quot;</span>;</span><br><span class="line">    String tag = event.tag;</span><br><span class="line">    configDataChanged(groupKey, dataId, group, tenant, isBeta, betaIps, tag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如：注册在缓存的client=1627734181270_127.0.0.1_53522</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210801091854.png"></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210801092420.png"></p>
<p><strong>5.客户端处理变更通知</strong> </p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210801094245.png"></p>
<p><strong>小结：</strong> 走查了服务端如何将变更通知送达到连接该节点的客户端的。</p>
<h1 id="向其他节点发送变更通知-1"><a href="#向其他节点发送变更通知-1" class="headerlink" title="向其他节点发送变更通知"></a>向其他节点发送变更通知</h1><p><strong>1.接上面「服务端变更发布流程」最后步骤「向集群中的其他节点发送变更通知」</strong> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">configClusterRpcClientProxy</span><br><span class="line">        .syncConfigChange(member, syncRequest, <span class="keyword">new</span> AsyncRpcNotifyCallBack(task));</span><br></pre></td></tr></table></figure>

<p>从缓存中获取与其他节点的rpcClient连接，key=Cluster-1.2.3.4:1111</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">asyncRequest</span><span class="params">(Member member, Request request, RequestCallBack callBack)</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">    RpcClient client = RpcClientFactory.getClient(memberClientKey(member));</span><br><span class="line">    <span class="keyword">if</span> (client != <span class="keyword">null</span>) &#123;</span><br><span class="line">        client.asyncRequest(request, callBack);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NacosException(CLIENT_INVALID_PARAM, <span class="string">&quot;No rpc client related to member: &quot;</span> + member);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.其他节点处理请求入口</strong> </p>
<p>GrpcRequestAcceptor#request只列出部分代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行RequestHandler逻辑</span></span><br><span class="line">Response response = requestHandler.handleRequest(request, requestMeta);</span><br></pre></td></tr></table></figure>

<p><strong>3.其他节点由ConfigChangeClusterSyncRequestHandler处理ConfigChangeClusterSyncRequest</strong> </p>
<p>即：完成向客户端发送变更通知</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210801102703.png"></p>
<p><strong>小结：</strong> 当集群其他节点收到变更通知后，会向连接到本节点的Client发送变更通知，逻辑同上一小结「向Client发送变更通知」，从而完成全部向所有Client下发变更通知。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>Nacos</category>
      </categories>
      <tags>
        <tag>Nacos</tag>
      </tags>
  </entry>
  <entry>
    <title>Nacos3# 服务注册与发现服务端启动源码解析</title>
    <url>/posts/57538bcc/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>本文从gRPC的.proto文件解读其暴露的服务，由此生成gRPC的客户端/服务端存根。进而分析服务端加载启动过程。最近家里事情较多，本文短了点，大伙随便看看。</p>
<h1 id="内容提要"><a href="#内容提要" class="headerlink" title="内容提要"></a>内容提要</h1><h3 id="gRPC-Service-proto解读"><a href="#gRPC-Service-proto解读" class="headerlink" title="gRPC Service.proto解读"></a>gRPC Service.proto解读</h3><ul>
<li>暴露用于服务端到客户端流式RPC的服务RequestStream#requestStream</li>
<li>暴露用于简单RPC调用的服务Request#request</li>
<li>暴露用于双向流式RPC调用的服务BiRequestStream#requestBiStream</li>
<li>三种方式入参均为Payload</li>
</ul>
<h3 id="Server启动流程"><a href="#Server启动流程" class="headerlink" title="Server启动流程"></a>Server启动流程</h3><ul>
<li>定义了拦截器获取客户端的ip、port、connectId等</li>
<li>装配了.proto定义的两种调用方式，用于接受客户端请求<br>简单调用方式Request#request和双向流调用方式BiRequestStream#biRequestStream</li>
<li>设置了服务启动端口、线程、接受消息的限制、压缩/解压缩类型</li>
</ul>
<a id="more"></a>



<h1 id="gRPC-Service-proto解读-1"><a href="#gRPC-Service-proto解读-1" class="headerlink" title="gRPC Service .proto解读"></a>gRPC Service .proto解读</h1><p>客户端和服务端通过gRPC通信，基于.proto生成响应的通信代码，那先看看.proto暴露了哪些服务。</p>
<p><strong>api/proto/nacos_grpc_service.proto</strong> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>; <span class="comment">// 注解@1 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注解@2</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;google/protobuf/any.proto&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;google/protobuf/timestamp.proto&quot;</span>;</span><br><span class="line"></span><br><span class="line">option java_multiple_files = <span class="keyword">true</span>; </span><br><span class="line">option java_package = <span class="string">&quot;com.alibaba.nacos.api.grpc.auto&quot;</span>; <span class="comment">// 注解@3</span></span><br><span class="line"></span><br><span class="line">message Metadata &#123; <span class="comment">// 注解@4</span></span><br><span class="line">  string type = <span class="number">3</span>;</span><br><span class="line">  string clientIp = <span class="number">8</span>;</span><br><span class="line">  map&lt;string, string&gt; headers = <span class="number">7</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message Payload &#123; <span class="comment">// 注解@5</span></span><br><span class="line">  Metadata metadata = <span class="number">2</span>;</span><br><span class="line">  google.protobuf.Any body = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">service RequestStream &#123; <span class="comment">// 注解@6</span></span><br><span class="line">  <span class="comment">// build a streamRequest</span></span><br><span class="line">  <span class="function">rpc <span class="title">requestStream</span> <span class="params">(Payload)</span> <span class="title">returns</span> <span class="params">(stream Payload)</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">service Request &#123; <span class="comment">// 注解@7</span></span><br><span class="line">  <span class="comment">// Sends a commonRequest</span></span><br><span class="line">  <span class="function">rpc <span class="title">request</span> <span class="params">(Payload)</span> <span class="title">returns</span> <span class="params">(Payload)</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">service BiRequestStream &#123; <span class="comment">// 注解@8</span></span><br><span class="line">  <span class="comment">// Sends a commonRequest</span></span><br><span class="line">  <span class="function">rpc <span class="title">requestBiStream</span> <span class="params">(stream Payload)</span> <span class="title">returns</span> <span class="params">(stream Payload)</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**注解@1 ** 定义proto的版本</p>
<p><strong>注解@2</strong> 导入其他的.proto文件</p>
<p><strong>注解@3</strong> option可选的；指java类生成所在的包</p>
<p><strong>注解@4</strong>  定义Metadata消息格式，生成对应Metadata类，包含了字符串类型type和clientIp、map类型的headers</p>
<p><strong>注解@5</strong> 定义Payload消息格式，生成对应Payload类，包含了Metadata的引用、Any类型（对应java中Object）body</p>
<p><strong>注解@6</strong> 定义service RequestStream会生产客户端和服务端存根用于grpc通信，暴露的服务为requestStream，类型为：服务端到客户端流式RPC，接受Payload对象参数，返回批量Payload数据</p>
<p><strong>注解@7</strong>  定义service Request会生产客户端和服务端存根用于grpc通信，暴露的服务为request，类型为：简单RPC调用，接受Payload参数返回Payload类型对象</p>
<p><strong>注解@8</strong> 定义service BiRequestStream会生产客户端和服务端存根用于grpc通信，暴露的服务为requestBiStream，类型为：双向流式RPC，接受批量Payload类型数据，返回批量Payload类型数据</p>
<p><strong>小结：</strong> 我们从.proto的描述中能够发现，nacos server将暴露三个服务。@1 RequestStream#requestStream用于服务端到客户端流式RPC；@2 Request#request用于简单RPC调用；@3 BiRequestStream#requestBiStream用于双向流式RPC调用。三种的出入参均为Payload。</p>
<h1 id="Server启动流程-1"><a href="#Server启动流程-1" class="headerlink" title="Server启动流程"></a>Server启动流程</h1><p>坐标com.alibaba.nacos.core.remote.BaseRpcServer，在nacos启动时执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	 String serverName = getClass().getSimpleName();</span><br><span class="line">   Loggers.REMOTE.info(<span class="string">&quot;Nacos &#123;&#125; Rpc server starting at port &#123;&#125;&quot;</span>, serverName, getServicePort());</span><br><span class="line"></span><br><span class="line">   startServer();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>源码解读</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startServer</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> MutableHandlerRegistry handlerRegistry = <span class="keyword">new</span> MutableHandlerRegistry();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注解@9</span></span><br><span class="line">  ServerInterceptor serverInterceptor = <span class="keyword">new</span> ServerInterceptor() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T, S&gt; ServerCall.<span class="function">Listener&lt;T&gt; <span class="title">interceptCall</span><span class="params">(ServerCall&lt;T, S&gt; call, Metadata headers,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                       ServerCallHandler&lt;T, S&gt; next)</span> </span>&#123;</span><br><span class="line">      Context ctx = Context.current()</span><br><span class="line">        .withValue(CONTEXT_KEY_CONN_ID, call.getAttributes().get(TRANS_KEY_CONN_ID))</span><br><span class="line">        .withValue(CONTEXT_KEY_CONN_REMOTE_IP, call.getAttributes().get(TRANS_KEY_REMOTE_IP))</span><br><span class="line">        .withValue(CONTEXT_KEY_CONN_REMOTE_PORT, call.getAttributes().get(TRANS_KEY_REMOTE_PORT))</span><br><span class="line">        .withValue(CONTEXT_KEY_CONN_LOCAL_PORT, call.getAttributes().get(TRANS_KEY_LOCAL_PORT));</span><br><span class="line">      <span class="keyword">if</span> (REQUEST_BI_STREAM_SERVICE_NAME.equals(call.getMethodDescriptor().getServiceName())) &#123;</span><br><span class="line">        Channel internalChannel = getInternalChannel(call);</span><br><span class="line">        ctx = ctx.withValue(CONTEXT_KEY_CHANNEL, internalChannel);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> Contexts.interceptCall(ctx, call, headers, next);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 注解@10</span></span><br><span class="line">  addServices(handlerRegistry, serverInterceptor);</span><br><span class="line">  <span class="comment">// 注解@11</span></span><br><span class="line">  server = ServerBuilder.forPort(getServicePort()).executor(getRpcExecutor())</span><br><span class="line">    .maxInboundMessageSize(getInboundMessageSize()).fallbackHandlerRegistry(handlerRegistry)</span><br><span class="line">    .compressorRegistry(CompressorRegistry.getDefaultInstance())</span><br><span class="line">    .decompressorRegistry(DecompressorRegistry.getDefaultInstance())</span><br><span class="line">    .addTransportFilter(<span class="keyword">new</span> ServerTransportFilter() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Attributes <span class="title">transportReady</span><span class="params">(Attributes transportAttrs)</span> </span>&#123;  <span class="comment">// transport/connection 建立回调</span></span><br><span class="line">        InetSocketAddress remoteAddress = (InetSocketAddress) transportAttrs</span><br><span class="line">          .get(Grpc.TRANSPORT_ATTR_REMOTE_ADDR);</span><br><span class="line">        InetSocketAddress localAddress = (InetSocketAddress) transportAttrs</span><br><span class="line">          .get(Grpc.TRANSPORT_ATTR_LOCAL_ADDR);</span><br><span class="line">        <span class="keyword">int</span> remotePort = remoteAddress.getPort();</span><br><span class="line">        <span class="keyword">int</span> localPort = localAddress.getPort();</span><br><span class="line">        String remoteIp = remoteAddress.getAddress().getHostAddress();</span><br><span class="line">        Attributes attrWrapper = transportAttrs.toBuilder()</span><br><span class="line">          .set(TRANS_KEY_CONN_ID, System.currentTimeMillis() + <span class="string">&quot;_&quot;</span> + remoteIp + <span class="string">&quot;_&quot;</span> + remotePort)</span><br><span class="line">          .set(TRANS_KEY_REMOTE_IP, remoteIp).set(TRANS_KEY_REMOTE_PORT, remotePort)</span><br><span class="line">          .set(TRANS_KEY_LOCAL_PORT, localPort).build();</span><br><span class="line">        String connectionId = attrWrapper.get(TRANS_KEY_CONN_ID);</span><br><span class="line">        Loggers.REMOTE_DIGEST.info(<span class="string">&quot;Connection transportReady,connectionId = &#123;&#125; &quot;</span>, connectionId);</span><br><span class="line">        <span class="keyword">return</span> attrWrapper;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transportTerminated</span><span class="params">(Attributes transportAttrs)</span> </span>&#123; <span class="comment">// transport/connection 关闭回调</span></span><br><span class="line">        String connectionId = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          connectionId = transportAttrs.get(TRANS_KEY_CONN_ID);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          <span class="comment">// Ignore</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotBlank(connectionId)) &#123;</span><br><span class="line">          Loggers.REMOTE_DIGEST</span><br><span class="line">            .info(<span class="string">&quot;Connection transportTerminated,connectionId = &#123;&#125; &quot;</span>, connectionId);</span><br><span class="line">          connectionManager.unregister(connectionId);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).build();</span><br><span class="line">	</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 注解@12</span></span><br><span class="line">  server.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@9</strong> 定义server的拦截器，可以从请求中获取connection id、ip、port等</p>
<p><strong>注解@10</strong> 添加处理服务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addServices</span><span class="params">(MutableHandlerRegistry handlerRegistry, ServerInterceptor... serverInterceptor)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// unary common call register.</span></span><br><span class="line">  <span class="comment">// 注解@10.1</span></span><br><span class="line">  <span class="keyword">final</span> MethodDescriptor&lt;Payload, Payload&gt; unaryPayloadMethod = MethodDescriptor.&lt;Payload, Payload&gt;newBuilder()</span><br><span class="line">    .setType(MethodDescriptor.MethodType.UNARY)  <span class="comment">// 服务调用方式UNARY</span></span><br><span class="line">    .setFullMethodName(MethodDescriptor.generateFullMethodName(REQUEST_SERVICE_NAME, REQUEST_METHOD_NAME)) <span class="comment">// 服务的接口名和方法名「request」</span></span><br><span class="line">    .setRequestMarshaller(ProtoUtils.marshaller(Payload.getDefaultInstance())) <span class="comment">// 请求序列化类</span></span><br><span class="line">    .setResponseMarshaller(ProtoUtils.marshaller(Payload.getDefaultInstance())).build(); <span class="comment">// 响应序列化类</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注解@10.2</span></span><br><span class="line">  <span class="keyword">final</span> ServerCallHandler&lt;Payload, Payload&gt; payloadHandler = ServerCalls</span><br><span class="line">    .asyncUnaryCall((request, responseObserver) -&gt; &#123;</span><br><span class="line">      grpcCommonRequestAcceptor.request(request, responseObserver);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注解@10.3</span></span><br><span class="line">  <span class="keyword">final</span> ServerServiceDefinition serviceDefOfUnaryPayload = ServerServiceDefinition.builder(REQUEST_SERVICE_NAME)</span><br><span class="line">    .addMethod(unaryPayloadMethod, payloadHandler).build();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注解@10.4</span></span><br><span class="line">  handlerRegistry.addService(ServerInterceptors.intercept(serviceDefOfUnaryPayload, serverInterceptor));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// bi stream register.</span></span><br><span class="line">  <span class="comment">// 注解@10.5</span></span><br><span class="line">  <span class="keyword">final</span> ServerCallHandler&lt;Payload, Payload&gt; biStreamHandler = ServerCalls.asyncBidiStreamingCall(</span><br><span class="line">    (responseObserver) -&gt; grpcBiStreamRequestAcceptor.requestBiStream(responseObserver));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注解@10.6</span></span><br><span class="line">  <span class="keyword">final</span> MethodDescriptor&lt;Payload, Payload&gt; biStreamMethod = MethodDescriptor.&lt;Payload, Payload&gt;newBuilder()</span><br><span class="line">    .setType(MethodDescriptor.MethodType.BIDI_STREAMING).setFullMethodName(MethodDescriptor</span><br><span class="line">                                                                           .generateFullMethodName(REQUEST_BI_STREAM_SERVICE_NAME, REQUEST_BI_STREAM_METHOD_NAME))</span><br><span class="line">    .setRequestMarshaller(ProtoUtils.marshaller(Payload.newBuilder().build()))</span><br><span class="line">    .setResponseMarshaller(ProtoUtils.marshaller(Payload.getDefaultInstance())).build();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注解@10.7</span></span><br><span class="line">  <span class="keyword">final</span> ServerServiceDefinition serviceDefOfBiStream = ServerServiceDefinition</span><br><span class="line">    .builder(REQUEST_BI_STREAM_SERVICE_NAME).addMethod(biStreamMethod, biStreamHandler).build();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注解@10.8</span></span><br><span class="line">  handlerRegistry.addService(ServerInterceptors.intercept(serviceDefOfBiStream, serverInterceptor));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@10.1</strong> 构造MethodDescriptor，包括：服务调用方式简单RPC即UNARY、服务的接口名和方法名、请求序列化类、响应序列化类</p>
<p><strong>注解@10.2</strong> 服务接口处理类，接受到request请求将调用执行</p>
<p><strong>注解@10.3</strong> 构建暴露的服务「Request」</p>
<p><strong>注解10.4</strong> 注册到内部的注册中心（Registry）中，可以根据服务定义信息查询实现类（普通对象request/response调用）</p>
<p><strong>注解@10.5</strong> 服务接口处理类，接收到biRequestStream请求将调用执行</p>
<p><strong>注解@10.6</strong> 构造MethodDescriptor，包括：服务双向流调用方式BIDI_STREAMING、服务的接口名和方法名、请求序列化类、响应序列化类</p>
<p><strong>注解@10.7</strong> 构建暴露的服务「BiRequestStream」</p>
<p><strong>注解@10.8</strong> 注册到内部的注册中心（Registry）中，可以根据服务定义信息查询实现类（双向流调用）</p>
<p><strong>注解@11</strong> 设置server启动的端口（默认为 8848 + 1001 = 9849），getRpcExecutor线程执行器（线程数默认为 = 处理器核数*16） ，maxInboundMessageSize最大限制为10M，压缩解压缩使用gzip。</p>
<p><strong>注解@12</strong> 注册发现server启动（grpc）</p>
<p><strong>小结：</strong> server启动过程中主要干了三件事 @1定义了拦截器获取客户端的ip、port、connectId等；@2装配了.proto定义的两种调用方式，简单调用方式Request#request和双向流调用方式BiRequestStream#biRequestStream；@3设置了服务启动端口、线程、接受消息的限制、压缩/解压缩类型。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>Nacos</category>
      </categories>
      <tags>
        <tag>Nacos</tag>
      </tags>
  </entry>
  <entry>
    <title>Nacos5# Distro协议寻址模式</title>
    <url>/posts/ea86b72f/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在Nacos服务端分析服务注册逻辑，就绕不开Distro协议。该协议为临时一致性协议，数据存储在缓存中。阿里专门为注册中心而设计的。后面文章逐步还原该协议承担的职责，本文先分析寻址模式。</p>
<h1 id="内容提要"><a href="#内容提要" class="headerlink" title="内容提要"></a>内容提要</h1><h3 id="寻址概念"><a href="#寻址概念" class="headerlink" title="寻址概念"></a>寻址概念</h3><ul>
<li>寻址是指如何发现Nacos集群中节点变化的，当检测到变化时能后及时更新节点信息。</li>
</ul>
<h3 id="寻址模式"><a href="#寻址模式" class="headerlink" title="寻址模式"></a>寻址模式</h3><ul>
<li>Nacos支持两种寻址模式分别为「文件寻址」和「地址服务器寻址」</li>
<li>默认为文件寻址，可以通过参数「nacos.core.member.lookup.type」设置取值为「file」或者「address-server」</li>
<li>文件寻址路径默认为 「${user.home}/nacos/conf/cluster.conf」</li>
<li>文件寻址cluster.conf配置文件的内容格式为「ip1:port,ip2:port」</li>
<li>地址服务器寻址默认为：<a href="http://jmenv.tbsite.net:8080/serverlist%EF%BC%9B%E5%85%B6%E4%B8%AD%E5%9F%9F%E5%90%8D%E3%80%81%E7%AB%AF%E5%8F%A3%E3%80%81url%E5%9D%87%E5%8F%AF%E8%87%AA%E5%AE%9A%E4%B9%89">http://jmenv.tbsite.net:8080/serverlist；其中域名、端口、url均可自定义</a></li>
<li>检测到集群节点变更时会更新缓存并发布MembersChangeEvent事件</li>
<li>为防止新节点没有初始化好，当检测到新节点加入时先设置该节点状态为DOWN，该节点不参与通信</li>
<li>过几秒通过节点之间通信将已初始化的新节点状态由DOWN设置为UP，该节点正式参与通信</li>
</ul>
<a id="more"></a>



<h1 id="寻址初始化"><a href="#寻址初始化" class="headerlink" title="寻址初始化"></a>寻址初始化</h1><p>寻址是指如何发现Nacos集群中节点变化的，当检测到变化时能后及时更新节点信息。Nacos提供了两种寻址模式，分别为 <strong>文件寻址</strong> 和<strong>地址服务器寻址</strong>。如果单机启动就本机一个节点也无所谓寻址。</p>
<p>接下来看下源码部分如何实现的。在DistroProtocol类中有一个成员变量ServerMemberManager memberManager，寻址的逻辑即封装在ServerMemberManager中。</p>
<p>坐标：ServerMemberManager#init()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">  Loggers.CORE.info(<span class="string">&quot;Nacos-related cluster resource initialization&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注解@1 </span></span><br><span class="line">  <span class="keyword">this</span>.port = EnvUtil.getProperty(<span class="string">&quot;server.port&quot;</span>, Integer.class, <span class="number">8848</span>);</span><br><span class="line">  <span class="comment">// 注解@2</span></span><br><span class="line">  <span class="keyword">this</span>.localAddress = InetUtils.getSelfIP() + <span class="string">&quot;:&quot;</span> + port;</span><br><span class="line">  <span class="comment">// 注解@3</span></span><br><span class="line">  <span class="keyword">this</span>.self = MemberUtil.singleParse(<span class="keyword">this</span>.localAddress);</span><br><span class="line">  <span class="comment">// 注解@4</span></span><br><span class="line">  <span class="keyword">this</span>.self.setExtendVal(MemberMetaDataConstants.VERSION, VersionUtils.version);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.self.setAbilities(initMemberAbilities());</span><br><span class="line">  <span class="comment">// 注解@5</span></span><br><span class="line">  serverList.put(self.getAddress(), self);</span><br><span class="line"> 	<span class="comment">// 注解@6</span></span><br><span class="line">  registerClusterEvent();</span><br><span class="line">  <span class="comment">// 注解@7</span></span><br><span class="line">  initAndStartLookup();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (serverList.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NacosException(NacosException.SERVER_ERROR, <span class="string">&quot;cannot get serverlist, so exit.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Loggers.CORE.info(<span class="string">&quot;The cluster resource is initialized&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@1</strong> 可以通过server.port指定服务端端口，默认8848</p>
<p><strong>注解@2</strong> 获取本地地址</p>
<p><strong>注解@3</strong> 拆分IP和Port组装Member对象</p>
<p><strong>注解@4</strong> 设置版本取自pom文件 version=${project.version}</p>
<p><strong>注解@5</strong> 缓存本节点信息</p>
<p><strong>注解@6</strong> 发布MembersChangeEvent事件并订阅IPChangeEvent事件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerClusterEvent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 发布MembersChangeEvent事件</span></span><br><span class="line">  NotifyCenter.registerToPublisher(MembersChangeEvent.class,</span><br><span class="line">                                   EnvUtil.getProperty(<span class="string">&quot;nacos.member-change-event.queue.size&quot;</span>, Integer.class, <span class="number">128</span>));</span><br><span class="line">  <span class="comment">// 订阅IPChangeEvent事件</span></span><br><span class="line">  NotifyCenter.registerSubscriber(<span class="keyword">new</span> Subscriber&lt;InetUtils.IPChangeEvent&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(InetUtils.IPChangeEvent event)</span> </span>&#123;</span><br><span class="line">      String newAddress = event.getNewIP() + <span class="string">&quot;:&quot;</span> + port;</span><br><span class="line">      ServerMemberManager.<span class="keyword">this</span>.localAddress = newAddress;</span><br><span class="line">      EnvUtil.setLocalAddress(localAddress);</span><br><span class="line"></span><br><span class="line">      Member self = ServerMemberManager.<span class="keyword">this</span>.self;</span><br><span class="line">      self.setIp(event.getNewIP());</span><br><span class="line"></span><br><span class="line">      String oldAddress = event.getOldIP() + <span class="string">&quot;:&quot;</span> + port;</span><br><span class="line">      ServerMemberManager.<span class="keyword">this</span>.serverList.remove(oldAddress);</span><br><span class="line">      ServerMemberManager.<span class="keyword">this</span>.serverList.put(newAddress, self);</span><br><span class="line"></span><br><span class="line">      ServerMemberManager.<span class="keyword">this</span>.memberAddressInfos.remove(oldAddress);</span><br><span class="line">      ServerMemberManager.<span class="keyword">this</span>.memberAddressInfos.add(newAddress);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;? extends Event&gt; subscribeType() &#123;</span><br><span class="line">      <span class="keyword">return</span> InetUtils.IPChangeEvent.class;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="寻址适配器"><a href="#寻址适配器" class="headerlink" title="寻址适配器"></a>寻址适配器</h1><p><strong>注解@7</strong> 初始化寻址模式适配器并启动；寻址模式分别为单机、配置文件、地址服务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initAndStartLookup</span><span class="params">()</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">  <span class="comment">// 注解@7.1</span></span><br><span class="line">  <span class="keyword">this</span>.lookup = LookupFactory.createLookUp(<span class="keyword">this</span>);</span><br><span class="line">  isUseAddressServer = <span class="keyword">this</span>.lookup.useAddressServer();</span><br><span class="line">  <span class="comment">// 注解@7.2</span></span><br><span class="line">  <span class="keyword">this</span>.lookup.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@7.1</strong> 获取寻址模式适配器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MemberLookup <span class="title">createLookUp</span><span class="params">(ServerMemberManager memberManager)</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!EnvUtil.getStandaloneMode()) &#123;</span><br><span class="line">    <span class="comment">// 注解@7.1.1</span></span><br><span class="line">    String lookupType = EnvUtil.getProperty(LOOKUP_MODE_TYPE);</span><br><span class="line">    LookupType type = chooseLookup(lookupType);</span><br><span class="line">    <span class="comment">// 注解@7.1.2</span></span><br><span class="line">    LOOK_UP = find(type);</span><br><span class="line">    currentLookupType = type;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 注解@7.1.3</span></span><br><span class="line">    LOOK_UP = <span class="keyword">new</span> StandaloneMemberLookup();</span><br><span class="line">  &#125;</span><br><span class="line">  LOOK_UP.injectMemberManager(memberManager);</span><br><span class="line">  Loggers.CLUSTER.info(<span class="string">&quot;Current addressing mode selection : &#123;&#125;&quot;</span>, LOOK_UP.getClass().getSimpleName());</span><br><span class="line">  <span class="keyword">return</span> LOOK_UP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@7.1.1</strong> 寻址类型可以通过「nacos.core.member.lookup.type」参数指定，取值为「file」或者「address-server」</p>
<p><strong>注解@7.1.2</strong> 根据不同的类型实例化不同的MemberLookup分别为：FileConfigMemberLookup和AddressServerMemberLookup</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> MemberLookup <span class="title">find</span><span class="params">(LookupType type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (LookupType.FILE_CONFIG.equals(type)) &#123;</span><br><span class="line">        LOOK_UP = <span class="keyword">new</span> FileConfigMemberLookup();</span><br><span class="line">        <span class="keyword">return</span> LOOK_UP;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (LookupType.ADDRESS_SERVER.equals(type)) &#123;</span><br><span class="line">        LOOK_UP = <span class="keyword">new</span> AddressServerMemberLookup();</span><br><span class="line">        <span class="keyword">return</span> LOOK_UP;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@7.1.3</strong> 如果采用standalone模式实例化StandaloneMemberLookup</p>
<p><strong>注解@7.2</strong> 寻址适配器启动</p>
<p><strong>standalone寻址适配器启动</strong> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (start.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">    String url = InetUtils.getSelfIP() + <span class="string">&quot;:&quot;</span> + EnvUtil.getPort();</span><br><span class="line">    afterLookup(MemberUtil.readServerConf(Collections.singletonList(url)));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>备注：</strong> 坐标StandaloneMemberLookup#start()，获取本地地址执行afterLookup</p>
<p><strong>文件寻址适配器启动</strong> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">            readClusterConfFromDisk();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                WatchFileCenter.registerWatcher(EnvUtil.getConfPath(), watcher);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                Loggers.CLUSTER.error(<span class="string">&quot;An exception occurred in the launch file monitor : &#123;&#125;&quot;</span>, e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readClusterConfFromDisk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   Collection&lt;Member&gt; tmpMembers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     List&lt;String&gt; tmp = EnvUtil.readClusterConf(); <span class="comment">// 从磁盘文件读取节点列表</span></span><br><span class="line">     tmpMembers = MemberUtil.readServerConf(tmp);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">     Loggers.CLUSTER</span><br><span class="line">       .error(<span class="string">&quot;nacos-XXXX [serverlist] failed to get serverlist from disk!, error : &#123;&#125;&quot;</span>, e.getMessage());</span><br><span class="line">   &#125;</span><br><span class="line">	</span><br><span class="line">   afterLookup(tmpMembers);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>备注：</strong> 默认从 ${user.home}/nacos/conf/cluster.conf文件中读取集群地址信息，文件格式为：「ip1:port,ip2:port」。读取后执行afterLookup。并注册FileWatcher监听cluster.conf的变化，有变更会被监听并更新缓存地址列表。</p>
<p><strong>地址服务器寻址适配器</strong> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (start.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">    <span class="keyword">this</span>.maxFailCount = Integer.parseInt(EnvUtil.getProperty(<span class="string">&quot;maxHealthCheckFailCount&quot;</span>, <span class="string">&quot;12&quot;</span>));</span><br><span class="line">    initAddressSys();</span><br><span class="line">    run();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每5秒定时请求地址服务器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">    Throwable ex = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> maxRetry = EnvUtil.getProperty(<span class="string">&quot;nacos.core.address-server.retry&quot;</span>, Integer.class, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxRetry; i++) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            syncFromAddressUrl();</span><br><span class="line">            success = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            ex = e;</span><br><span class="line">            Loggers.CLUSTER.error(<span class="string">&quot;[serverlist] exception, error : &#123;&#125;&quot;</span>, ExceptionUtil.getAllExceptionMsg(ex));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NacosException(NacosException.SERVER_ERROR, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    GlobalExecutor.scheduleByCommon(<span class="keyword">new</span> AddressServerSyncTask(), <span class="number">5_000L</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>处理地址列表</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">syncFromAddressUrl</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    RestResult&lt;String&gt; result = restTemplate</span><br><span class="line">            .get(addressServerUrl, Header.EMPTY, Query.EMPTY, genericType.getType());</span><br><span class="line">    <span class="keyword">if</span> (result.ok()) &#123;</span><br><span class="line">        isAddressServerHealth = <span class="keyword">true</span>;</span><br><span class="line">        Reader reader = <span class="keyword">new</span> StringReader(result.getData());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            afterLookup(MemberUtil.readServerConf(EnvUtil.analyzeClusterConf(reader)));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            Loggers.CLUSTER.error(<span class="string">&quot;[serverlist] exception for analyzeClusterConf, error : &#123;&#125;&quot;</span>,</span><br><span class="line">                    ExceptionUtil.getAllExceptionMsg(e));</span><br><span class="line">        &#125;</span><br><span class="line">        addressServerFailCount = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        addressServerFailCount++;</span><br><span class="line">        <span class="keyword">if</span> (addressServerFailCount &gt;= maxFailCount) &#123;</span><br><span class="line">            isAddressServerHealth = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Loggers.CLUSTER.error(<span class="string">&quot;[serverlist] failed to get serverlist, error code &#123;&#125;&quot;</span>, result.getCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>备注：</strong> 域名默认为「jmenv.tbsite.net」可以通过参数「address.server.domain」指定服务器地址；端口默认为「8080」可以通过参数「address.server.port」指定；url默认为「/serverlist」可以通过参数指定「address.server.url」。</p>
<p>默认为：<a href="http://jmenv.tbsite.net:8080/serverlist%EF%BC%9B%E6%AF%8F5%E7%A7%92%E9%92%9F%E5%AE%9A%E6%97%B6%E5%90%91%E5%9C%B0%E5%9D%80%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AF%B7%E6%B1%82%E8%8E%B7%E5%8F%96%E5%9C%B0%E5%9D%80%E5%88%97%E8%A1%A8%EF%BC%9B%E8%8E%B7%E5%8F%96%E5%88%97%E8%A1%A8%E5%90%8E%E6%89%A7%E8%A1%8CafterLookup%E3%80%82">http://jmenv.tbsite.net:8080/serverlist；每5秒钟定时向地址服务器请求获取地址列表；获取列表后执行afterLookup。</a></p>
<h1 id="节点变更"><a href="#节点变更" class="headerlink" title="节点变更"></a>节点变更</h1><p>三种适配器寻址最后都调用到了afterLookup，接下来看下这块逻辑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterLookup</span><span class="params">(Collection&lt;Member&gt; members)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.memberManager.memberChange(members);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">memberChange</span><span class="params">(Collection&lt;Member&gt; members)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (members == <span class="keyword">null</span> || members.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 是否包含本地地址</span></span><br><span class="line">  <span class="keyword">boolean</span> isContainSelfIp = members.stream()</span><br><span class="line">    .anyMatch(ipPortTmp -&gt; Objects.equals(localAddress, ipPortTmp.getAddress()));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isContainSelfIp) &#123;</span><br><span class="line">    isInIpList = <span class="keyword">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    isInIpList = <span class="keyword">false</span>;</span><br><span class="line">    members.add(<span class="keyword">this</span>.self);</span><br><span class="line">    Loggers.CLUSTER.warn(<span class="string">&quot;[serverlist] self ip &#123;&#125; not in serverlist &#123;&#125;&quot;</span>, self, members);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 集群中地址列表是否有变化</span></span><br><span class="line">  <span class="keyword">boolean</span> hasChange = members.size() != serverList.size();</span><br><span class="line">  ConcurrentSkipListMap&lt;String, Member&gt; tmpMap = <span class="keyword">new</span> ConcurrentSkipListMap&lt;&gt;();</span><br><span class="line">  Set&lt;String&gt; tmpAddressInfo = <span class="keyword">new</span> ConcurrentHashSet&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (Member member : members) &#123;</span><br><span class="line">    <span class="keyword">final</span> String address = member.getAddress();</span><br><span class="line">    Member existMember = serverList.get(address);</span><br><span class="line">    <span class="keyword">if</span> (existMember == <span class="keyword">null</span>) &#123; <span class="comment">// 有新的节点加入</span></span><br><span class="line">      hasChange = <span class="keyword">true</span>;</span><br><span class="line">     <span class="comment">// 新增的节点先设置状态为DOWN，过几秒中通过心跳更改状态UP。防止新节点未成功启动而发请求</span></span><br><span class="line">     member.setState(NodeState.DOWN); </span><br><span class="line">      tmpMap.put(address, member);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">// 已存在，还会被更新</span></span><br><span class="line">      tmpMap.put(address, existMember); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (NodeState.UP.equals(member.getState())) &#123;</span><br><span class="line">      tmpAddressInfo.add(address);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  serverList = tmpMap;</span><br><span class="line">  memberAddressInfos = tmpAddressInfo;</span><br><span class="line"></span><br><span class="line">  Collection&lt;Member&gt; finalMembers = allMembers();</span><br><span class="line"></span><br><span class="line">  Loggers.CLUSTER.warn(<span class="string">&quot;[serverlist] updated to : &#123;&#125;&quot;</span>, finalMembers);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (hasChange) &#123; <span class="comment">// 集群节点有变更</span></span><br><span class="line">    MemberUtil.syncToFile(finalMembers); <span class="comment">// 同步写入磁盘文件cluster.conf中</span></span><br><span class="line">    Event event = MembersChangeEvent.builder().members(finalMembers).build();</span><br><span class="line">    NotifyCenter.publishEvent(event); <span class="comment">// 发布MembersChangeEvent事件</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> hasChange;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>备注：</strong> 通过寻址适配器获取的集群节点列表，会与缓存的节点信息进行比较。如果有变更会更新缓存、把全部节点写入磁盘文件cluster.conf、同时发布MembersChangeEvent事件。</p>
<p><strong>小结：</strong> Nacos集群中的节点变更了怎么发现呢？Nacos提供两种模式一个是通过动态监听配置文件cluster.conf；另外一种是通过定时5秒去地址中心获取。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>Nacos</category>
      </categories>
      <tags>
        <tag>Nacos</tag>
      </tags>
  </entry>
  <entry>
    <title>Nacos8# 集群中节点之间健康检查</title>
    <url>/posts/765f2ae1/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>当新的节点加入集群或者集群中有节点下线了，集群之间可以通过健康检查发现。健康检查的频率是怎么样的？节点的状态又是如何变动的？状态的变动又会触发什么动作。带着这些问题本文捋一捋。</p>
<h1 id="内容提要"><a href="#内容提要" class="headerlink" title="内容提要"></a>内容提要</h1><h3 id="健康检查"><a href="#健康检查" class="headerlink" title="健康检查"></a>健康检查</h3><ul>
<li>Nacos节点会向集群其他节点发送健康检查心跳，每一轮频率为2秒</li>
<li>当健康检查异常时设置为不信任「SUSPICIOUS」状态，超过失败最大次数3次设置为下线「DOWN」状态</li>
<li>健康检查成功设置该节点为科通信「UP」状态</li>
<li>无论成功还是失败当节点状态变更时均发布MembersChangeEvent事件</li>
</ul>
<h3 id="成员变更事件"><a href="#成员变更事件" class="headerlink" title="成员变更事件"></a>成员变更事件</h3><ul>
<li>当集群节点成员变更时，MemberChangeListener会收到该事件</li>
<li>例如回调ClusterRpcClientProxy#onEvent触发refresh</li>
<li>刷新本节点与集群中其他节点的RPC状态，关闭无效的或者增加新的RPC连接</li>
</ul>
<a id="more"></a>



<h1 id="健康检查-1"><a href="#健康检查-1" class="headerlink" title="健康检查"></a>健康检查</h1><p>代码翻到ServerMemberManager#onApplicationEvent，在Nacos启动的时候会启动一个定时任务，第一次延迟5秒执行，该定时任务即负责节点之间的心跳。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(WebServerInitializedEvent event)</span> </span>&#123;</span><br><span class="line">    getSelf().setState(NodeState.UP);</span><br><span class="line">    <span class="keyword">if</span> (!EnvUtil.getStandaloneMode()) &#123; <span class="comment">// 注解@1</span></span><br><span class="line">        GlobalExecutor.scheduleByCommon(<span class="keyword">this</span>.infoReportTask, <span class="number">5_000L</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    EnvUtil.setPort(event.getWebServer().getPort());</span><br><span class="line">    EnvUtil.setLocalAddress(<span class="keyword">this</span>.localAddress);</span><br><span class="line">    Loggers.CLUSTER.info(<span class="string">&quot;This node is ready to provide external services&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@1</strong> 非单机模式延迟5秒执行，执行的infoReportTask为MemberInfoReportTask。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> shutdown = <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="comment">// 注解@2</span></span><br><span class="line">        <span class="keyword">if</span> (shutdown) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            executeBody();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            Loggers.CORE.error(<span class="string">&quot;this task execute has error : &#123;&#125;&quot;</span>, ExceptionUtil.getStackTrace(t));</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!shutdown) &#123;</span><br><span class="line">                after();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@2</strong> 看下这个Task执行逻辑，先执行 executeBody()，执行结束后执行after()。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MemberInfoReportTask</span> <span class="keyword">extends</span> <span class="title">Task</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> GenericType&lt;RestResult&lt;String&gt;&gt; reference = <span class="keyword">new</span> GenericType&lt;RestResult&lt;String&gt;&gt;() &#123;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cursor = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">executeBody</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ----------注解@1 start---------------</span></span><br><span class="line">      	<span class="comment">// 获取集群中除了自身以外的其他节点列表</span></span><br><span class="line">        List&lt;Member&gt; members = ServerMemberManager.<span class="keyword">this</span>.allMembersWithoutSelf();</span><br><span class="line">        <span class="keyword">if</span> (members.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 定义一个游标</span></span><br><span class="line">        <span class="keyword">this</span>.cursor = (<span class="keyword">this</span>.cursor + <span class="number">1</span>) % members.size();</span><br><span class="line">        <span class="comment">// 获取每个节信息</span></span><br><span class="line">        Member target = members.get(cursor);</span><br><span class="line">				<span class="comment">//-----------注解@1 end-----------------</span></span><br><span class="line">        Loggers.CLUSTER.debug(<span class="string">&quot;report the metadata to the node : &#123;&#125;&quot;</span>, target.getAddress());</span><br><span class="line">        <span class="comment">// 注解@2</span></span><br><span class="line">        <span class="keyword">final</span> String url = HttpUtils</span><br><span class="line">                .buildUrl(<span class="keyword">false</span>, target.getAddress(), EnvUtil.getContextPath(), Commons.NACOS_CORE_CONTEXT,</span><br><span class="line">                        <span class="string">&quot;/cluster/report&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          	<span class="comment">// 注解@3</span></span><br><span class="line">            asyncRestTemplate</span><br><span class="line">                    .post(url, Header.newInstance().addParam(Constants.NACOS_SERVER_HEADER, VersionUtils.version),</span><br><span class="line">                            Query.EMPTY, getSelf(), reference.getType(), <span class="keyword">new</span> Callback&lt;String&gt;() &#123; </span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(RestResult&lt;String&gt; result)</span> </span>&#123; <span class="comment">// 注解@4</span></span><br><span class="line">                                    <span class="comment">// 注解@5 返回版本不一致</span></span><br><span class="line">                                    <span class="keyword">if</span> (result.getCode() == HttpStatus.NOT_IMPLEMENTED.value()</span><br><span class="line">                                            || result.getCode() == HttpStatus.NOT_FOUND.value()) &#123;</span><br><span class="line">                                        <span class="comment">// ...</span></span><br><span class="line">                                        Member memberNew = target.copy();</span><br><span class="line">                                        <span class="keyword">if</span> (memberNew.getAbilities() != <span class="keyword">null</span></span><br><span class="line">                                                &amp;&amp; memberNew.getAbilities().getRemoteAbility() != <span class="keyword">null</span> &amp;&amp; memberNew</span><br><span class="line">                                                .getAbilities().getRemoteAbility().isSupportRemoteConnection()) &#123;</span><br><span class="line">                                            memberNew.getAbilities().getRemoteAbility()</span><br><span class="line">                                                    .setSupportRemoteConnection(<span class="keyword">false</span>);</span><br><span class="line">                                            update(memberNew); <span class="comment">// 更新节点属性</span></span><br><span class="line">                                        &#125;</span><br><span class="line">                                        <span class="keyword">return</span>;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                    <span class="comment">// 注解@6</span></span><br><span class="line">                                    <span class="keyword">if</span> (result.ok()) &#123;</span><br><span class="line">                                        MemberUtil.onSuccess(ServerMemberManager.<span class="keyword">this</span>, target);</span><br><span class="line">                                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                    	<span class="comment">// 注解@7 处理失败上报</span></span><br><span class="line">                                        MemberUtil.onFail(ServerMemberManager.<span class="keyword">this</span>, target);</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">                                  	<span class="comment">// 注解@8 处理失败上报</span></span><br><span class="line">                                     MemberUtil.onFail(ServerMemberManager.<span class="keyword">this</span>, target, throwable);</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        GlobalExecutor.scheduleByCommon(<span class="keyword">this</span>, <span class="number">2_000L</span>); <span class="comment">// 注解@9</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@1</strong> 获取集群中除了自身以外的其他节点列表，通过游标循环每个节点。</p>
<p><strong>注解@2</strong> 构造每个节点的上报url请求路径为「/cluster/report」</p>
<p><strong>注解@3</strong> 发起Post健康检查请求，请求内容为自身信息Member</p>
<p><strong>注解@4</strong> 处理健康检查返回结果，有以下三种类型</p>
<p><strong>注解@5</strong> 版本过低错误，这个可能在集群中版本不一致出现</p>
<p><strong>注解@6</strong> 处理成功上报，更新该节点member的状态为UP表示科通信，设置失败次数为0，并发布成员变更事件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(<span class="keyword">final</span> ServerMemberManager manager, <span class="keyword">final</span> Member member)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> NodeState old = member.getState();</span><br><span class="line">    manager.getMemberAddressInfos().add(member.getAddress());</span><br><span class="line">    member.setState(NodeState.UP); <span class="comment">// 状态为UP可通信状态</span></span><br><span class="line">    member.setFailAccessCnt(<span class="number">0</span>); <span class="comment">// 失败次数为0</span></span><br><span class="line">    <span class="keyword">if</span> (!Objects.equals(old, member.getState())) &#123;</span><br><span class="line">        manager.notifyMemberChange(); <span class="comment">// 发布成员变更事件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@7&amp;注解@8</strong> 均为处理失败的上报，例如：集群中一个节点被kill -9 杀掉后。在nacos-cluster.log日志文件中会打印如下日志，并发布成员变更事件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2021-07-0x 16:30:24,994 ERROR failed to report new info to target node : x.x.x.x:8848, error : caused: Connection refused;</span><br><span class="line"></span><br><span class="line">:2021-07-0x 16:30:30,995 ERROR failed to report new info to target node : x.x.x.x:8848, error : caused: Connection refused;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">onFail</span><span class="params">(<span class="keyword">final</span> ServerMemberManager manager, <span class="keyword">final</span> Member member, Throwable ex)</span> </span>&#123;</span><br><span class="line">    manager.getMemberAddressInfos().remove(member.getAddress());</span><br><span class="line">    <span class="keyword">final</span> NodeState old = member.getState();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置该节点为「不信任」</span></span><br><span class="line">    member.setState(NodeState.SUSPICIOUS);</span><br><span class="line">    <span class="comment">// 失败次数递增+1</span></span><br><span class="line">    member.setFailAccessCnt(member.getFailAccessCnt() + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 默认最大失败重试次数为3</span></span><br><span class="line">    <span class="keyword">int</span> maxFailAccessCnt = EnvUtil.getProperty(<span class="string">&quot;nacos.core.member.fail-access-cnt&quot;</span>, Integer.class, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the number of consecutive failures to access the target node reaches</span></span><br><span class="line">    <span class="comment">// a maximum, or the link request is rejected, the state is directly down</span></span><br><span class="line">    <span class="comment">// 超过重试次数设置节点状态为「下线」</span></span><br><span class="line">    <span class="keyword">if</span> (member.getFailAccessCnt() &gt; maxFailAccessCnt || StringUtils</span><br><span class="line">            .containsIgnoreCase(ex.getMessage(), TARGET_MEMBER_CONNECT_REFUSE_ERRMSG)) &#123;</span><br><span class="line">        member.setState(NodeState.DOWN);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!Objects.equals(old, member.getState())) &#123;</span><br><span class="line">        manager.notifyMemberChange(); <span class="comment">// 发布成员变更事件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>被kill -9 杀掉的节点显示状态为下线DOWN</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210702164901.png"></p>
<p><strong>注解@9</strong> 执行完executeBody后延迟2秒继续执行executeBody，也就是检查健康检查的心跳频率为2秒，一轮全部节点检查结束后延迟2秒接着下一轮</p>
<p>无论检查成功还是失败，当节点状态变更时，发布成员变更事件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!Objects.equals(old, member.getState())) &#123;</span><br><span class="line">    manager.notifyMemberChange();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">notifyMemberChange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    NotifyCenter.publishEvent(MembersChangeEvent.builder().members(allMembers()).build());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>小结：</strong> Nacos节点会向集群其他节点发送健康检查心跳，每一轮频率为2秒；当健康检查异常时设置为不信任「SUSPICIOUS」状态，超过失败最大次数3次设置为下线「DOWN」状态；健康检查成功设置该节点为科通信「UP」状态；无论成功还是失败当节点状态变更时均发布MembersChangeEvent事件。</p>
<h1 id="成员变更事件-1"><a href="#成员变更事件-1" class="headerlink" title="成员变更事件"></a>成员变更事件</h1><p>当集群中有节点下线或者新节点上线都会通过心跳健康检查探测对节点状态进行改变。而状态的变更均会触发成员变更事件MembersChangeEvent。那订阅到这个事件干啥呢？</p>
<p>ClusterRpcClientProxy继承了MemberChangeListener，当有MembersChangeEvent事件时会回调其onEvent方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(MembersChangeEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        List&lt;Member&gt; members = serverMemberManager.allMembersWithoutSelf();</span><br><span class="line">        refresh(members);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NacosException e) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那接着看refresh方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">(List&lt;Member&gt; members)</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Member member : members) &#123;</span><br><span class="line">        <span class="keyword">if</span> (MemberUtil.isSupportedLongCon(member)) &#123;</span><br><span class="line">            <span class="comment">// 注解@10</span></span><br><span class="line">            createRpcClientAndStart(member, ConnectionType.GRPC);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Set&lt;Map.Entry&lt;String, RpcClient&gt;&gt; allClientEntrys = RpcClientFactory.getAllClientEntries();</span><br><span class="line">    Iterator&lt;Map.Entry&lt;String, RpcClient&gt;&gt; iterator = allClientEntrys.iterator();</span><br><span class="line">    List&lt;String&gt; newMemberKeys = members.stream().filter(a -&gt; MemberUtil.isSupportedLongCon(a))</span><br><span class="line">            .map(a -&gt; memberClientKey(a)).collect(Collectors.toList());</span><br><span class="line">    <span class="comment">// 关闭旧的grpc连接</span></span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        Map.Entry&lt;String, RpcClient&gt; next1 = iterator.next();</span><br><span class="line">        <span class="keyword">if</span> (next1.getKey().startsWith(<span class="string">&quot;Cluster-&quot;</span>) &amp;&amp; !newMemberKeys.contains(next1.getKey())) &#123;</span><br><span class="line">            Loggers.CLUSTER.info(<span class="string">&quot;member leave,destroy client of member - &gt; : &#123;&#125;&quot;</span>, next1.getKey());</span><br><span class="line">            RpcClientFactory.getClient(next1.getKey()).shutdown();</span><br><span class="line">            iterator.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@10</strong> 为集群中每个节点member创建rcp client，在client启动时会先目标节点发送HealthCheckRequest，如果非健康节点将会被移除。见RpcClient类部分代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> isHealthy = healthCheck();</span><br><span class="line"><span class="comment">// 非健康节点</span></span><br><span class="line"><span class="keyword">if</span> (!isHealthy) &#123;</span><br><span class="line">    <span class="keyword">if</span> (currentConnection == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LoggerUtils.printIfInfoEnabled(LOGGER,</span><br><span class="line">            <span class="string">&quot;[&#123;&#125;]Server healthy check fail,currentConnection=&#123;&#125;&quot;</span>, name,</span><br><span class="line">            currentConnection.getConnectionId());</span><br><span class="line">    <span class="comment">// 标记客户端状态为unhealthy</span></span><br><span class="line">    rpcClientStatus.set(RpcClientStatus.UNHEALTHY);</span><br><span class="line">    <span class="comment">// 重置ReconnectContext移除serverInfo</span></span><br><span class="line">    reconnectContext = <span class="keyword">new</span> ReconnectContext(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure>

<p>这个意味着如果集群中有节点下线，与下线节点的rpc将会失效；同样如果集群中有新节点加入将会建立新的rpc通道。</p>
<p><strong>小结：</strong> 当集群节点成员变更时，MemberChangeListener会收到该事件。例如回调ClusterRpcClientProxy#onEvent触发refresh。刷新本节点与集群中其他节点的RPC状态，关闭无效的或者增加新的RPC连接。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>Nacos</category>
      </categories>
      <tags>
        <tag>Nacos</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty1# Netty组件之Channel实例化</title>
    <url>/posts/8e76511e/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="一、Channel概述"><a href="#一、Channel概述" class="headerlink" title="一、Channel概述"></a>一、Channel概述</h1><p>Channel提供了I/O的基本操作。从以下子接口中可以看出Netty对不同的底层协议提供了对应的channel来处理，例如：TCP/IP、UDP/IP、SCTP/IP、HTTP2等。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202185721.png"></p>
<a id="more"></a>



<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202185853.png"></p>
<h1 id="二、实例化流程"><a href="#二、实例化流程" class="headerlink" title="二、实例化流程"></a>二、实例化流程</h1><p>从客户端引导类示例中查看Channel初始化过程。示例中使用NioSocketChannel作为通信通道，在java中通信中会建立socket连接</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">Http2ClientInitializer initializer = <span class="keyword">new</span> Http2ClientInitializer(sslCtx, Integer.MAX_VALUE);</span><br><span class="line"></span><br><span class="line">Bootstrap b = <span class="keyword">new</span> Bootstrap();</span><br><span class="line"></span><br><span class="line">b.group(workerGroup);</span><br><span class="line"></span><br><span class="line">b.channel(NioSocketChannel.class);</span><br><span class="line"></span><br><span class="line">b.option(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">b.remoteAddress(HOST, PORT);</span><br><span class="line"></span><br><span class="line">b.handler(initializer);</span><br><span class="line"></span><br><span class="line">Channel channel = b.connect().syncUninterruptibly().channel();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;Connected to [&quot;</span> + HOST + <span class="string">&#x27;:&#x27;</span> + PORT + <span class="string">&#x27;]&#x27;</span>);</span><br></pre></td></tr></table></figure>



<p>Channel通过ChannelFactory创建，下面看一下ChannelFactory类图。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202185957.png"></p>
<p>ReflectiveChannelFactory提供了newChannel()方法通过反射实例化。</p>
<p>示例中通过b.channel(NioSocketChannel.class)将NioSocketChannel.class赋值给ReflectiveChannelFactory的成员变量Constructor&lt;? extends T&gt; constructor，Channel在connect的时候实例化，下面为实例化调用链路。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202190011.png"></p>
<!--more-->



<h1 id="三、实例化过程"><a href="#三、实例化过程" class="headerlink" title="三、实例化过程"></a>三、实例化过程</h1><p><strong>客户端实例化过程</strong></p>
<p>了解了Channel初始化调用链，再来看下以NioSocketChannel为例初始化做了哪些事情。下面是NioSocketChannel的四个构造重载方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioSocketChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>(DEFAULT_SELECTOR_PROVIDER); <span class="comment">// @1</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioSocketChannel</span><span class="params">(SelectorProvider provider)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>(newSocket(provider)); <span class="comment">// @2</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioSocketChannel</span><span class="params">(SocketChannel socket)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>(<span class="keyword">null</span>, socket);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioSocketChannel</span><span class="params">(Channel parent, SocketChannel socket)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">super</span>(parent, socket);</span><br><span class="line"></span><br><span class="line">config = <span class="keyword">new</span> NioSocketChannelConfig(<span class="keyword">this</span>, socket.socket());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractNioChannel</span><span class="params">(Channel parent, SelectableChannel ch, <span class="keyword">int</span> readInterestOp)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">super</span>(parent);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.ch = ch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.readInterestOp = readInterestOp;</span><br><span class="line"></span><br><span class="line">ch.configureBlocking(<span class="keyword">false</span>); <span class="comment">// @3</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>代码解读</strong></p>
<p>@1 默认使用SelectorProvider.provider()</p>
<p>@2 使用Provider创建SocketChannel。provider.openSocketChannel()-&gt;new SocketChannelImpl(this)。</p>
<p>@3 设置NioChannel非阻塞模式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：客户端NioSocketChannel实例化过程中已经回到所熟悉的java nio。创建了通道SocketChannel，并设置为非阻塞。</span><br></pre></td></tr></table></figure>



<p><strong>服务端实例化过程</strong></p>
<p>Channel服务端的实例化流程与客户端是相同的，下面以NioServerSocketChannel为例走查实例化过程。服务端引导初始化示例代码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line"></span><br><span class="line">b.option(ChannelOption.SO_BACKLOG, <span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">b.group(group)</span><br><span class="line"></span><br><span class="line">.channel(NioServerSocketChannel.class)</span><br><span class="line"></span><br><span class="line">.handler(<span class="keyword">new</span> LoggingHandler(LogLevel.INFO))</span><br><span class="line"></span><br><span class="line">.childHandler(<span class="keyword">new</span> Http2ServerInitializer(sslCtx));</span><br><span class="line"></span><br><span class="line">Channel ch = b.bind(PORT).sync().channel();</span><br></pre></td></tr></table></figure>



<p>NioServerSocketChannel的构造方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioServerSocketChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>(newSocket(DEFAULT_SELECTOR_PROVIDER)); <span class="comment">// @1</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioServerSocketChannel</span><span class="params">(SelectorProvider provider)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>(newSocket(provider)); <span class="comment">// @2</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioServerSocketChannel</span><span class="params">(ServerSocketChannel channel)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">super</span>(<span class="keyword">null</span>, channel, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">config = <span class="keyword">new</span> NioServerSocketChannelConfig(<span class="keyword">this</span>, javaChannel().socket());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractNioChannel</span><span class="params">(Channel parent, SelectableChannel ch, <span class="keyword">int</span> readInterestOp)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">super</span>(parent);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.ch = ch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.readInterestOp = readInterestOp;</span><br><span class="line"></span><br><span class="line">ch.configureBlocking(<span class="keyword">false</span>); <span class="comment">// @3</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>代码解读</strong></p>
<p>@1 使用默认Provider类SelectorProvider</p>
<p>@2 开启服务端通道ServerSocketChannel。provider.openServerSocketChannel()-&gt;new ServerSocketChannelImpl(this)。</p>
<p>@3 将ServerSocketChanne设置为非阻塞。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：服务端NioServerSocketChannel的实例化过程同样回到熟悉的Java NIO，创建非阻塞ServerSocketChanne通道。</span><br></pre></td></tr></table></figure>



<p><strong>实例化其他事项</strong> </p>
<p>在实例化的过程中，会调父类的构造方法super(parent)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractChannel</span><span class="params">(Channel parent)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.parent = parent;</span><br><span class="line"></span><br><span class="line">id = newId(); <span class="comment">// @1</span></span><br><span class="line"></span><br><span class="line">unsafe = newUnsafe(); <span class="comment">// @2</span></span><br><span class="line"></span><br><span class="line">pipeline = newChannelPipeline(); <span class="comment">// @3</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>@1 ChannelId初始化</strong></p>
<p>ChannelId是Channel的唯一标识，下面看下DefaultChannelId的生成规则。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">DefaultChannelId</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">data = <span class="keyword">new</span> <span class="keyword">byte</span>[MACHINE_ID.length + PROCESS_ID_LEN + SEQUENCE_LEN + TIMESTAMP_LEN + RANDOM_LEN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// machineId</span></span><br><span class="line"></span><br><span class="line">System.arraycopy(MACHINE_ID, <span class="number">0</span>, data, i, MACHINE_ID.length);</span><br><span class="line"></span><br><span class="line">i += MACHINE_ID.length;</span><br><span class="line"></span><br><span class="line"><span class="comment">// processId</span></span><br><span class="line"></span><br><span class="line">i = writeInt(i, PROCESS_ID);</span><br><span class="line"></span><br><span class="line"><span class="comment">// sequence</span></span><br><span class="line"></span><br><span class="line">i = writeInt(i, nextSequence.getAndIncrement());</span><br><span class="line"></span><br><span class="line"><span class="comment">// timestamp (kind of)</span></span><br><span class="line"></span><br><span class="line">i = writeLong(i, Long.reverse(System.nanoTime()) ^ System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line"><span class="comment">// random</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> random = PlatformDependent.threadLocalRandom().nextInt();</span><br><span class="line"></span><br><span class="line">i = writeInt(i, random);</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> i == data.length;</span><br><span class="line"></span><br><span class="line">hashCode = Arrays.hashCode(data);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：默认的ChannelId由machineId、processId、sequence、timestamp、random构成。</span><br><span class="line">machineId：可以由参数io.netty.machineId自定义，默认为8位随机byte构成</span><br><span class="line">processId：可以由参数io.netty.processId自定义，默认为4位进程ID</span><br><span class="line">sequence：原子自增序号AtomicInteger，每创建一个Chanenl会进行自增</span><br><span class="line">timestamp：8位的timestamp</span><br><span class="line">random：4位的随机整数</span><br></pre></td></tr></table></figure>

<p><strong>@2 unsafe初始化</strong></p>
<p>unsafe即I/O的核心操作，byte的读写都靠它来处理。服务端NioServerSocketChannel初始化使用NioMessageUnsafe。客户端NioSocketChannel初始化使用NioSocketChannelUnsafe。以NIO为例看下Unsafe的类图结构。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202190316.png"></p>
<p><strong>@3 ChannelPipeline初始化</strong></p>
<p>默认使用DefaultChannelPipeline，从构造方法可以看出为链表结构，详细分析另文分析。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">DefaultChannelPipeline</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.channel = ObjectUtil.checkNotNull(channel, <span class="string">&quot;channel&quot;</span>);</span><br><span class="line"></span><br><span class="line">succeededFuture = <span class="keyword">new</span> SucceededChannelFuture(channel, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">voidPromise = <span class="keyword">new</span> VoidChannelPromise(channel, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">tail = <span class="keyword">new</span> TailContext(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">head = <span class="keyword">new</span> HeadContext(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">head.next = tail;</span><br><span class="line"></span><br><span class="line">tail.prev = head;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty10# 堆外内存底盘PlatformDependent</title>
    <url>/posts/821aaf66/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>非池化/池化内存如何分配的？该撸这块了，奈何到处都在调用PlatformDependent类的方法，要不各种判断，要不分配堆外内存。反正到处都能看到它，得，索性先把这个撸一把。PlatformDependent又依赖了PlatformDependent0，那就一层一层剥好了。</p>
<p>嗯，有点碎，大伙随便看看。</p>
<a id="more"></a>



<h1 id="PlatformDependent0"><a href="#PlatformDependent0" class="headerlink" title="PlatformDependent0"></a>PlatformDependent0</h1><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><table>
<thead>
<tr>
<th>名称</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td>ADDRESS_FIELD_OFFSET</td>
<td align="left">Buffer#address字段的内存偏移地址</td>
</tr>
<tr>
<td>BYTE_ARRAY_BASE_OFFSET</td>
<td align="left">获取内存中第一个元素的内存偏移量</td>
</tr>
<tr>
<td>DIRECT_BUFFER_CONSTRUCTOR</td>
<td align="left">DirectByteBuffer构造器对象，用于反射实例化</td>
</tr>
<tr>
<td>EXPLICIT_NO_UNSAFE_CAUSE</td>
<td align="left">平台不支持UNSAFE时，不支持异常封装在EXPLICIT_NO_UNSAFE_CAUSE中</td>
</tr>
<tr>
<td>ALLOCATE_ARRAY_METHOD</td>
<td align="left">Unsafe#allocateUninitializedArray Method对象，用于反射调用</td>
</tr>
<tr>
<td>JAVA_VERSION</td>
<td align="left">获取Java版本</td>
</tr>
<tr>
<td>IS_ANDROID</td>
<td align="left">系统是否为Android</td>
</tr>
<tr>
<td>UNSAFE_UNAVAILABILITY_CAUSE</td>
<td align="left">系统不支持UNSAFE会将异常封装在此变量中</td>
</tr>
<tr>
<td>INTERNAL_UNSAFE</td>
<td align="left">Java9中Unsafe实例对象</td>
</tr>
<tr>
<td>IS_EXPLICIT_TRY_REFLECTION_SET_ACCESSIBLE</td>
<td align="left">启用反射访问，在Java9版本之前是禁止的；Java9以及之后版本需要开启（这点要注意，Netty到处都有对Java9之后的兼容判断）</td>
</tr>
<tr>
<td>UNSAFE</td>
<td align="left">Unsafe实例对象，操作堆外内存</td>
</tr>
<tr>
<td>UNSAFE_COPY_THRESHOLD</td>
<td align="left">Java8以及以下版本内存拷贝时的最大阈值，最大为1M（1024L * 1024L）</td>
</tr>
<tr>
<td>UNALIGNED</td>
<td align="left">java.nio.Bits#unaligned方法在当前系统是否可用</td>
</tr>
</tbody></table>
<h3 id="赋值流程"><a href="#赋值流程" class="headerlink" title="赋值流程"></a>赋值流程</h3><p>这部分主要针对当前运行的系统平台是否支持UNSAFE等众多涉及到堆外内存分配的属性是否支持，以及赋值给成员变量，在static静态块中判断。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210131171437.png"></p>
<p><strong>@1 检查平台是否支持Unsafe，不支持将异常错误封装在UNSAFE_UNAVAILABILITY_CAUSE中</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210131102931.png"></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210131103148.png"></p>
<p><strong>@2 如果系统支持Unsafe，检查Unsafe类中是否包含copyMemory方法，不支持禁用Unsaf</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210131103401.png"></p>
<p><strong>@3 检查Buffer类的内存地址address功能，不支持禁用Unsafe</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210131103802.png"></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210131172146.png"></p>
<p><strong>@4 检查Unsafe类中的arrayIndexScale方法是否支持，不支持禁用Unsafe</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210131104315.png"></p>
<p><strong>@5 检查是否支持反射获取DirectBuffer的构造器，方便堆外内存分配</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210131110146.png"></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210131110242.png"></p>
<p><strong>@6 检查系统是否支持java.nio.Bits#unaligned方法</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210131172239.png"></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210131172305.png"></p>
<p><strong>@7 Java9以及以上版本检查jdk.internal.misc.Unsafe以及其方法allocateUninitializedArray，并赋值给INTERNAL_UNSAFE和ALLOCATE_ARRAY_METHOD</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210131111631.png"></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210131172450.png"></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210131111747.png"></p>
<h3 id="重要方法走查"><a href="#重要方法走查" class="headerlink" title="重要方法走查"></a>重要方法走查</h3><p>PlatformDependent0提供的方法，主要判断Unsafe是否可用、Unsafe分配堆外内存、Unsafe从堆外内存获取数据等。下面挑几个走查下。</p>
<p><strong>@1 检查UNSAFE是否可用</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasUnsafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> UNSAFE != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>@2 DirectByteBuffer的构造函数是否可用</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasDirectBufferNoCleanerConstructor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> DIRECT_BUFFER_CONSTRUCTOR != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>@3 堆外内存分配</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  malloc()返回获得内存空间的首地址，失败返回null</span></span><br><span class="line"><span class="comment">*  根据返回的内存地址构造DirectBuffer</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> capacity</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> ByteBuffer <span class="title">allocateDirectNoCleaner</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * malloc()返回获得内存空间的首地址，失败返回null</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">	<span class="keyword">return</span> newDirectBuffer(UNSAFE.allocateMemory(Math.max(<span class="number">1</span>, capacity)), capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>@4 调用DirectByteBuffer构造函数分配堆外内存</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ByteBuffer <span class="title">newDirectBuffer</span><span class="params">(<span class="keyword">long</span> address, <span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        ObjectUtil.checkPositiveOrZero(capacity, <span class="string">&quot;capacity&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (ByteBuffer) DIRECT_BUFFER_CONSTRUCTOR.newInstance(address, capacity);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable cause) &#123;</span><br><span class="line">            <span class="comment">// Not expected to ever throw!</span></span><br><span class="line">            <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> Error) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (Error) cause;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(cause);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>@5 获取堆外内存数据</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">byte</span> <span class="title">getByte</span><span class="params">(<span class="keyword">long</span> address)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> UNSAFE.getByte(address);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="PlatformDependent"><a href="#PlatformDependent" class="headerlink" title="PlatformDependent"></a>PlatformDependent</h1><h3 id="成员变量-1"><a href="#成员变量-1" class="headerlink" title="成员变量"></a>成员变量</h3><table>
<thead>
<tr>
<th>名称</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>MAX_DIRECT_MEMORY_SIZE_ARG_PATTERN</td>
<td>允许最大堆外内存的正则表达式，可以通过MaxDirectMemorySize参数在应用启动时指定</td>
</tr>
<tr>
<td>IS_WINDOWS</td>
<td>判断系统是否为windows系统</td>
</tr>
<tr>
<td>IS_OSX</td>
<td>判断是否为MacOS系统</td>
</tr>
<tr>
<td>IS_J9_JVM</td>
<td>是否为jdk9版本</td>
</tr>
<tr>
<td>IS_IVKVM_DOT_NET</td>
<td>判断是否为IKVM.NET</td>
</tr>
<tr>
<td>MAYBE_SUPER_USER</td>
<td>判断是否为root超级用户</td>
</tr>
<tr>
<td>CAN_ENABLE_TCP_NODELAY_BY_DEFAULT</td>
<td>Linux系统可以开启TCP_NODELAY参数，当开启时数据会以最快的速度发出去同时也就禁用了纳格算法（Nagle algorithm）；如果不设置（开启纳格算法），数据会缓存满足阈值后发出</td>
</tr>
<tr>
<td>UNSAFE_UNAVAILABILITY_CAUSE</td>
<td>平台不支持UNSAFE会将异常封装在UNSAFE_UNAVAILABILITY_CAUSE中</td>
</tr>
<tr>
<td>DIRECT_BUFFER_PREFERRED</td>
<td>默认优先使用堆外内存分配</td>
</tr>
<tr>
<td>MAX_DIRECT_MEMORY</td>
<td>获取最大堆外内存通过sun.misc.VM#maxDirectMemory方法获取</td>
</tr>
<tr>
<td>MPSC_CHUNK_SIZE</td>
<td>使用JCTools提供的无锁队列，初始化队列容量，默认1024</td>
</tr>
<tr>
<td>MIN_MAX_MPSC_CAPACITY</td>
<td>使用JCTools提供的无锁队列，最大队列容量；MIN_MAX_MPSC_CAPACITY =  MPSC_CHUNK_SIZE * 2</td>
</tr>
<tr>
<td>MAX_ALLOWED_MPSC_CAPACITY</td>
<td>使用JCTools提供的无锁队列，允许队列最大容量，默认为1073741824（1 &lt;&lt; 30）；MAX_ALLOWED_MPSC_CAPACITY = Pow2.MAX_POW2</td>
</tr>
<tr>
<td>BYTE_ARRAY_BASE_OFFSET</td>
<td>获取内存中第一个元素的内存偏移量；UNSAFE.arrayBaseOffset</td>
</tr>
<tr>
<td>TMPDIR</td>
<td>Netty临时目录</td>
</tr>
<tr>
<td>BIT_MODE</td>
<td>操作系统是32位还是64位</td>
</tr>
<tr>
<td>NORMALIZED_ARCH</td>
<td>获取操作系统CPU architecture，例如：x86_64</td>
</tr>
<tr>
<td>NORMALIZED_OS</td>
<td>获取操作系统名称，例如：Linux</td>
</tr>
<tr>
<td>ALLOWED_LINUX_OS_CLASSIFIERS</td>
<td>Linux系统演化了众多版本，下面是允许的的Linux版本</td>
</tr>
<tr>
<td>LINUX_OS_CLASSIFIERS</td>
<td>通过系统识别文件将支持的Linux版本填充到该集合中，是ALLOWED_LINUX_OS_CLASSIFIERS子集</td>
</tr>
<tr>
<td>ADDRESS_SIZE</td>
<td>返回系统指针的大小，32位系统返回4；64位系统返回8</td>
</tr>
<tr>
<td>USE_DIRECT_BUFFER_NO_CLEANER</td>
<td>堆外内存是否能分配（系统是否支持unsafe、DirectByteBuffer是否可用）</td>
</tr>
<tr>
<td>DIRECT_MEMORY_COUNTER</td>
<td>堆外内存使用限制</td>
</tr>
<tr>
<td>ThreadLocalRandomProvider</td>
<td>随机数字生成器</td>
</tr>
<tr>
<td>CLEANER</td>
<td>可以用于堆外内存回收</td>
</tr>
<tr>
<td>UNINITIALIZED_ARRAY_ALLOCATION_THRESHOLD</td>
<td>堆外内存分配阈值，默认为1024（字节）；小于该阈值分配堆内存，大于分配堆外内存；可以通过-Dio.netty.uninitializedArrayAllocationThreshold指定</td>
</tr>
<tr>
<td>OS_RELEASE_FILES</td>
<td>包含了操作系统识别数据 /etc/os-release与/usr/lib/os-release；String[] OS_RELEASE_FILES = {“/etc/os-release”, “/usr/lib/os-release”}</td>
</tr>
<tr>
<td>BIG_ENDIAN_NATIVE_ORDER</td>
<td>是否为大端排序（默认大端排序）；boolean BIG_ENDIAN_NATIVE_ORDER = ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN</td>
</tr>
</tbody></table>
<h3 id="重要方法走查-1"><a href="#重要方法走查-1" class="headerlink" title="重要方法走查"></a>重要方法走查</h3><p>挑几个比较重要的方法走查下，</p>
<p><strong>@1 内存分配</strong></p>
<p>小于阈值默认1024（字节），使用堆内存；大于阈值使用堆外内存</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] allocateUninitializedArray(<span class="keyword">int</span> size) &#123;</span><br><span class="line">        <span class="keyword">return</span> UNINITIALIZED_ARRAY_ALLOCATION_THRESHOLD &lt; <span class="number">0</span> || UNINITIALIZED_ARRAY_ALLOCATION_THRESHOLD &gt; size ?</span><br><span class="line">                <span class="keyword">new</span> <span class="keyword">byte</span>[size] : PlatformDependent0.allocateUninitializedArray(size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>@2释放堆外内存</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">freeDirectBuffer</span><span class="params">(ByteBuffer buffer)</span> </span>&#123;</span><br><span class="line">        CLEANER.freeDirectBuffer(buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>@3 构造Queue</strong></p>
<p>使用了使用JCTools提供的无锁队列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Queue&lt;T&gt; <span class="title">newMpscQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Mpsc.newMpscQueue();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function">Queue&lt;T&gt; <span class="title">newMpscQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> USE_MPSC_CHUNKED_ARRAY_QUEUE ? <span class="keyword">new</span> MpscUnboundedArrayQueue&lt;T&gt;(MPSC_CHUNK_SIZE)</span><br><span class="line">    : <span class="keyword">new</span> MpscUnboundedAtomicArrayQueue&lt;T&gt;(MPSC_CHUNK_SIZE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>其他的方法基本在判断成员变量或者调用PlatformDependent0的方法分配堆外内存、获取堆外内存数据、释放堆外内存等。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>PlatformDependent与PlatformDependent0主要针对操作系统、JDK版本等环境因素是否支持堆外内存Unsafe以及一些关联类进行判断；通过封装Unsafe申请堆外内存、释放、获取数据等操作。另外Netty为了提高性能使用了JCTools提供的无锁队列、可以通过-XX:MaxDirectMemorySize参数调整Netty允许使用的最大堆外内存，超过最大限制将使堆外内存分配失败，抛出 “failed to allocate byte(s) of direct memory” 异常。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty12# 池化内存框架流程</title>
    <url>/posts/80419269/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文简要梳理为什么使用池化内存？Netty使用池化内存从哪些方面提升了效率？梳理了池化内存的核心组件大体含义以及内存分配流程，勾勒池化内存的整体框架。后面文章会详细拆解每个点是如何实现的。</p>
<a id="more"></a>



<h1 id="使用池化内存"><a href="#使用池化内存" class="headerlink" title="使用池化内存"></a>使用池化内存</h1><p><strong>为啥要使用池化内存呢？</strong> 主要以下两点：</p>
<p>1.频繁申请释放堆外直接内存耗时严重影响效率</p>
<p>2.减少小而不连续的空闲内存（也就是内存碎片）</p>
<p><strong>Netty中又是如何体现内存池并提升效率的呢？</strong> </p>
<p>1.将申请的大块内存划分为不同的尺寸</p>
<p>2.不同尺寸的内存使用不同的分配算法，例如：Netty参考slab内存分配算法和Buddy（伙伴）分配算法</p>
<p>3.将划分的不同尺寸缓存起来，使用的时候先从缓存中获取</p>
<p>4.每个线程绑定了专属逻辑内存区域（PoolArena），减少资源竞争</p>
<p>5.使用对象池减少频繁创建销毁性能损耗（ByteBuf对象池）</p>
<p>6.内存用完后，按照特定算法重新合并到大块内存中，看起来像是内存池</p>
<h1 id="内存池核心组件"><a href="#内存池核心组件" class="headerlink" title="内存池核心组件"></a>内存池核心组件</h1><p><strong>内存池尺寸划分</strong></p>
<p>Netty内存池划分了四种类型尺寸，Netty以Chunk为单位申请内存。 内存池主要指16M（默认）以下的内存，大于16M的内存分配不做缓存。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>范围</th>
</tr>
</thead>
<tbody><tr>
<td>tiny</td>
<td>0~512Byte，内存分配参考了slab算法</td>
</tr>
<tr>
<td>small</td>
<td>512Byte~8KB，内存分配同tiny参考了slab算法</td>
</tr>
<tr>
<td>normal</td>
<td>8KB~16M，内存分配参考了</td>
</tr>
<tr>
<td>huge</td>
<td>大于16M</td>
</tr>
</tbody></table>
<p><strong>内存池核心类</strong> </p>
<table>
<thead>
<tr>
<th>类名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>PooledByteBufAllocator</td>
<td>内存池门面类，池化内存分配入口</td>
</tr>
<tr>
<td>PoolArena</td>
<td>逻辑上的一块内存区域，管理多个PoolChunk</td>
</tr>
<tr>
<td>PoolChunk</td>
<td>连续的内存区域，一个Chunk大小为16M。每个Chunk由Page组成，每个Page大小为8KB；包含nomal类型核心内存分配算法（参考了Buddy（伙伴）分配算法）</td>
</tr>
<tr>
<td>PoolSubpage</td>
<td>包含8KB以下tiny和small的核心分配算法（参考了slab分配算法）</td>
</tr>
<tr>
<td>PoolThreadCache</td>
<td>每个线程都有独立的PoolThreadCache，缓存了tiny类型、small类型、normal类型；分配时先从缓存中获取</td>
</tr>
<tr>
<td>Recycler</td>
<td>轻量级对象缓存池，避免频繁创建和消费性能损耗</td>
</tr>
<tr>
<td>ResourceLeakDetector</td>
<td>负责内存泄漏检测</td>
</tr>
</tbody></table>
<h1 id="内存分配流程"><a href="#内存分配流程" class="headerlink" title="内存分配流程"></a>内存分配流程</h1><p>下面通过PooledByteBufAllocator#newDirectBuffer()方法，梳理内存分配的整体流程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> ByteBuf <span class="title">newDirectBuffer</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">   PoolThreadCache cache = threadCache.get(); <span class="comment">// 注解@1</span></span><br><span class="line">   PoolArena&lt;ByteBuffer&gt; directArena = cache.directArena;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> ByteBuf buf;</span><br><span class="line">  <span class="keyword">if</span> (directArena != <span class="keyword">null</span>) &#123;</span><br><span class="line">  	buf = directArena.allocate(cache, initialCapacity, maxCapacity); <span class="comment">// 注解@2</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    buf = PlatformDependent.hasUnsafe() ?</span><br><span class="line">    UnsafeByteBufUtil.newUnsafeDirectByteBuf(<span class="keyword">this</span>, initialCapacity, maxCapacity) :</span><br><span class="line">    <span class="keyword">new</span> UnpooledDirectByteBuf(<span class="keyword">this</span>, initialCapacity, maxCapacity);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> toLeakAwareBuffer(buf); <span class="comment">// 注解@3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@1</strong>  从当前线程中获取PoolThreadCache，也就是每个线程都绑定了PoolThreadCache</p>
<p><strong>注解@2</strong> 执行内存分配过程</p>
<p><strong>注解@3</strong> 通过ResourceLeakDetector检测内存泄漏</p>
<p>跟踪第二步，查看内存分配过程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function">PooledByteBuf&lt;T&gt; <span class="title">allocate</span><span class="params">(PoolThreadCache cache, <span class="keyword">int</span> reqCapacity, <span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">        PooledByteBuf&lt;T&gt; buf = newByteBuf(maxCapacity); </span><br><span class="line">        allocate(cache, buf, reqCapacity);</span><br><span class="line">        <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PooledByteBuf从RECYCLER中获取（对象池）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> PooledUnsafeDirectByteBuf <span class="title">newInstance</span><span class="params">(<span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">        PooledUnsafeDirectByteBuf buf = RECYCLER.get();</span><br><span class="line">        buf.reuse(maxCapacity);</span><br><span class="line">        <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的内存分配过程，先关注主干代码框架，分配过程整体包含了三个部分： tiny&amp;small、small、huge。</p>
<p>huge：大于16M，直接分配堆外直接内存。</p>
<p>small：先从缓存中分配，缓存没有再从内存池分配（借鉴了buddy伙伴算法）</p>
<p>tiny&amp;small：先从缓存中分配，缓存没有再从内存池分配（借鉴了slab算法）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">allocate</span><span class="params">(PoolThreadCache cache, PooledByteBuf&lt;T&gt; buf, <span class="keyword">final</span> <span class="keyword">int</span> reqCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> normCapacity = normalizeCapacity(reqCapacity);</span><br><span class="line">        <span class="keyword">if</span> (isTinyOrSmall(normCapacity)) &#123; <span class="comment">// capacity &lt; pageSize（8KB） tiny或者small粒度</span></span><br><span class="line">            <span class="keyword">int</span> tableIdx;</span><br><span class="line">            PoolSubpage&lt;T&gt;[] table;</span><br><span class="line">            <span class="keyword">boolean</span> tiny = isTiny(normCapacity);</span><br><span class="line">            <span class="keyword">if</span> (tiny) &#123; <span class="comment">// &lt; 512 tiny粒度</span></span><br><span class="line">                <span class="keyword">if</span> (cache.allocateTiny(<span class="keyword">this</span>, buf, reqCapacity, normCapacity)) &#123; <span class="comment">// 缓存分配</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                tableIdx = tinyIdx(normCapacity);</span><br><span class="line">                table = tinySubpagePools;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// small 粒度</span></span><br><span class="line">                <span class="keyword">if</span> (cache.allocateSmall(<span class="keyword">this</span>, buf, reqCapacity, normCapacity)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                tableIdx = smallIdx(normCapacity);</span><br><span class="line">                table = smallSubpagePools;</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">            <span class="keyword">final</span> PoolSubpage&lt;T&gt; head = table[tableIdx];  <span class="comment">// 获取对应的节点</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (head) &#123;</span><br><span class="line">                <span class="keyword">final</span> PoolSubpage&lt;T&gt; s = head.next;</span><br><span class="line">                <span class="keyword">if</span> (s != head) &#123;</span><br><span class="line">                    <span class="keyword">assert</span> s.doNotDestroy &amp;&amp; s.elemSize == normCapacity;</span><br><span class="line">                    <span class="keyword">long</span> handle = s.allocate();</span><br><span class="line">                    <span class="keyword">assert</span> handle &gt;= <span class="number">0</span>;</span><br><span class="line">                    s.chunk.initBufWithSubpage(buf, <span class="keyword">null</span>, handle, reqCapacity);</span><br><span class="line">                    incTinySmallAllocation(tiny);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                allocateNormal(buf, reqCapacity, normCapacity);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            incTinySmallAllocation(tiny);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (normCapacity &lt;= chunkSize) &#123; <span class="comment">// Normal粒度（8K~16M） </span></span><br><span class="line">            <span class="keyword">if</span> (cache.allocateNormal(<span class="keyword">this</span>, buf, reqCapacity, normCapacity)) &#123; <span class="comment">// 尝试先从缓存分配</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                allocateNormal(buf, reqCapacity, normCapacity);</span><br><span class="line">                ++allocationsNormal;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            allocateHuge(buf, reqCapacity); <span class="comment">// 大于16M的huge内存分配</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><strong>小结下内存分配的整体过程</strong> </p>
<p>1.从RECYCLER对象池中复用PooledByteBuf</p>
<p>2.每个线程绑定了缓存PoolThreadCache</p>
<p>3.内存分配时，先从当前线程绑定的PoolThreadCache缓存分配；缓存没有再内存池分配，不同内存尺寸使用不同的分配算法</p>
<p>4.每个分配的Buffer都会由ResourceLeakDetector检测内存泄漏</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty11# 非池化内存分配</title>
    <url>/posts/f74d0239/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>非池化内存的分配由UnpooledByteBufAllocator负责，本文梳理下由其负责分配的堆内存和堆外内存如何实现的 。</p>
<p>Netty在非池化堆内存分配上Java9与Java8以下版本有啥不同呢？Netty堆外内存回收默认机制使用JDK提供的Cleaner吗？</p>
<a id="more"></a>



<h1 id="非池化堆内内存分配"><a href="#非池化堆内内存分配" class="headerlink" title="非池化堆内内存分配"></a>非池化堆内内存分配</h1><p>下面这小段代码摘自UnpooledByteBufAllocator#newHeapBuffer，通过此方法分析非池化堆内存的分配。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ByteBuf <span class="title">newHeapBuffer</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> PlatformDependent.hasUnsafe() ?</span><br><span class="line">  <span class="keyword">new</span> InstrumentedUnpooledUnsafeHeapByteBuf(<span class="keyword">this</span>, initialCapacity, maxCapacity) :</span><br><span class="line">  <span class="keyword">new</span> InstrumentedUnpooledHeapByteBuf(<span class="keyword">this</span>, initialCapacity, maxCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>解读：</strong> 堆内内存分配由newHeapBuffer方法负责，如果平台支持Unsafe则创建InstrumentedUnpooledUnsafeHeapByteBuf，否则创建</p>
<p>InstrumentedUnpooledHeapByteBuf，下图为非池化相关类图，分别从两个类UnpooledDirectByteBuf和UnpooledHeapByteBuf延伸开来。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/%E9%9D%9E%E6%B1%A0%E5%8C%96%E7%B1%BB%E5%9B%BE.png"></p>
<p>还是聚集到堆内存的分配上来，主要分析上图中红色部分。InstrumentedUnpooledUnsafeHeapByteBuf和InstrumentedUnpooledHeapByteBuf有啥区别？</p>
<h3 id="InstrumentedUnpooledUnsafeHeapByteBuf"><a href="#InstrumentedUnpooledUnsafeHeapByteBuf" class="headerlink" title="InstrumentedUnpooledUnsafeHeapByteBuf"></a>InstrumentedUnpooledUnsafeHeapByteBuf</h3><p>下面看下InstrumentedUnpooledUnsafeHeapByteBuf其内存分配的行为allocateArray().</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210206144813.png"></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210206144919.png"></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210206145307.png"></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210206180549.png"></p>
<p><strong>注解@1</strong> 调用了父类UnpooledUnsafeHeapByteBuf的allocateArray()</p>
<p><strong>注解@2</strong> 父类UnpooledUnsafeHeapByteBuf调用了PlatformDependent#allocateUninitializedArray</p>
<p><strong>注解@3/@4</strong>  Java9以上版本：如果待分配的内存小于1K使用堆内存，待分配的内存大于等于1K使用堆外内存。</p>
<p>Java8以及以下版本全部在堆内存分配</p>
<p><u><strong>小结：</strong>  使用InstrumentedUnpooledUnsafeHeapByteBuf进行内存分配时：</u></p>
<p><u>Java9以及以上版本：如果待分配的内存小于1K使用堆内存；待分配的内存大于等于1K使用堆外内存（调用底层PlatformDependent#allocateUninitializedArray）。</u></p>
<p><u>Java8以及以下版本：使用堆内存分配。</u></p>
<h3 id="InstrumentedUnpooledHeapByteBuf"><a href="#InstrumentedUnpooledHeapByteBuf" class="headerlink" title="InstrumentedUnpooledHeapByteBuf"></a>InstrumentedUnpooledHeapByteBuf</h3><p>下面为InstrumentedUnpooledHeapByteBuf的内存分配allocateArray().</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210206150611.png"></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210206150640.png"></p>
<p><strong>注解@1</strong> 调用父类 UnpooledHeapByteBuf的内存分配</p>
<p><strong>注解@2</strong> UnpooledHeapByteBuf的通过new byte直接在堆内存分配</p>
<p><u><strong>小结：</strong> InstrumentedUnpooledHeapByteBuf直接在堆内存分配空间。</u></p>
<h3 id="数据获取方式"><a href="#数据获取方式" class="headerlink" title="数据获取方式"></a>数据获取方式</h3><p><strong>UnpooledUnsafeHeapByteBuf数据获取</strong> </p>
<p>UnpooledUnsafeHeapByteBuf的数据获取方式getByte()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">byte</span> <span class="title">_getByte</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> UnsafeByteBufUtil.getByte(array, index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法调用UnsafeByteBufUtil的getByte，跟进去看下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">byte</span> <span class="title">getByte</span><span class="params">(<span class="keyword">byte</span>[] array, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> PlatformDependent.getByte(array, index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>底层通过UNSAFE.getByte这种地址+偏移量的方式获取内存中的数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">byte</span> <span class="title">getByte</span><span class="params">(<span class="keyword">byte</span>[] data, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> UNSAFE.getByte(data, BYTE_ARRAY_BASE_OFFSET + index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>UnpooledHeapByteBuf数据获取</strong> </p>
<p>UnpooledHeapByteBuf数据获取方式_getByte()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">byte</span> <span class="title">_getByte</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> HeapByteBufUtil.getByte(array, index);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>该方法调用HeapByteBufUtil.getByte，跟进去看下，即直接从数组中获取数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">byte</span> <span class="title">getByte</span><span class="params">(<span class="keyword">byte</span>[] memory, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> memory[index];</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<p><u><strong>小结：</strong> UnpooledUnsafeHeapByteBuf通过UNSAFE.getByte这种地址+偏移量的方式获取内存中的数据；UnpooledHeapByteBuf通过数组直接从堆内存获取。</u></p>
<h3 id="非池化堆内存分配总结"><a href="#非池化堆内存分配总结" class="headerlink" title="非池化堆内存分配总结"></a>非池化堆内存分配总结</h3><p><u>当使用Netty非池化进行堆内存分配时：</u></p>
<p><u>1.Java8及其以下版本：直接在堆空间分配内存。</u></p>
<p><u>2.Java9及其以上版本：如果系统支持Unsafe时（通常都是支持的），对于小于1K（默认）的在堆内存分配，大于1K的分配堆外内存；如果系统不支持Unsafe直接在堆内存分配；默认大小阈值可以通过-Dio.netty.uninitializedArrayAllocationThreshold来指定，默认为1024字节。</u></p>
<p><u>3.堆内存数据获取通过数组实现；堆外内存获取通过UNSAFE.getByte这种地址+偏移量的方式获取。</u></p>
<h1 id="非池化堆外内存分配"><a href="#非池化堆外内存分配" class="headerlink" title="非池化堆外内存分配"></a>非池化堆外内存分配</h1><p>下面这段代码摘自UnpooledByteBufAllocator#newDirectBuffer方法，通过此方法分析非池化堆外存的分配。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ByteBuf <span class="title">newDirectBuffer</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> ByteBuf buf;</span><br><span class="line">  <span class="keyword">if</span> (PlatformDependent.hasUnsafe()) &#123;</span><br><span class="line">  	buf = noCleaner ? <span class="keyword">new</span> InstrumentedUnpooledUnsafeNoCleanerDirectByteBuf(<span class="keyword">this</span>, initialCapacity, maxCapacity) :</span><br><span class="line">  	<span class="keyword">new</span> InstrumentedUnpooledUnsafeDirectByteBuf(<span class="keyword">this</span>, initialCapacity, maxCapacity);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  	buf = <span class="keyword">new</span> InstrumentedUnpooledDirectByteBuf(<span class="keyword">this</span>, initialCapacity, maxCapacity);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> disableLeakDetector ? buf : toLeakAwareBuffer(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解读：</strong> 平台不支持支持Unsafe，构造InstrumentedUnpooledDirectByteBuf；平台支持Unsafe并且noCleaner=true构造InstrumentedUnpooledUnsafeNoCleanerDirectByteBuf；平台支持Unsafe并且noCleaner=false，构造InstrumentedUnpooledUnsafeDirectByteBuf。那问题来了，这三个有啥区别呢？</p>
<h3 id="noCleaner"><a href="#noCleaner" class="headerlink" title="noCleaner"></a>noCleaner</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">noCleaner = tryNoCleaner &amp;&amp; PlatformDependent.hasUnsafe()</span><br><span class="line">               &amp;&amp; PlatformDependent.hasDirectBufferNoCleanerConstructor();</span><br></pre></td></tr></table></figure>

<p><strong>解读</strong> ：三个判断条件一个一个来看：</p>
<p>@1 tryNoCleaner=PlatformDependent.useDirectBufferNoCleaner()该方法在前一篇文章中也分析过，当maxDirectMemory!=0 &amp;&amp; 支持Unsafe &amp;&amp; DirectByteBuffer的构造函数可用时，tryNoCleaner = true。</p>
<p>@2 PlatformDependent.hasUnsafe() 在上一篇文章中分析过具体 UNSAFE_UNAVAILABILITY_CAUSE == null，平台不支持UNSAFE会将异常封装在UNSAFE_UNAVAILABILITY_CAUSE中，等于null意味着平台支持Unsafe。</p>
<p>@3 PlatformDependent.hasDirectBufferNoCleanerConstructor() 指的是通过反射DirectByteBuffer构造器对象是否可用。</p>
<p>所以看出，通常在实践中（Linux、JDK8）上面这些条件都是支持的，也就是Netty默认noCleaner为true。</p>
<h3 id="InstrumentedUnpooledUnsafeNoCleanerDirectByteBuf"><a href="#InstrumentedUnpooledUnsafeNoCleanerDirectByteBuf" class="headerlink" title="InstrumentedUnpooledUnsafeNoCleanerDirectByteBuf"></a>InstrumentedUnpooledUnsafeNoCleanerDirectByteBuf</h3><p>下面看下堆外内存的分配和回收：</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210208102959.png"></p>
<p><strong>注解@1</strong>  堆外内存分配底层调用了PlatformDependent0#allocateDirectNoCleaner方法，malloc()返回获得内存空间的首地址，失败返回null，然后根据返回的内存地址调用DirectByteBuffer构造函数分配堆外内存。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ByteBuffer <span class="title">allocateDirectNoCleaner</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Calling malloc with capacity of 0 may return a null ptr or a memory address that can be used.</span></span><br><span class="line">  <span class="comment">// Just use 1 to make it safe to use in all cases:</span></span><br><span class="line">  <span class="comment">// See: http://pubs.opengroup.org/onlinepubs/009695399/functions/malloc.html</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * malloc()返回获得内存空间的首地址，失败返回null</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">	<span class="keyword">return</span> newDirectBuffer(UNSAFE.allocateMemory(Math.max(<span class="number">1</span>, capacity)), capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@2</strong> 堆外内存释放底层调用了PlatformDependent0#freeMemory方法，通过UNSAFE.freeMemory释放堆外内存。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">freeMemory</span><span class="params">(<span class="keyword">long</span> address)</span> </span>&#123;</span><br><span class="line">    UNSAFE.freeMemory(address);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="InstrumentedUnpooledUnsafeDirectByteBuf"><a href="#InstrumentedUnpooledUnsafeDirectByteBuf" class="headerlink" title="InstrumentedUnpooledUnsafeDirectByteBuf"></a>InstrumentedUnpooledUnsafeDirectByteBuf</h3><p>下面看下堆外内存的分配与回收</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210209094247.png"></p>
<p><strong>注解@1</strong> 底层调用ByteBuffer#allocateDirect来分配堆外内存，具体为直接new DirectByteBuffer()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">allocateDirect</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DirectByteBuffer(capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@2</strong> 释放堆外内存调用了PlatformDependent#freeDirectBuffer()底层调用CLEANER.freeDirectBuffer实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">freeDirectBuffer</span><span class="params">(ByteBuffer buffer)</span> </span>&#123;</span><br><span class="line">   CLEANER.freeDirectBuffer(buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="nstrumentedUnpooledDirectByteBuf"><a href="#nstrumentedUnpooledDirectByteBuf" class="headerlink" title="nstrumentedUnpooledDirectByteBuf"></a>nstrumentedUnpooledDirectByteBuf</h3><p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210210074748.png"></p>
<p><strong>注解@1</strong> 堆外内存分配同InstrumentedUnpooledUnsafeDirectByteBuf，通过父类UnpooledDirectByteBuf#allocateDirect调用ByteBuffer#allocateDirect来分配堆外内存，堆内存直接new DirectByteBuffer</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">allocateDirect</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DirectByteBuffer(capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>注解@2</strong> 堆外内存释放同InstrumentedUnpooledUnsafeDirectByteBuf，通过父类UnpooledDirectByteBuf#freeDirect调用底层调用CLEANER.freeDirectBuffer实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">freeDirectBuffer</span><span class="params">(ByteBuffer buffer)</span> </span>&#123;</span><br><span class="line">    CLEANER.freeDirectBuffer(buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>小结：</strong> @1 InstrumentedUnpooledUnsafeNoCleanerDirectByteBuf的内存释放调用UNSAFE.freeMemory(address)实现</p>
<p>​             @2 InstrumentedUnpooledUnsafeDirectByteBuf和nstrumentedUnpooledDirectByteBuf的内存释放是一样的，使用了JDK提供的CLEANER.freeDirectBuffer(buffer)。</p>
<p>​            @3 Netty默认自行管理堆外内存的分配与释放，并未使用JDK提供的释放方式，而是通过底层API自行释放。</p>
<h3 id="堆外内存数据获取"><a href="#堆外内存数据获取" class="headerlink" title="堆外内存数据获取"></a>堆外内存数据获取</h3><p>下面是三个buffer获取内存数据的方式：</p>
<p>InstrumentedUnpooledUnsafeNoCleanerDirectByteBuf通过UnpooledUnsafeDirectByteBuf#_getByte()获取数据</p>
<p>InstrumentedUnpooledUnsafeDirectByteBuf通过UnpooledUnsafeDirectByteBuf#_getByte()获取数据</p>
<p>nstrumentedUnpooledDirectByteBuf通过UnpooledDirectByteBuf#_getByte()获取数据</p>
<p>InstrumentedUnpooledUnsafeNoCleanerDirectByteBuf和InstrumentedUnpooledUnsafeDirectByteBuf获取方式一样；下面看下这两类获取方式。</p>
<p><strong>UnpooledUnsafeDirectByteBuf获取内存数据</strong> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">byte</span> <span class="title">_getByte</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> UnsafeByteBufUtil.getByte(addr(index)); <span class="comment">// 注解@1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@1</strong> 底层通过UNSAFE.getByte(address)这种“地址+偏移量” 的方式获取内存数据。</p>
<p><strong>UnpooledDirectByteBuf获取内存数据</strong> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">byte</span> <span class="title">_getByte</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> buffer.get(index); <span class="comment">// 注解@2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@2</strong> 通过ByteBuffer#get方式获取，底层通过Bits#unsafe.getByte(address)获取内存数据。</p>
<h3 id="非池化堆外内存总结"><a href="#非池化堆外内存总结" class="headerlink" title="非池化堆外内存总结"></a>非池化堆外内存总结</h3><p>Netty在堆外内存分配上，在系统支持的情况下，默认自己通过UNSAFE.freeMemory去释放内存，也就是noCleaner，没有使用JDK提供的Cleaner释放机制。至于为啥netty选择自己实现，不用JDK提供的方式，主要考虑性能原因，与JDK Bits设计有关系。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty13# 池化内存分配器</title>
    <url>/posts/bf0be4d0/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>PooledByteBufAllocator作为池化内存分配的入口，提供了众多的配置参数和便捷方法。这篇主要撸下他们大体都啥含义、干啥用的。为后面池化内存其他组件做铺垫。</p>
<h1 id="成员变量说明"><a href="#成员变量说明" class="headerlink" title="成员变量说明"></a>成员变量说明</h1><p>下面的成员变量基本都提供了默认值，可以通过参数去自定义，下面表格给出具体说明。</p>
<table>
<thead>
<tr>
<th>成员变量</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>DEFAULT_NUM_HEAP_ARENA</td>
<td>PoolAreana（堆内存）个数，默认为核数的2倍，可以由参数-Dio.netty.allocator.numHeapArenas指定</td>
</tr>
<tr>
<td>DEFAULT_NUM_DIRECT_ARENA</td>
<td>PoolAreana（堆外内存）个数默认为核数的2倍，堆外内存，可以通过-Dio.netty.allocator.numDirectArenas指定</td>
</tr>
<tr>
<td>DEFAULT_PAGE_SIZE</td>
<td>默认pageSize=8K，可以通过-Dio.netty.allocator.pageSize，需大于4096且为2的倍数</td>
</tr>
<tr>
<td>DEFAULT_MAX_ORDER</td>
<td>二叉树最高层数，取值范围为0~14，默认为11，可以通过-Dio.netty.allocator.maxOrder参数指定</td>
</tr>
<tr>
<td>DEFAULT_TINY_CACHE_SIZE</td>
<td>默认tiny类型缓存池大小512，可以通过-Dio.netty.allocator.tinyCacheSize指定</td>
</tr>
<tr>
<td>DEFAULT_SMALL_CACHE_SIZE</td>
<td>默认small类型缓存池大小为256，可以通过-Dio.netty.allocator.smallCacheSize指定</td>
</tr>
<tr>
<td>DEFAULT_NORMAL_CACHE_SIZE</td>
<td>默认normal类型缓存池大小为64，可以通过-Dio.netty.allocator.normalCacheSize指定</td>
</tr>
<tr>
<td>DEFAULT_MAX_CACHED_BUFFER_CAPACITY</td>
<td>默认为32KB，用于限制normal缓存数组的长度，可以通过-Dio.netty.allocator.maxCachedBufferCapacity指定</td>
</tr>
<tr>
<td>DEFAULT_CACHE_TRIM_INTERVAL</td>
<td>默认8192，分配次数阈值，超过后释放内存池，可以通过-Dio.netty.allocator.cacheTrimInterval指定</td>
</tr>
<tr>
<td>DEFAULT_CACHE_TRIM_INTERVAL_MILLIS</td>
<td>默认0不开启，定时释放内存池，可以通过-Dio.netty.allocator.cacheTrimIntervalMillis指定</td>
</tr>
<tr>
<td>DEFAULT_USE_CACHE_FOR_ALL_THREADS</td>
<td>默认true，使用线程缓存，可以通过-Dio.netty.allocator.useCacheForAllThread制定</td>
</tr>
<tr>
<td>DEFAULT_DIRECT_MEMORY_CACHE_ALIGNMENT</td>
<td>直接内存的校准对齐参数，分配内存时按位与（&amp;）校准。默认0不校准，可以通过-Dio.netty.allocator.directMemoryCacheAlignment指定</td>
</tr>
<tr>
<td>DEFAULT_MAX_CACHED_BYTEBUFFERS_PER_CHUNK</td>
<td>默认1023，指定PoolChunk缓存ByteBuffer对象的最大数量，可以通过-Dio.netty.allocator.maxCachedByteBuffersPerChunk指定</td>
</tr>
<tr>
<td>MIN_PAGE_SIZE</td>
<td>校验用的，PageSize不能小于4KB</td>
</tr>
<tr>
<td>MAX_CHUNK_SIZE</td>
<td>校验用的，Chunk的边界值，(((long) Integer.MAX_VALUE + 1) / 2)</td>
</tr>
<tr>
<td>heapArenas</td>
<td>Arena数组，元素为HeapArena</td>
</tr>
<tr>
<td>directArenas</td>
<td>Arena数组，元素为DirectArena</td>
</tr>
<tr>
<td>PooledByteBufAllocatorMetric metric</td>
<td>暴露统计指标，例如：用了多少堆内存、用了多少堆外直接内存等</td>
</tr>
</tbody></table>
<a id="more"></a>



<h1 id="静态块赋值"><a href="#静态块赋值" class="headerlink" title="静态块赋值"></a>静态块赋值</h1><p><strong>DEFAULT_PAGE_SIZE</strong> </p>
<p>下面是通过static{}静态块赋值PageSize，默认为8KB，可以通过-Dio.netty.allocator.pageSize自定义。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> defaultPageSize = SystemPropertyUtil.getInt(<span class="string">&quot;io.netty.allocator.pageSize&quot;</span>, <span class="number">8192</span>);</span><br><span class="line">        Throwable pageSizeFallbackCause = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            validateAndCalculatePageShifts(defaultPageSize);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            pageSizeFallbackCause = t;</span><br><span class="line">            defaultPageSize = <span class="number">8192</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        DEFAULT_PAGE_SIZE = defaultPageSize;</span><br></pre></td></tr></table></figure>

<p>PageSize校验过程，不能小于MIN_PAGE_SIZE（4KB），需要2的倍数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">validateAndCalculatePageShifts</span><span class="params">(<span class="keyword">int</span> pageSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pageSize &lt; MIN_PAGE_SIZE) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;pageSize: &quot;</span> + pageSize + <span class="string">&quot; (expected: &quot;</span> + MIN_PAGE_SIZE + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((pageSize &amp; pageSize - <span class="number">1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;pageSize: &quot;</span> + pageSize + <span class="string">&quot; (expected: power of 2)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Logarithm base 2. At this point we know that pageSize is a power of two.</span></span><br><span class="line">        <span class="keyword">return</span> Integer.SIZE - <span class="number">1</span> - Integer.numberOfLeadingZeros(pageSize);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><strong>DEFAULT_MAX_ORDER</strong> </p>
<p>maxOrder默认大小为11，可以通过-Dio.netty.allocator.maxOrder自定义。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">pageSizeint defaultMaxOrder = SystemPropertyUtil.getInt(<span class="string">&quot;io.netty.allocator.maxOrder&quot;</span>, <span class="number">11</span>);</span><br><span class="line">Throwable maxOrderFallbackCause = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  validateAndCalculateChunkSize(DEFAULT_PAGE_SIZE, defaultMaxOrder);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">  maxOrderFallbackCause = t;</span><br><span class="line">  defaultMaxOrder = <span class="number">11</span>;</span><br><span class="line">&#125;</span><br><span class="line">DEFAULT_MAX_ORDER = defaultMaxOrder;</span><br></pre></td></tr></table></figure>

<p>maxOrder校验过程，最大值不能超过14，同时计算了ChunkSize &lt;&lt;=1 ，即：8192&lt;&lt;=1 为 16777216（16M），也就是默认ChunkSize大小为16M。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">validateAndCalculateChunkSize</span><span class="params">(<span class="keyword">int</span> pageSize, <span class="keyword">int</span> maxOrder)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (maxOrder &gt; <span class="number">14</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;maxOrder: &quot;</span> + maxOrder + <span class="string">&quot; (expected: 0-14)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> chunkSize = pageSize;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = maxOrder; i &gt; <span class="number">0</span>; i --) &#123;</span><br><span class="line">    <span class="keyword">if</span> (chunkSize &gt; MAX_CHUNK_SIZE / <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(</span><br><span class="line">        <span class="string">&quot;pageSize (%d) &lt;&lt; maxOrder (%d) must not exceed %d&quot;</span>, pageSize, maxOrder, MAX_CHUNK_SIZE));</span><br><span class="line">    &#125;</span><br><span class="line">    chunkSize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> chunkSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>DEFAULT_NUM_HEAP_ARENA和DEFAULT_NUM_DIRECT_ARENA</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Runtime runtime = Runtime.getRuntime();</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> defaultMinNumArena = NettyRuntime.availableProcessors() * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> defaultChunkSize = DEFAULT_PAGE_SIZE &lt;&lt; DEFAULT_MAX_ORDER;</span><br><span class="line">DEFAULT_NUM_HEAP_ARENA = Math.max(<span class="number">0</span>,</span><br><span class="line">                SystemPropertyUtil.getInt(</span><br><span class="line">                        <span class="string">&quot;io.netty.allocator.numHeapArenas&quot;</span>,</span><br><span class="line">                        (<span class="keyword">int</span>) Math.min(</span><br><span class="line">                                defaultMinNumArena,</span><br><span class="line">                                runtime.maxMemory() / defaultChunkSize / <span class="number">2</span> / <span class="number">3</span>)));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> DEFAULT_NUM_DIRECT_ARENA = Math.max(<span class="number">0</span>,</span><br><span class="line">                SystemPropertyUtil.getInt(</span><br><span class="line">                        <span class="string">&quot;io.netty.allocator.numDirectArenas&quot;</span>,</span><br><span class="line">                        (<span class="keyword">int</span>) Math.min(</span><br><span class="line">                                defaultMinNumArena,</span><br><span class="line">                                PlatformDependent.maxDirectMemory() / defaultChunkSize / <span class="number">2</span> / <span class="number">3</span>)));</span><br></pre></td></tr></table></figure>

<p><strong>解读：</strong> DEFAULT_NUM_HEAP_ARENA与DEFAULT_NUM_DIRECT_ARENA赋值结构相同，默认值也相同。DEFAULT_NUM_HEAP_ARENA通过-Dio.netty.allocator.numHeapArenas自定义；DEFAULT_NUM_DIRECT_ARENA通过-Dio.netty.allocator.numDirectArenas自定义。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>defaultMinNumArena</td>
<td>默认为CPU核数的2倍</td>
</tr>
<tr>
<td>defaultChunkSize</td>
<td>DEFAULT_PAGE_SIZE &lt;&lt; DEFAULT_MAX_ORDER 也就是 8192 &lt;&lt; 11 = 16777216（16M）</td>
</tr>
<tr>
<td>runtime.maxMemory()</td>
<td>Jvm从操作系统获取的最大内存由参数-Xmx指定</td>
</tr>
<tr>
<td>runtime.maxMemory() / defaultChunkSize / 2 / 3</td>
<td>defaultChunkSize=16M，可以简化为 runtime.maxMemory()/96M。也就是Jvm最大内存/96M</td>
</tr>
</tbody></table>
<p>所以默认DEFAULT_NUM_HEAP_ARENA=DEFAULT_NUM_DIRECT_ARENA，CPU核数2倍与runtime.maxMemory()/96M取最小值，在高配的环境下，通常为核数的两倍。</p>
<p><strong>其他</strong> </p>
<p>下面这几个，都是可以通过参数指定，没啥特别逻辑，具体含义见上面成员变量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DEFAULT_TINY_CACHE_SIZE = SystemPropertyUtil.getInt(<span class="string">&quot;io.netty.allocator.tinyCacheSize&quot;</span>, <span class="number">512</span>);</span><br><span class="line">DEFAULT_SMALL_CACHE_SIZE = SystemPropertyUtil.getInt(<span class="string">&quot;io.netty.allocator.smallCacheSize&quot;</span>, <span class="number">256</span>);</span><br><span class="line">DEFAULT_NORMAL_CACHE_SIZE = SystemPropertyUtil.getInt(<span class="string">&quot;io.netty.allocator.normalCacheSize&quot;</span>, <span class="number">64</span>);</span><br><span class="line">DEFAULT_MAX_CACHED_BUFFER_CAPACITY = SystemPropertyUtil.getInt(</span><br><span class="line">                <span class="string">&quot;io.netty.allocator.maxCachedBufferCapacity&quot;</span>, <span class="number">32</span> * <span class="number">1024</span>);</span><br><span class="line">DEFAULT_CACHE_TRIM_INTERVAL = SystemPropertyUtil.getInt(</span><br><span class="line">                <span class="string">&quot;io.netty.allocator.cacheTrimInterval&quot;</span>, <span class="number">8192</span>);</span><br><span class="line">DEFAULT_CACHE_TRIM_INTERVAL_MILLIS = SystemPropertyUtil.getLong(</span><br><span class="line">                        <span class="string">&quot;io.netty.allocator.cacheTrimIntervalMillis&quot;</span>, <span class="number">0</span>);</span><br><span class="line">DEFAULT_USE_CACHE_FOR_ALL_THREADS = SystemPropertyUtil.getBoolean(</span><br><span class="line">                <span class="string">&quot;io.netty.allocator.useCacheForAllThreads&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">DEFAULT_DIRECT_MEMORY_CACHE_ALIGNMENT = SystemPropertyUtil.getInt(</span><br><span class="line">                <span class="string">&quot;io.netty.allocator.directMemoryCacheAlignment&quot;</span>, <span class="number">0</span>);</span><br><span class="line">DEFAULT_MAX_CACHED_BYTEBUFFERS_PER_CHUNK = SystemPropertyUtil.getInt(</span><br><span class="line">                <span class="string">&quot;io.netty.allocator.maxCachedByteBuffersPerChunk&quot;</span>, <span class="number">1023</span>);</span><br></pre></td></tr></table></figure>



<h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><p>下面对构造函数的赋值和校验进行走查。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PooledByteBufAllocator</span><span class="params">(<span class="keyword">boolean</span> preferDirect, <span class="keyword">int</span> nHeapArena, <span class="keyword">int</span> nDirectArena, <span class="keyword">int</span> pageSize, <span class="keyword">int</span> maxOrder,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">int</span> tinyCacheSize, <span class="keyword">int</span> smallCacheSize, <span class="keyword">int</span> normalCacheSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">boolean</span> useCacheForAllThreads, <span class="keyword">int</span> directMemoryCacheAlignment)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 指定是否使用直接内存</span></span><br><span class="line">        <span class="keyword">super</span>(preferDirect);</span><br><span class="line">        <span class="comment">// 创建PoolThreadLocalCache，useCacheForAllThreads是否允许使用对象池</span></span><br><span class="line">        threadCache = <span class="keyword">new</span> PoolThreadLocalCache(useCacheForAllThreads);</span><br><span class="line">        <span class="comment">// tiny类型缓存大小</span></span><br><span class="line">        <span class="keyword">this</span>.tinyCacheSize = tinyCacheSize;</span><br><span class="line">        <span class="comment">// small类型缓存大小</span></span><br><span class="line">        <span class="keyword">this</span>.smallCacheSize = smallCacheSize;</span><br><span class="line">        <span class="comment">// normal类型缓存大小</span></span><br><span class="line">        <span class="keyword">this</span>.normalCacheSize = normalCacheSize;</span><br><span class="line">        <span class="comment">// chunk大小默认16M</span></span><br><span class="line">        chunkSize = validateAndCalculateChunkSize(pageSize, maxOrder);</span><br><span class="line">				<span class="comment">// 需正数</span></span><br><span class="line">        checkPositiveOrZero(nHeapArena, <span class="string">&quot;nHeapArena&quot;</span>);</span><br><span class="line">        checkPositiveOrZero(nDirectArena, <span class="string">&quot;nDirectArena&quot;</span>);</span><br><span class="line"></span><br><span class="line">        checkPositiveOrZero(directMemoryCacheAlignment, <span class="string">&quot;directMemoryCacheAlignment&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (directMemoryCacheAlignment &gt; <span class="number">0</span> &amp;&amp; !isDirectMemoryCacheAlignmentSupported()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;directMemoryCacheAlignment is not supported&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((directMemoryCacheAlignment &amp; -directMemoryCacheAlignment) != directMemoryCacheAlignment) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;directMemoryCacheAlignment: &quot;</span></span><br><span class="line">                    + directMemoryCacheAlignment + <span class="string">&quot; (expected: power of two)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 页偏移默认为13，pageShift = Integer.SIZE - 1 - Integer.numberOfLeadingZeros(8192) = 32 - 1 - 18 = 13</span></span><br><span class="line">        <span class="keyword">int</span> pageShifts = validateAndCalculatePageShifts(pageSize);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nHeapArena &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 堆内存，创建PoolArena[]数组</span></span><br><span class="line">            heapArenas = newArenaArray(nHeapArena);</span><br><span class="line">            List&lt;PoolArenaMetric&gt; metrics = <span class="keyword">new</span> ArrayList&lt;PoolArenaMetric&gt;(heapArenas.length);</span><br><span class="line">            <span class="comment">// 给数组元素赋值HeapArena</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; heapArenas.length; i ++) &#123;</span><br><span class="line">                PoolArena.HeapArena arena = <span class="keyword">new</span> PoolArena.HeapArena(<span class="keyword">this</span>,</span><br><span class="line">                        pageSize, maxOrder, pageShifts, chunkSize,</span><br><span class="line">                        directMemoryCacheAlignment);</span><br><span class="line">                heapArenas[i] = arena;</span><br><span class="line">                metrics.add(arena);</span><br><span class="line">            &#125;</span><br><span class="line">            heapArenaMetrics = Collections.unmodifiableList(metrics);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            heapArenas = <span class="keyword">null</span>;</span><br><span class="line">            heapArenaMetrics = Collections.emptyList();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nDirectArena &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 堆外直接内存，创建PoolArena[]数组</span></span><br><span class="line">            directArenas = newArenaArray(nDirectArena);</span><br><span class="line">            List&lt;PoolArenaMetric&gt; metrics = <span class="keyword">new</span> ArrayList&lt;PoolArenaMetric&gt;(directArenas.length);</span><br><span class="line">            <span class="comment">// 直接内存数组赋值DirectArena</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; directArenas.length; i ++) &#123;</span><br><span class="line">                PoolArena.DirectArena arena = <span class="keyword">new</span> PoolArena.DirectArena(</span><br><span class="line">                        <span class="keyword">this</span>, pageSize, maxOrder, pageShifts, chunkSize, directMemoryCacheAlignment);</span><br><span class="line">                directArenas[i] = arena;</span><br><span class="line">                metrics.add(arena);</span><br><span class="line">            &#125;</span><br><span class="line">            directArenaMetrics = Collections.unmodifiableList(metrics);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            directArenas = <span class="keyword">null</span>;</span><br><span class="line">            directArenaMetrics = Collections.emptyList();</span><br><span class="line">        &#125;</span><br><span class="line">        metric = <span class="keyword">new</span> PooledByteBufAllocatorMetric(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h1 id="重要方法走查"><a href="#重要方法走查" class="headerlink" title="重要方法走查"></a>重要方法走查</h1><p>比较重要的方法主要是newHeapBuffer&amp;newDirectBuffer，这两个的流程和代码结构一致，大体流程见上一篇文末有梳理。</p>
<p>另外，metric这个方法可以观察到内存相关情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PooledByteBufAllocatorMetric <span class="title">metric</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> metric;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>usedHeapMemory</strong> ，查看Netty内存池分配堆空间大小。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">usedHeapMemory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> usedMemory(heapArenas);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>usedDirectMemory</strong>, 查看Netty内存池分配堆外直接空间大小。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">usedDirectMemory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> usedMemory(directArenas);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过usedMemory累加PoolArena的内存分配。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">usedMemory</span><span class="params">(PoolArena&lt;?&gt;[] arenas)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (arenas == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">long</span> used = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (PoolArena&lt;?&gt; arena : arenas) &#123;</span><br><span class="line">    used += arena.numActiveBytes();</span><br><span class="line">    <span class="keyword">if</span> (used &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> Long.MAX_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> used;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty15# 池化内存Normal类型内存分配</title>
    <url>/posts/d12e9a09/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Netty所谓的池化就是先申请了一块大内存，后面需要分配的时候就来我这里分就完了。以堆外直接内存分配为例，Netty以Chunk为单位16M申请了一块连续内存，这么一大块内存是以平衡二叉树的形式组织起来的。分配的时候就从这颗树上找合适的节点。池化内存的分配是Netty的最为核心部分，这块的代码很多位运算，不太容易看懂，读的时候需要边调试边分析。</p>
<h1 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h1><p>Netty使用平衡二叉树将申请到的Chunk块组织起来，如下图所示，并使用数组将整个树映射进去，见下文构造函数中memoryMap。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/Netty%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.png"></p>
<a id="more"></a>



<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PoolChunk(PoolArena&lt;T&gt; arena, T memory, <span class="keyword">int</span> pageSize, <span class="keyword">int</span> maxOrder, <span class="keyword">int</span> pageShifts, <span class="keyword">int</span> chunkSize, <span class="keyword">int</span> offset) &#123;</span><br><span class="line">        unpooled = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">this</span>.arena = arena;</span><br><span class="line">        <span class="keyword">this</span>.memory = memory;</span><br><span class="line">        <span class="keyword">this</span>.pageSize = pageSize;</span><br><span class="line">        <span class="keyword">this</span>.pageShifts = pageShifts;</span><br><span class="line">        <span class="keyword">this</span>.maxOrder = maxOrder;</span><br><span class="line">        <span class="keyword">this</span>.chunkSize = chunkSize;</span><br><span class="line">        <span class="keyword">this</span>.offset = offset;</span><br><span class="line">        unusable = (<span class="keyword">byte</span>) (maxOrder + <span class="number">1</span>);</span><br><span class="line">        log2ChunkSize = log2(chunkSize);</span><br><span class="line">        subpageOverflowMask = ~(pageSize - <span class="number">1</span>);</span><br><span class="line">        freeBytes = chunkSize;</span><br><span class="line">        <span class="keyword">assert</span> maxOrder &lt; <span class="number">30</span> : <span class="string">&quot;maxOrder should be &lt; 30, but is: &quot;</span> + maxOrder;</span><br><span class="line">        maxSubpageAllocs = <span class="number">1</span> &lt;&lt; maxOrder;</span><br><span class="line">        memoryMap = <span class="keyword">new</span> <span class="keyword">byte</span>[maxSubpageAllocs &lt;&lt; <span class="number">1</span>];</span><br><span class="line">        depthMap = <span class="keyword">new</span> <span class="keyword">byte</span>[memoryMap.length];</span><br><span class="line">        <span class="keyword">int</span> memoryMapIndex = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>; d &lt;= maxOrder; ++ d) &#123;</span><br><span class="line">            <span class="keyword">int</span> depth = <span class="number">1</span> &lt;&lt; d;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; depth; ++ p) &#123;</span><br><span class="line">                memoryMap[memoryMapIndex] = (<span class="keyword">byte</span>) d;</span><br><span class="line">                depthMap[memoryMapIndex] = (<span class="keyword">byte</span>) d;</span><br><span class="line">                memoryMapIndex ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        subpages = newSubpageArray(maxSubpageAllocs);</span><br><span class="line">        cachedNioBuffers = <span class="keyword">new</span> ArrayDeque&lt;ByteBuffer&gt;(<span class="number">8</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>关键参数</strong> </p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>memory</td>
<td>申请的一块内存大小为16M，以字节数组表示</td>
</tr>
<tr>
<td>pageSize</td>
<td>8KB</td>
</tr>
<tr>
<td>pageShifts</td>
<td>13</td>
</tr>
<tr>
<td>maxOrder</td>
<td>11</td>
</tr>
<tr>
<td>chunkSize</td>
<td>16M</td>
</tr>
<tr>
<td>log2ChunkSize</td>
<td>14</td>
</tr>
<tr>
<td>subpageOverflowMask</td>
<td>-8192</td>
</tr>
<tr>
<td>maxSubpageAllocs</td>
<td>2048</td>
</tr>
<tr>
<td>maxSubpageAllocs &lt;&lt; 1</td>
<td>memoryMap数组的长度，4096</td>
</tr>
<tr>
<td>memoryMap</td>
<td>将二叉树平铺在该数组，格式见下文。</td>
</tr>
<tr>
<td>depthMap</td>
<td>同memoryMap将二叉树平铺在该数组</td>
</tr>
</tbody></table>
<p>上面这些有些是直接传入的，有的一眼看不出结果，代入公式算算。</p>
<p><strong>log2ChunkSize</strong> 这个是chunkSize的对数，chunkSize大小是16M</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testlog2ChunkSize</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	System.out.println(<span class="string">&quot;16M的对数：&quot;</span> + log2(<span class="number">16384</span>));</span><br><span class="line"></span><br><span class="line">	System.out.println(<span class="string">&quot;2的14次方：&quot;</span> + Math.pow(<span class="number">2</span>, <span class="number">14</span>));</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">log2</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> INTEGER_SIZE_MINUS_ONE = Integer.SIZE - <span class="number">1</span>;</span><br><span class="line">	<span class="comment">// compute the (0-based, with lsb = 0) position of highest set bit i.e, log2</span></span><br><span class="line">	<span class="keyword">return</span> INTEGER_SIZE_MINUS_ONE - Integer.numberOfLeadingZeros(val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">16M的对数：<span class="number">14</span></span><br><span class="line"><span class="number">2</span>的<span class="number">14</span>次方：<span class="number">16384.0</span></span><br></pre></td></tr></table></figure>

<p><strong>subpageOverflowMask</strong> 主要用于位运算的“&amp;”操作判断。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSubpageOverflowMask</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> pageSize = <span class="number">8192</span>;</span><br><span class="line">  <span class="keyword">int</span> subpageOverflowMask = ~(pageSize - <span class="number">1</span>);</span><br><span class="line">  System.out.println(<span class="string">&quot;subpageOverflowMask:&quot;</span> + subpageOverflowMask);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">subpageOverflowMask:-<span class="number">8192</span></span><br></pre></td></tr></table></figure>

<p><strong>maxSubpageAllocs</strong> 用于限制数组的长度</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMaxSubpageAllocs</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> maxOrder = <span class="number">11</span>;</span><br><span class="line">   <span class="keyword">int</span> maxSubpageAllocs = <span class="number">1</span> &lt;&lt; maxOrder;</span><br><span class="line">   System.out.println(<span class="string">&quot;maxSubpageAllocs:&quot;</span> + maxSubpageAllocs);</span><br><span class="line">   <span class="keyword">int</span> length = maxSubpageAllocs &lt;&lt; <span class="number">1</span>;</span><br><span class="line">   System.out.println(<span class="string">&quot;memoryMap数组的长度:&quot;</span> + length);</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">maxSubpageAllocs:<span class="number">2048</span></span><br><span class="line">memoryMap数组的长度:<span class="number">4096</span></span><br></pre></td></tr></table></figure>



<p><strong>memoryMap&amp;depthMap</strong> </p>
<p>这两个数组主要把平衡二叉树装到了数组里，外层循环控制层高，内层循环控制每层的节点数。直接看还是看不出到底啥格式，不要紧代入输出看看。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@Test</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMemoryMap</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> maxOrder = <span class="number">11</span>;</span><br><span class="line">  <span class="keyword">int</span> memoryMapIndex = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> maxSubpageAllocs = <span class="number">2048</span>;</span><br><span class="line">  <span class="keyword">byte</span>[] memoryMap = <span class="keyword">new</span> <span class="keyword">byte</span>[maxSubpageAllocs &lt;&lt; <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">byte</span>[] depthMap = <span class="keyword">new</span> <span class="keyword">byte</span>[memoryMap.length];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>; d &lt;= maxOrder; ++ d) &#123;</span><br><span class="line">            <span class="keyword">int</span> depth = <span class="number">1</span> &lt;&lt; d;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; depth; ++ p) &#123;</span><br><span class="line">                memoryMap[memoryMapIndex] = (<span class="keyword">byte</span>) d;</span><br><span class="line">                depthMap[memoryMapIndex] = (<span class="keyword">byte</span>) d;</span><br><span class="line">                memoryMapIndex ++;</span><br><span class="line">            &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   System.out.println(<span class="string">&quot;memoryMap的长度：&quot;</span> + memoryMap.length);</span><br><span class="line">   System.out.println(<span class="string">&quot;memoryMap数组内容:&quot;</span> + Arrays.toString(memoryMap));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">memoryMap的长度：<span class="number">4096</span></span><br><span class="line">memoryMap数组内容:[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, ..... ]</span><br></pre></td></tr></table></figure>



<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>由输出可以看出memoryMap的长度为4096，内容格式如上，值表示所在的层，例如：数字1表示该节点在第树的第1层；有两个1表示该层有两个叶子节点。也就是从2的0次方，一直到2的11次方，平铺到了数组中。</p>
<h1 id="平衡二叉树查找更新过程"><a href="#平衡二叉树查找更新过程" class="headerlink" title="平衡二叉树查找更新过程"></a>平衡二叉树查找更新过程</h1><h3 id="三次分配示例"><a href="#三次分配示例" class="headerlink" title="三次分配示例"></a>三次分配示例</h3><p>Normal类型的内存分配，主要是如何在二叉树中找到匹配的节点的过程，以及该节点的被分配后整个树的状态更新变化。</p>
<p>源码部分在PoolChunk#allocateRun(int normCapacity) 部分，为了方便debug和调试，把值代入后单独拎出来跑一跑。</p>
<p>下面代码可以直接运行，以执行三次分配，每次分配8KB的过程来看其对平衡二叉树的查找过程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PoolChunkTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span>[] memoryMap = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span> unusable = (<span class="keyword">byte</span>) (<span class="number">11</span> + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">        PoolChunkTest poolChunkTest = <span class="keyword">new</span> PoolChunkTest();</span><br><span class="line">        poolChunkTest.initMemoryMap();</span><br><span class="line">        <span class="keyword">int</span> normCapacity = <span class="number">8</span> * <span class="number">1024</span>;</span><br><span class="line">        <span class="keyword">long</span> id01 = poolChunkTest.allocateRun(normCapacity);</span><br><span class="line">        System.out.println(<span class="string">&quot;第一次分配：&quot;</span> + id01);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> id02 = poolChunkTest.allocateRun(normCapacity);</span><br><span class="line">        System.out.println(<span class="string">&quot;第二次分配：&quot;</span> + id02);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> id03 = poolChunkTest.allocateRun(normCapacity);</span><br><span class="line">        System.out.println(<span class="string">&quot;第三次分配：&quot;</span> + id03);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">allocateRun</span><span class="params">(<span class="keyword">int</span> normCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> d = <span class="number">11</span> - (log2(normCapacity) - <span class="number">13</span>);</span><br><span class="line">        <span class="keyword">int</span> id = allocateNode(d);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">allocateNode</span><span class="params">(<span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> id = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> initial = - (<span class="number">1</span> &lt;&lt; d); <span class="comment">// has last d bits = 0 and rest all = 1</span></span><br><span class="line">        <span class="keyword">byte</span> val = value(id);</span><br><span class="line">        <span class="keyword">if</span> (val &gt; d) &#123; <span class="comment">// unusable</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (val &lt; d || (id &amp; initial) == <span class="number">0</span>) &#123; <span class="comment">// id &amp; initial == 1 &lt;&lt; d for all ids at depth d, for &lt; d it is 0</span></span><br><span class="line">            id &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            val = value(id);</span><br><span class="line">            <span class="keyword">if</span> (val &gt; d) &#123;</span><br><span class="line">                id ^= <span class="number">1</span>;</span><br><span class="line">                val = value(id);</span><br><span class="line">                System.out.println(<span class="string">&quot;val:&quot;</span> + val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">byte</span> value = value(id);</span><br><span class="line">        <span class="keyword">assert</span> value == d &amp;&amp; (id &amp; initial) == <span class="number">1</span> &lt;&lt; d : String.format(<span class="string">&quot;val = %d, id &amp; initial = %d, d = %d&quot;</span>,</span><br><span class="line">                value, id &amp; initial, d);</span><br><span class="line">        setValue(id, unusable); <span class="comment">// mark as unusable</span></span><br><span class="line">        updateParentsAlloc(id);</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateParentsAlloc</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (id &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> parentId = id &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">byte</span> val1 = value(id);</span><br><span class="line">            <span class="keyword">byte</span> val2 = value(id ^ <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">byte</span> val = val1 &lt; val2 ? val1 : val2;</span><br><span class="line">            setValue(parentId, val);</span><br><span class="line">            id = parentId;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">byte</span> val)</span> </span>&#123;</span><br><span class="line">        memoryMap[id] = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">log2</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> INTEGER_SIZE_MINUS_ONE = Integer.SIZE - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// compute the (0-based, with lsb = 0) position of highest set bit i.e, log2</span></span><br><span class="line">        <span class="keyword">return</span> INTEGER_SIZE_MINUS_ONE - Integer.numberOfLeadingZeros(val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">byte</span> <span class="title">value</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> memoryMap[id];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initMemoryMap</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxOrder = <span class="number">11</span>;</span><br><span class="line">        <span class="keyword">int</span> memoryMapIndex = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> maxSubpageAllocs = <span class="number">2048</span>;</span><br><span class="line">        memoryMap = <span class="keyword">new</span> <span class="keyword">byte</span>[maxSubpageAllocs &lt;&lt; <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">byte</span>[] depthMap = <span class="keyword">new</span> <span class="keyword">byte</span>[memoryMap.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>; d &lt;= maxOrder; ++ d) &#123;</span><br><span class="line">            <span class="keyword">int</span> depth = <span class="number">1</span> &lt;&lt; d;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; depth; ++ p) &#123;</span><br><span class="line">                memoryMap[memoryMapIndex] = (<span class="keyword">byte</span>) d;</span><br><span class="line">                depthMap[memoryMapIndex] = (<span class="keyword">byte</span>) d;</span><br><span class="line">                memoryMapIndex ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一次分配：2048</span><br><span class="line">第二次分配：2049</span><br><span class="line">第三次分配：2050</span><br></pre></td></tr></table></figure>



<p>例子中分配的8KB，根据公式 int d = 11 - (log2(normCapacity) - 13)算出其在11层，所以下文中三次分配时入参d=11。</p>
<h3 id="第一分配8KB"><a href="#第一分配8KB" class="headerlink" title="第一分配8KB"></a>第一分配8KB</h3><p>第一次分配找到了数组memoryMap的下标为2048，此时对应的值为memoryMap[2048]=11。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210314192404.png"></p>
<p>当分配后将该节点标记为不可用，也就是更新为12（总共才11层，所以12为不可用），此时memoryMap[2048]=12。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210314174107.png"></p>
<p>递归整棵树，从下往上更新直到根节点，将父节点更新为其子节点的最小值。例如：memoryMap[1024]的值原来为10，被更新成了11.</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210314195243.png"></p>
<h3 id="第二次分配8KB"><a href="#第二次分配8KB" class="headerlink" title="第二次分配8KB"></a>第二次分配8KB</h3><p>先找到了id=2048，这个节点发现其值为12，也就是不可用了。此时memoryMap[2049]=11。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210314185849.png"></p>
<p>通过id ^= 1找到其兄弟节点id=2049，其对应的值为11可用。返回该节点。</p>
<p>![image-20210314185941227](/Users/yongliang/Library/Application Support/typora-user-images/image-20210314185941227.png)</p>
<p>将节点id=2049设置为不可用，即：memoryMap[2049]=12。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210314200044.png"></p>
<p>递归更新整棵树，由于其父节点的两个子节点都被分配出去了，所以1024被标记为不可用。memoryMap[1024]=12。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210314200415.png"></p>
<h3 id="第三次分配8KB"><a href="#第三次分配8KB" class="headerlink" title="第三次分配8KB"></a>第三次分配8KB</h3><p>第三次分配8KB时，当循环到了节点1024，发现其不可用，也就是其子节点也不可用了。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210314192117.png"></p>
<p>通过id &lt;&lt;= 1找到1024的兄弟节点1025，接着向下查找。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210314191633.png"></p>
<p>找到节点1025的子节点2050发现其可用，即：memoryMap[2050]=11。找到后最后过程同上，标记其不可用表示已分配了，并更新整个树把其父节点更新为子节点的最小值。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210314190313.png"></p>
<h1 id="平衡二叉树查找更新图示"><a href="#平衡二叉树查找更新图示" class="headerlink" title="平衡二叉树查找更新图示"></a>平衡二叉树查找更新图示</h1><h3 id="第一次分配8KB前"><a href="#第一次分配8KB前" class="headerlink" title="第一次分配8KB前"></a>第一次分配8KB前</h3><p>整个树都没有被占用，8KB会被选在第11层分配。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%88%86%E9%85%8D.png"></p>
<h3 id="第一次分配8KB后"><a href="#第一次分配8KB后" class="headerlink" title="第一次分配8KB后"></a>第一次分配8KB后</h3><p>红色标记为变化部分，节点红色表示被占用。第11层的第一个节点memoryMap[2048]被标记为不可用。第10层的第一个节点memoryMap[1024]值被从10更新为11，整个树会继续向上递归变化，将整个树父节点更新为子节点最小的值。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%88%86%E9%85%8D%E5%90%8E.png"></p>
<h3 id="第二次分配8KB后"><a href="#第二次分配8KB后" class="headerlink" title="第二次分配8KB后"></a>第二次分配8KB后</h3><p>第二次分配8KB后，第11层的第二个节点memoryMap[2049]被标记为不可用，其父节点memoryMap[1024]由于其子节点都被分配完毕，也被标记为不可用。整个树会继续向上递归变化，将整个树父节点更新为子节点最小的值。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/%E7%AC%AC%E4%BA%8C%E6%AC%A18KB%E5%88%86%E9%85%8D%E5%90%8E.png"></p>
<h3 id="第三次分配8KB后"><a href="#第三次分配8KB后" class="headerlink" title="第三次分配8KB后"></a>第三次分配8KB后</h3><p>第三次分配8KB后，将第11层的第三个节点memoryMap[2050]标记为不可用，同时更新其父节点memoryMap[1025]为子节点最小值11。整个树会继续向上递归变化，将整个树父节点更新为子节点最小的值。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/%E7%AC%AC%E4%B8%89%E6%AC%A18KB%E5%88%86%E9%85%8D%E5%90%8E.png"></p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty16# 池化内存Subpage类型内存分配</title>
    <url>/posts/97466a5c/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>前面聊了大于8KB的内存分配，那小于8KB的呢？上一篇的平衡二叉树第十一层的叶子节点最小也是8KB，那比如要分配128B的缓存，直接分给8KB显然是不合适的，Tiny是小于512Byte，Small介于512B~8KB，Tiny和Small统称Subpage，本文就聊聊他们的内存分配情况，这块应该是整个netty最为复杂的部分了。</p>
<h1 id="内容提要"><a href="#内容提要" class="headerlink" title="内容提要"></a>内容提要</h1><p>下面是以分配128B为例的整体流程架构图，下面大体叙述下其流程。</p>
<ul>
<li><p>先从平衡二叉树的第11层选一个未分配的叶子节点大小为8KB的一个Page<br>备注：本例中为memoryMap[2048]</p>
</li>
<li><p>对该Page进行切割，假如要分配128B，整体会切割为64块<br>备注：8192/128=64</p>
</li>
<li><p>通过long类型二进制64位来标记分割成各个块的分配状态</p>
<p>备注：0:未分配，1:已分配</p>
</li>
<li><p>一个bitmap数组长度为8，每个元素都能对64块内存进行标记</p>
</li>
<li><p>建立了二叉树节点与切分块之间的映射关系<br>备注：memoryMapIdx ^ maxSubpageAllocs</p>
</li>
<li><p>分配后建立二叉树叶子节点与标记位之间的关系，可以指向内存一块区域<br>备注：0x4000000000000000L | (long) bitmapIdx &lt;&lt; 32 | memoryMapIdx</p>
</li>
</ul>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/subpages%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84.png"></p>
<a id="more"></a>



<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p><strong>示例代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAllocateSubpage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ByteBufAllocator allocator = <span class="keyword">new</span> PooledByteBufAllocator();</span><br><span class="line">    allocator.directBuffer(<span class="number">128</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>备注：以分配128B的内存为例，分析其分配过程。</p>
<p><strong>源码分析</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">allocateSubpage</span><span class="params">(<span class="keyword">int</span> normCapacity)</span> </span>&#123;</span><br><span class="line">    PoolSubpage&lt;T&gt; head = arena.findSubpagePoolHead(normCapacity); <span class="comment">// 注解@1</span></span><br><span class="line">  	<span class="keyword">int</span> d = maxOrder; </span><br><span class="line">    <span class="keyword">synchronized</span> (head) &#123;</span><br><span class="line">        <span class="keyword">int</span> id = allocateNode(d); <span class="comment">// 注解@2</span></span><br><span class="line">			  <span class="keyword">if</span> (id &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> id;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> PoolSubpage&lt;T&gt;[] subpages = <span class="keyword">this</span>.subpages; <span class="comment">// 注解@3</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> pageSize = <span class="keyword">this</span>.pageSize;</span><br><span class="line">        freeBytes -= pageSize;</span><br><span class="line">        <span class="keyword">int</span> subpageIdx = subpageIdx(id); <span class="comment">// 注解@4</span></span><br><span class="line"></span><br><span class="line">        PoolSubpage&lt;T&gt; subpage = subpages[subpageIdx]; </span><br><span class="line">        <span class="keyword">if</span> (subpage == <span class="keyword">null</span>) &#123; <span class="comment">// 注解@5</span></span><br><span class="line">            subpage = <span class="keyword">new</span> PoolSubpage&lt;T&gt;(head, <span class="keyword">this</span>, id, runOffset(id), pageSize, normCapacity);</span><br><span class="line">            subpages[subpageIdx] = subpage;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            subpage.init(head, normCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> subpage.allocate(); <span class="comment">// 注解@6</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@1</strong> 从tinySubpagePools中获取PoolSubpage。获取过程为elemSize &gt;&gt;&gt; 4（除以16）来获取。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210403195729.png"></p>
<p><strong>tinySubpagePools结构</strong></p>
<p>tinySubpagePools被初始化成长度为32的数组，元素之间差额为16B。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/tinySubpagePools%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E6%96%B0.png"></p>
<p><strong>注解@2</strong> allocateNode 在上一篇文章分析过，d = maxOrder = 1。表示在平衡二叉树的第11层找到可分配的节点，具体为memoryMap数组中的下标。如果整个树都没有内存可分配了，返回的id=-1。</p>
<p><strong>注解@3</strong> 先看下subpages的初始化，maxSubpageAllocs = 1 &lt;&lt; maxOrder= 2048。也就是PoolSubpage<T>[] subpages的长度为平衡二叉树第11层所有的节点数（2^11）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">subpages = newSubpageArray(maxSubpageAllocs);</span><br></pre></td></tr></table></figure>



<p><strong>注解@4</strong> 将平衡二叉树第11层的下标memoryMap[]的下标转换为subpages[]数组的下标。转换关系为memoryMapIdx ^ maxSubpageAllocs。</p>
<p>例如：平衡二叉树第11层第1个节点数组下标为2048，转换为subpages的下标为0，平衡二叉树第11层第2个节点数组下标为2049，转换为subpages的下标为1，平衡二叉树第11层第2个节点数组下标为2050，转换为subpages的下标为2。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%86%E5%B8%83%20(1).png"></p>
<p><strong>注解@5</strong> 初始化PoolSubpage</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PoolSubpage(PoolSubpage&lt;T&gt; head, PoolChunk&lt;T&gt; chunk, <span class="keyword">int</span> memoryMapIdx, <span class="keyword">int</span> runOffset, <span class="keyword">int</span> pageSize, <span class="keyword">int</span> elemSize) &#123;</span><br><span class="line">  <span class="keyword">this</span>.chunk = chunk;</span><br><span class="line">  <span class="keyword">this</span>.memoryMapIdx = memoryMapIdx;</span><br><span class="line">  <span class="keyword">this</span>.runOffset = runOffset;</span><br><span class="line">  <span class="keyword">this</span>.pageSize = pageSize;</span><br><span class="line">  bitmap = <span class="keyword">new</span> <span class="keyword">long</span>[pageSize &gt;&gt;&gt; <span class="number">10</span>]; <span class="comment">// pageSize / 16 / 64</span></span><br><span class="line">  init(head, elemSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>参数说明</strong> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">head: PoolSubpage数组中的一个元素，本例中为第4个元素</span><br><span class="line"></span><br><span class="line">chunk: 当前PoolChunk实例</span><br><span class="line"></span><br><span class="line">memoryMapIdx: 平衡二叉树第11层用于分配的节点，具体为memoryMap数组下标</span><br><span class="line"></span><br><span class="line">elemSize: 待分配的内存，本例中为128KB</span><br><span class="line"></span><br><span class="line">bitmap: long数组长度为8「8192无符号右移10位&#x3D;8」</span><br></pre></td></tr></table></figure>

<p><strong>初始化说明</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(PoolSubpage&lt;T&gt; head, <span class="keyword">int</span> elemSize)</span> </span>&#123;</span><br><span class="line">     doNotDestroy = <span class="keyword">true</span>;</span><br><span class="line">  	 <span class="comment">// 待分配内存</span></span><br><span class="line">     <span class="keyword">this</span>.elemSize = elemSize; </span><br><span class="line">     <span class="keyword">if</span> (elemSize != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// maxNumElems表示可以被切割成几份（8192除以待分配内存）例如：64=8192/128被切成了64份</span></span><br><span class="line">            maxNumElems = numAvail = pageSize / elemSize;</span><br><span class="line">            nextAvail = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 无符号右移6位，高位补零（相当于除以64）例如：64的二进制右移6位为1，128的二进制右移6位为2</span></span><br><span class="line">            bitmapLength = maxNumElems &gt;&gt;&gt; <span class="number">6</span>;</span><br><span class="line">            <span class="keyword">if</span> ((maxNumElems &amp; <span class="number">63</span>) != <span class="number">0</span>) &#123; <span class="comment">// 相当于是否能被64整除</span></span><br><span class="line">                bitmapLength ++; <span class="comment">// 不能被整除递增bitmapLength</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bitmapLength; i ++) &#123;</span><br><span class="line">                bitmap[i] = <span class="number">0</span>; <span class="comment">// 等于零表示未被分配</span></span><br><span class="line">            &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     addToPool(head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>过程说明</strong> </p>
<p>@1 先计算一个Page被切成了几份 maxNumElems（ pageSize / elemSize）</p>
<p>@2 计算bitmap数组长度bitmapLength（maxNumElems无符号右移6位相当于除以64）</p>
<p><strong>备注：</strong> 此处不太好理解为什么要maxNumElems要除以64来计算bitmap的长度呢？也就是bitmap数组中的每个元素可以标记64个被切的内存块。bitmap是long数组，每个long类型是64位，他用每个二进制位来标记被切内存块的分配情况。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/bitmap%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D%E5%88%9D%E5%A7%8B%E5%8C%96%E7%8A%B6%E6%80%81%20(1).png"></p>
<p><strong>加入链表</strong> </p>
<p>新构建的PoolSubpage与tinySubpagePools中的PoolSubpage建成链表关系。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addToPool</span><span class="params">(PoolSubpage&lt;T&gt; head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> prev == <span class="keyword">null</span> &amp;&amp; next == <span class="keyword">null</span>;</span><br><span class="line">    prev = head;</span><br><span class="line">    next = head.next;</span><br><span class="line">    next.prev = <span class="keyword">this</span>;</span><br><span class="line">    head.next = <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>小结：</strong> 构造的PoolSubpage中持有了一个bitmap[]数组，数组长度与待分配的内存有关。待分配内存大小为elemSize，数组长度=PageSize/elemSize，并将bitmap数组的元素标记为未分配。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/subpages%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%20(2).png"></p>
<p><strong>注解@6</strong> 分配内存</p>
<p>内存的分配以两次分配128B内存为例观察期分配过程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAllocateSubpage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   ByteBufAllocator allocator = <span class="keyword">new</span> PooledByteBufAllocator();</span><br><span class="line">   allocator.directBuffer(<span class="number">128</span>); <span class="comment">// 第一次分配</span></span><br><span class="line">   allocator.directBuffer(<span class="number">128</span>); <span class="comment">// 第二次分配</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第一次分配</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210410194035.png"></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210410195035.png"></p>
<p><strong>第二次分配</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210410200757.png"></p>
<p>第一次轮询第一位已被占用，需要向右移位。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210410201041.png"></p>
<p>第二次轮询第二位未被占用。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210410201407.png"></p>
<p>第二次分配过程</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210410202216.png"></p>
<h1 id="两次内存分配图示"><a href="#两次内存分配图示" class="headerlink" title="两次内存分配图示"></a>两次内存分配图示</h1><p><strong>第一次分配128B图示</strong></p>
<p>此时64位第一位被标记为1，bitmap[0] = 1</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.png"></p>
<p><strong>第二次分配128B图示</strong></p>
<p>此时64位第二位也被标记为1，bitmap[0] = 3</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%20(1).png"></p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty17# 实战|Young GC时间过长导致RPC超时</title>
    <url>/posts/63d0eab2/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h1><p>前几天一个业务负责的同事找老梁，说每次发布SOA拉入时就有少量报错。</p>
<p>报错的集中在RPC设置超时时间比较短的上游服务，比如设置300ms，发布完就好了。</p>
<p>我说最近没有发布新版本，应该不是中间件变更引起的。</p>
<p>同事说这问题存在好几个月了，他们一直想抓原因，一直没找到。</p>
<p>你咋早点不反馈到我这呢？就自己这么琢磨了几个月，够执着的。</p>
<p>老梁让他组织个会议，拉了小组两个同事一起参与下，聚焦复盘下问题。</p>
<p>忘了说了，我们SOA框架使用gRPC通信，gRPC底层使用Netty。</p>
<h1 id="问题复盘"><a href="#问题复盘" class="headerlink" title="问题复盘"></a>问题复盘</h1><p><strong>GC 日志</strong> </p>
<p>从GC日志现象来看，在第4次和第5次Young GC的时间过长，线上达到了900ms。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/netty%E5%A4%8D%E7%9B%9801.jpg"></p>
<p>在测试环境复现，第4次Young GC的时间也超过500ms。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/netty%E5%A4%8D%E7%9B%9802.jpg"></p>
<a id="more"></a>



<p><strong>dump文件情况</strong></p>
<p>dump一份看看当时内存情况，可以看到主要是MpscArrayQueue这个队列给占了。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/Netty03.jpg"></p>
<p><strong>小结：</strong> 通过日志和dump文件看出，由于MpscArrayQueue对象占用过多，导致Young GC时间过长。</p>
<h1 id="根因分析"><a href="#根因分析" class="headerlink" title="根因分析"></a>根因分析</h1><p><strong>解决方式</strong> </p>
<p>这个问题到时网上也有人遇到，下面帖子指出通过以下设置解决。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-Dio.netty.allocator.useCacheForAllThreads=<span class="keyword">false</span> </span><br><span class="line">-Dio.grpc.netty.shaded.io.netty.allocator.useCacheForAllThreads=<span class="keyword">false</span></span><br></pre></td></tr></table></figure>

<p>设置GC参数后，再看下GC日志发现，Young GC耗时100ms左右，通过线上灰度QPS和资源均可满足需求。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/Netty%E5%A4%8D%E7%9B%9804.jpg"></p>
<p><strong>源码分析</strong></p>
<p>先看下useCacheForAllThreads参数，用于设置DEFAULT_USE_CACHE_FOR_ALL_THREADS的值，默认为true，指会对所有线程对象进行缓存。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> DEFAULT_USE_CACHE_FOR_ALL_THREADS;</span><br><span class="line"></span><br><span class="line">DEFAULT_USE_CACHE_FOR_ALL_THREADS = SystemPropertyUtil.getBoolean(</span><br><span class="line">                <span class="string">&quot;io.netty.allocator.useCacheForAllThreads&quot;</span>, <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>

<p>如下代码，开启线程缓存会构造PoolThreadCache时会有一系列的值传入。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> PoolThreadCache <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> PoolArena&lt;<span class="keyword">byte</span>[]&gt; heapArena = leastUsedArena(heapArenas);</span><br><span class="line">  <span class="keyword">final</span> PoolArena&lt;ByteBuffer&gt; directArena = leastUsedArena(directArenas);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">  <span class="comment">// 线程缓存开关</span></span><br><span class="line">  <span class="keyword">if</span> (useCacheForAllThreads || current <span class="keyword">instanceof</span> FastThreadLocalThread) &#123;</span><br><span class="line">    <span class="keyword">final</span> PoolThreadCache cache = <span class="keyword">new</span> PoolThreadCache(</span><br><span class="line">      heapArena, directArena, tinyCacheSize, smallCacheSize, normalCacheSize,</span><br><span class="line">      DEFAULT_MAX_CACHED_BUFFER_CAPACITY, DEFAULT_CACHE_TRIM_INTERVAL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DEFAULT_CACHE_TRIM_INTERVAL_MILLIS &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">final</span> EventExecutor executor = ThreadExecutorMap.currentExecutor();</span><br><span class="line">      <span class="keyword">if</span> (executor != <span class="keyword">null</span>) &#123;</span><br><span class="line">        executor.scheduleAtFixedRate(trimTask, DEFAULT_CACHE_TRIM_INTERVAL_MILLIS,</span><br><span class="line">                                     DEFAULT_CACHE_TRIM_INTERVAL_MILLIS, TimeUnit.MILLISECONDS);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cache;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// No caching so just use 0 as sizes.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> PoolThreadCache(heapArena, directArena, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟到下面可以看到通过构造MpscArrayQueue实现的，下面为对象数组。与dump文件显示的图示一致。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210717194334.png"></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210717194244.png"></p>
<p><strong>小结：</strong> 其实这部分在<a href="https://mp.weixin.qq.com/s/PLCx-Yu7BKA5lmP-R_z6Lw">《Netty14# 池化内存之线程缓存》</a> 有详细的分析，会形成如下图结构，顺带着把小结也摘录下。</p>
<ul>
<li>Netty以chunk为单位（16M）向系统申请物理内存，Netty池化内存分成了4种内存类型。Tiny（0<del>512Byte），Small（512Byte</del>8KB），Normal（8KB~16MB），Huge（&gt;16M）</li>
<li> Netty对Tiny、Small、Normal做了缓存，针对不同的类型通过”数组+队列“继续切成不同的尺寸，每个尺寸内的缓存ByteBuffer大小相同，不同尺寸之间缓存的Buffer大小以2的N次增长。</li>
<li>Tiny类型从0到496被划分为32个尺寸（数组）</li>
<li> Small类型从512到4096（4K）被划分4个尺寸</li>
<li> Normal类型从8192（8K）到32768（32K）被划分为3个尺寸</li>
<li>在内存分配时，先根据需要分配的内存大小判断属于那种内存类每个尺寸都维护有队列Queue，定位到尺寸规格也就拿到Queue中的实际缓存（PoolChunk）和指针（handle）并完成所需分配内存buffer的初始化。于该内存类型的哪个尺寸。</li>
<li>每个尺寸都维护有队列Queue，定位到尺寸规格也就拿到Queue中的实际缓存（PoolChunk）和指针（handle）并完成所需分配内存buffer的初始化。</li>
</ul>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/%E7%BC%93%E5%AD%98%E7%BB%93%E6%9E%84%E5%9B%BE%E7%A4%BA%20(1).png"></p>
<p>当把缓存关闭-Dio.netty.allocator.useCacheForAllThreads=false 时，上面这个结构也就不存在，构建的对象少了自然Young GC时间就短了。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty2# Netty组件之Channel初始化</title>
    <url>/posts/7d3cb711/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>继上文分析Channel实例化流程后，本文通过分析Channel的初始化流程。旨在从整体上厘清DefaultChannelPipeline、ChannelHandlerContext、ChannelHandler的逻辑关系。</p>
<a id="more"></a>



<h1 id="一、DefaultChannelPipeline实例化"><a href="#一、DefaultChannelPipeline实例化" class="headerlink" title="一、DefaultChannelPipeline实例化"></a>一、DefaultChannelPipeline实例化</h1><p>DefaultChannelPipeline随着Channel的创建而创建，即只要创建了Channel就会同时创建与其对应的ChannelPipeline。下面代码是Channel实例化时调用，上篇文章文末的代码。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202184535.png"></p>
<p><strong>ChannelHandlerContext类图结构</strong> </p>
<p>ChannelHandlerContext直观从命名上看出为ChannelHandler上下文，每次构造DefaultChannelHandlerContext都会传入与之对应的ChannelHandler.</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202184642.png"></p>
<p><strong>ChannelHandlerContext类图结构</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202184711.png"></p>
<p><strong>ChannelPipeline类图结构</strong></p>
<p>从下面类图结构可以看出，ChannelPipeline提供了很多操作链表的方法，addFirst/addLast/addBefore/addLast/remove/replace等，入参为ChannelHandler。ChannelPipeline的各种fire操作均通过HandlerContext进行处理。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202184932.png"></p>
<p><strong>链表关系图示</strong></p>
<p>先从下面代码看下运营时的链表结构，截图如下。</p>
<p><strong>示例代码</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202185015.png"></p>
<p><strong>内存结构</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/1612263172761.jpg"></p>
<p>画个示意图来说明ChannelPipeline、ChannelHandlerContext、ChannelHandler的关系。</p>
<p><strong>关系图示</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202185341.png"></p>
<h1 id="二、Channel初始化"><a href="#二、Channel初始化" class="headerlink" title="二、Channel初始化"></a>二、Channel初始化</h1><p>切换到Channel初始化过程，在客户端引导类Bootstrap调用b.connect()或者服务端引导类ServerBootstrap调用bind()时，会调用到抽象引导类AbstractBootstrap的initAndRegister()。下面红色部分即channel初始化入口。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202185411.png"></p>
<p><strong>客户端初始化</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202185431.png"></p>
<p>@1 客户端初始化代码中，将ChannelHandler通过DefaultChannelHandlerContext加入ChannelPipeline链表中</p>
<p>@2 setChannelOptions以NioChannelOption为例，客户端最后调用到SocketChannelImpl#setOption(); 可以对以下属性进行设置。</p>
<p>* StandardSocketOptions.SO_RCVBUF // 接受缓存区大小</p>
<p>* StandardSocketOptions.SO_SNDBUF // 发送缓存区大小</p>
<p>* StandardSocketOptions.SO_LINGER // 设置延迟关闭的时间</p>
<p>* StandardSocketOptions.IP_TOS // 设置数据包优先级</p>
<p>* StandardSocketOptions.IP_MULTICAST_TTL // 设置多播组数据的TTL值</p>
<p>* …</p>
<p><strong>服务端初始化</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202185459.png"></p>
<p>@1 setChannelOptions同样以NioChannelOption为例，服务端会调用到ServerSocketChannelImpl#setOption()，参数含义见客户端端初始化@1</p>
<p>@2 ChannelInitializer实现了ChannelHandler加入到了ChannelPipeline的链表中，其中的逻辑在另文分析EventLoopGroup时梳理。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty3# Netty组件之Channel注册</title>
    <url>/posts/d7c49a97/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文将分析EventLoopGroup初始化、EventLoop的选择策略以及Channel是如何通过EventLoop注册到Selector上的。</p>
<a id="more"></a>



<h1 id="一、EventLoopGroup类图概览"><a href="#一、EventLoopGroup类图概览" class="headerlink" title="一、EventLoopGroup类图概览"></a>一、EventLoopGroup类图概览</h1><p>在客户端示例代码中的中实例化了NioEventLoopGroup，接下来分析下该实例化过程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">Bootstrap b = <span class="keyword">new</span> Bootstrap();</span><br><span class="line"></span><br><span class="line">b.group(workerGroup);</span><br></pre></td></tr></table></figure>



<p>从以下类图结构io.netty.util.concurrent.AbstractEventExecutorGroup分支主要负责多线程任务的处理；io.netty.channel.EventLoopGroup分支主要负责Channel相关的注册。MultithreadEventExecutorGroup与MultithreadEventLoopGroup分别继承和实现了上面AbstractEventExecutorGroup和EventLoopGroup，将其负责的功能进行融合。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202180638.png"></p>
<h1 id="二、构造函数解读"><a href="#二、构造函数解读" class="headerlink" title="二、构造函数解读"></a>二、构造函数解读</h1><p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202180703.png"></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202180713.png"></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202180724.png"></p>
<p><strong>构造函数</strong></p>
<p>nThreads：eventLoopThreads线程数量，默认值0时取CPU核数的2倍，可以通过参数io.netty.eventLoopThreads指定</p>
<p>Executor：默认ThreadPerTaskExecutor</p>
<p>SelectorProvider默认SelectorProvider.provider()，用于开启Selector和Channel</p>
<p>SelectStrategyFactory：SelectStrategy工厂类，默认DefaultSelectStrategyFactory</p>
<p>EventExecutorChooserFactory：EventExecutor选择器，默认为DefaultEventExecutorChooserFactory</p>
<h1 id="三、初始化EventExecutor数组"><a href="#三、初始化EventExecutor数组" class="headerlink" title="三、初始化EventExecutor数组"></a>三、初始化EventExecutor数组</h1><p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202180746.png"></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202180802.png"></p>
<p><strong>代码解读</strong></p>
<p>EventExecutor[] children：数组大小为nThreads，默认为CPU核数乘以2。</p>
<p>EventExecutor继承了EventExecutorGroup本质上为线程框架类Executor</p>
<p>children[i]：数据元素为EventLoop，本示例中为NioEventLoop。</p>
<p><strong>NioEventLoop类图</strong></p>
<p>NioEventLoop继承了SingleThreadEventLoop，SingleThreadEventLoop同时继承和实现了EventExecutor和EventLoop。即：NioEventLoop拥有了线程类框架处理多线程任务的能力和处理Channel能力。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202180841.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">备注：本文中EventExecutor数组children的元素为NioEventLoop，NioEventLoop同时拥有线程框架能力和Channel注册等处理能力。</span><br></pre></td></tr></table></figure>



<h1 id="四、EventExecutor选择器"><a href="#四、EventExecutor选择器" class="headerlink" title="四、EventExecutor选择器"></a>四、EventExecutor选择器</h1><p>第三部分对EventExecutor[] children进行初始化分析，然在使用时如何选择其中一个元素呢？</p>
<p>在初始化过程中有以下一行代码，用于初始化EventExecutorChooser。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">chooser = chooserFactory.newChooser(children);</span><br></pre></td></tr></table></figure>



<p><strong>EventExecutorChooser类图结构</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202180923.png"></p>
<p><strong>选择策略</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202180943.png"></p>
<p>@1 如果数组长度是2的幂次方，选择PowerOfTwoEventExecutorChooser，在选取EventExecutor时使用executors[idx.getAndIncrement() &amp; executors.length - 1]</p>
<p>@2 如果数组长度不是2的幂次方，选择GenericEventExecutorChooser，executors[Math.abs(idx.getAndIncrement() % executors.length)]。</p>
<h1 id="五、Channel注册"><a href="#五、Channel注册" class="headerlink" title="五、Channel注册"></a>五、Channel注册</h1><p><strong>Channel注册入口</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202181021.png"></p>
<p><strong>选择EventLoop</strong></p>
<p>本文为NioEventLoop</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202181034.png"></p>
<p><strong>绑定Channel到EventExecutor</strong></p>
<p>通过DefaultChannelPromise绑定Channel到EventExecutor（NioEventLoop）。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202181106.png"></p>
<p><strong>将Channel注册到Selector</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202181120.png"></p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty4# Netty之异步通知机制</title>
    <url>/posts/9fda0b0b/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前面的文章分析了Channel实例化、初始化、注册机制，本文分析下异步结果的通知，也就是回调，同时梳理下Future、Promise、ChannelFuture、ChannelPromise的关系。</p>
<a id="more"></a>



<h1 id="一、异步通知代码走查"><a href="#一、异步通知代码走查" class="headerlink" title="一、异步通知代码走查"></a>一、异步通知代码走查</h1><p>在Channel注册到Selector后，会返回ChannelFuture。如果注册未完成，会通过增加Listener来进行异步通知注册结果，接下来看下是如何回调的。</p>
<p><strong>代码块</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202175023.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">备注：上面代码块中在注册完Channel后返回ChannelFuture，在ChannelFuture注册了ChannelFutureListener，通过异步通知的方式获取注册结果。</span><br></pre></td></tr></table></figure>

<p><strong>代码块</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202175039.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">备注：构建DefaultChannelPromise绑定了EventLoop和Channel，上面注册的ChannelFutureListener实际注册到了DefaultChannelPromise。</span><br></pre></td></tr></table></figure>

<p><strong>代码块</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202175059.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">备注：通过ChannelPromise标记Channel注册成功。</span><br></pre></td></tr></table></figure>

<p><strong>代码块</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202175115.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">备注：在DefaultPromise中通过cas设置Channel注册结果，并回调加在其身上的Listener。</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202175138.png"></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202175150.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">备注：将注册的所有Listener，通过回调GenericFutureListener的operationComplete方法，完成结果的通知。</span><br></pre></td></tr></table></figure>



<h1 id="二、异步通知流程图"><a href="#二、异步通知流程图" class="headerlink" title="二、异步通知流程图"></a>二、异步通知流程图</h1><p>下面以channel注册为例，勾勒异步回调流程图。Future/Promise作为结果载体与执行Listener的执行主体。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202175347.png"></p>
<h1 id="三、Future-Promise关系图谱"><a href="#三、Future-Promise关系图谱" class="headerlink" title="三、Future/Promise关系图谱"></a>三、Future/Promise关系图谱</h1><p>以下类图中展现了Future/Promise的类图结构，Netty中Future继承Java中的Future并<code>增加了基于Listener的异步通知机制</code>。</p>
<p>Promise允许在标志某个操作结果后再回调Listener（比如：在注册成功后调用Promise#trySuccess将成功结果在Promise中标记，并回调Listener）。</p>
<p>ChannelFuture与特定的Channel绑定，ChannelPromise继承ChannelFuture与Promise即拥有绑定特定Channel与标记操作结果回调Listener的能力。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202175418.png"></p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty5# Netty之客户端连接调用</title>
    <url>/posts/5e7437e/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文主要梳理Netty客户端如何发起连接请求的以及最终通过SocketChannel与服务端建立连接，顺便分析了在此过程中涉及到的地址解析过程。</p>
<a id="more"></a>



<h1 id="一、获取地址解析器"><a href="#一、获取地址解析器" class="headerlink" title="一、获取地址解析器"></a>一、获取地址解析器</h1><p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202173713.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">备注：在Netty客户端发起连接前，先获取了AddressResolver，并进行了解析判断。</span><br></pre></td></tr></table></figure>



<p><strong>获取AddressResolver过程</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202173747.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">备注： 创建AddressResolver并将其放到缓存Map中，key为executor。</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202173813.png"></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202173826.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">备注：默认使用DefaultAddressResolverGroup中的DefaultNameResolver构建InetSocketAddressResolver。</span><br><span class="line">小结：从上面获取地址解析过程中，AddressResolverGroup拥有一组AddressResolver存储于Map中，key为EventExecutor，而AddressResolver是通过NameResolver构建的。</span><br></pre></td></tr></table></figure>







<h1 id="二、地址解析器图谱"><a href="#二、地址解析器图谱" class="headerlink" title="二、地址解析器图谱"></a>二、地址解析器图谱</h1><p><strong>AddressResolverGroup类图</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202173916.png"></p>
<p><strong>AddressResolver类图</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202173950.png"></p>
<p><strong>NameResolver类图</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202174015.png"></p>
<p><strong>关系图示</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202174037.png"></p>
<h1 id="三、地址解析过程"><a href="#三、地址解析过程" class="headerlink" title="三、地址解析过程"></a>三、地址解析过程</h1><p>地址解析通过下面的方法来实现。分别看下isSupported、isResolved、doResolve的逻辑。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202174104.png"></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202174118.png"></p>
<p>@1 isSupported主要判断传入socket地址是否属于InetSocketAddress，通过JDK中isInstance来实现。</p>
<p>@2 doIsResolved判断包含了isSupported和非空判断，入参非空并且属于InetSocketAddress则标记解析成功</p>
<p>@3 doResolve 根据host name解析成InetSocketAddress，通过InetAddress.getByName(hostname)实现。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：地址解析主要得到SocketAddress是合法有效的，如果为host name默认为通过InetAddress.getByName转换为InetAddress。</span><br></pre></td></tr></table></figure>



<h1 id="四、建立连接"><a href="#四、建立连接" class="headerlink" title="四、建立连接"></a>四、建立连接</h1><p>在地址解析成功后，该建立连接了，接下来看下netty是如何发起的。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202174150.png"></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202174201.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">备注：接着调用AbstractChannel的connect方法，即：DefaultChannelPipeline#connect。</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202174244.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">备注：从链表的最后一个tail发起连接。</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202174256.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">备注：从之前文章分析中，我们知道链表构成。会调用到AbstractChannelHandlerContext#connect方法。通过方法findContextOutbound查找链表中负责出站的HandlerContext调用其connect方法，结束后向下一个出站HandlerContext传递调用。</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202174326.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">备注：出站HandlerContext查找过程。</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202174340.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">备注：上图为运行时DefaultChannelPipeline链表中的Handler结构。尾部为TailContext，头部为HeadContext。</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202174416.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">备注：继续上面的连接传递，最后会调用HeaderContext的connect方法。通过unsafe.connect向服务端发起连接调用。</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202174434.png"></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202174446.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">备注：调用NioSocketChannel#doConnect方法，最后通过Java NIO的SocketChannel#connect发起连接请求。</span><br></pre></td></tr></table></figure>





















</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty6# Netty之事件轮询与处理</title>
    <url>/posts/a3306fb0/</url>
    <content><![CDATA[<div id="vip-container"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在前面的文章第三篇《Netty组件之Channel注册》分析了channel是如何注册到Selector上的。第五篇《Netty之客户端连接调用》，分析了建立连接的过程。本文将梳理如下内容：</p>
<p>1.就绪事件如何轮询的？bossGroup和workGroup都轮询什么感兴趣的事件</p>
<p>2.bossGroup的职责是什么？又是如何将客户端新建连接Channel传递到workGroup的？</p>
<p>3.workGroup的职责是什么？如何回调到我们自己加入的childHandler中的？</p>
<a id="more"></a>





<h2 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h2><h4 id="1-示例代码"><a href="#1-示例代码" class="headerlink" title="1.示例代码"></a>1.示例代码</h4><p>本文将以这段示例为入口进行分析，示例中设置了bossGroup、workerGroup以及childHandler为HttpUploadServerInitializer。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">b.group(bossGroup, workerGroup);</span><br><span class="line">b.channel(NioServerSocketChannel.class);</span><br><span class="line">b.handler(<span class="keyword">new</span> LoggingHandler(LogLevel.INFO));</span><br><span class="line">b.childHandler(<span class="keyword">new</span> HttpUploadServerInitializer(sslCtx));</span><br><span class="line"></span><br><span class="line">Channel ch = b.bind(PORT).sync().channel();</span><br></pre></td></tr></table></figure>



<h4 id="2-原理文章"><a href="#2-原理文章" class="headerlink" title="2.原理文章"></a>2.原理文章</h4><p>在阅读本文前，可以先阅读下之前的两篇文章。<a href="https://mp.weixin.qq.com/s/A4x5xCqHOV4HXdU3R4frnw">系统五种I/O模型</a> 和 <a href="https://mp.weixin.qq.com/s/WZB4ChAsail2dPD8zuCutA">Reactor线程模型</a>。</p>
<h2 id="二、就绪事件轮询"><a href="#二、就绪事件轮询" class="headerlink" title="二、就绪事件轮询"></a>二、就绪事件轮询</h2><p>接着第三篇《Netty组件之Channel注册》channel注册到Selector，返回selectionKey。其中包含isReadable、isWritable、isConnectable、isAcceptable等通道的就绪状态。一起看下Netty是如何轮询这些就绪事件的。</p>
<h4 id="1-注册selectionKey集合"><a href="#1-注册selectionKey集合" class="headerlink" title="1.注册selectionKey集合"></a>1.注册selectionKey集合</h4><p>将Channel注册到Selector时再往后看下implRegister()方法以及实现AbstractPollSelectorImpl。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected abstract void implRegister(SelectionKeyImpl ski)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">implRegister</span><span class="params">(SelectionKeyImpl ski)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (closeLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (closed)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClosedSelectorException();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check to see if the array is large enough</span></span><br><span class="line">        <span class="keyword">if</span> (channelArray.length == totalChannels) &#123;</span><br><span class="line">            <span class="comment">// Make a larger array</span></span><br><span class="line">            <span class="keyword">int</span> newSize = pollWrapper.totalChannels * <span class="number">2</span>;</span><br><span class="line">            SelectionKeyImpl temp[] = <span class="keyword">new</span> SelectionKeyImpl[newSize];</span><br><span class="line">            <span class="comment">// Copy over</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=channelOffset; i&lt;totalChannels; i++)</span><br><span class="line">                temp[i] = channelArray[i];</span><br><span class="line">            channelArray = temp;</span><br><span class="line">            <span class="comment">// Grow the NativeObject poll array</span></span><br><span class="line">            pollWrapper.grow(newSize);</span><br><span class="line">        &#125;</span><br><span class="line">        channelArray[totalChannels] = ski;</span><br><span class="line">        ski.setIndex(totalChannels);</span><br><span class="line">        pollWrapper.addEntry(ski.channel);</span><br><span class="line">        totalChannels++;</span><br><span class="line">        keys.add(ski); <span class="comment">// 注解@1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">SelectorImpl</span><span class="params">(SelectorProvider sp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(sp);</span><br><span class="line">    keys = <span class="keyword">new</span> HashSet&lt;SelectionKey&gt;();</span><br><span class="line">    selectedKeys = <span class="keyword">new</span> HashSet&lt;SelectionKey&gt;();</span><br><span class="line">    <span class="keyword">if</span> (Util.atBugLevel(<span class="string">&quot;1.4&quot;</span>)) &#123;</span><br><span class="line">        publicKeys = keys;</span><br><span class="line">        publicSelectedKeys = selectedKeys;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        publicKeys = Collections.unmodifiableSet(keys); <span class="comment">// 注解@2</span></span><br><span class="line">        publicSelectedKeys = Util.ungrowableSet(selectedKeys); <span class="comment">// 注解@3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注解@1：将注册channel返回的selectionKey放入到了HashSet<SelectionKey> keys中。</p>
<p>注解@2：Set<SelectionKey> publicKeys 也就是selectionKey的集合。</p>
<p>小结：SelectorImpl类中有这么一个结合publicKeys存储了selectionKey，而就绪事件的轮询需要依靠轮询selectionKey。</p>
<h4 id="2-就绪selectionKey集合"><a href="#2-就绪selectionKey集合" class="headerlink" title="2.就绪selectionKey集合"></a>2.就绪selectionKey集合</h4><p>当执行select()方法时，以AbstractPollSelectorImpl为例，会执行到updateSelectedKeys()方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Copy the information in the pollfd structs into the opss</span></span><br><span class="line"><span class="comment"> * of the corresponding Channels. Add the ready keys to the</span></span><br><span class="line"><span class="comment"> * ready queue.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">updateSelectedKeys</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> numKeysUpdated = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Skip zeroth entry; it is for interrupts only</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=channelOffset; i&lt;totalChannels; i++) &#123;</span><br><span class="line">        <span class="comment">// 获取通道就绪操作类型（可读、可写、错误等）</span></span><br><span class="line">        <span class="keyword">int</span> rOps = pollWrapper.getReventOps(i);</span><br><span class="line">        <span class="keyword">if</span> (rOps != <span class="number">0</span>) &#123;</span><br><span class="line">            SelectionKeyImpl sk = channelArray[i];</span><br><span class="line">            pollWrapper.putReventOps(i, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (selectedKeys.contains(sk)) &#123;</span><br><span class="line">                <span class="comment">// 将ReventOps就绪的操作类型转换到SelectionKeyImpl</span></span><br><span class="line">                <span class="keyword">if</span> (sk.channel.translateAndSetReadyOps(rOps, sk)) &#123;</span><br><span class="line">                    numKeysUpdated++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sk.channel.translateAndSetReadyOps(rOps, sk);</span><br><span class="line">                <span class="keyword">if</span> ((sk.nioReadyOps() &amp; sk.nioInterestOps()) != <span class="number">0</span>) &#123;</span><br><span class="line">                    selectedKeys.add(sk); <span class="comment">// 注解@4</span></span><br><span class="line">                    numKeysUpdated++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numKeysUpdated;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注解@3：由SelectorImpl方法可以看出publicSelectedKeys即为selectedKeys。</p>
<p>注解@4：将就绪的key放入了selectedKeys集合中。</p>
<p>小结：SelectorImpl中的publicSelectedKeys存放了就绪selectedKey。</p>
<h4 id="3-轮询就绪selectionKey集合"><a href="#3-轮询就绪selectionKey集合" class="headerlink" title="3.轮询就绪selectionKey集合"></a>3.轮询就绪selectionKey集合</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doBind0</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> ChannelFuture regFuture, <span class="keyword">final</span> Channel channel,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    channel.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123; <span class="comment">// 注解@5</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (regFuture.isSuccess()) &#123;</span><br><span class="line">                channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                promise.setFailure(regFuture.cause());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注解@5： 顺着示例b.bind(PORT)进入到doBind0()方法。channel.eventLoop().execute(…)，此处的eventLoop()即NioEventLoop。也就是后续的轮询事件在该NioEventLoop线程中进行。SingleThreadEventExecutor是NioEventLoop的父类，实际执行到SingleThreadEventExecutor的execute方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">    ObjectUtil.checkNotNull(task, <span class="string">&quot;task&quot;</span>);</span><br><span class="line">    execute(task, !(task <span class="keyword">instanceof</span> LazyRunnable) &amp;&amp; wakesUpForTask(task));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task, <span class="keyword">boolean</span> immediate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> inEventLoop = inEventLoop();</span><br><span class="line">    addTask(task); <span class="comment">// 注解@6</span></span><br><span class="line">    <span class="keyword">if</span> (!inEventLoop) &#123;</span><br><span class="line">        startThread(); <span class="comment">// 注解@7</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doStartThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            SingleThreadEventExecutor.<span class="keyword">this</span>.run(); <span class="comment">// 注解@8</span></span><br><span class="line">            <span class="comment">//...   </span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注解@6：将Runnable放入Queue中。</p>
<p>注解@7：此处启动了一个线程默认为ThreadPerTaskExecutor。</p>
<p>注解@8：具体执行逻辑由NioEventLoop#run()来执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> selectCnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;  <span class="comment">// 注解@9</span></span><br><span class="line">     <span class="comment">// ... </span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">     		  <span class="comment">// ...</span></span><br><span class="line">      		 processSelectedKeys(); <span class="comment">// @10</span></span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      	 <span class="comment">// Ensure we always run tasks.</span></span><br><span class="line">         ranTasks = runAllTasks(); <span class="comment">// @11</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// ...   </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注解@9：一个死循环在不断轮询就绪事件</p>
<p>注解@10：处理就绪事件</p>
<p>注解@11：处理放入Queue中的Runnable任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processSelectedKeys</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (selectedKeys != <span class="keyword">null</span>) &#123;</span><br><span class="line">        processSelectedKeysOptimized();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        processSelectedKeysPlain(selector.selectedKeys()); <span class="comment">// 注解@12</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注解@12：selector.selectedKeys()即为SelectorImpl的publicSelectedKeys，即获取了就绪事件集合。</p>
<p>小结：就绪事件的轮询SingleThreadEventExecutor#run方法负责，不断轮询就绪事件集合publicSelectedKeys，来判断是否有就绪事件。</p>
<h2 id="三、事件处理"><a href="#三、事件处理" class="headerlink" title="三、事件处理"></a>三、事件处理</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processSelectedKey</span><span class="params">(SelectionKey k, AbstractNioChannel ch)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AbstractNioChannel.NioUnsafe unsafe = ch.unsafe();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> readyOps = k.readyOps();</span><br><span class="line">        <span class="comment">// We first need to call finishConnect() before try to trigger a read(...) or write(...) as otherwise</span></span><br><span class="line">        <span class="comment">// the NIO JDK channel implementation may throw a NotYetConnectedException.</span></span><br><span class="line">        <span class="keyword">if</span> ((readyOps &amp; SelectionKey.OP_CONNECT) != <span class="number">0</span>) &#123; <span class="comment">// 注解@13</span></span><br><span class="line">            <span class="comment">// remove OP_CONNECT as otherwise Selector.select(..) will always return without blocking</span></span><br><span class="line">            <span class="comment">// See https://github.com/netty/netty/issues/924</span></span><br><span class="line">            <span class="keyword">int</span> ops = k.interestOps();</span><br><span class="line">            ops &amp;= ~SelectionKey.OP_CONNECT;</span><br><span class="line">            k.interestOps(ops);</span><br><span class="line"></span><br><span class="line">            unsafe.finishConnect();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Process OP_WRITE first as we may be able to write some queued buffers and so free memory.</span></span><br><span class="line">        <span class="keyword">if</span> ((readyOps &amp; SelectionKey.OP_WRITE) != <span class="number">0</span>) &#123; <span class="comment">// 注解@14</span></span><br><span class="line">          <span class="comment">// Call forceFlush which will also take care of clear the OP_WRITE once there is nothing left to write</span></span><br><span class="line">          ch.unsafe().forceFlush();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Also check for readOps of 0 to workaround possible JDK bug which may otherwise lead</span></span><br><span class="line">        <span class="comment">// to a spin loop</span></span><br><span class="line">        <span class="keyword">if</span> ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="number">0</span> || readyOps == <span class="number">0</span>) &#123; <span class="comment">// 注解@15</span></span><br><span class="line">            unsafe.read();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CancelledKeyException ignored) &#123;</span><br><span class="line">        unsafe.close(unsafe.voidPromise());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注解@13：处理连接事件</p>
<p>注解@14：处理可写事件</p>
<p>注解@15：处理可读事件和处理客户端连接事件</p>
<p>小结：在以上的事件处理中，bossGroup主要处理客户端连接OP_ACCEPT事件。当有新的客户端的连接时触发unsafe.read()执行。具体为NioMessageUnsafe#read()方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void read() &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    try &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            do &#123;</span><br><span class="line">                int localRead &#x3D; doReadMessages(readBuf); &#x2F;&#x2F; 注解@16</span><br><span class="line">                &#x2F;&#x2F; ...</span><br><span class="line">                allocHandle.incMessagesRead(localRead);</span><br><span class="line">            &#125; while (allocHandle.continueReading());</span><br><span class="line">        &#125; catch (Throwable t) &#123;</span><br><span class="line">            exception &#x3D; t;</span><br><span class="line">        &#125;</span><br><span class="line">			  int size &#x3D; readBuf.size();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; size; i ++) &#123;</span><br><span class="line">            readPending &#x3D; false;</span><br><span class="line">            pipeline.fireChannelRead(readBuf.get(i)); &#x2F;&#x2F; 注解@17</span><br><span class="line">        &#125;</span><br><span class="line">      	&#x2F;&#x2F; ...</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注解@16：见下面doReadMessages逻辑。</p>
<p>注解@17：pipeline.fireChannelRead触发了pipeline链表向下执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doReadMessages</span><span class="params">(List&lt;Object&gt; buf)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    SocketChannel ch = SocketUtils.accept(javaChannel()); <span class="comment">// 注解@18</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch != <span class="keyword">null</span>) &#123;</span><br><span class="line">            buf.add(<span class="keyword">new</span> NioSocketChannel(<span class="keyword">this</span>, ch)); <span class="comment">// 注解@19</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractNioByteChannel</span><span class="params">(Channel parent, SelectableChannel ch)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(parent, ch, SelectionKey.OP_READ);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注解@18：获取新建立的连接通道SocketChannel。</p>
<p>注解@19：将连接通道SocketChannel转换为NioSocketChannel，建立时注册的OP_READ读事件。并将新建立的连接通道放入了List中。</p>
<p>再回到注解@17，pipeline.fireChannelRead触发了链表向下传递。具体传递到那个Handler中需要翻前面初始化代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">    setChannelOptions(channel, newOptionsArray(), logger); </span><br><span class="line">    setAttributes(channel, attrs0().entrySet().toArray(EMPTY_ATTRIBUTE_ARRAY));</span><br><span class="line"></span><br><span class="line">    ChannelPipeline p = channel.pipeline();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> EventLoopGroup currentChildGroup = childGroup;</span><br><span class="line">    <span class="keyword">final</span> ChannelHandler currentChildHandler = childHandler;</span><br><span class="line">    <span class="keyword">final</span> Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] currentChildOptions;</span><br><span class="line">    <span class="keyword">synchronized</span> (childOptions) &#123;</span><br><span class="line">        currentChildOptions = childOptions.entrySet().toArray(EMPTY_OPTION_ARRAY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] currentChildAttrs = childAttrs.entrySet().toArray(EMPTY_ATTRIBUTE_ARRAY);</span><br><span class="line"></span><br><span class="line">    p.addLast(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123; </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(<span class="keyword">final</span> Channel ch)</span> </span>&#123; <span class="comment">// 注解@20</span></span><br><span class="line">            <span class="keyword">final</span> ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">            ChannelHandler handler = config.handler();</span><br><span class="line">            <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                pipeline.addLast(handler);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ch.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> ServerBootstrapAcceptor( <span class="comment">// 注解21</span></span><br><span class="line">                            ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注解@20：在Server初始化时回调</p>
<p>注解@21：Server初始化后在pipeline加入了ServerBootstrapAcceptor，同时注意参数currentChildGroup和currentChildHandler，分别对应示例中传入的childGroup和childHandler。</p>
<p>接着看下ServerBootstrapAcceptor的channelRead方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Channel child = (Channel) msg; <span class="comment">// 注解@22</span></span><br><span class="line"></span><br><span class="line">    child.pipeline().addLast(childHandler); <span class="comment">// 注解@23</span></span><br><span class="line"></span><br><span class="line">    setChannelOptions(child, childOptions, logger);</span><br><span class="line">    setAttributes(child, childAttrs);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        childGroup.register(child).addListener(<span class="keyword">new</span> ChannelFutureListener() &#123; <span class="comment">// 注解@24</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (!future.isSuccess()) &#123;</span><br><span class="line">                    forceClose(child, future.cause());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        forceClose(child, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注解@22：注意此处有“注解@17”步回调回来，传入的msg为新建立连接的NioSocketChannel，再强调下该通道注册了可读事件。</p>
<p>注解@23：把childHandler加入到新建立连接Channel的pipeline，也就是示例中的HttpUploadServerInitializer。HttpUploadServerInitializer的初始化（channel注册后回调）又加入了HttpRequestDecoder、HttpResponseEncoder、HttpContentCompressor、HttpUploadServerHandler到该channel的pipeline。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> </span>&#123;</span><br><span class="line">    ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sslCtx != <span class="keyword">null</span>) &#123;</span><br><span class="line">        pipeline.addLast(sslCtx.newHandler(ch.alloc()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pipeline.addLast(<span class="keyword">new</span> HttpRequestDecoder());</span><br><span class="line">    pipeline.addLast(<span class="keyword">new</span> HttpResponseEncoder());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remove the following line if you don&#x27;t want automatic content compression.</span></span><br><span class="line">    pipeline.addLast(<span class="keyword">new</span> HttpContentCompressor());</span><br><span class="line"></span><br><span class="line">    pipeline.addLast(<span class="keyword">new</span> HttpUploadServerHandler());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>注解@24：将childGroup绑定到该NioSocketChannel，并将该NioSocketChannel注册到Selector。</p>
<p>小结：1.当轮询到有新的客户端连接建立时，将该新建的通道NioSocketChannel通过pipeline转发给ServerBootstrapAcceptor，这个过程由线程池bossGroup分配的线程负责。</p>
<p>2.当ServerBootstrapAcceptor收到新建立的通道NioSocketChannel时与workGroup分配的线程绑定，并将用户添加的childHandler加入到该channel的pipeline，注册OP_READ读事件到Selector。该过程由线程池workGroup分配的线程负责。</p>
<p>3.当有数据可读时由线程池workGroup分配的线程处理，并一路通过pipeline回调到我们自己加入的ChannelHandler 见注解@23.</p>
<p>例如：示例中加入的HttpUploadServerHandler，父类为SimpleChannelInboundHandler。当监听到有可读时间时，通过pipeline一路回调到SimpleChannelInboundHandler的channelRead()，进而调用到HttpUploadServerHandler的channelRead0()方法，从而处理我们的逻辑。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty8# Netty之ByteBuf初体验</title>
    <url>/posts/17c9a786/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>字节的流动形成了流，Netty作为优秀的通信框架他的字节是如何流动的，本文就理一下这个事。梳理完Netty的字节流动与JDK提供的ByteBuffer一对比看下Netty方便在哪里。本分从官方文档概念原理入手梳理，然后看下源码解读下这些原理如何实现的，体验一把Netty写入数据自动扩容，探究下这个过程如何实现的。</p>
<a id="more"></a>



<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p><strong>ByteBuf创建</strong></p>
<p>使用Unpooled类来创建ByteBuf，不建议使用ByteBuf的构造函数自己去创建。</p>
<p><strong>读写索引</strong></p>
<p>ByteBuf提供了两个指针readerIndex和writerIndex，分别记录读、写的开始位置。两个指针将ByteBuf分成了三个区域。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210102104805.png"></p>
<p><strong>discardable bytes</strong> </p>
<p>这个区间的范围为0~readerIndex，已经被读过的、可废弃的区域。通过调用discardReadBytes()，可以释放discardable bytes区域。这个区域释放后，可写区域（writable bytes）部分增多。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210102141428.png"></p>
<p><strong>readable bytes</strong></p>
<p>可读区域的范围为（writerIndex-readerIndex）</p>
<p><strong>writable bytes</strong></p>
<p>可写区域的范围为（capacity-writerIndex）</p>
<p><strong>清理索引</strong></p>
<p>调用Buffer.clear()后，读写索引全部归零，缓存buffer被释放。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210102143322.png"></p>
<h1 id="ByteBuf的构建"><a href="#ByteBuf的构建" class="headerlink" title="ByteBuf的构建"></a><strong>ByteBuf的构建</strong></h1><p>接下来通过示例窜下上面的知识点，看下源码是如何实现的，示例中将字符串写入ByteBuf中，然后再读出来打印。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWriteUtf81</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     String str1 = <span class="string">&quot;瓜农&quot;</span>;</span><br><span class="line">     ByteBuf buf = Unpooled.buffer(<span class="number">1</span>);</span><br><span class="line">     buf.writeBytes(str1.getBytes(CharsetUtil.UTF_8));</span><br><span class="line">     ByteBuf readByteBuf = ByteBufUtil.readBytes(UnpooledByteBufAllocator.DEFAULT,buf,str1.getBytes(CharsetUtil.UTF_8).length);</span><br><span class="line">     System.out.print(readByteBuf.toString(CharsetUtil.UTF_8));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>源码解读</strong> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuf <span class="title">buffer</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> ALLOC.heapBuffer(initialCapacity); <span class="comment">// 注解@1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">heapBuffer</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> heapBuffer(initialCapacity, DEFAULT_MAX_CAPACITY); <span class="comment">// 注解@2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">InstrumentedUnpooledUnsafeHeapByteBuf(UnpooledByteBufAllocator alloc, <span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity) &#123;</span><br><span class="line">  <span class="keyword">super</span>(alloc, initialCapacity, maxCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UnpooledHeapByteBuf</span><span class="params">(ByteBufAllocator alloc, <span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>(maxCapacity);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (initialCapacity &gt; maxCapacity) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(</span><br><span class="line">      <span class="string">&quot;initialCapacity(%d) &gt; maxCapacity(%d)&quot;</span>, initialCapacity, maxCapacity));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.alloc = checkNotNull(alloc, <span class="string">&quot;alloc&quot;</span>);</span><br><span class="line">  setArray(allocateArray(initialCapacity)); <span class="comment">// 注解@3</span></span><br><span class="line">  setIndex(<span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 注解@4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@1</strong> 使用ByteBufAllocator来分配ByteBuf，默认为UnpooledByteBufAllocator。</p>
<p><strong>注解@2</strong> initialCapacity为初始容量例子中给的为16，maxCapacity为默认的DEFAULT_MAX_CAPACITY=Integer.MAX_VALUE。</p>
<p><strong>注解@3</strong> allocateArray()的方法如下，此时使用JDK的byte[]初始化缓存区。通过setArray()，UnpooledHeapByteBuf持有byte[]缓存区。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">protected</span> <span class="keyword">byte</span>[] allocateArray(<span class="keyword">int</span> initialCapacity) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">byte</span>[initialCapacity];</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setArray</span><span class="params">(<span class="keyword">byte</span>[] initialArray)</span> </span>&#123;</span><br><span class="line">  array = initialArray;</span><br><span class="line">  tmpNioBuf = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@4</strong> 初始化readerIndex和writerIndex，均为0。</p>
<p><strong>小结</strong> ByteBuf的构建通过Unpooled来分配，示例中通过UnpooledByteBufAllocator持有byte[]、 readerIndex、writerIndex、maxCapacity完成ByteBuf的初始化。 示例中array数组大小为16；readerIndex=writerIndex=0；maxCapacity=Integer.MAX_VALUE。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210103092431.png"></p>
<h1 id="写入数据"><a href="#写入数据" class="headerlink" title="写入数据"></a>写入数据</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">writeBytes</span><span class="params">(<span class="keyword">byte</span>[] src, <span class="keyword">int</span> srcIndex, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">  ensureWritable(length); <span class="comment">// 注解@5</span></span><br><span class="line">  setBytes(writerIndex, src, srcIndex, length); <span class="comment">// 注解@6</span></span><br><span class="line">  writerIndex += length; <span class="comment">// 注解@7</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@5</strong> 确保剩余的空间能够容纳需写入的数据。</p>
<p>具体逻辑如下：<br>如果写入的数据长度小于已经分配的容量空间capacity则允许直接返回；</p>
<p>如果写入的数据长度超过允许的最大容量maxCapacity直接抛出IndexOutOfBoundsException拒绝；</p>
<p>如果写入数据长度大于已经分配的空间capacity但是小于最大最大允许空间maxCapacity，则需要扩容。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">ensureWritable0</span><span class="params">(<span class="keyword">int</span> minWritableBytes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> writerIndex = writerIndex(); <span class="comment">// 注解@5.1</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> targetCapacity = writerIndex + minWritableBytes; <span class="comment">// 注解@5.2</span></span><br><span class="line">    <span class="keyword">if</span> (targetCapacity &lt;= capacity()) &#123; <span class="comment">// 注解@5.3</span></span><br><span class="line">        ensureAccessible();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (checkBounds &amp;&amp; targetCapacity &gt; maxCapacity) &#123; <span class="comment">// 注解@5.4 </span></span><br><span class="line">        ensureAccessible();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(String.format(</span><br><span class="line">                <span class="string">&quot;writerIndex(%d) + minWritableBytes(%d) exceeds maxCapacity(%d): %s&quot;</span>,</span><br><span class="line">                writerIndex, minWritableBytes, maxCapacity, <span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Normalize the target capacity to the power of 2.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> fastWritable = maxFastWritableBytes(); <span class="comment">// 注解@5.5 </span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = fastWritable &gt;= minWritableBytes ? writerIndex + fastWritable</span><br><span class="line">            : alloc().calculateNewCapacity(targetCapacity, maxCapacity); <span class="comment">// 注解@5.6</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Adjust to the new capacity.</span></span><br><span class="line">    capacity(newCapacity); <span class="comment">// 注解@5.7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@5.1</strong>  获取当前写索引</p>
<p><strong>注解@5.2</strong> 计算需要的容量</p>
<p>**注解@5.3 ** 与当前已分配的容量capacity进行比较</p>
<p><strong>注解@5.4</strong> 不能超过最大允许的容量maxCapacity</p>
<p><strong>注解@5.5</strong> fastWritable = capacity() - writerIndex</p>
<p><strong>注解@5.6</strong> newCapacity的判断通常走到这里应该为，剩余的空间不够了。所以通常会进入alloc().calculateNewCapacity(targetCapacity, maxCapacity)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculateNewCapacity</span><span class="params">(<span class="keyword">int</span> minNewCapacity, <span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> threshold = CALCULATE_THRESHOLD; <span class="comment">// 4 MiB page</span></span><br><span class="line">        <span class="keyword">if</span> (minNewCapacity == threshold) &#123; <span class="comment">// 注解@5.6.1</span></span><br><span class="line">            <span class="keyword">return</span> threshold;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// If over threshold, do not double but just increase by threshold.</span></span><br><span class="line">        <span class="keyword">if</span> (minNewCapacity &gt; threshold) &#123; <span class="comment">// 注解@5.6.2</span></span><br><span class="line">            <span class="keyword">int</span> newCapacity = minNewCapacity / threshold * threshold;</span><br><span class="line">            <span class="keyword">if</span> (newCapacity &gt; maxCapacity - threshold) &#123;</span><br><span class="line">                newCapacity = maxCapacity;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                newCapacity += threshold;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> newCapacity;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Not over threshold. Double up to 4 MiB, starting from 64.</span></span><br><span class="line">        <span class="keyword">int</span> newCapacity = <span class="number">64</span>;</span><br><span class="line">        <span class="keyword">while</span> (newCapacity &lt; minNewCapacity) &#123; <span class="comment">// 注解@5.6.3</span></span><br><span class="line">            newCapacity &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Math.min(newCapacity, maxCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@5.6.1</strong> 如果写入的数据长度刚好为4M则返回threshold=4M</p>
<p><strong>注解@5.6.2</strong> 如果写入的数据长度大于4M，newCapacity不再翻倍增长，通过minNewCapacity / threshold * threshold计算刚容下需要的数据即可。</p>
<p><strong>注解@5.6.3</strong> 如果写入的数据长度小于4M，则newCapacity从64翻倍增长（128、256、512…），直到newCapacity能够容纳需要写入的数据。</p>
<p><strong>注解@5.7</strong> 确定了要扩容的容量newCapacity后，我们看下如何扩容的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">capacity</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">    checkNewCapacity(newCapacity);</span><br><span class="line">    <span class="keyword">byte</span>[] oldArray = array;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldArray.length;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity == oldCapacity) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> bytesToCopy;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity &gt; oldCapacity) &#123;</span><br><span class="line">      bytesToCopy = oldCapacity;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      trimIndicesToCapacity(newCapacity);</span><br><span class="line">      bytesToCopy = newCapacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">byte</span>[] newArray = allocateArray(newCapacity); <span class="comment">// 注解@5.7.1</span></span><br><span class="line">    System.arraycopy(oldArray, <span class="number">0</span>, newArray, <span class="number">0</span>, bytesToCopy); <span class="comment">// 注解@5.7.2</span></span><br><span class="line">    setArray(newArray); <span class="comment">// 注解@5.7.3</span></span><br><span class="line">    freeArray(oldArray); <span class="comment">// 注解@5.7.4</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@5.7.1</strong> 使用新的容量初始化newArray=new byte[initialCapacity]</p>
<p><strong>注解@5.7.2</strong> 将旧的oldArray数据拷贝到新的newArray=new中</p>
<p><strong>注解@5.7.3</strong> 将UnpooledHeapByteBuf的byte[]引用替换为newArray</p>
<p><strong>注解@5.7.4</strong> oldArray清理操作</p>
<p><strong>注解@6</strong> 写入数据，通过System.arraycopy将数据写入array中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">setBytes</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">byte</span>[] src, <span class="keyword">int</span> srcIndex, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">  checkSrcIndex(index, length, srcIndex, src.length);</span><br><span class="line">  System.arraycopy(src, srcIndex, array, index, length);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@7</strong> 移动writerIndex指针。</p>
<p><strong>小结：</strong> 将上面例子的initialCapacity设置成1，促使写入数据时扩充容量。下面运行时截图：array被扩容到64，writerIndex从0位置移动到6. </p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210103110741.png"></p>
<p>在写入数据时，判断剩余容量是否足够；不够则需要扩容，如果写入的数据小于4M，则双倍增长，直到容纳写写入的数据。如果写入的数据大于4M，通过（minNewCapacity / threshold * threshold）计算需要扩容的大小。</p>
<h1 id="读出数据"><a href="#读出数据" class="headerlink" title="读出数据"></a>读出数据</h1><p>从buf中把刚才写入的数据（”瓜农“）读出来，通过工具类ByteBufUtil.readBytes来实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ByteBuf readByteBuf = ByteBufUtil.readBytes(UnpooledByteBufAllocator.DEFAULT,buf,str1.getBytes(CharsetUtil.UTF_8).length);</span><br><span class="line">System.out.print(readByteBuf.toString(CharsetUtil.UTF_8));</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuf <span class="title">readBytes</span><span class="params">(ByteBufAllocator alloc, ByteBuf buffer, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> release = <span class="keyword">true</span>;</span><br><span class="line">    ByteBuf dst = alloc.buffer(length); <span class="comment">// 注解@8</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        buffer.readBytes(dst); <span class="comment">// 注解@9</span></span><br><span class="line">        release = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> dst;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (release) &#123;</span><br><span class="line">            dst.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@8</strong> 重新构造了一个ByteBuf（dst）用于存储读取的数据</p>
<p><strong>注解@9</strong> 读取数据，并移动读索引。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">readBytes</span><span class="params">(ByteBuf dst, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (checkBounds) &#123;</span><br><span class="line">        <span class="keyword">if</span> (length &gt; dst.writableBytes()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(String.format(</span><br><span class="line">                    <span class="string">&quot;length(%d) exceeds dst.writableBytes(%d) where dst is: %s&quot;</span>, length, dst.writableBytes(), dst));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    readBytes(dst, dst.writerIndex(), length); <span class="comment">// 注解@9.1</span></span><br><span class="line">    dst.writerIndex(dst.writerIndex() + length); <span class="comment">// 注解@9.2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@9.1</strong> 读取字节到新的ByteBuf。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">readBytes</span><span class="params">(ByteBuf dst, <span class="keyword">int</span> dstIndex, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    checkReadableBytes(length);</span><br><span class="line">    getBytes(readerIndex, dst, dstIndex, length); <span class="comment">// 注解@9.1.1</span></span><br><span class="line">    readerIndex += length; <span class="comment">// 注解@9.1.2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@9.1.1</strong> 通过native api UNSAFE.copyMemory() 实现byte数组之间的拷贝</p>
<p><strong>注解@9.1.2</strong> 源byteBuf读索引readerIndex向前移动</p>
<p><strong>注解@9.2</strong> 数据读入新构建的缓存区dst，dst的写索引向前移动</p>
<p><strong>小结：</strong> 示例中通过构造一个新的ByteBuf（dst），将源ByteBuf（buf）的数据读入到dst。数据读取结束后，源ByteBuf（buf）readerIndex向前移动；ByteBuf（dst）的writerIndex向前移动。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210103125302.png"></p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty9# Netty抽象内存分配器实现原理</title>
    <url>/posts/2e57625b/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p> 本文通过分析抽象内存分配器API梳理其基于堆内存、堆外内存分配的实现原理。最后走查了CompositeByteBuf这种类似数据库视图的实现原理。</p>
<a id="more"></a>



<h1 id="内存分配器概览"><a href="#内存分配器概览" class="headerlink" title="内存分配器概览"></a>内存分配器概览</h1><p><strong>堆外内存&amp;堆内存</strong> </p>
<table>
<thead>
<tr>
<th>分配方式</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>堆内存</td>
<td>JVM负责内存的分配与回收</td>
<td>数据过多会引起频繁GC和停顿；<br />多一次拷贝，在用户态分配、I/O通信需要数据拷贝到内核态</td>
</tr>
<tr>
<td>堆外内存</td>
<td>I/O性能高，直接在内核态分配<br />降低GC频率和停顿</td>
<td>内存分配和收回比较慢、需要手动处理</td>
</tr>
</tbody></table>
<p><strong>内存分配器类图</strong> </p>
<p>字节缓存的分配出自ByteBufAllocator，其实现类AbstractByteBufAllocator（抽象类）、PooledByteBufAllocator（池化内存分配器）、UnpooledByteBufAllocator（非池化内存分配器）、PreferHeapByteBufAllocator（堆内存分配器）、PreferredDirectByteBufAllocator（堆外内存分配器）。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8%E7%B1%BB%E5%9B%BE%20(1).png"></p>
<p><strong>主要接口</strong> </p>
<table>
<thead>
<tr>
<th>接口</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>ByteBuf buffer()</td>
<td>分配一块字节缓存，由其实现类决定堆外内存或者堆内存</td>
</tr>
<tr>
<td>ByteBuf ioBuffer()</td>
<td>系统支持UNSAFE和CLEANER则优先分配堆外内存；否则分配堆内存。</td>
</tr>
<tr>
<td>ByteBuf heapBuffer()</td>
<td>分配堆内存字节缓存区</td>
</tr>
<tr>
<td>ByteBuf directBuffer()</td>
<td>分配堆外内存字节缓存区</td>
</tr>
<tr>
<td>CompositeByteBuf compositeBuffer()</td>
<td>分配一个CompositeByteBuf（将多个buffers组合成一个buffer）<br />由实现类决定堆内存或者堆外内存</td>
</tr>
</tbody></table>
<h1 id="内存分配器API解读"><a href="#内存分配器API解读" class="headerlink" title="内存分配器API解读"></a>内存分配器API解读</h1><p>下面走查下抽象内存分配器AbstractByteBufAllocator的API。</p>
<p><strong>构造函数</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> directByDefault;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ByteBuf emptyBuf;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractByteBufAllocator</span><span class="params">(<span class="keyword">boolean</span> preferDirect)</span> </span>&#123;</span><br><span class="line">  directByDefault = preferDirect &amp;&amp; PlatformDependent.hasUnsafe(); <span class="comment">// 注解@1</span></span><br><span class="line">  emptyBuf = <span class="keyword">new</span> EmptyByteBuf(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@1</strong> directByDefault是否使用堆外内存分配，满足两个条件。preferDirect布尔型用户传入；PlatformDependent.hasUnsafe() 系统是否支持UNSAFE（通过内存指针进行堆外内存分配）；即：用户传入preferDirect=true并且系统支持UNSAFE则使用堆外内存。</p>
<p><strong>buffer()</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">buffer</span><span class="params">()</span> </span>&#123; <span class="comment">// 注解@2</span></span><br><span class="line">  <span class="keyword">if</span> (directByDefault) &#123;</span><br><span class="line">    <span class="keyword">return</span> directBuffer();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> heapBuffer();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@2</strong> directByDefault如果为true使用堆外内存分配DirectByteBuffer，底层使用unsafe.allocateMemory分配。</p>
<p>directByDefault如果为false使用堆内存分配 new byte[initialCapacity]。</p>
<p><strong>ioBuffer</strong> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">ioBuffer</span><span class="params">()</span> </span>&#123; <span class="comment">// 注解@3</span></span><br><span class="line">  <span class="keyword">if</span> (PlatformDependent.hasUnsafe() || isDirectBufferPooled()) &#123;</span><br><span class="line">  <span class="keyword">return</span> directBuffer(DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> heapBuffer(DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@3</strong> 如果系统支持UNSAFE或者使用池化内存，优先分配堆外内存，否则分配堆内存。</p>
<p><strong>heapBuffer</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">heapBuffer</span><span class="params">()</span> </span>&#123; <span class="comment">// 注解@4</span></span><br><span class="line">	<span class="keyword">return</span> heapBuffer(DEFAULT_INITIAL_CAPACITY, DEFAULT_MAX_CAPACITY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@4</strong> 分配堆外内存new一个byte数组（new byte[]）。</p>
<p><strong>directBuffer</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">directBuffer</span><span class="params">()</span> </span>&#123; <span class="comment">// 注解@5</span></span><br><span class="line">	<span class="keyword">return</span> directBuffer(DEFAULT_INITIAL_CAPACITY, DEFAULT_MAX_CAPACITY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@5</strong> 分配堆外内存。</p>
<p><strong>compositeBuffer</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompositeByteBuf <span class="title">compositeBuffer</span><span class="params">()</span> </span>&#123; <span class="comment">// 注解@6</span></span><br><span class="line">  <span class="keyword">if</span> (directByDefault) &#123;</span><br><span class="line">  	<span class="keyword">return</span> compositeDirectBuffer();</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="keyword">return</span> compositeHeapBuffer();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@6</strong> 跟上面一样的，只是分配的CompositeByteBuf。下面看下这种将多个个buffer组合成一个buffer是如何实现的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompositeByteBuf <span class="title">compositeHeapBuffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> compositeHeapBuffer(DEFAULT_MAX_COMPONENTS);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompositeByteBuf <span class="title">compositeHeapBuffer</span><span class="params">(<span class="keyword">int</span> maxNumComponents)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> toLeakAwareBuffer(<span class="keyword">new</span> CompositeByteBuf(<span class="keyword">this</span>, <span class="keyword">false</span>, maxNumComponents));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">CompositeByteBuf</span><span class="params">(ByteBufAllocator alloc, <span class="keyword">boolean</span> direct, <span class="keyword">int</span> maxNumComponents, <span class="keyword">int</span> initSize)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>(AbstractByteBufAllocator.DEFAULT_MAX_CAPACITY);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.alloc = ObjectUtil.checkNotNull(alloc, <span class="string">&quot;alloc&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (maxNumComponents &lt; <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">  <span class="string">&quot;maxNumComponents: &quot;</span> + maxNumComponents + <span class="string">&quot; (expected: &gt;= 1)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.direct = direct;</span><br><span class="line">  <span class="keyword">this</span>.maxNumComponents = maxNumComponents;</span><br><span class="line">  components = newCompArray(initSize, maxNumComponents); <span class="comment">// 注解@6.1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@6.1</strong> 在CompositeByteBuf的构造方法中初始化了一个components，这个默认initSize=0；maxNumComponents默认为16。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Component[] newCompArray(<span class="keyword">int</span> initComponents, <span class="keyword">int</span> maxNumComponents) &#123;</span><br><span class="line">	<span class="keyword">int</span> capacityGuess = Math.min(AbstractByteBufAllocator.DEFAULT_MAX_COMPONENTS, maxNumComponents);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> Component[Math.max(initComponents, capacityGuess)]; <span class="comment">// 注解@6.2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@6.2</strong> components是Component的对象数组，数组大小默认为16. </p>
<h1 id="CompositeByteBuf实现原理"><a href="#CompositeByteBuf实现原理" class="headerlink" title="CompositeByteBuf实现原理"></a>CompositeByteBuf实现原理</h1><p>下面通过例子来体验一把CompositeByteBuf，先直观感受下。</p>
<p><strong>示例代码</strong> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCompositeByteBuf</span><span class="params">()</span></span>&#123;</span><br><span class="line">  String str1 = <span class="string">&quot;瓜农&quot;</span>;</span><br><span class="line">  String str2 = <span class="string">&quot;老梁&quot;</span>;</span><br><span class="line">  ByteBuf buf1 = Unpooled.buffer(<span class="number">10</span>);</span><br><span class="line">  buf1.writeBytes(str1.getBytes(CharsetUtil.UTF_8));</span><br><span class="line">  System.out.println(<span class="string">&quot;buf1&#x27;s readerIndex:&quot;</span> + buf1.readerIndex());</span><br><span class="line">  System.out.println(<span class="string">&quot;buf1&#x27;s writeIndex&quot;</span> + buf1.writerIndex());</span><br><span class="line"></span><br><span class="line">  ByteBuf buf2 = Unpooled.buffer(<span class="number">10</span>);</span><br><span class="line">  buf2.writeBytes(str2.getBytes(CharsetUtil.UTF_8));</span><br><span class="line">  System.out.println(<span class="string">&quot;buf2&#x27;s readerIndex:&quot;</span> + buf2.readerIndex());</span><br><span class="line">  System.out.println(<span class="string">&quot;buf2&#x27;s writeIndex&quot;</span> + buf2.writerIndex());</span><br><span class="line"></span><br><span class="line">  ByteBuf compositeByteBuf = Unpooled.wrappedBuffer(buf1,buf2);</span><br><span class="line">  System.out.println(<span class="string">&quot;compositeByteBuf&#x27;s readerIndex:&quot;</span> + compositeByteBuf.readerIndex());</span><br><span class="line">  System.out.println(<span class="string">&quot;compositeByteBuf&#x27;s writeIndex&quot;</span> + compositeByteBuf.writerIndex());</span><br><span class="line">  System.out.print(compositeByteBuf.toString(CharsetUtil.UTF_8));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结果输出</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">buf1&#39;s readerIndex:0</span><br><span class="line">buf1&#39;s writeIndex6</span><br><span class="line">buf2&#39;s readerIndex:0</span><br><span class="line">buf2&#39;s writeIndex6</span><br><span class="line">compositeByteBuf&#39;s readerIndex:0</span><br><span class="line">compositeByteBuf&#39;s writeIndex12</span><br><span class="line">瓜农老梁</span><br></pre></td></tr></table></figure>

<p><strong>小结</strong>  Unpooled.wrappedBuffer(buf1,buf2)将两个ByteBuf进行了合并一个ByteBuf；对外提供统一的读写指针供使用。</p>
<p>接下来看下他是如何合并的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuf <span class="title">wrappedBuffer</span><span class="params">(<span class="keyword">int</span> maxNumComponents, ByteBuf... buffers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (buffers.length) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            ByteBuf buffer = buffers[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span> (buffer.isReadable()) &#123;</span><br><span class="line">                <span class="keyword">return</span> wrappedBuffer(buffer.order(BIG_ENDIAN));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                buffer.release();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buffers.length; i++) &#123;</span><br><span class="line">                ByteBuf buf = buffers[i];</span><br><span class="line">                <span class="keyword">if</span> (buf.isReadable()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> CompositeByteBuf(ALLOC, <span class="keyword">false</span>, maxNumComponents, buffers, i); <span class="comment">// 注解@7</span></span><br><span class="line">                &#125;</span><br><span class="line">                buf.release();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> EMPTY_BUFFER;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@7</strong> 通过创建一个CompositeByteBuf，将ByteBuf数组传入构造函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompositeByteBuf(ByteBufAllocator alloc, <span class="keyword">boolean</span> direct, <span class="keyword">int</span> maxNumComponents,</span><br><span class="line">            ByteBuf[] buffers, <span class="keyword">int</span> offset) &#123;</span><br><span class="line">            <span class="keyword">this</span>(alloc, direct, maxNumComponents, buffers.length - offset);</span><br><span class="line"></span><br><span class="line">	addComponents0(<span class="keyword">false</span>, <span class="number">0</span>, buffers, offset); <span class="comment">// 注解@8</span></span><br><span class="line">	consolidateIfNeeded();</span><br><span class="line">	setIndex0(<span class="number">0</span>, capacity()); <span class="comment">// 注解@9</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@8</strong>  填充Component[]数据，每个Component元素包含了传入的ByteBuf。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> CompositeByteBuf <span class="title">addComponents0</span><span class="params">(<span class="keyword">boolean</span> increaseWriterIndex,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">final</span> <span class="keyword">int</span> cIndex, ByteBuf[] buffers, <span class="keyword">int</span> arrOffset)</span> </span>&#123;</span><br><span class="line">  			<span class="comment">//  buffers数组的长度；本例中arrOffset=0；count=len</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> len = buffers.length, count = len - arrOffset;</span><br><span class="line">        <span class="keyword">int</span> ci = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            checkComponentIndex(cIndex); <span class="comment">// 合法性校验</span></span><br><span class="line">            shiftComps(cIndex, count); <span class="comment">// 注解@8.1</span></span><br><span class="line">            <span class="keyword">int</span> nextOffset = cIndex &gt; <span class="number">0</span> ? components[cIndex - <span class="number">1</span>].endOffset : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (ci = cIndex; arrOffset &lt; len; arrOffset++, ci++) &#123; <span class="comment">// 注解@8.2</span></span><br><span class="line">                <span class="comment">// 从数组中拿出传入的ByteBuf</span></span><br><span class="line">              	ByteBuf b = buffers[arrOffset];</span><br><span class="line">                <span class="keyword">if</span> (b == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 构建Component</span></span><br><span class="line">                Component c = newComponent(ensureAccessible(b), nextOffset); </span><br><span class="line">              	<span class="comment">// 加入components数组</span></span><br><span class="line">                components[ci] = c;</span><br><span class="line">                <span class="comment">// 递增endOffset</span></span><br><span class="line">                nextOffset = c.endOffset;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@8.1</strong> 扩容Component数组，默认的数量为16个，当添加的buffer的数量超过16时就需要扩容了，下面看下其如何扩容的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">shiftComps</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> size = componentCount, newSize = size + count;</span><br><span class="line">        <span class="keyword">assert</span> i &gt;= <span class="number">0</span> &amp;&amp; i &lt;= size &amp;&amp; count &gt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (newSize &gt; components.length) &#123;</span><br><span class="line">            <span class="comment">// grow the array </span></span><br><span class="line">          	<span class="keyword">int</span> newArrSize = Math.max(size + (size &gt;&gt; <span class="number">1</span>), newSize); <span class="comment">// 注解@8.1.1</span></span><br><span class="line">            Component[] newArr;</span><br><span class="line">            <span class="comment">// 注解@8.1.2</span></span><br><span class="line">            <span class="keyword">if</span> (i == size) &#123;</span><br><span class="line">                newArr = Arrays.copyOf(components, newArrSize, Component[].class);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                newArr = <span class="keyword">new</span> Component[newArrSize];</span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    System.arraycopy(components, <span class="number">0</span>, newArr, <span class="number">0</span>, i);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i &lt; size) &#123;</span><br><span class="line">                    System.arraycopy(components, i, newArr, i + count, size - i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            components = newArr;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; size) &#123;</span><br><span class="line">            System.arraycopy(components, i, components, i + count, size - i);</span><br><span class="line">        &#125;</span><br><span class="line">        componentCount = newSize;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>**注解@8.1.1 ** 默认size=16，size &gt;&gt; 1 = 8 也就是扩容会以原大小一半的容量进行扩容。</p>
<p><strong>注解@8.1.2</strong> 下面判断根据场景通过Arrays.copyOf、System.arraycopy将Component数组扩容；插入尾部、中部、头部等情况。本示例中没有超过16，所以不会扩容，componentCount=2。</p>
<p><strong>注解@8.2</strong> 循环拿出传入的ByteBuf数组构建Component，并将其加入Component数组中；最后移动nextOffset。关于各个参数的含义，源码给出了注释。构造函数中</p>
<p>第一个参数：传入的ByteBuf<br>第二个参数：源ByteBuf的readerIndex<br>第三个参数：unwrapped的buffer<br>第四个参数：unwrappedIndex<br>第五个参数：offset = components[cIndex - 1].endOffset<br>第六个参数：len = buf.readableBytes()  buf为源buffer<br>第七个参数：slice = null （示例）</p>
<p>以endOffset为例，等于插入数组中上一个Conponent的endOffset + 当前ByteBuf的可读长度，从而维护了其在整个CompositeByteBuf的写索引情况。</p>
<p>一个buffer对应一个Component，每个Component持有源buffer并维护了其在整个CompositeByteBuf的索引情况。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210117101614.png"></p>
<p><strong>注解@9</strong> 设置整个CompositeByteBuf的读索引和写索引，读索引初始值为0；写索引为components[size - 1].endOffset，也就是整个Conponent数组中其每个元素维护的ByteBuf可读字节（writerIndex - readerIndex）大小的总和。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setIndex0</span><span class="params">(<span class="keyword">int</span> readerIndex, <span class="keyword">int</span> writerIndex)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.readerIndex = readerIndex;</span><br><span class="line">	<span class="keyword">this</span>.writerIndex = writerIndex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">capacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> size = componentCount;</span><br><span class="line">  <span class="keyword">return</span> size &gt; <span class="number">0</span> ? components[size - <span class="number">1</span>].endOffset : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>小结：</strong> CompositeByteBuf通过将多个ByteBuf装入component数组中，对其统一维护读写索引，在外面看起来是一个统一的buffer；类似数据库中的视图。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>SK1# 给老板画饼</title>
    <url>/posts/4eda328d/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>大家好，我是老梁，一个想跟大家分享点干活的家伙。</p>
<p>今天周末，这上海的天也冷了，晚上喝了点羊汤，到了一周中最放松的时刻。</p>
<p>今天不聊技术，咱聊聊给老板画饼。 </p>
<a id="more"></a>



<h1 id="一"><a href="#一" class="headerlink" title="一"></a>一</h1><p>崇祯元年七月十四日，崇祯在平台召见袁崇焕，聊辽东的事。</p>
<p>崇祯说卿是我大明的忠诚义士，有你在收复辽东我就放心了，卿需要多久可收复？</p>
<p>袁崇焕答：“臣受陛下眷顾，以臣便宜行事，计五年全辽可复！”。</p>
<p>崇祯太高兴了，说收复辽东，朕给你封侯赏赐绝不吝啬。</p>
<p>会后，兵科给事中许誉卿向袁大人讨教平辽方略，袁大人答”聊慰上意“，看到皇上如此操劳，好言劝慰而已。许大人这下傻眼了，到时候干不成，皇上怪罪下来如何是好。</p>
<p>再次会见时，袁大人意识到吹的大了，跟皇上要人、要钱、要权。崇祯全部答应，召集六部要求全部落实，嗯，皇上是认真的。</p>
<p>崇祯二年十一月，皇太极率数十万大军绕道蒙古，避开山海关，突破长城，威胁北京。最后袁大人虽然统领各地援军最终逼退后金军队，北京解围。对了，袁大人在这一年多在未请示皇上的情况下，干掉了皮岛军区司令员毛文龙。</p>
<p>崇祯二年十二月，后金退兵后，袁大人却下狱了。</p>
<p>崇祯三年八月，袁崇焕被凌迟处死，被割了3000多刀，家人流徙三千里，财产没收。</p>
<p>袁大人是从底层一点一点干起来的，自己的能力得到贵人兵部尚书、东阁大学士孙承宗赏识才有了后来的袁督师。对袁崇焕的奋斗史很受感动。临终绝笔诗《临刑口占》述说着他奋斗的一生。</p>
<p>一生事业总成空，半世功名在梦中。<br>死后不愁无勇将，忠魂依旧守辽东。</p>
<p>袁大人被杀的原因很多什么通敌、政治迫害就不聊这个了。</p>
<p>有一点是袁大人忽悠了老板，而且忽悠的没了边，老板虽然不太懂军事，你不能这么忽悠。</p>
<p>所谓期望越高失望越大，你说五年平辽，第二年后金打到了京城，这怎么解释？</p>
<h1 id="二"><a href="#二" class="headerlink" title="二"></a>二</h1><p>多年前老梁所在公司计划成立中间件团队，成立后大领导发现缺一个团队负责人，眼下无人索性让以前管业务的同学来带。几个月后经人介绍给大领导，来了一位大神。</p>
<p>大神第一次会议是在一个大方桌举行的，大领导也在，介绍了新来的团队负责人，并邀请大神发言。大神开口就语出惊人，”我熟读Linux源码“。</p>
<p>老梁我赶紧直了直腰，寻思着能从大神那里学点干货。第一次会议开得很成功，大领导很是欣慰，相见恨晚，团队小伙伴们也有士气。</p>
<p>大神上任三把火开始了，先规划未来。写了很多PPT，我们要完成什么什么什么。看了后你会发现除了BAT外基础设施就该我们最牛了。另外大神有个特点，业务运维的对团队的需求都能接，还承诺实现时间。大神写的PPT也得到了大领导认可。</p>
<p>但是后面的会议，每次会议都是天南海北的说，就是不见落地的具体措施。几次后老梁索性不参加了，年底绩效看着给吧，所谓的学习干货，除了听了忽悠也没学到啥。</p>
<p>三个季度大半年过去了，老梁在公司代码仓库上看了看，发现大神就没提交过代码。提交过，大致是不到10行的代码。但是PPT上的东西没看到一样落地，原来是什么样还是什么样。</p>
<p>年底看结果了，承诺的一个没实现，PPT什么样还是什么样，承诺运维的没实现，承诺业务部门的没实现。同样承诺领导的也没实现。</p>
<p>大领导在众多不满的声音中只好换人，大神只好去别的地方去跳了。</p>
<h1 id="三"><a href="#三" class="headerlink" title="三"></a>三</h1><p>我们应该给领导画饼吗？老梁觉得是应该的，但是这个饼是自己踮起脚尖能实现的。</p>
<p>如果有些领域的确没做过，在尝试的过程中及时跟领导保持沟通，把其中面临的问题及时反馈给领导。</p>
<p>能做你领导思考问题的方式和调动的资源必然比你多，跟领导一起去干不熟悉的领域，就算失败通常领导也愿意给你交学费。</p>
<p>过分忽悠领导就不应该了，如果遇到领导不熟悉这块领域听了你的忽悠信了你，但是技术这个东西是要落地的，落不了呢？</p>
<p>如果领导也懂这块领域，你忽悠不了他，在领导心里留下好大喜功的印象，何必呢？</p>
<p>能做你领导，通常必然有些能力超过你，能让你坐在这个位置上，也能让你滚蛋。</p>
<p>能捧得起你，自然可以踩得扁你。或许不出彩，或许绩效平平，但是有如何呢？多了一份踏实</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>思考随记</category>
      </categories>
      <tags>
        <tag>思考随记</tag>
      </tags>
  </entry>
  <entry>
    <title>SK1# 仰望星空</title>
    <url>/posts/8a7728e3/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="仰望星空"><a href="#仰望星空" class="headerlink" title="仰望星空"></a>仰望星空</h1><p>大家好，我是老梁，一个想跟大伙分享点干货的家伙。</p>
<p>今天周末，晚上喝了点啤酒，又到了一周中最放松的时刻，咱接着聊聊天。</p>
<p>上周写了篇小文《给老板画饼》，老板看了后怼了一句，脚踏实地和仰望星空其实缺一不可。</p>
<p>老梁想了想，他是对的。老梁我就佩服他这点，总能发现你的问题所在，指出前进的方向。</p>
<p>嗯，不是谁都能当老板。</p>
<p>老梁仰望星空，看到那些闪闪发光的星星……</p>
<a id="more"></a>



<h1 id="多看看历史星空中的星星"><a href="#多看看历史星空中的星星" class="headerlink" title="多看看历史星空中的星星"></a>多看看历史星空中的星星</h1><p>明正统十四年（1449年）八月，明英宗朱祁镇率军50万御驾亲征瓦刺，命弟弟朱祁钰留守京城。</p>
<p>皇上这年22岁，还是一个容易被蛊惑的年轻人，说是御驾亲征，实际由太监王振指挥。</p>
<p>王振不懂军事，一通乱指挥后，被瓦刺首领也先在今河北省张家口市怀来县境内的土木堡围猎。</p>
<p>20万大军损失大半，精锐尽失，皇上也被瓦刺掳走了，跟随出征的高官阵亡五十余人。</p>
<p>国不可一日无君，八月十八日皇太后命朱祁钰监国，八月二十九日百官拥立朱祁钰为帝，即景帝。</p>
<p>这一个月的变化真是太大了，而且瓦刺马上就要打到北京了，大明危在旦夕。</p>
<p>景帝命于谦为兵部尚书，原来的尚书邝埜呢？也在土木堡阵亡了。然而主战还是南迁成了争论的焦点。</p>
<p>以徐珵为代表的大臣主张南迁，北京守不住，原因很简单，精锐部队都埋葬在土木堡了，拿什么守！</p>
<p>于谦主战认为“京师天下根本，一动则大事去矣”。呵斥 “言南迁者，可斩也”。</p>
<p>于谦的建议得到了吏部尚书等人的支持，廷议最后决定固守北京，皇上把北京守卫重任交给了于谦。</p>
<p>皇上心里也没底，守说着容易，20万都打没了，现在京城不到10万军队还都是老弱病残居多。</p>
<p>有兵的话还廷议个啥，直接打就完了，这不是没兵嘛。</p>
<p>没了精锐就拿后备军凑，于谦命令各地备操军、备倭军、运粮军按时到京城布防，违令者斩！</p>
<p>嗯，清一色后备役。。。</p>
<p>这些后备役差不多有10万人，并要求途径通州粮仓把粮食顺便带到京城。</p>
<p>九月初，各路人马总算集合完毕，二十二万人，粮食问题也解决了。</p>
<p>十月十一日瓦刺军队来了，他们只用了11天就打到了北京城下，更增加了他们拿下北京的信心。</p>
<p>“京城必破，大元必兴”！</p>
<p>于谦召集将领召开战前会议，聊如何退敌。</p>
<p>大将石享提出敌军实力远超明军，应该坚壁清野，等待敌军疲惫后自然退兵。</p>
<p>大家比较赞同这个，但是一个人反对，这个是于谦，他是总指挥，是说了算的人。</p>
<p>找你们来，不是跟你们商量的，让你们来听令的！他的军令：</p>
<p>“大军全部开出九门之外，列阵迎敌”</p>
<p>“锦衣卫巡查城内，但凡查到有盔甲军士不出城作战者，格杀勿论！”</p>
<p>“九门是京城门户，若有丢失立斩！”</p>
<p>“临阵，将不顾军先退者，立斩！“</p>
<p>“临阵，军不顾将先退者，后队斩前队！”</p>
<p>“敢违军令者，格杀勿论！”</p>
<p>“大军开战之日，众将率军出城之后，立即关闭九门，有敢擅自放入城者立斩！”</p>
<p>嗯，在玩命！不玩命，大明就完了，这次输不起。</p>
<p>最终于谦带领着这只大部分的后备役军队逼退了瓦刺军，取得了北京保卫战的胜利。</p>
<p>于谦有大明再造之功！下面是他老人家的一首《石灰吟》，感受下他的风骨：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">千锤万凿出深山，烈火焚烧若等闲。</span><br><span class="line"></span><br><span class="line">粉骨碎身浑不怕，要留清白在人间。</span><br></pre></td></tr></table></figure>



<p>他那是历史星空中耀眼的一颗星星，每次翻开这段历史，总是那么明亮，让人充满敬意！</p>
<h1 id="多发现工作生活中的星星"><a href="#多发现工作生活中的星星" class="headerlink" title="多发现工作生活中的星星"></a>多发现工作生活中的星星</h1><p>我们在写ORK目标时，经常提到打造业界领先的、对齐业界一流的某些能力！</p>
<p>这些业界领先的东西就是我们的星星，需要时常抬头仰望，好让我们跟的紧一点。</p>
<p>工作中优秀的人，需要时常抬头仰望，好让我们与优秀者同行。</p>
<p>比如老梁吧，平时工作比较忙，基本上是995的节凑，周末还得抽出时间看源码写文章，不写不行吗？</p>
<p>也想不写，也想懈怠，但是抬头仰望星空，老梁看到了啥？老梁看到了丁威，那家伙又输出很多东西。</p>
<p>输出倒逼输入，输入倒逼输出，不断输入输出让自己能力提升。</p>
<p>这家伙不知疲倦，笔耕不戳！典型的湖南人性格，耐得烦、吃得苦、霸得蛮！</p>
<p>还特别有恒心，一坚持就7、8年，没一点停的意思！你说气人不气人。</p>
<p>能咋办？喝口水，擦把汗，接着干呗。。。</p>
<h4 id="最后说两句"><a href="#最后说两句" class="headerlink" title="最后说两句"></a>最后说两句</h4><p>当你生活不如意时看看以前和周围的人和事，在历史长河中，你的那点事其实没多大点事，不值得怨天尤人、寻死觅活。</p>
<p>当你春风得意时看看以前和周围的人和事，在历史长河中，你再大的成就不过沧海一粟，不值得骄傲自大、目中无人。</p>
<p>当你遇到无论什么样的困惑时，多仰望星空，历史的星星、身边的星星会给你照前进的路。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>思考随记</category>
      </categories>
      <tags>
        <tag>思考随记</tag>
      </tags>
  </entry>
  <entry>
    <title>SK3# 苍天饶过谁</title>
    <url>/posts/bb2245d5/</url>
    <content><![CDATA[<div id="vip-container"><h2 id="一"><a href="#一" class="headerlink" title="一"></a>一</h2><p>大家好，我是老梁，一个想跟大伙分享点干货的家伙。</p>
<p>今天周末，晚上喝了点女儿红，又到了一周中最放松的时候，咱接着聊聊天。</p>
<p>上周文章《仰望星空》，老梁说多看看历史和生活中的星星，让他们给咱照亮前进的路。</p>
<p>有朋友怼老梁，管看星星有啥用，看就能解决问题了？该踩的坑还要踩，该流的泪还要流。</p>
<p>老梁想了想，可不是么？该受的难还得受，苍天绕过谁。。。</p>
<a id="more"></a>



<h2 id="二"><a href="#二" class="headerlink" title="二"></a>二</h2><p>弘治元年（1488年）杨慎生于北京，祖籍四川成都人。爹是内阁首辅、东阁大学士杨廷和。不当爹是副国级，爷爷也是1481年的进士。</p>
<p>进士可不是那么容易的，首先你得先考中秀才，再考中举人，才有资格参加进士考试。进士考试的录取比例大约9%，平均每年也就百八十号人。。。</p>
<p>嗯，妥妥的官二代。</p>
<p>总有那么有些人，长得比你帅，出生比你好，还比你更努力，杨慎就是这号人。11岁就能作诗，12岁做的文章就得到当时文学家、书法家李东阳赞赏，收到其门下学习。</p>
<p>嗯，读书是要点天分的。</p>
<p>明武宗正德六年（1511年），24岁的杨慎考中状元，进士及第，授翰林院修撰。刚毕业就是修撰从六品官职，县太爷是七品，多少人体制内的人，熬啊熬。熬一辈子才是副科待遇，副科也就是从九品吧。</p>
<p>关键是在翰林院就业，这地方能进去的都是蔗吉士。啥概念，一甲三人（状元、榜眼、探花）和二甲中的头几名才有资格进去的。这是宰相培训班、帝国柱梁的摇篮。</p>
<p>这么下去，杨慎就是做不了宰相，最少熬个副部级没问题，前途一片光明。</p>
<p>嘉靖三年（1524年），发生了”大议礼“事件后，杨慎确挨了板子，被贬出京城，这年33岁。</p>
<p>明武宗朱厚照，去世时没子嗣。按照兄终弟及的祖训，朱厚熜被选为帝国皇帝，即嘉靖。</p>
<p>大议礼争来争去就是给朱厚熜他爸的主祀及封号问题。杨廷和给出的他爹封号为“皇叔考兴献大王”，他妈为“皇叔母兴国大妃”，祭祀时其亲生父母自称“侄皇帝”。原因很简单，他爹是王爷没做过皇帝，皇位是从堂兄手上继承过来的，朱厚熜不同意。</p>
<p>在这次事件中，杨慎与两百多位官员，在左順門哭天喊地，请皇上同意他们的主张。杨慎是带头大哥之一，并说”國家養士百五十年，仗節死義，正在今日“。</p>
<p>那会当官还真团结，一起跟皇上叫板。</p>
<p>皇上也不客气，两百多位，一个别想跑，廷杖！廷杖就是打屁股，还褪去裤子打，被打的还是高干们，这次廷杖死了16人。</p>
<p>杨慎也被打了，被打的皮开肉绽，差点昏死过去，然后被贬到了今云南保山市，年七十二岁终于被贬之地，终身未再复用。</p>
<p>就这事争了三年才算完，最后嘉靖赢了，其父上尊号“皇考恭穆献皇帝”，其母尊号“圣母章圣皇太后”。</p>
<p>惨不惨，是真的惨！自幼才华横溢、家世显赫、高中状元、进士极第，一次事件中就被扫到祖国边疆终身不许离开一直到老。</p>
<p>如果这都不算难的话，什么才是难！受此劫难后，安邦立国、指点江山不可能了，他把余生投入到读书写作中。《明史》记载杨慎的 “明世记诵之博，著作之富，推慎为第一。詩文外，雜著至一百余種，并行于世。” </p>
<p>下面《三国演义》第一回的开篇词就是出自杨慎大才子的《临江仙》：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">滚滚长江东逝水，浪花淘尽英雄。是非成败转头空，青山依旧在，几度夕阳红。</span><br><span class="line">白发渔樵江渚上，惯看秋月春风。一壶浊酒喜相逢，古今多少事，都付笑谈中。</span><br></pre></td></tr></table></figure>



<p>嗯，至于杨慎落难时如何熬过去的，只有他知道。。。</p>
<h2 id="三"><a href="#三" class="headerlink" title="三"></a>三</h2><p>“历史记下来的都是有本事的人，大部分都是不普通人，有什么可比的！”</p>
<p>你能说这话不对吗？不能，那接着聊聊身边的事。</p>
<p>老梁有个朋友，在前两年工作中遇到点难处，工作和生活的双重压力下抑郁了！按照他的说法是根本没法写代码了，严重时连续10多天晚上不能入眠，想死的心都有了！此时安慰都是苍白的。</p>
<p>能咋办，只好离职先休养一段时间。此后很长一段时间没了他的消息。再联系时是他看房子的时候，联系同事们看看周围的配套。老梁见他时也蛮惊讶的，小子阔达了很多，谈笑风生！</p>
<p>房子买好后请以前处的不错的同事们吃饭，大家都替他高兴，听他讲起那段往事时，感觉是别人的事。</p>
<p>嗯，困难就是这样，熬过去就会让你更阔达！当初经历时的痛苦，谁又能体会的到呢？</p>
<p>谁的苦谁受，谁的福谁享。</p>
<p>该来的总会来，该怕的依然怕，只是有勇气面对了！</p>
<p>下面是老梁长白头发时琢磨的一首打油诗，你品品有没有点老酒的味道：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	《十年回首》 作者：老梁						</span><br><span class="line"></span><br><span class="line">十年奋斗总成空，半世浮华在梦中。</span><br><span class="line"></span><br><span class="line">莫愁前路无机遇，病树前头万木春。</span><br></pre></td></tr></table></figure>



<p>生活岂能事事如意！正所谓大有大的难，小有小的困惑，各有各的难。</p>
<p>熬过去就是佳酿！</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>思考随记</category>
      </categories>
      <tags>
        <tag>思考随记</tag>
      </tags>
  </entry>
  <entry>
    <title>SK4# 让心静下来</title>
    <url>/posts/43fa99ab/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>大家好，我是老梁，一个想跟大伙分享点干货的家伙。</p>
<p>今天周末，晚上喝了点鸡尾酒，又到了一周中最放松的时候，咱接着聊聊天。</p>
<p>上周文章《苍天绕过谁》，一个读者朋友看了发微信给老梁，问我那朋友怎么走出来的，他最近想太多，有些睡眠障碍。</p>
<p>写着写着咋感觉有点像苦情文了，好在有读者朋友说虽然不是技术文章，但他受益匪浅。</p>
<p>嗯嗯，有些帮助就好，老梁想着文章能有点思考、有点故事。</p>
<p>除了积累点技术外，也积累些生活思考，在小故事中的一点思考。</p>
<p>如何度过困难期呢？困难千千万万，每个人都不同？困难有大有小，多大的事算困难？</p>
<p>这事老梁其实也不知道，可不是么？帮人度苦度难那是菩萨的事情呀。。。</p>
<p>把天聊死了，还能聊不？老梁想了想，让我给讲两个故事吧。。。</p>
<a id="more"></a>



<h1 id="一"><a href="#一" class="headerlink" title="一"></a>一</h1><p>杨博，今湖北石首市人。27岁考了全省第一（解元），28岁中进士，考了全国第21名（二甲18名）。</p>
<p>授予翰林院编修，翰林院之前说过，这个地方是宰相培训班，帝国栋梁的摇篮。</p>
<p>永乐初年改授洗马，洗马是官职，可以理解为幕僚，跟着太子朱高炽混，这份工作很有前途，太子未来的皇帝。</p>
<p>嗯，看到了吧，管自己能干也不行，还得跟着赏识你的老板才行！</p>
<p>明永乐十二年（1414年），瓦刺（蒙古族）逐渐发展壮大，经常冒犯大明边界。</p>
<p>永乐大帝朱棣决定御驾亲征，率领50万大军远征，令太子朱高炽监国。</p>
<p>朱棣是个厉害的皇帝，上马能打仗，下马能治国，全能型的。</p>
<p>这次出征朱棣打赢了，瓦刺受到重创，被打怕了，以后多年不敢犯边。</p>
<p>班师凯旋，太子朱高炽迎驾慢了点。朱棣大怒，迁怒太子，把太子的随从都扔进了诏狱。</p>
<p>就因为迎驾慢了点就这么玩？也太搞了吧。。。明面是迎驾慢，其实是有人进了谗言诋毁太子。</p>
<p>毕竟想当太子的还有朱高炽的弟弟朱高煦。总之诋毁起了作用，太子势力被打压。</p>
<p>很不幸杨博也被关进了诏狱。。。这一关就是10年啊，这年杨博42岁，出来都52岁了。</p>
<p>诏狱就是皇上下诏要关的人，这里没皇上说话基本这辈子算是交代了。</p>
<p>诏狱刑法非常残酷，上夹棍、剥皮、舌、断脊、堕指、刺心、琵琶等几十种。用这种东西招呼人，生不如死。不是怀疑人生的问题，是后悔生出来。</p>
<p>人生能有几个十年，一般在里面呆这么久基本算是废了。杨博就这么进去了，想送钱捞人不不知道送给谁。</p>
<p>皇帝下的旨，难不成给皇帝送礼去？那地方过了今天不知道能不能熬过明天。</p>
<p>很多跟杨博一起进去的忍受不了这份煎熬，死在了里面。</p>
<p>好在杨博没受大的刑法，家里没能力给皇上送钱，给看监狱的送还是可以的，家里送了很多书给杨博。</p>
<p>反正也出不去，也不知道哪天就没命了，索性不想了。</p>
<p>能读一天是一天吧，杨博把所有的精力和时间全部投入到读书之中。</p>
<p>读啥书呢？各类经史子集书籍。</p>
<p>在杨博45岁那边，太子朱高炽的地位总算是稳固了，他弟弟被赶到山东惠民县就藩汉王。朱棣也没再为难杨博，但是一直关着直到朱棣去世，太子朱高炽继位才被放出来。</p>
<p>毕竟因为太子才坐了十年的牢，朱高炽非常怜惜杨博。为了报答，一路重用高升，历经三朝最终官至内阁首辅、武英殿大学士。</p>
<p>经历了十年牢灾的杨博，为人宽静、大家有争议时都能平心处之、大家都佩服。</p>
<p>看到了吧，为人宽静、平心处之！这份豁达与蹲了十年监狱不无关系。</p>
<p>坐牢还坐出好来了，所以有时候经历点挫折也不是坏事。</p>
<h1 id="二"><a href="#二" class="headerlink" title="二"></a>二</h1><p>她18岁考入上海交通大学，2000年毕业获得学士学位。赴挪威奥斯陆大学留学，获得硕士学位、复旦大学博士。后在复旦大学留校任教。</p>
<p>这一轮下来参加工作要2008年了，交大、海归、博士哪一个不是那么靓丽，太优秀了。</p>
<p>她于2000年结婚，期间忙于学业奔波，直到2008年9月才生了孩子。</p>
<p>幸福的生活才刚刚开启，2009年十二月一场剧痛，去医院检查被告知为乳腺癌晚期，已经扩散转移！</p>
<p>医生断言，最多存活两年。。。</p>
<p>哎，天地不仁以万物为刍狗。</p>
<p>她只好放下一切，去医院接受治疗。她把自己的生病期间的痛苦、见闻写在了自己的博客。</p>
<p>她叫于娟，生于1978年，2011年4月19日在上海去世，享年33岁。</p>
<p>住院期间她写了70篇的癌症日记，去世后家人好友整理出版《此生未完成》。</p>
<p>这是老梁多年前读过的一本书，这段老梁也有点不想写，她真是太苦了，再次翻开还是太震撼了，震撼到老梁有点受不了。</p>
<p>一次次被她的乐观、坚强、挣扎、无奈、善良、幽默感动！</p>
<p>她太热爱生活了，就是想活下去，陪着孩子一天天长大。。。</p>
<p>”在生死临界点的时候，你会发现，任何的加班（长期熬夜等于慢性自杀），给自己太多的压力，买房买车的需求，这些都是浮云。如果有时间，好好陪陪你的孩子，把买车的钱给父母亲买双鞋子，不要拼命去换什么大房子，和相爱的人在一起，蜗居也温暖。“</p>
<p>”三十岁之前的努力更多是因为自己有着太多的欲望和执著，从没有“只要活着就好”的简单。我不是高僧，若不是这病患，自然放不下尘世。这场癌症却让我不得不放下一切。如此一来，索性简单了，索性真的很容易快乐。若天有定数，我过好我的每一天就是。若天不绝我，那么癌症却真是个警钟：我何苦像之前的三十年那样辛勤地做蚍蜉。名利权情，没有一样是不辛苦的，却没有一样可以带去。“</p>
<p>”生不如死、九死一生、死里逃生、生生死死后，我突然觉得，一生轻松。不想去控制大局小局，不想去多管闲事，我不再有对手，</p>
<p>不再有敌人，我也不关心。“</p>
<p>”透过生死，你会觉得名利权情都很虚无，尤其是首当其冲的名，说穿了，无非是别人茶余饭后的谈资。即便你名声四海皆知响彻云天，也无非是一时猎奇，各种各样的人揣着各种各样的心态唾沫四溅过后，你仍然是你，其实，你一直是你，只是别人在谈论你的时候，你忘记了你自己是谁而已。“</p>
<p>”我甚至想，哪怕就让我那般痛，痛得不能动，每日像个瘫痪的人，污衣垢面趴在国泰路和政立路的十字路口上，任千人唾骂万人践踏，只要能看着爸妈牵着土豆的手蹦蹦跳跳去幼儿园上学，我也是愿意的。“</p>
<p>…</p>
<p>于娟会是一直感动着我的人，每次读她的《此生未完成》情不自禁饱含着泪水。</p>
<h1 id="三"><a href="#三" class="headerlink" title="三"></a>三</h1><p>写在后面的话。。。</p>
<p>杨博坐牢那十年，旦夕不保的日子是怎么熬过的呢？</p>
<p>答：杨博的方式是读书！</p>
<p>于娟在经历癌症痛苦，病痛折磨是如何熬过的呢？</p>
<p>答：于娟的方式是写博客！把她患病以来的所见、所闻、所思写出来，希望能帮助更多的人！她说：“我做不了什么了，能做的只有无畏施了。”</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>思考随记</category>
      </categories>
      <tags>
        <tag>思考随记</tag>
      </tags>
  </entry>
  <entry>
    <title>SK5# 丢掉幻想准备战斗</title>
    <url>/posts/48a2a5be/</url>
    <content><![CDATA[<div id="vip-container"><p>大家好，我是老梁，一个想跟大伙分享点干货的家伙。</p>
<p>明天请假办点事，夜神人静了，喝了点白开水，到了一周中最放松的时候，老梁确放松不起来。</p>
<p>丢掉幻想，准备战斗！这句常见于官方辞令，老梁觉得用到个人身上也不违和，朗朗上口的，那就拿来用用。</p>
<p>那就最近也发生的事情和想法聊一下。不一定对，各位随便看看。</p>
<a id="more"></a>



<h1 id="一"><a href="#一" class="headerlink" title="一"></a>一</h1><h3 id="习惯"><a href="#习惯" class="headerlink" title="习惯"></a>习惯</h3><p>从面试入职到现在一直在同一个领导手下做事。</p>
<p>慢慢的习惯了领导的风格，你会钦佩和欣赏他魅力和亮点。</p>
<p>比如老梁的领导，分析问题和事情总能让你感觉到总览全局和提纲挈领！总能从不同的角度对你的事情提出问题和思考点。</p>
<p>所以老梁做事情时的一些新想法喜欢征求下他的意见，让他把把关，指点指点。</p>
<p>你说让领导去下水解决具体问题是不现实的，但是能指出问题可能出现的方向，这是洞察力。</p>
<p>你说让领导去写代码攻克一些难点也是不现实的，但是能指出你和业界的差距，这是引领能力。</p>
<p>在一个领导下做长了，你会习惯了他的存在，是你工作的一部分。</p>
<p>你干成的一件件事情，再看看钉钉支持群里人数，基本是公司使用最广的几块。这都离不开领导的支持。</p>
<p>“别人不怎么说话，不代表孤僻，他可能很早就知道自己想要什么，不想去凑那个热闹！” 我们的领导就是这样的。</p>
<p>“领导，明天请天假，去趟**办点事”，老梁要请假。</p>
<p>”你跟**说哦“，领导回复说。</p>
<p>是的，我们换领导了，老领导公司另有安排！</p>
<p>老梁心里莫名的惆怅……</p>
<!--more-->



<h1 id="二"><a href="#二" class="headerlink" title="二"></a>二</h1><h3 id="稳定"><a href="#稳定" class="headerlink" title="稳定"></a>稳定</h3><p>老梁的第一份公司是在一家央企做软件开发，做的是煤炭行业的软件。</p>
<p>需要跟客户沟通需求经常去出差，出差的地方都是国企，所以对在这些地方工作的人有点了解。</p>
<p>那会老梁还在北京去秦皇岛出差，那里客户的员工，都是干一个月休息一个月，一年拿12个月干6个月的活，还保吃包住。</p>
<p>早上10点溜溜达达上班，录一些数据之类的，做做核对，一晃11点半就去吃饭了，下午5点都下班了。</p>
<p>当时老梁就想真舒服呀，而且待遇在当地算高的了。</p>
<p>那年在秦皇岛出差长达3个多月，老梁交点生活费也在他们食堂吃，吃完了也跟着他们出去走走。</p>
<p>听他们聊聊天，聊的无非是领导不关心员工，就想着自己啥的。谁干的活少拿的多不公平，谁是拖关系进来的，尽这些东西。</p>
<p>我发现他们事情虽然不多，但是经常抱怨。</p>
<p>同时也缺少成长和上升空间，待遇也常年稳定，里面很多人过的并不开心，也就是心累。</p>
<p>所以，干的事情少不一定就很开心，你995工作干的事情多未必没有成就感。</p>
<h1 id="三"><a href="#三" class="headerlink" title="三"></a>三</h1><h3 id="初衷"><a href="#初衷" class="headerlink" title="初衷"></a>初衷</h3><p>老梁有个朋友最近准备换工作，已经找好了新东家准备入职了。</p>
<p>以前跟老梁一起码代码的时候，有天下午跟老梁说准备离职了，去一家大厂。</p>
<p>问了下去了干啥，说没谈具体的东西，去了再看。</p>
<p>老梁就有疑问，如果咱积累的东西新东家用不上，不是慢慢就丢了吗？</p>
<p>毕竟我们是技术应用的，你不用就会丢。朋友说年纪慢慢大了，大厂平台大稳定。</p>
<p>当初去主要考虑的是稳定，那如今为啥离职呢？</p>
<p>朋友说，没发展，领导规划能力不行，甚至都没规划。</p>
<p>老梁知道他初衷变了，当初想的多的是稳定，但是他是想干点事的，坐不住的。</p>
<h1 id="四"><a href="#四" class="headerlink" title="四"></a>四</h1><p>你习惯了的领导会变！你认为的国企稳定可能心累、待遇多年不变！你认为的初衷也可能会变！</p>
<p>物质决定意识，物质是不断变化，意识想法也是变化的。</p>
<p>追求体制的稳定，不如追求工作学习的成就感！</p>
<p>在公司做成的一件件事就是你的成就感、在做事的过程中不断积累。</p>
<p>丢掉幻想，准备战斗！</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>思考随记</category>
      </categories>
      <tags>
        <tag>思考随记</tag>
      </tags>
  </entry>
  <entry>
    <title>SK6# 上海居转户随记</title>
    <url>/posts/a540a8f2/</url>
    <content><![CDATA[<div id="vip-container"><p>大家好，我是老梁，一个想跟大伙分享点干货的家伙。</p>
<p>到了一周中最放松的时刻，回来就10点多了，洗洗涮涮就到了11点了。</p>
<p>夜神人静了，喝了点碧螺春，老梁坐在沙发上抱着电脑跟大伙聊聊天。</p>
<p>今天聊聊居转户，申请过程中也是各种查询挺费劲，记录下或许对一些朋友有点用。</p>
<a id="more"></a>



<h1 id="一"><a href="#一" class="headerlink" title="一"></a>一</h1><h3 id="矛盾"><a href="#矛盾" class="headerlink" title="矛盾"></a>矛盾</h3><p>大大说我国社会主要矛盾是人民日益增长的美好生活需要和不平衡不充分的发展之间的矛盾。</p>
<p>这是大大对当前社会主要矛盾的把脉，你想想是不是。</p>
<p>对美好生活的需要，老梁的理解是上海比老家好，好在哪里呢？</p>
<p>机会多、薪水高、公共资源、营商生活环境、自然生态绿化等好太多，如果不是这些你来大城市干啥呢？</p>
<p>也就是上海比老家是一个拥有美好生活的地方。</p>
<p>接着看不平衡不充分，也就是有些地方是发展不充分的，而有些地方是发展充分的。</p>
<p>那连起来就是上海比老家是发展充分的，是大伙所向往的美好生活的地方。</p>
<p>作为普通个人，你要不努力去拥有美好生活的地方生活，要不等老家发展成你所期望的样子。</p>
<p>等还是挪，是个问题。人挪活，树挪死，自个选。</p>
<h1 id="二"><a href="#二" class="headerlink" title="二"></a>二</h1><h3 id="抓手"><a href="#抓手" class="headerlink" title="抓手"></a>抓手</h3><p>美好生活的地方大伙都想去，资源是有限的，对于城市管理者来说治理就是一个问题。</p>
<p>户籍以及积分就成为城市管理者的治理人口的抓手，公共资源的调配通过他们来治理。</p>
<p>什么时候这个抓手不用了呢？</p>
<p>老梁的理解是发展充分了，发展平衡了就不需要了。</p>
<p>你老家也跟上海发展的差不多了就没必要了，都美好了，在哪里都一样。</p>
<p>在你老家没变成上海之前，还是要争取成为新上海人民。</p>
<p>居转户给普通打工人开的一扇窗户，我们要做的是抱紧它，努力符合它的要求。</p>
<p>有不同意见可能被现实揍的还不够，不要跟老梁争，一争那肯定是你赢了。</p>
<!--more-->



<h1 id="三"><a href="#三" class="headerlink" title="三"></a>三</h1><h3 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h3><p>提前打听申请需要的资料，跟HR要个资料的最新列表，早做准备。</p>
<p>尽早办理居住证和积分，满足条件尽快提交申请。</p>
<p>合法合规缴纳社保和个税。</p>
<p>准备好上海之前的最后一家公司离职证明，国企央企的每家都要。</p>
<p>勤跑腿，当人才市场老师有反馈时，不清楚的自己去跑人才市场询问。</p>
<p>别总指着HR小姐姐，别人很忙的，为你的事单独一趟一趟的跑怎么可能，自己去跑去问。</p>
<p>遇到问题，比如不能开具离职证明等任何问题，去人才市场排队询问，礼貌向人才老师请教解决或者替代方法。</p>
<p>下载上海人社APP、随申办市民云两个都是查看居转户状态和反馈信息的。</p>
<h1 id="四"><a href="#四" class="headerlink" title="四"></a>四</h1><h3 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h3><p>下面状态截图均为上海人社APP中落户状态查询。</p>
<p><strong>1.2020年10月21</strong> </p>
<p>   找人事同学提交居转户申请，办理状态：“已受理，等待初审”。</p>
<p><strong>2.2020年11月04日</strong> </p>
<p>  办理状态 ：“请补充相关资料”。</p>
<p>  反馈有资料填错了，按人才老师要求修改就好了。</p>
<p>   <img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210313001045.png"></p>
<p><strong>3.2020年11月15日</strong> </p>
<p>办理状态：“预受理通过，等待档案核实”。</p>
<p>此时档案在外地的需要调档案了。人才市场会出调档函PDF格式，打印出来和你的身份证复印件去档案所在地办理即可，这个可以找人代办。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210313080336.png"></p>
<p><strong>4.2020年12月02日</strong> </p>
<p>通过“随申办市民云” 查询到档案已经到上海了。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210313001903.png"></p>
<p><strong>5.2020年12月11日</strong> </p>
<p>办理状态：“请补充相关资料、修改相关表格”。</p>
<p>反馈需要修改工作衔接日期，按照老师的要求去修改就好。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210313002151.png"></p>
<p><strong>6.2020年12月17日</strong> </p>
<p>办理状态：“您的材料网上受理已通过，请及时到相应受理点提交材料”</p>
<p>把纸质版的资料给HR小姐姐送过去，她会帮你交给人才市场。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210313002259.png"></p>
<p><strong>6.2020年12月28日</strong> </p>
<p>办理状态：“已受理，等待初审”。</p>
<p>此时你提交的材料才算是正式受理，之前都算是在补材料。审批权限在区人才。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210313002442.png"></p>
<p><strong>7.2021年01月13日</strong> </p>
<p>办理状态：“初审通过，等待复核”。</p>
<p>此时审批权限在区社保，审批通过后资料会提交到市里审批。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210313002603.png"></p>
<p><strong>8.2021年02月04日</strong> </p>
<p>办理状态：“复核通过，等待审核”。</p>
<p>此时审批权限在市人才，据说此时也非常关键，有被打回去的情况。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210313002752.png"></p>
<p><strong>9.2021年02月05日</strong> </p>
<p>办理状态：“审核中”。</p>
<p>此时审批权限在市人保。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210313002848.png"></p>
<p><strong>10.2021年02月09日</strong> </p>
<p>办理状态：“公式中”。</p>
<p>公示7天。2021年开始一个月公示2次，月中和月末各一次。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210313002922.png"></p>
<p><strong>11.2021年02月16日</strong> </p>
<p>办理状态：“公示通过，流程结束”。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210313080155.png"></p>
<p><strong>12.2021年02月19日</strong> </p>
<p>此时居转户审批流程告一段落，开始迁户口了。</p>
<p>关注”上海公安人口管理”微信公众号，便民服务-落户审批查询，查到自己名字就可以去迁入派出所办理了。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210313003352.png"></p>
<p><strong>13.2021年02月20日</strong> </p>
<p>去派出所办理《准迁入证明》。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210313080109.png"></p>
<p><strong>14.2021年02月22日</strong> </p>
<p>回老家或者代办《户口迁移证》。</p>
<p>这个注意一下，有的外地派出所迁出原因中没有居转户，这个最好问下要迁入的派出所。</p>
<p>有的填其他、有的填积分落户、还有填别的，五花八门。总之，上海派出所让填啥就填啥。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210313003704.png"></p>
<p><strong>15.2021年02月26日</strong> </p>
<p>带着《户口迁移证》去派出所办理户口和身份证，身份证5个工作日邮寄。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210313004048.png"></p>
<p><strong>16.2021年03月05日</strong> </p>
<p>去社区服务中心办理《就业创业证》（以前叫劳动手册），然后交给公司HR。</p>
<p>2张2寸照片、身份证+户口本、最高学历证书、存档证明。</p>
<p>存档证明可以从网站打印。<a href="http://weixin.shrc.com.cn:8080/rcdasb/login.jsp">http://weixin.shrc.com.cn:8080/rcdasb/login.jsp</a></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/16%E5%B0%B1%E4%B8%9A%E5%88%9B%E4%B8%9A%E8%AF%813%E6%9C%885%E6%97%A5.jpg"></p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>思考随记</category>
      </categories>
      <tags>
        <tag>思考随记</tag>
      </tags>
  </entry>
  <entry>
    <title>SK7# 大咖分享随记</title>
    <url>/posts/cf517bd1/</url>
    <content><![CDATA[<div id="vip-container"><p>大家好，我是老梁，一个想跟大伙分享点干货的家伙。</p>
<p>到了一周中最放松的时刻，老梁回到家，家人往往都睡了。</p>
<p>老梁就找点吃的喝的，今天喝了大半罐RIO强爽8°C白桃酒，有点晕晕乎乎的。</p>
<p>老梁坐在沙发上抱着电脑跟大伙聊聊天，今天聊点啥呢？</p>
<p>前些天公司请了头部公司研究员大咖来分享，大领导口干舌燥费了好大劲请来的。</p>
<p>大咖抽出宝贵的时间来分享，听的人不少，听进去的不多，听了去实践就更少了，大部分过几天就忘的差不多了。</p>
<p>这种情况领导们也知道，才要求组织者们去收集启发感受，沉淀下来点东西。</p>
<p>老梁也被拉进去要求写一篇，组织者说已经跟领导吹出去了，不写凑不够数量。</p>
<p>大咖分享的是质量和效能，下面是老梁瞎想的，不一点对，各位随便看看。</p>
<a id="more"></a>



<h1 id="一"><a href="#一" class="headerlink" title="一"></a>一</h1><h3 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h3><p>你见到大咖给你秀专利、秀高深的技术、秀什么时髦的方法论了吗？这些都没有。</p>
<p>有没有感觉听大咖们分享，有点在上哲学课的感觉，跟你分享他们的思考总结、事物的辩证关系。</p>
<p>为什么他们喜欢讲这些呢？这玩意又不能立竿见影解决你遇到的问题，难道是忽悠咱吗？</p>
<p>他们是真诚的，这些的确是他们长期经常思考的，提炼了告诉咱。</p>
<p>上来第一句 ”大家有没有想过质量和效能关系？“</p>
<p>大咖举了例子：自行车是骑得慢容易倒还是骑得快容易倒？</p>
<p>告诉你他对质量和效能的理解：”不是平衡关系、是相辅相成、互相促进的关系“。</p>
<p>上来第二句 ”测试其实就一直回答一个问题，啥问题呢？这个东西是不是好的？“</p>
<p>大咖们类似的思考还有很多，记得去年的QCon全球软件开发大会居然有一个专题分享价值观的，来讲的不是公司CEO就是CTO。</p>
<p>大咖们把自己思考和提炼告诉我们有啥指导意义呢？</p>
<p>拿着这些立即去指导实践又太远？但是他们苦苦思索提炼告诉我们意义在哪里呢？</p>
<p>老梁觉得这些往往是事务发展的底层原理、核心内核。</p>
<p>嗯，我们也可以多思考总结，没准哪天也能开悟，这事谁说得准呢？</p>
<!--more-->



<h1 id="二"><a href="#二" class="headerlink" title="二"></a>二</h1><h3 id="套路"><a href="#套路" class="headerlink" title="套路"></a>套路</h3><p>大咖工作20多年来，几乎一直在从事质量&amp;效能相关领域。</p>
<p>在长期的实战中必然总结了自己的一套打法，老梁就叫他套路吧。</p>
<p>套路用在战场叫阵法，戚继光在抗击倭寇实战中创立的鸳鸯阵，耳熟能详的游击战法，敌进我退，敌驻我扰，敌疲我打，敌退我追。</p>
<p>公司花大价钱请的高管看重往往是其治理公司的经验与其背后链接的资源。他们有自己的套路整合公司内外资源，带领公司发展壮大。</p>
<p>大咖分享了几个他喜欢的套路：代码门禁、代码门禁的最佳时机选择、先去治理稳定性和时长（减少噪音、最后搞覆盖率）、持续集成、自动化测试、多环境隔离、自动化造数据能力等。</p>
<p>这些套路值得相关领域的同学去认真研究的，发展成满足公司实际情况的有效措施。</p>
<p>在领导交给你的领域，多关注业界头部公司的玩法和套路，这些经验能否为我所用，充实我们的套路库。</p>
<p>嗯，套路是可以学的，能在实践中用起来的。</p>
<h1 id="三"><a href="#三" class="headerlink" title="三"></a>三</h1><h3 id="防患"><a href="#防患" class="headerlink" title="防患"></a>防患</h3><p>我们都听过扁鹊三兄弟的故事，一起重温下。</p>
<p>魏文侯问扁鹊：“ 我听说你们家兄弟三人都学医，那么谁的医术最高？”</p>
<p>扁鹊说：“大哥医术最高，二哥其次，我最差。”</p>
<p>“那为什么只有你名动天下，他们两个一点名气都没有？” 魏文侯问。</p>
<p>“我大哥的医术之高在于防患于未然，一个人的病未起之时，他一望气色便知，然后用药将其调理好，所以天下人都以为他不会治病，他便一点名气都没有”。</p>
<p>“我二哥的能耐，是能治病初起之时，防止别人酿成大病。病人刚开始感冒咳嗽时，他就用药将人治好了，所以我二哥的名气仅止于乡里，被人认为是治小病的医生。”</p>
<p>“我呢，就因为医术最差。所以一定要等到这个人病入膏肓、奄奄一息，然后下虎狼之药，起死回生。这样，全世界便都以为我是神医。想想看，像我大哥这样治病，人的元气丝毫不伤，我二哥治病，这个人元气稍有破损就补回来了，像我这么治病呢，命是救回来了，可元气大伤，您说，我们家谁医术最高明？”</p>
<p>做底层后端的同学是不是有点同感呢？你负责基础设施平稳运行时是默默无闻的，当听到你时往往是出现了故障。</p>
<p>从0到1的新东西是必须的，这是增量！已有的存量东西也要重视，事故的发生不分新旧。</p>
<p>在疫情期间，我们常常听到高层的指示 “毫不放松抓紧抓实抓细防控工作” 。</p>
<p>接着看看大咖在防患的警示：“功夫花在平时”。</p>
<p>“故障多修复不及时”、“忽略时好时不好的用例”、“信息被海量告警淹没” 等，这些都是平时的小问题。</p>
<p>嗯，我们要做的是坚持改进平时的一件件小事，把他们落实到实处。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>思考随记</category>
      </categories>
      <tags>
        <tag>思考随记</tag>
      </tags>
  </entry>
  <entry>
    <title>SK8# 过一种笃定的生活</title>
    <url>/posts/3266629d/</url>
    <content><![CDATA[<div id="vip-container"><p>大家好，我是老梁，一个想分享点干货的家伙。</p>
<p>喝了一杯菊花枸杞决明子茶，这茶喝起来没啥味道，据说有清肝明目功效。</p>
<p>老梁坐电脑前跟大伙聊聊天，各位随便看看。</p>
<h1 id="一"><a href="#一" class="headerlink" title="一"></a>一</h1><h3 id="咳嗽"><a href="#咳嗽" class="headerlink" title="咳嗽"></a>咳嗽</h3><p>咋不喝鸡尾酒了呢？</p>
<p>前段时间咳嗽跑到三甲医院挂了专家号，专家开了一个多月药，叮嘱说把他开的要都吃光。</p>
<p>专家说的话，能不听吗？老梁就天天吃，吃了一个多月终于都给吃光了。</p>
<p>药吃光了，病没好，一吹风就咳两声。</p>
<p>是药不管用还是药不对病呢？还是身体不行了？</p>
<p>身体也不至于呀！</p>
<p>老梁虽然平时没时间锻炼，但每天基本能走1万步以上。</p>
<p>每周六周天各跑3.5公里，一周也有7公里了。</p>
<p>总之，咳嗽没好。</p>
<p>旧的没好新的又开始了，扁桃体又开始发炎，咳嗽前兆！</p>
<p>跑到大药房，卖药的小姑娘，说让喝点蒲公英颗粒。</p>
<p>老梁买了四天的，喝了三天，扁桃体发炎好了，咳嗽也好了。</p>
<p>得谢谢小姑娘这药，比三甲医院的专家开的管用。</p>
<p>嗯，一个小咳嗽就能折腾你两月，天道有常，多一分敬畏。</p>
<a id="more"></a>



<h1 id="二"><a href="#二" class="headerlink" title="二"></a>二</h1><h3 id="访谈"><a href="#访谈" class="headerlink" title="访谈"></a>访谈</h3><p>老梁属于陈晓楠的多年粉丝了，从以前的《冷暖人生》就经常看，多好的节目停办了挺可惜。</p>
<p>她在腾讯开了个栏目《我的青铜时代》，有一期采访了罗翔，有一段罗翔的思考总结，摘出来看看。</p>
<p>陈晓楠：您现在和未来有什么终极的目标或者梦想吗？</p>
<p>罗翔：过好每一天，演好当下的剧本，朝着心中那个标杆前进。</p>
<p>陈晓楠：每一天都过得踏实。</p>
<p>罗翔：对，人要做到：不清高、不矫情、不抱怨。</p>
<p>….</p>
<p>陈晓楠：可能越来越多的年轻人在非常大的竞争中面临这样的困惑，我得赢。</p>
<p>我需要找到非常多的可以赢的办法，以前老说的我要忠于我自己，现在我要妥协很多事情，我要避免被淘汰。</p>
<p>你会怎么跟学生说这些事情？</p>
<p>罗翔：那就是如何过看起来好的一生，那就要去定义了，什么叫好？</p>
<p>这个世界上有太多有关好的标准了。</p>
<p>good加个s就成了goods就成了商品，所以做一切事情最重要就是挣钱嘛。</p>
<p>什么叫好医生，赚钱就是好医生。</p>
<p>什么是好老师，赚钱就是好老师。</p>
<p>什么是好记者，赚钱就是好记者。</p>
<p>那这样做一切职业分工没有意义了啊。</p>
<p>你要寻找什么叫good，你才能去过good的一生。</p>
<p>你才可以避免去随波逐流，你才内心会拥有一种笃定。</p>
<p>你才会拒绝跟别人去攀比，也拒绝被别人所攀比。</p>
<p>嗯，内心拥有一种笃定，每一天都过得踏实。</p>
<h1 id="三"><a href="#三" class="headerlink" title="三"></a>三</h1><h3 id="佛理"><a href="#佛理" class="headerlink" title="佛理"></a>佛理</h3><p>在王宝强电影《少林寺之德宝传奇》中有一小段，得宝的儿子有肉掉下悬崖摔死了。</p>
<p>德宝求和尚带他去找儿子，和尚说你把房子盖好就带你去。</p>
<p>德宝盖好就被和尚踹踏，在第十八遍盖好后，德宝和和尚的一段对话。</p>
<p>和尚：盖房子的时候你在想什么？</p>
<p>得宝：我在想有肉啊，我一想到儿子就一定要把房子盖好。</p>
<p>和尚：忘记儿子。</p>
<p>得宝：忘不掉啊。</p>
<p>和尚：那也得忘掉。</p>
<p>佛理就是：吃饭的时候吃饭，烧火的时候烧火，打架的时候打架，踹房子的时候踹房子。</p>
<p>发现了没，和尚的佛理和罗翔的思考是不是很相似？</p>
<p>认真做着每天中的一件件小事，向着心中的目标一点点前进。</p>
<p>笃定，安详镇定的意思。</p>
<p>生活亦修行，过一种笃定的生活。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>思考随记</category>
      </categories>
      <tags>
        <tag>思考随记</tag>
      </tags>
  </entry>
  <entry>
    <title>SK9# 公司的军规</title>
    <url>/posts/4951a8cc/</url>
    <content><![CDATA[<div id="vip-container"><p>大家好，我是老梁，一个想分享点干货的家伙。</p>
<p>最近天天喝花枸杞决明子茶，有用没用的权当白开水喝着。</p>
<p>老梁坐电脑前跟大伙聊聊天，聊聊公司军规，各位随便看看。</p>
<h1 id="一"><a href="#一" class="headerlink" title="一"></a>一</h1><h3 id="初期"><a href="#初期" class="headerlink" title="初期"></a>初期</h3><p>组织发展初期人不多物资也不丰富，人就这么点，要做的东西很多。</p>
<p>开发从前端到后端，从网关到存储，从公共组件到业务，最好都能顶上去干。</p>
<p>自然规矩也没那么多，很多时候自测上线的，线上有问题难避免。</p>
<p>生产环境有问题，上去干两把，直接替换包，先修复了再说。</p>
<p>没办法，就这点人，先充分调动大伙积极性先把事干了。</p>
<p>就像《亮剑》李云龙说的：</p>
<p>“我说旅长啊，我好歹也是堂堂正规军的团长，我不能连县大队都不如吧？”</p>
<p>“这不是砸咱们师的牌子嘛？你猜旅长怎么说？”</p>
<p>“旅长说，我有装备我要你干什么？你既然能当团长，就有能耐去搞枪，要不然你就回家抱孩子去！你别在这给我丢人显眼！”</p>
<p>“得鳓，我等的就是这句话！让我搞枪，没问题啊！可是你不能给我戴紧箍咒啊，对不对？”</p>
<p>“你总得给我点自主权吧，不能什么事都让你大旅长占了啊！又想让我搞枪，又想让我当乖孩子，这叫不讲理！ ”</p>
<p>就像改革开发初期，需要努力抓住发展机遇，避免无效争论。</p>
<p>需要先解决国家经济薄弱和老百姓普遍贫困问题。</p>
<p> “不管黑猫白猫，捉到老鼠就是好猫”。</p>
<p>回顾下《秦孝公的招贤令》：</p>
<p>“…诸侯卑秦，丑莫大焉…寡人思念先君之意，常痛于心”。</p>
<p>“宾客群臣有能出奇计强秦者，吾且尊官，与之分土”。</p>
<p>秦孝公要强秦之策，至于儒家、法家、道家哪家学说不重要。</p>
<p>嗯，发展初期的首要问题是抓住机遇发展壮大。</p>
<a id="more"></a>



<h1 id="二"><a href="#二" class="headerlink" title="二"></a>二</h1><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>随着组织规模的扩大，人员越来越多，问题也越来越多。</p>
<p>1927年毛主席领导秋收起义拉起的军队，这只部队成分复杂工人、农名、学生、土匪、军阀过来的士兵。</p>
<p>作战不听指挥，临阵脱逃，很多高级指挥官直接叛变投敌。</p>
<p>军官打骂士兵，随意拿老百姓的财物，随意打骂老百姓的现象比较普遍。</p>
<p>有的把筹来的钱物据为己有。</p>
<p>早些年的高速发展也带来很多问题。</p>
<p>腐败问题，小官巨贪屡见不鲜。</p>
<p>环境问题，就连北京还是APEC蓝。</p>
<p>一个小的bug影响几十万的用户。</p>
<p>业务的停摆还能冲上热搜。</p>
<p>嗯，危机倒闭改革，一个阶段有一个阶段的使命。</p>
<h1 id="三"><a href="#三" class="headerlink" title="三"></a>三</h1><h3 id="秩序"><a href="#秩序" class="headerlink" title="秩序"></a>秩序</h3><p>大户人家为了约束后世子孙，传承家业往往有家规、家训。    </p>
<p>你家就三口人需要这玩意吗？天天都在眼前晃，有问题直接说就完了。</p>
<p>很多人看过《乔家大院》都听说过乔致庸，看看他们家的《乔氏家规》。</p>
<p>”不准纳妾，不准赌博“</p>
<p>”不准嫖娼，不准吸毒“</p>
<p>”不准虐仆，不准酗酒“。</p>
<p>《乔致庸家训要言》</p>
<p>”求名求利莫求人需求己“</p>
<p>”惜衣惜实非惜财缘惜福“</p>
<p>1927年毛主席针对出现的问题，制定了《三大纪律 八项注意》：</p>
<p>”一切行动听指挥，不拿群众一针一线，一切缴获要归公“。</p>
<p>”说话和气，买卖公平，借东西要还，损坏东西要赔偿，不打人骂人，不损坏庄稼，不调戏妇女，不虐待俘虏“。</p>
<p>”老虎苍蝇一起打“、”绿水青山就是金山银山“，解决发展中的腐败问题、环境等问题。</p>
<p>找几个印象深的军规看看。</p>
<p>崇祯年间督师卢象升奉命率兵勤王，满清打进来了，出兵前给将士下军令：</p>
<p>“刀必见血，人必带伤，马必喘汗，违者斩。”</p>
<p>于谦北京保卫战的军战连坐法：</p>
<p>“凡守城将士，必英勇杀敌，战端一开，即为死战之时！</p>
<p>“临阵，将不顾军先退者，立斩！”</p>
<p>“临阵，军不顾将先退者，后队斩前队！“</p>
<p>“敢违军令者，格杀勿论！”</p>
<p>“大军开战之日，众将率军出城之后，立即关闭九门，有敢擅自放入城者立斩！”</p>
<p>蚂蚁内部的线上变更三板斧：可灰度、可监控、可回滚。</p>
<p>让敬畏生产、防患风险，避免生产事故。</p>
<p>嗯，组织大了，按秩序行事才会给组织带来最大收益。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>思考随记</category>
      </categories>
      <tags>
        <tag>思考随记</tag>
      </tags>
  </entry>
  <entry>
    <title>Sentinel20# 针对调用来源限流的分析</title>
    <url>/posts/27ee073a/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>当我们SOA的服务提供方S的某个资源（接口方法）想针不同的服务消费方（A与B）设置不同的限流阈值时，这时就需要用到针对调用来源的限流。那我们可以大规模去使用这种限流方式吗？</p>
<h1 id="内容提要"><a href="#内容提要" class="headerlink" title="内容提要"></a>内容提要</h1><p><strong>1.应用场景</strong> </p>
<p>示意图如下，针对A服务methodA1调用服务S的methodS1设置QPS限流300，针对B服务methodB1调用S服务的methodS1设置限流1000。也就是需要在S服务中对相同的资源（methodS1）针对不同的来源A与B设置不同的限流阈值。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/%E9%92%88%E5%AF%B9%E8%B0%83%E7%94%A8%E6%9D%A5%E6%BA%90%E9%99%90%E6%B5%81%E5%9C%BA%E6%99%AF.png"></p>
<p><strong>2.实现原理</strong> </p>
<ul>
<li><p>Sentinel在统计请求流量时会为每个调用来源构建统计信息（StatisticNode）</p>
</li>
<li><p>在请求通过时获取调用来源origin对应的统计信息判决请求是否放行</p>
</li>
</ul>
<p><strong>3.为什么不能大量使用针对调用来源的限流？</strong> </p>
<p>备注：由于需要为每个调用来源origin的资源建立统计信息StatisticNode，大量使用会造成内存占用过多。这点官方faq中也给出了警示。**“注意 origin 数量不能太多，否则会导致内存暴涨，并且目前不支持模式匹配。” ** </p>
<p>下面举例说明，下面的例子中针对来源限流是不针对来源限流内存占用的30倍。</p>
<p>不针对来源限流：S服务有15个对外提供的服务接口，如果不针对来源限流，只需要15个统计StatisticNode即可</p>
<p>针对来源限流：如果调用S服务的消费者有30个，那么需要统计的StatisticNode的数量=30 * 15 = 450个</p>
<p>在实际中如果支持了其实难以控制数量是否是太多的，所以这是一个权衡的过程。首先针对调用来源的限流这个场景是不是很普遍，如果只是偶尔出现，这个功能应该考虑被禁用。</p>
<a id="more"></a>



<h1 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h1><p><strong>注入规则</strong></p>
<p>注入同一个资源“consumer-source-test“针对不同来源AppId1、AppId2的两条规则。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;clusterMode&quot;: false,</span><br><span class="line">        &quot;controlBehavior&quot;: 0,</span><br><span class="line">        &quot;count&quot;: 20,</span><br><span class="line">        &quot;grade&quot;: 1,</span><br><span class="line">        &quot;limitApp&quot;: &quot;AppId1&quot;,</span><br><span class="line">        &quot;maxQueueingTimeMs&quot;: 500,</span><br><span class="line">        &quot;resource&quot;: &quot;consumer-source-test&quot;,</span><br><span class="line">        &quot;strategy&quot;: 0,</span><br><span class="line">        &quot;warmUpPeriodSec&quot;: 10</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;clusterMode&quot;: false,</span><br><span class="line">        &quot;controlBehavior&quot;: 0,</span><br><span class="line">        &quot;count&quot;: 40,</span><br><span class="line">        &quot;grade&quot;: 1,</span><br><span class="line">        &quot;limitApp&quot;: &quot;AppId2&quot;,</span><br><span class="line">        &quot;maxQueueingTimeMs&quot;: 500,</span><br><span class="line">        &quot;resource&quot;: &quot;consumer-source-test&quot;,</span><br><span class="line">        &quot;strategy&quot;: 0,</span><br><span class="line">        &quot;warmUpPeriodSec&quot;: 10</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<p><strong>限流日志</strong></p>
<p>针对AppId2的运行日志显示限流40，针对调用来源限流生效。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1619830979000|2021-05-01 09:02:59|consumer-source-test|42|1135|42|0|0|0|0|0</span><br><span class="line">1619830980000|2021-05-01 09:03:00|consumer-source-test|40|1152|40|0|0|0|0|0</span><br><span class="line">1619830981000|2021-05-01 09:03:01|consumer-source-test|42|1180|42|0|0|0|0|0</span><br><span class="line">1619830982000|2021-05-01 09:03:02|consumer-source-test|40|1172|40|0|0|0|0|0</span><br><span class="line">1619830983000|2021-05-01 09:03:03|consumer-source-test|40|1152|40|0|0|0|0|0</span><br><span class="line">1619830984000|2021-05-01 09:03:04|consumer-source-test|43|1159|43|0|0|0|0|0</span><br><span class="line">1619830985000|2021-05-01 09:03:05|consumer-source-test|41|1195|41|0|0|0|0|0</span><br><span class="line">1619830986000|2021-05-01 09:03:06|consumer-source-test|40|1160|40|0|0|0|0|0</span><br><span class="line">1619830987000|2021-05-01 09:03:07|consumer-source-test|40|1209|40|0|0|0|0|0</span><br><span class="line">1619830988000|2021-05-01 09:03:08|consumer-source-test|41|1159|41|0|0|0|0|0</span><br><span class="line">1619830989000|2021-05-01 09:03:09|consumer-source-test|40|1136|40|0|0|0|0|0</span><br></pre></td></tr></table></figure>





<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p><strong>针对调用来源构建统计信息</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210501082237.png"></p>
<p>为每个origin构建统计信息StatisticNode</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210430100704.png"></p>
<p><strong>请求通过时的校验</strong></p>
<p>当请求判断是否允许放行时，需要统计信息Node与规则阈值比较，此时获取的是origin的统计信息。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210501085359.png"></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210501085530.png"></p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>Sentinel</category>
      </categories>
      <tags>
        <tag>Sentinel</tag>
      </tags>
  </entry>
  <entry>
    <title>gRPC1# HTTP/2协议之连接前言</title>
    <url>/posts/75903813/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>HTTP/2在传输数据之前，先建立连接，<code>建立HTTP/2连接的标记为Client发送连接前言Magic</code>。HTTP/2属于应用层，位于TPC/IP及安全传输层协议TLS之上。在建立HTTP/2连接的过程中，会先后经历TCP握手、TLS握手、HTTP/2连接前言。下图网络分层图示：</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210225093219.png"></p>
<a id="more"></a>



<p><strong>TCP握手回顾</strong></p>
<p>回顾下TCP的三次握手，三次握手后TPC连接建立，具体步骤如下：<br>第一步：Client发送[SYN]报文到Server。Client进入SYN_SENT状态，等待Server响应。[SYN]报文序号Seq=x《备注：截图中Seq=0》<br>第二步：Server收到后发送[SYN,ACK]报文给Client，ACK为x+1(备注：截图中ACK=1); [SYN,ACK]报文序号为y(备注：截图中Seq=0),Server进入SYN_RECV状态<br>第三步：Client收到后，发送[ACK]报文到Server，包序号Seq=x+1，ACK=y+1。Server收到后Client/Server进入ESTABLISHED状态。</p>
<p><strong>TPC握手报文</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210225093303.png"></p>
<p><strong>TPC握手交互图</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210225093336.png"></p>
<h1 id="TLS握手简化回顾"><a href="#TLS握手简化回顾" class="headerlink" title="TLS握手简化回顾"></a>TLS握手简化回顾</h1><p>TLS传输层安全协议，主要回顾简化的交互过程：</p>
<p><strong>第一步</strong></p>
<p>Client向Server发送ClientHello，包括支持的协议版本、Client随机数、支持的加密算法等</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210225093415.png"></p>
<p><strong>第二步</strong> </p>
<p>Server向Client发送ServerHello，包括确认协议版本、Server随机数、确认加密算法、Server证书</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210225093515.png"></p>
<p><strong>第三步</strong></p>
<p>Server向Client发送证书，客户端校验证书有效性</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210225093556.png"></p>
<p><strong>第四步</strong></p>
<p>Client通知Server用协商的密钥进行通信</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210225093627.png"></p>
<p><strong>第五步</strong> </p>
<p>传输加密数据</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210225093654.png"></p>
<h1 id="建立HTTP-2连接前言"><a href="#建立HTTP-2连接前言" class="headerlink" title="建立HTTP/2连接前言"></a>建立HTTP/2连接前言</h1><p>在TLS之后，Client会向Server发送Magic标记着HTTP/2连接的建立，具体Magic为：PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n 详见下图：</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210225093730.png"></p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>gRPC</category>
      </categories>
      <tags>
        <tag>gRPC</tag>
      </tags>
  </entry>
  <entry>
    <title>gRPC2# HTTP/2协议之二进制桢</title>
    <url>/posts/bb87ad4/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>HTTP/2的报文是以二进制桢发送的。那桢格式、桢大小、桢类型是怎么样的？本文会整理桢的格式以及十种桢类型。</p>
<a id="more"></a>



<h1 id="桢格式"><a href="#桢格式" class="headerlink" title="桢格式"></a>桢格式</h1><p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210225094347.png"></p>
<h5 id="1-桢格式说明"><a href="#1-桢格式说明" class="headerlink" title="1.桢格式说明"></a>1.桢格式说明</h5><p>桢的格式由9个字节的桢头和桢数据Payload构成；桢头由3个字节的桢长度、1个字节的桢类型、1个字节的标志位、4个字节的流标识符（含1位R保留位）构成。</p>
<p><strong>桢长度</strong><br>桢长度由24位3个字节大小表示。取值在2^14(16,384)与2^24-1(16,777,215)之间；可在接收方SETTINGS_MAX_FRAME_SIZE设置。</p>
<p><strong>桢类型</strong><br>桢类型用8位1个字节表示，说明桢的格式和语义。具体桢的类型详见下文介绍。</p>
<p><strong>标志位</strong><br>标志位用8位1个字节表示。例如：END_HEADERS标志表示头数据传输结束；END_STREAM表示单方向数据传输结束。</p>
<p><strong>R</strong><br>R即1位保留字段，未定义，以0x0结尾。</p>
<p><strong>流标识符</strong><br>流标识符用31位表示，上限为2^31。接收方可以根据流标识ID进行组装，同一个Stream中内Frame必须是有序的，所以接受方根据流ID可以拼接成有序的流。另外：客户端发起的流用奇数表识；服务器发起的流用偶数标识。正因为使用了流标识，接收端可以将并发的Stream进行有序拼接，实现多路复用。</p>
<p><strong>桢数据</strong><br>传输的数据内容Payload由桢类型决定。</p>
<h5 id="2-Wireshark抓包截图"><a href="#2-Wireshark抓包截图" class="headerlink" title="2.Wireshark抓包截图"></a>2.Wireshark抓包截图</h5><p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210225094502.png"></p>
<h1 id="桢类型"><a href="#桢类型" class="headerlink" title="桢类型"></a>桢类型</h1><h6 id="1-DATA桢"><a href="#1-DATA桢" class="headerlink" title="1.DATA桢"></a>1.DATA桢</h6><p>数据桢主要存储HTTP/2数据报文，具体格式如下图：</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210225094537.png"></p>
<p><strong>字段含义</strong><br>Padding: 8位填充字节，填充字节可以改变DATA桢的大小，可以启到安全性功能<br>Pad Length: 填充字节的长度；PADDED标记为true时表明有填充字节<br>Data: 具体传输的数据</p>
<p><strong>Wireshark抓包截图</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210225094605.png"></p>
<h6 id="2-Header桢"><a href="#2-Header桢" class="headerlink" title="2.Header桢"></a>2.Header桢</h6><p>Header桢的结构如下图：</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210225094628.png"></p>
<p><strong>字段含义</strong><br>Pad Length：填充字节的长度，填充字节含义同上述Data桢<br>E：表识流是否为独占的。设置PRIORITY时才有值<br>Stream Dependency：该流的依赖流。设置PRIORITY时才有值<br>Weight：流优先级权重。设置PRIORITY时才有值<br>Header Block Fragment：Header块片段<br>Padding：填充的字节长度</p>
<p><strong>Wireshark抓包截图</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210225094649.png"></p>
<h6 id="3-PRIORITY帧"><a href="#3-PRIORITY帧" class="headerlink" title="3.PRIORITY帧"></a>3.PRIORITY帧</h6><p>发送流的优先级，格式如下，各字段含义与抓包截图见Header桢。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210225094710.png"></p>
<h6 id="4-RST-STREAM帧"><a href="#4-RST-STREAM帧" class="headerlink" title="4.RST_STREAM帧"></a>4.RST_STREAM帧</h6><p>当发生错误或者取消时，用于终止一个流。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210225094726.png"></p>
<p><strong>字段含义</strong><br>Error Code: 32位错误代码，指发生错误的原因。</p>
<p><strong>Wireshark抓包截图</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210225094750.png"></p>
<h6 id="5-SETTINGS帧"><a href="#5-SETTINGS帧" class="headerlink" title="5.SETTINGS帧"></a>5.SETTINGS帧</h6><p>用于传达连接端点之间的配置参数。<br>SETTINGS帧的标记ACK为0表示被对等的SETTINGS桢使用；ACK不为0时表示FRAME_SIZE_ERROR的连接错误。</p>
<p><strong>桢格式</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210225094817.png"></p>
<p><strong>Identifier参数含义</strong><br>SETTINGS_HEADER_TABLE_SIZE：通知接收方header解码表（解码header块）的最大尺寸<br>SETTINGS_ENABLE_PUSH：初始值1表示允许服务端推送，0表示不允许服务端推送<br>SETTINGS_MAX_CONCURRENT_STREAMS：最大的并发流数（发送者）<br>SETTINGS_INITIAL_WINDOW_SIZE：stream窗口大小，默认为65535<br>SETTINGS_MAX_FRAME_SIZE：桢负载大小<br>SETTINGS_MAX_HEADER_LIST_SIZE：Header列表的最大值</p>
<p><strong>Wireshark抓包截图</strong></p>
<p>![image-20210225094839960](/Users/yongliang/Library/Application Support/typora-user-images/image-20210225094839960.png)</p>
<p><strong>6.PUSH_PROMISE帧</strong></p>
<p>服务端向客户端推送的桢，客户端可以返回RST_STREAM拒绝。<br>图中R为保留位。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210225094901.png"></p>
<h6 id="7-PING帧"><a href="#7-PING帧" class="headerlink" title="7.PING帧"></a>7.PING帧</h6><p>心跳检测，测量发送往还时间，确定连接是否正常。<br>标记ACK为0即false表示为PING桢的响应（response）；1即True表示PING桢。</p>
<p><strong>桢格式</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210225094930.png"></p>
<p><strong>Wireshark抓包截图</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210225094951.png"></p>
<h6 id="8-GOAWAY帧"><a href="#8-GOAWAY帧" class="headerlink" title="8.GOAWAY帧"></a>8.GOAWAY帧</h6><p>用于关闭连接或者发出错误，允许停止接受新的流并完成前面的流处理。</p>
<p><strong>桢格式</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210225095017.png"></p>
<p><strong>Wireshark抓包截图</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210225095034.png"></p>
<p><strong>9.WINDOW_UPDATE帧</strong></p>
<p>用于连接和流的流量控制。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210225095054.png"></p>
<p><strong>Wireshark抓包截图</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210225095111.png"></p>
<h5 id="10-CONTINUATION"><a href="#10-CONTINUATION" class="headerlink" title="10.CONTINUATION"></a>10.CONTINUATION</h5><p>CONTINUATION一种持续桢用于继续传输Header头块片段。通常在Header块比较大，在HEADERS、PUSH_PROMISE、CONTINUATION桢之后继续传输。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210225095128.png"></p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>通过对二进制桢内容的整理和走查，对HTTP/2通信的各种桢不再陌生，根据桢的类型可以知道通信双方在做什么操作。欢迎跟作者互动、共同探讨。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>gRPC</category>
      </categories>
      <tags>
        <tag>gRPC</tag>
      </tags>
  </entry>
  <entry>
    <title>gRPC3# HTTP/2协议之头部压缩</title>
    <url>/posts/93361f73/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>为了报文传输更小、更快，在HTTP/2中Header头是经过压缩的，使用的压缩算法为HPACK。本文先通过Wireshark抓包截图直观感受下头部压缩效果，进而分析下这种压缩算法是如何工作的。 </p>
<a id="more"></a>



<h1 id="压缩效果对比"><a href="#压缩效果对比" class="headerlink" title="压缩效果对比"></a><strong>压缩效果对比</strong></h1><p><strong>压缩前效果</strong></p>
<p>以Header中的user-agent为例，在压缩前的大小为63个字节。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210225095546.png"></p>
<p><strong>压缩后效果</strong></p>
<p>Header中的user-agent在压缩后，大小为1个字节。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210225095620.png"></p>
<p>小结：Header中user-agent从压缩前的63个字节到压缩后的1个字节，HTTP/2是如何做到的呢？</p>
<h1 id="HPACK算法"><a href="#HPACK算法" class="headerlink" title="HPACK算法"></a>HPACK算法</h1><p>HTTP/2头部通过HPACK算法进行压缩，这种算法通过服务端和客户端个字维护索引表来实现。索引表又分为静态表和动态表。</p>
<p><strong>伪头字段</strong> </p>
<p>Header传输以二进制桢的方式进行，为了与HTTP1中Header区分，这些以冒号开头的字段被称为“伪头字段”。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210225095715.png"></p>
<p><strong>静态表</strong></p>
<p>静态表中定义了61个Header字段与Index，可以通过传输Index进而获取Header的字段与值，极大减少了报文大小。静态表中的字段和值固定，而且是只读的。</p>
<p>静态表部分值</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210225095753.png"></p>
<p>详见：<a href="https://tools.ietf.org/html/rfc7541#appendix-A">https://tools.ietf.org/html/rfc7541#appendix-A</a></p>
<p><strong>动态表</strong></p>
<p>动态表接在静态表之后，结构与静态表相同，可随时更新。下图中索引号62、63即为动态表字段。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210225095828.png"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>回到本文前的压缩效果对比，客户端通过传输索引号，服务端根据索引号在动态表中获取Header的key与value。user-agent索引号占1个字节。另外，索引表中不存在的使用huffman编码，再更新到动态表中。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>gRPC</category>
      </categories>
      <tags>
        <tag>gRPC</tag>
      </tags>
  </entry>
  <entry>
    <title>gRPC4# HTTP/2协议之Stream</title>
    <url>/posts/4914cf75/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前面三篇介绍了HPPT/2的“连接前言”、“二进制桢”、“头部压缩”。本文从“流及多路复用”、“流状态”、“流量控制”、“流优先级”、“HTTP/2扩展”介绍HTTP/2协议流相关知识。 </p>
<a id="more"></a>



<h1 id="流与多路复用"><a href="#流与多路复用" class="headerlink" title="流与多路复用"></a>流与多路复用</h1><p><strong>流</strong></p>
<p>前面介绍桢格式时，每个桢都有一个流标示，标记自己属于哪个流。通过将相同流标识的桢组装，桢之间时有严格顺序的，即形成了“流”。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210225100227.png"></p>
<p><strong>多路复用</strong></p>
<p>一个HTTP/2连接可以并非很多个流，流ID顺序递增且互相独立，形成多路复用。由客户端发起的流ID为奇数，服务端发起的为偶数。</p>
<h1 id="流状态"><a href="#流状态" class="headerlink" title="流状态"></a>流状态</h1><p><strong>idle</strong></p>
<p>流空闲状态，可以发送接收HEADERS帧。</p>
<p><strong>open</strong></p>
<p>流开启状态，idle发送或者接受HEADERS帧后，状态变更为开启</p>
<p><strong>half closed</strong></p>
<p>发送包含END_STREAM桢的一端流转为本地半关闭half closed(local)，表示客户端发送请求数据完毕，等待服务端响应数据，接受到服务端发送的END_STREAM进入close关闭状态。接受END_STREAM桢的另一端称为远程半关闭状态half closed(remote)，表示服务端知道客户端请求已经发送完毕，处理结束后可以发送响应数据，并发送END_STREAM到客户端，进入close关闭状态。</p>
<p><strong>close</strong></p>
<p>流的关闭状态。除了half closed数据发送结束关闭外，发送RST_STREAM(发生错误或取消)也可关闭流。</p>
<p><strong>流状态交互示意图</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210225100341.png"></p>
<h1 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h1><p>流量控制是保护接收方的机制，通过配额机制实现。发送端每发送数据后window窗口大小相应的减少。当发送端收到接收端WINDOW_UPDATE桢后window窗口增加。window等于0则不可以进行发送，窗口初始值为65535字节。 </p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210225100506.png"></p>
<h1 id="流优先级"><a href="#流优先级" class="headerlink" title="流优先级"></a>流优先级</h1><p>通过发送端向接收端发送优先级权重期待接收端给予资源分配支持，接受端不保证一定遵守，默认权重为16。优先级表达可以通过HEADERS或者单独发送PRIORITY帧实现。</p>
<p>![image-20210225100647921](/Users/yongliang/Library/Application Support/typora-user-images/image-20210225100647921.png)</p>
<h1 id="流依赖"><a href="#流依赖" class="headerlink" title="流依赖"></a>流依赖</h1><p>客户端通过PRIORITY帧可以告诉服务端当前流所依赖的流，形成流依赖树。同一父级的各个字节点通过权重分配资源；父级先分配资源传输结束后，再分配子级资源。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210225100804.png"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通HTTP/2的四篇文章，对HTTP2工作原理有了全局的认识，相信再阅读HTTP/2相关文献不再困难。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>gRPC</category>
      </categories>
      <tags>
        <tag>gRPC</tag>
      </tags>
  </entry>
  <entry>
    <title>gRPC5# Reactor线程模型</title>
    <url>/posts/a4cd6a20/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Reactor模型是基于事件驱动的线程模型，可以分为Reactor单线程模型、Reactor多线程模型、主从Reactor多线程模型，通常基于在I/O多路复用实现。不同的角色职责有：Dispatcher负责事件分发、Acceptor负责处理客户端连接、Handler处理非连接事件（例如：读写事件）。</p>
<a id="more"></a>



<h1 id="Reactor单线程模型"><a href="#Reactor单线程模型" class="headerlink" title="Reactor单线程模型"></a>Reactor单线程模型</h1><p><strong>原理图示</strong></p>
<p>在Reactor单线程模型中，操作在同一个Reactor线程中完成。根据事件的不同类型，由Dispatcher将事件转发到不同的角色中处理。连接事件转发到Acceptor处理、读写事件转发到不同的Handler处理。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210225101450.png"></p>
<p><strong>实现图示</strong></p>
<p>NIO实现中，可以将Accept事件注册到select选择器中，轮询是否有“接受就绪”事件。如果为“连接就绪”分发给Acceptor角色处理；“写就绪”事件分发给负责写的Handler角色处理；“读就绪”事件分发给负责读的Handler角色处理。这是事情都在一个线程中处理。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210225101514.png"></p>
<h1 id="Reactor多线程模型"><a href="#Reactor多线程模型" class="headerlink" title="Reactor多线程模型"></a>Reactor多线程模型</h1><p><strong>原理图示</strong></p>
<p>在Reactor多线程模型中。根据事件的不同类型，由Dispatcher将事件转发到不同的角色中处理。连接事件转发到Acceptor单线程处理、读写事件转发到不同的Handler由线程池处理。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210225101546.png"></p>
<p><strong>实现图示</strong></p>
<p>NIO实现中，可以将Accept事件注册到select选择器中，轮询是否有“接受就绪”事件。如果为“连接就绪”分发给Acceptor角色处理，此处处理“连接就绪”为一个线程；“写就绪”事件分发给负责写的Handler角色由线程池处理；“读就绪”事件分发给负责读的Handler角色由线程池处理。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210225101604.png"></p>
<h1 id="主从Reactor多线程模型"><a href="#主从Reactor多线程模型" class="headerlink" title="主从Reactor多线程模型"></a><strong>主从Reactor多线程模型</strong></h1><p><strong>原理图示</strong></p>
<p>Reactor多线程模型，由Acceptor接受客户端连接请求后，创建SocketChannel注册到Main-Reactor线程池中某个线程的Select中；具体处理读写事件还是使用线程池处理（Sub-Reactor线程池）。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210225101641.png"></p>
<p><strong>实现图示</strong></p>
<p>将Accept事件注册到select选择器中，轮询是否有“接受就绪”事件；“连接就绪”分发给Acceptor角色处理，创建新的SocketChannel转发给Main-Reactor线程池中的某个线程处理；在指定的Main-Reactor某个线程中，将SocketChannel注册读写事件；当“写就绪/读就绪”事件分别由线程池（Sub-Reactor线程池）处理。</p>
<p>![image-20210225101705355](/Users/yongliang/Library/Application Support/typora-user-images/image-20210225101705355.png)</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>gRPC</category>
      </categories>
      <tags>
        <tag>gRPC</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ13# RocketMQ性能测试</title>
    <url>/posts/5d180165/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.概述</span><br><span class="line"></span><br><span class="line">2.1个线程测试记录</span><br><span class="line"></span><br><span class="line">a.1个线程 消息1K 8个队列</span><br><span class="line"></span><br><span class="line">b.1个线程 消息3K 8个队列</span><br><span class="line"></span><br><span class="line">c.1个线程 消息1K 16个队列</span><br><span class="line"></span><br><span class="line">d.1个线程 消息3K 16个队列</span><br><span class="line"></span><br><span class="line">3.10个线程测试记录</span><br><span class="line"></span><br><span class="line">a.10个线程 消息1K 8个队列</span><br><span class="line"></span><br><span class="line">b.10个线程 消息3K 8个队列</span><br><span class="line"></span><br><span class="line">c.10个线程 消息1K 16个队列</span><br><span class="line"></span><br><span class="line">d.10个线程 消息3K 16个队列</span><br><span class="line"></span><br><span class="line">4.30个线程测试记录</span><br><span class="line"></span><br><span class="line">a.30个线程 消息1K 8个队列</span><br><span class="line"></span><br><span class="line">b.30个线程 消息3K 8个队列</span><br><span class="line"></span><br><span class="line">c.30个线程 消息1K 16个队列</span><br><span class="line"></span><br><span class="line">d.30个线程 消息3K 16个队列</span><br><span class="line"></span><br><span class="line">5.45个线程测试记录</span><br><span class="line"></span><br><span class="line">a.45个线程 消息1K 8个队列</span><br><span class="line"></span><br><span class="line">b.45个线程 消息3K 8个队列</span><br><span class="line"></span><br><span class="line">c.45个线程 消息1K 16个队列</span><br><span class="line"></span><br><span class="line">d.45个线程 消息3K 16个队列</span><br><span class="line"></span><br><span class="line">6.60个线程测试记录</span><br><span class="line"></span><br><span class="line">a.60个线程 消息1K 8个队列</span><br><span class="line"></span><br><span class="line">b.60个线程 消息3K 8个队列</span><br><span class="line"></span><br><span class="line">c.60个线程 消息1K 16个队列</span><br><span class="line"></span><br><span class="line">d.60个线程 消息3K 16个队列</span><br><span class="line"></span><br><span class="line">7.75个线程测试记录</span><br><span class="line"></span><br><span class="line">a.75个线程 消息1K 8个队列</span><br><span class="line"></span><br><span class="line">b.75个线程 消息3K 8个队列</span><br><span class="line"></span><br><span class="line">c.75个线程 消息1K 16个队列</span><br><span class="line"></span><br><span class="line">d.75个线程 消息3K 16个队列</span><br><span class="line"></span><br><span class="line">8.100个线程测试记录</span><br><span class="line"></span><br><span class="line">a.100个线程 消息1K 8个队列</span><br><span class="line"></span><br><span class="line">b.100个线程 消息3K 8个队列</span><br><span class="line"></span><br><span class="line">c.100个线程 消息1K 16个队列</span><br><span class="line"></span><br><span class="line">d.100个线程 消息3K 16个队列</span><br><span class="line"></span><br><span class="line">9.150个线程测试记录</span><br><span class="line"></span><br><span class="line">a.150个线程 消息1K 8个队列</span><br><span class="line"></span><br><span class="line">b.150个线程 消息3K 8个队列</span><br><span class="line"></span><br><span class="line">c.150个线程 消息1K 16个队列</span><br><span class="line"></span><br><span class="line">d.150个线程 消息3K 16个队列</span><br><span class="line"></span><br><span class="line">10.200个线程测试记录</span><br><span class="line"></span><br><span class="line">a.200个线程 消息1K 8个队列</span><br><span class="line"></span><br><span class="line">b.200个线程 消息3K 8个队列</span><br><span class="line"></span><br><span class="line">c.200个线程 消息1K 16个队列</span><br><span class="line"></span><br><span class="line">d.200个线程 消息3K 16个队列</span><br></pre></td></tr></table></figure>



<a id="more"></a>



<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>目的：对生产环境RocketMQ集群进行性能测试,该集群4主4从。</p>
<p>过程：线程数1、线程数10、线程数30、线程数60、线程数100、线程数150、线程数200对消息大小为1K、3K；队列为8个、16个分别进行测试。</p>
<p>结果：其中最大TPS为12.6万，最小TPS为3.6万。</p>
<h1 id="1个线程测试记录"><a href="#1个线程测试记录" class="headerlink" title="1个线程测试记录"></a>1个线程测试记录</h1><h3 id="1个线程-消息1K-8个队列"><a href="#1个线程-消息1K-8个队列" class="headerlink" title="1个线程 消息1K 8个队列"></a>1个线程 消息1K 8个队列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh producer.sh -t zms-clusterB-perf-tst8 -w 1 -s 1024 -n 192.168.x.x:9876</span><br><span class="line"></span><br><span class="line">Send TPS: 4281 Max RT: 299 Average RT: 0.233 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 4237 Max RT: 299 Average RT: 0.236 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 4533 Max RT: 299 Average RT: 0.221 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 4404 Max RT: 299 Average RT: 0.227 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 4360 Max RT: 299 Average RT: 0.229 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 4269 Max RT: 299 Average RT: 0.234 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 4319 Max RT: 299 Average RT: 0.231 Send Failed: 0 Response Failed: 0</span><br></pre></td></tr></table></figure>



<h3 id="1个线程-消息3K-8个队列"><a href="#1个线程-消息3K-8个队列" class="headerlink" title="1个线程 消息3K 8个队列"></a>1个线程 消息3K 8个队列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh producer.sh -t zms-clusterB-perf-tst8 -w 1 -s 3072 -n 192.168.x.x:9876</span><br><span class="line"></span><br><span class="line">Send TPS: 4120 Max RT: 255 Average RT: 0.242 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 4054 Max RT: 255 Average RT: 0.246 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 4010 Max RT: 255 Average RT: 0.249 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 4125 Max RT: 255 Average RT: 0.242 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 4093 Max RT: 255 Average RT: 0.244 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 4093 Max RT: 255 Average RT: 0.244 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 3999 Max RT: 255 Average RT: 0.250 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 3957 Max RT: 255 Average RT: 0.253 Send Failed: 0 Response Failed: 0</span><br></pre></td></tr></table></figure>

<h3 id="1个线程-消息1K-16个队列"><a href="#1个线程-消息1K-16个队列" class="headerlink" title="1个线程 消息1K 16个队列"></a>1个线程 消息1K 16个队列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh producer.sh -t zms-clusterB-perf-tst16 -w 1 -s 1024 -n 192.168.x.x:9876</span><br><span class="line"></span><br><span class="line">Send TPS: 5289 Max RT: 225 Average RT: 0.189 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 5252 Max RT: 225 Average RT: 0.190 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 5124 Max RT: 225 Average RT: 0.195 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 5146 Max RT: 225 Average RT: 0.194 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 4861 Max RT: 225 Average RT: 0.206 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 4998 Max RT: 225 Average RT: 0.200 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 5063 Max RT: 225 Average RT: 0.198 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 5039 Max RT: 225 Average RT: 0.198 Send Failed: 0 Response Failed: 0</span><br></pre></td></tr></table></figure>

<h3 id="1个线程-消息3K-16个队列"><a href="#1个线程-消息3K-16个队列" class="headerlink" title="1个线程 消息3K 16个队列"></a>1个线程 消息3K 16个队列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh producer.sh -t zms-clusterB-perf-tst16 -w 1 -s 3072 -n 192.168.x.x:9876</span><br><span class="line"></span><br><span class="line">Send TPS: 4778 Max RT: 244 Average RT: 0.209 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 5011 Max RT: 244 Average RT: 0.199 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 4826 Max RT: 244 Average RT: 0.207 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 4762 Max RT: 244 Average RT: 0.210 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 4663 Max RT: 244 Average RT: 0.214 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 4648 Max RT: 244 Average RT: 0.215 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 4778 Max RT: 244 Average RT: 0.209 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 4737 Max RT: 244 Average RT: 0.211 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 4523 Max RT: 244 Average RT: 0.221 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 4544 Max RT: 244 Average RT: 0.220 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 4683 Max RT: 244 Average RT: 0.213 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 4838 Max RT: 244 Average RT: 0.207 Send Failed: 0 Response Failed: 0</span><br></pre></td></tr></table></figure>





<h1 id="10个线程测试记录"><a href="#10个线程测试记录" class="headerlink" title="10个线程测试记录"></a>10个线程测试记录</h1><h3 id="10个线程-消息1K-8个队列"><a href="#10个线程-消息1K-8个队列" class="headerlink" title="10个线程 消息1K 8个队列"></a>10个线程 消息1K 8个队列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh producer.sh -t zms-clusterB-perf-tst16 -w 1 -s 3072 -n 192.168.x.x:9876</span><br><span class="line"></span><br><span class="line">Send TPS: 4778 Max RT: 244 Average RT: 0.209 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 5011 Max RT: 244 Average RT: 0.199 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 4826 Max RT: 244 Average RT: 0.207 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 4762 Max RT: 244 Average RT: 0.210 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 4663 Max RT: 244 Average RT: 0.214 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 4648 Max RT: 244 Average RT: 0.215 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 4778 Max RT: 244 Average RT: 0.209 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 4737 Max RT: 244 Average RT: 0.211 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 4523 Max RT: 244 Average RT: 0.221 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 4544 Max RT: 244 Average RT: 0.220 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 4683 Max RT: 244 Average RT: 0.213 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 4838 Max RT: 244 Average RT: 0.207 Send Failed: 0 Response Failed: 0</span><br></pre></td></tr></table></figure>



<h3 id="10个线程-消息3K-8个队列"><a href="#10个线程-消息3K-8个队列" class="headerlink" title="10个线程 消息3K 8个队列"></a>10个线程 消息3K 8个队列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh producer.sh -t zms-clusterB-perf-tst8 -w 10 -s 3072 -n 192.168.x.x:9876</span><br><span class="line"></span><br><span class="line">Send TPS: 40085 Max RT: 265 Average RT: 0.249 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 37710 Max RT: 265 Average RT: 0.265 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 39305 Max RT: 265 Average RT: 0.254 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 39881 Max RT: 265 Average RT: 0.251 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 38428 Max RT: 265 Average RT: 0.260 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 39280 Max RT: 265 Average RT: 0.255 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 38539 Max RT: 265 Average RT: 0.259 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 40927 Max RT: 265 Average RT: 0.244 Send Failed: 0 Response Failed: 0</span><br></pre></td></tr></table></figure>



<h3 id="10个线程-消息1K-16个队列"><a href="#10个线程-消息1K-16个队列" class="headerlink" title="10个线程 消息1K 16个队列"></a>10个线程 消息1K 16个队列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh producer.sh -t zms-clusterB-perf-tst16 -w 10 -s 1024 -n 192.168.x.x:9876</span><br><span class="line"></span><br><span class="line">Send TPS: 41301 Max RT: 243 Average RT: 0.242 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 42365 Max RT: 243 Average RT: 0.236 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 42181 Max RT: 243 Average RT: 0.237 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 42261 Max RT: 243 Average RT: 0.237 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 40831 Max RT: 243 Average RT: 0.245 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 43010 Max RT: 243 Average RT: 0.232 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 41871 Max RT: 243 Average RT: 0.239 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 40970 Max RT: 243 Average RT: 0.244 Send Failed: 0 Response Failed: 0</span><br></pre></td></tr></table></figure>



<h3 id="10个线程-消息3K-16个队列"><a href="#10个线程-消息3K-16个队列" class="headerlink" title="10个线程 消息3K 16个队列"></a>10个线程 消息3K 16个队列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh producer.sh -t zms-clusterB-perf-tst16 -w 10 -s 3072 -n 192.168.x.x:9876</span><br><span class="line"></span><br><span class="line">Send TPS: 36245 Max RT: 237 Average RT: 0.276 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 38713 Max RT: 237 Average RT: 0.258 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 36327 Max RT: 237 Average RT: 0.275 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 39005 Max RT: 237 Average RT: 0.256 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 37926 Max RT: 237 Average RT: 0.264 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 38804 Max RT: 237 Average RT: 0.258 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 39976 Max RT: 237 Average RT: 0.250 Send Failed: 0 Response Failed: 0</span><br></pre></td></tr></table></figure>



<h1 id="30个线程测试记录"><a href="#30个线程测试记录" class="headerlink" title="30个线程测试记录"></a>30个线程测试记录</h1><h3 id="30个线程-消息1K-8个队列"><a href="#30个线程-消息1K-8个队列" class="headerlink" title="30个线程 消息1K 8个队列"></a>30个线程 消息1K 8个队列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh producer.sh -t zms-clusterB-perf-tst8 -w 30 -s 1024 -n 192.168.x.x:9876</span><br><span class="line"></span><br><span class="line">Send TPS: 86259 Max RT: 309 Average RT: 0.348 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 85335 Max RT: 309 Average RT: 0.351 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 81850 Max RT: 309 Average RT: 0.366 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 87712 Max RT: 309 Average RT: 0.342 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 89288 Max RT: 309 Average RT: 0.336 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 86732 Max RT: 309 Average RT: 0.346 Send Failed: 0 Response Failed: 0</span><br></pre></td></tr></table></figure>



<h3 id="30个线程-消息3K-8个队列"><a href="#30个线程-消息3K-8个队列" class="headerlink" title="30个线程 消息3K 8个队列"></a>30个线程 消息3K 8个队列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh producer.sh -t zms-clusterB-perf-tst8 -w 30 -s 3072 -n 192.168.x.x:9876</span><br><span class="line"></span><br><span class="line">Send TPS: 74085 Max RT: 334 Average RT: 0.405 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 71014 Max RT: 334 Average RT: 0.422 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 77792 Max RT: 334 Average RT: 0.386 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 73913 Max RT: 334 Average RT: 0.406 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 77337 Max RT: 334 Average RT: 0.392 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 72184 Max RT: 334 Average RT: 0.416 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 77271 Max RT: 334 Average RT: 0.388 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 75016 Max RT: 334 Average RT: 0.400 Send Failed: 0 Response Failed: 0</span><br></pre></td></tr></table></figure>



<h3 id="30个线程-消息1K-16个队列"><a href="#30个线程-消息1K-16个队列" class="headerlink" title="30个线程 消息1K 16个队列"></a>30个线程 消息1K 16个队列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh producer.sh -t zms-clusterB-perf-tst16 -w 30 -s 1024 -n 192.168.x.x:9876</span><br><span class="line"></span><br><span class="line">Send TPS: 82946 Max RT: 306 Average RT: 0.362 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 86902 Max RT: 306 Average RT: 0.345 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 83157 Max RT: 306 Average RT: 0.365 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 86804 Max RT: 306 Average RT: 0.345 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 87009 Max RT: 306 Average RT: 0.345 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 80219 Max RT: 306 Average RT: 0.374 Send Failed: 0 Response Failed: 0</span><br></pre></td></tr></table></figure>



<h3 id="30个线程-消息3K-16个队列"><a href="#30个线程-消息3K-16个队列" class="headerlink" title="30个线程 消息3K 16个队列"></a>30个线程 消息3K 16个队列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh producer.sh -t zms-clusterB-perf-tst16 -w 30 -s 3072 -n 192.168.x.x:9876</span><br><span class="line"></span><br><span class="line">Send TPS: 73864 Max RT: 329 Average RT: 0.403 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 78555 Max RT: 329 Average RT: 0.382 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 75200 Max RT: 329 Average RT: 0.406 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 73925 Max RT: 329 Average RT: 0.406 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 69955 Max RT: 329 Average RT: 0.429 Send Failed: 0 Response Failed: 0</span><br></pre></td></tr></table></figure>



<h1 id="45个线程测试记录"><a href="#45个线程测试记录" class="headerlink" title="45个线程测试记录"></a>45个线程测试记录</h1><h3 id="45个线程-消息1K-8个队列"><a href="#45个线程-消息1K-8个队列" class="headerlink" title="45个线程 消息1K 8个队列"></a>45个线程 消息1K 8个队列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh producer.sh -t zms-clusterB-perf-tst8 -w 45 -s 1024 -n 192.168.x.x:9876</span><br><span class="line"></span><br><span class="line">Send TPS: 91266 Max RT: 2063 Average RT: 0.493 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 87279 Max RT: 2063 Average RT: 0.515 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 92130 Max RT: 2063 Average RT: 0.487 Send Failed: 0 Response Failed: 1</span><br><span class="line"></span><br><span class="line">Send TPS: 95227 Max RT: 2063 Average RT: 0.472 Send Failed: 0 Response Failed: 1</span><br><span class="line"></span><br><span class="line">Send TPS: 96340 Max RT: 2063 Average RT: 0.467 Send Failed: 0 Response Failed: 1</span><br><span class="line"></span><br><span class="line">Send TPS: 84272 Max RT: 2063 Average RT: 0.534 Send Failed: 0 Response Failed: 1</span><br></pre></td></tr></table></figure>



<h3 id="45个线程-消息3K-8个队列"><a href="#45个线程-消息3K-8个队列" class="headerlink" title="45个线程 消息3K 8个队列"></a>45个线程 消息3K 8个队列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh producer.sh -t zms-clusterB-perf-tst8 -w 45 -s 3072 -n 192.168.x.x:9876</span><br><span class="line"></span><br><span class="line">Send TPS: 89334 Max RT: 462 Average RT: 0.503 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 84237 Max RT: 462 Average RT: 0.534 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 86051 Max RT: 462 Average RT: 0.523 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 86475 Max RT: 462 Average RT: 0.520 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 86088 Max RT: 462 Average RT: 0.523 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 90403 Max RT: 462 Average RT: 0.498 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 84229 Max RT: 462 Average RT: 0.534 Send Failed: 0 Response Failed: 0</span><br></pre></td></tr></table></figure>



<h3 id="45个线程-消息1K-16个队列"><a href="#45个线程-消息1K-16个队列" class="headerlink" title="45个线程 消息1K 16个队列"></a>45个线程 消息1K 16个队列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh producer.sh -t zms-clusterB-perf-tst16 -w 45 -s 1024 -n 192.168.x.:9876</span><br><span class="line"></span><br><span class="line">Send TPS: 91724 Max RT: 604 Average RT: 0.490 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 90414 Max RT: 604 Average RT: 0.498 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 89904 Max RT: 604 Average RT: 0.500 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 100158 Max RT: 604 Average RT: 0.449 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 99658 Max RT: 604 Average RT: 0.451 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 92440 Max RT: 604 Average RT: 0.489 Send Failed: 0 Response Failed: 0</span><br></pre></td></tr></table></figure>



<h3 id="45个线程-消息3K-16个队列"><a href="#45个线程-消息3K-16个队列" class="headerlink" title="45个线程 消息3K 16个队列"></a>45个线程 消息3K 16个队列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh producer.sh -t zms-clusterB-perf-tst16 -w 30 -s 3072 -n 192.168.x.x:9876</span><br><span class="line"></span><br><span class="line">Send TPS: 75159 Max RT: 436 Average RT: 0.399 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 75315 Max RT: 436 Average RT: 0.398 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 77297 Max RT: 436 Average RT: 0.388 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 72188 Max RT: 436 Average RT: 0.415 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 77525 Max RT: 436 Average RT: 0.387 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 71535 Max RT: 436 Average RT: 0.422 Send Failed: 0 Response Failed: 0</span><br></pre></td></tr></table></figure>





<h1 id="60个线程测试记录"><a href="#60个线程测试记录" class="headerlink" title="60个线程测试记录"></a>60个线程测试记录</h1><h3 id="60个线程-消息1K-8个队列"><a href="#60个线程-消息1K-8个队列" class="headerlink" title="60个线程 消息1K 8个队列"></a>60个线程 消息1K 8个队列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh producer.sh -t zms-clusterB-perf-tst8 -w 60 -s 1024 -n 192.168.x.x:9876</span><br><span class="line"></span><br><span class="line">Send TPS: 110067 Max RT: 369 Average RT: 0.545 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 111395 Max RT: 369 Average RT: 0.538 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 103114 Max RT: 369 Average RT: 0.582 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 107466 Max RT: 369 Average RT: 0.558 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 106655 Max RT: 369 Average RT: 0.562 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 107241 Max RT: 369 Average RT: 0.559 Send Failed: 0 Response Failed: 1</span><br><span class="line"></span><br><span class="line">Send TPS: 110672 Max RT: 369 Average RT: 0.540 Send Failed: 0 Response Failed: 1</span><br><span class="line"></span><br><span class="line">Send TPS: 109037 Max RT: 369 Average RT: 0.552 Send Failed: 0 Response Failed: 1</span><br></pre></td></tr></table></figure>



<h3 id="60个线程-消息3K-8个队列"><a href="#60个线程-消息3K-8个队列" class="headerlink" title="60个线程 消息3K 8个队列"></a>60个线程 消息3K 8个队列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh producer.sh -t zms-clusterB-perf-tst8 -w 60 -s 3072 -n 192.168.x.x:9876</span><br><span class="line"></span><br><span class="line">Send TPS: 92572 Max RT: 583 Average RT: 0.648 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 95163 Max RT: 583 Average RT: 0.640 Send Failed: 0 Response Failed: 1</span><br><span class="line"></span><br><span class="line">Send TPS: 93823 Max RT: 583 Average RT: 0.654 Send Failed: 0 Response Failed: 1</span><br><span class="line"></span><br><span class="line">Send TPS: 97091 Max RT: 583 Average RT: 0.628 Send Failed: 0 Response Failed: 1</span><br><span class="line"></span><br><span class="line">Send TPS: 98205 Max RT: 583 Average RT: 0.628 Send Failed: 0 Response Failed: 1</span><br><span class="line"></span><br><span class="line">Send TPS: 99535 Max RT: 583 Average RT: 0.596 Send Failed: 0 Response Failed: 3</span><br></pre></td></tr></table></figure>



<h3 id="60个线程-消息1K-16个队列"><a href="#60个线程-消息1K-16个队列" class="headerlink" title="60个线程 消息1K 16个队列"></a>60个线程 消息1K 16个队列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh producer.sh -t zms-clusterB-perf-tst16 -w 60 -s 1024 -n 192.168.x.x:9876</span><br><span class="line"></span><br><span class="line">Send TPS: 105229 Max RT: 358 Average RT: 0.578 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 103003 Max RT: 358 Average RT: 0.582 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 95497 Max RT: 358 Average RT: 0.628 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 108878 Max RT: 358 Average RT: 0.551 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 109265 Max RT: 358 Average RT: 0.549 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 105545 Max RT: 358 Average RT: 0.568 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 111667 Max RT: 358 Average RT: 0.537 Send Failed: 0 Response Failed: 0</span><br></pre></td></tr></table></figure>



<h3 id="60个线程-消息3K-16个队列"><a href="#60个线程-消息3K-16个队列" class="headerlink" title="60个线程 消息3K 16个队列"></a>60个线程 消息3K 16个队列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh producer.sh -t zms-clusterB-perf-tst16 -w 60 -s 3072 -n 192.168.x.x:9876</span><br><span class="line"></span><br><span class="line">Send TPS: 98899 Max RT: 358 Average RT: 0.606 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 101073 Max RT: 358 Average RT: 0.594 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 97295 Max RT: 358 Average RT: 0.617 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 97923 Max RT: 358 Average RT: 0.609 Send Failed: 0 Response Failed: 1</span><br><span class="line"></span><br><span class="line">Send TPS: 96111 Max RT: 358 Average RT: 0.620 Send Failed: 0 Response Failed: 2</span><br><span class="line"></span><br><span class="line">Send TPS: 93873 Max RT: 358 Average RT: 0.639 Send Failed: 0 Response Failed: 2</span><br><span class="line"></span><br><span class="line">Send TPS: 96466 Max RT: 358 Average RT: 0.622 Send Failed: 0 Response Failed: 2</span><br><span class="line"></span><br><span class="line">Send TPS: 96579 Max RT: 358 Average RT: 0.621 Send Failed: 0 Response Failed: 2</span><br></pre></td></tr></table></figure>



<h1 id="75个线程测试记录"><a href="#75个线程测试记录" class="headerlink" title="75个线程测试记录"></a>75个线程测试记录</h1><h3 id="75个线程-消息1K-8个队列"><a href="#75个线程-消息1K-8个队列" class="headerlink" title="75个线程 消息1K 8个队列"></a>75个线程 消息1K 8个队列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh producer.sh -t zms-clusterB-perf-tst8 -w 75 -s 1024 -n 192.168.x.x:9876</span><br><span class="line"></span><br><span class="line">Send TPS: 108367 Max RT: 384 Average RT: 0.692 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 107516 Max RT: 384 Average RT: 0.701 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 110974 Max RT: 384 Average RT: 0.680 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 109754 Max RT: 384 Average RT: 0.683 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 111917 Max RT: 384 Average RT: 0.670 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 104764 Max RT: 384 Average RT: 0.712 Send Failed: 0 Response Failed: 1</span><br><span class="line"></span><br><span class="line">Send TPS: 112208 Max RT: 384 Average RT: 0.668 Send Failed: 0 Response Failed: 1</span><br><span class="line"></span><br><span class="line">Send TPS: 112707 Max RT: 384 Average RT: 0.665 Send Failed: 0 Response Failed: 1</span><br></pre></td></tr></table></figure>



<h3 id="75个线程-消息3K-8个队列"><a href="#75个线程-消息3K-8个队列" class="headerlink" title="75个线程 消息3K 8个队列"></a>75个线程 消息3K 8个队列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh producer.sh -t zms-clusterB-perf-tst8 -w 75 -s 3072 -n 192.168.x.x:9876</span><br><span class="line"></span><br><span class="line">Send TPS: 102311 Max RT: 370 Average RT: 0.733 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 93722 Max RT: 370 Average RT: 0.800 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 101091 Max RT: 370 Average RT: 0.742 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 100404 Max RT: 370 Average RT: 0.747 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 102328 Max RT: 370 Average RT: 0.733 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 103953 Max RT: 370 Average RT: 0.722 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 103454 Max RT: 370 Average RT: 0.725 Send Failed: 0 Response Failed: 0</span><br></pre></td></tr></table></figure>



<h3 id="75个线程-消息1K-16个队列"><a href="#75个线程-消息1K-16个队列" class="headerlink" title="75个线程 消息1K 16个队列"></a>75个线程 消息1K 16个队列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh producer.sh -t zms-clusterB-perf-tst16 -w 75 -s 1024 -n 192.168.x.x:9876</span><br><span class="line"></span><br><span class="line">Send TPS: 106813 Max RT: 605 Average RT: 0.687 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 110828 Max RT: 605 Average RT: 0.673 Send Failed: 0 Response Failed: 1</span><br><span class="line"></span><br><span class="line">Send TPS: 109855 Max RT: 605 Average RT: 0.676 Send Failed: 0 Response Failed: 3</span><br><span class="line"></span><br><span class="line">Send TPS: 102741 Max RT: 605 Average RT: 0.730 Send Failed: 0 Response Failed: 3</span><br><span class="line"></span><br><span class="line">Send TPS: 110123 Max RT: 605 Average RT: 0.681 Send Failed: 0 Response Failed: 3</span><br><span class="line"></span><br><span class="line">Send TPS: 115659 Max RT: 605 Average RT: 0.648 Send Failed: 0 Response Failed: 3</span><br><span class="line"></span><br><span class="line">Send TPS: 108157 Max RT: 605 Average RT: 0.693 Send Failed: 0 Response Failed: 3</span><br></pre></td></tr></table></figure>



<h3 id="75个线程-消息3K-16个队列"><a href="#75个线程-消息3K-16个队列" class="headerlink" title="75个线程 消息3K 16个队列"></a>75个线程 消息3K 16个队列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh producer.sh -t zms-clusterB-perf-tst16 -w 75 -s 3072 -n 192.168.x.x:9876</span><br><span class="line"></span><br><span class="line">Send TPS: 90459 Max RT: 499 Average RT: 0.829 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 96838 Max RT: 499 Average RT: 0.770 Send Failed: 0 Response Failed: 1</span><br><span class="line"></span><br><span class="line">Send TPS: 96590 Max RT: 499 Average RT: 0.776 Send Failed: 0 Response Failed: 1</span><br><span class="line"></span><br><span class="line">Send TPS: 95137 Max RT: 499 Average RT: 0.788 Send Failed: 0 Response Failed: 1</span><br><span class="line"></span><br><span class="line">Send TPS: 89502 Max RT: 499 Average RT: 0.834 Send Failed: 0 Response Failed: 2</span><br><span class="line"></span><br><span class="line">Send TPS: 90255 Max RT: 499 Average RT: 0.831 Send Failed: 0 Response Failed: 2</span><br><span class="line"></span><br><span class="line">Send TPS: 99871 Max RT: 499 Average RT: 0.725 Send Failed: 0 Response Failed: 9</span><br></pre></td></tr></table></figure>



<h1 id="100个线程测试记录"><a href="#100个线程测试记录" class="headerlink" title="100个线程测试记录"></a>100个线程测试记录</h1><h3 id="100个线程-消息1K-8个队列"><a href="#100个线程-消息1K-8个队列" class="headerlink" title="100个线程 消息1K 8个队列"></a>100个线程 消息1K 8个队列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh producer.sh -t zms-clusterB-perf-tst8 -w 100 -s 1024 -n 192.168.x.x:9876</span><br><span class="line"></span><br><span class="line">Send TPS: 113204 Max RT: 402 Average RT: 0.883 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 114872 Max RT: 402 Average RT: 0.868 Send Failed: 0 Response Failed: 1</span><br><span class="line"></span><br><span class="line">Send TPS: 116261 Max RT: 402 Average RT: 0.860 Send Failed: 0 Response Failed: 1</span><br><span class="line"></span><br><span class="line">Send TPS: 118116 Max RT: 402 Average RT: 0.847 Send Failed: 0 Response Failed: 1</span><br><span class="line"></span><br><span class="line">Send TPS: 112594 Max RT: 402 Average RT: 0.888 Send Failed: 0 Response Failed: 1</span><br><span class="line"></span><br><span class="line">Send TPS: 124407 Max RT: 402 Average RT: 0.801 Send Failed: 0 Response Failed: 2</span><br><span class="line"></span><br><span class="line">Send TPS: 126590 Max RT: 402 Average RT: 0.790 Send Failed: 0 Response Failed: 2</span><br></pre></td></tr></table></figure>



<h3 id="100个线程-消息3K-8个队列"><a href="#100个线程-消息3K-8个队列" class="headerlink" title="100个线程 消息3K 8个队列"></a>100个线程 消息3K 8个队列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh producer.sh -t zms-clusterB-perf-tst8 -w 100 -s 3072 -n 192.168.x.x:9876</span><br><span class="line"></span><br><span class="line">Send TPS: 106723 Max RT: 426 Average RT: 0.937 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 104768 Max RT: 426 Average RT: 0.943 Send Failed: 0 Response Failed: 1</span><br><span class="line"></span><br><span class="line">Send TPS: 106697 Max RT: 426 Average RT: 0.935 Send Failed: 0 Response Failed: 2</span><br><span class="line"></span><br><span class="line">Send TPS: 105147 Max RT: 426 Average RT: 0.951 Send Failed: 0 Response Failed: 2</span><br><span class="line"></span><br><span class="line">Send TPS: 105814 Max RT: 426 Average RT: 0.935 Send Failed: 0 Response Failed: 5</span><br><span class="line"></span><br><span class="line">Send TPS: 108616 Max RT: 426 Average RT: 0.916 Send Failed: 0 Response Failed: 6</span><br><span class="line"></span><br><span class="line">Send TPS: 101429 Max RT: 426 Average RT: 0.986 Send Failed: 0 Response Failed: 6</span><br></pre></td></tr></table></figure>



<h3 id="100个线程-消息1K-16个队列"><a href="#100个线程-消息1K-16个队列" class="headerlink" title="100个线程 消息1K 16个队列"></a>100个线程 消息1K 16个队列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh producer.sh -t zms-clusterB-perf-tst16 -w 100 -s 1024 -n 192.168.x.x:9876</span><br><span class="line"></span><br><span class="line">Send TPS: 123424 Max RT: 438 Average RT: 0.805 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 111418 Max RT: 438 Average RT: 0.897 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 110360 Max RT: 438 Average RT: 0.905 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 118734 Max RT: 438 Average RT: 0.842 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 120725 Max RT: 438 Average RT: 0.816 Send Failed: 0 Response Failed: 4</span><br><span class="line"></span><br><span class="line">Send TPS: 113823 Max RT: 438 Average RT: 0.878 Send Failed: 0 Response Failed: 4</span><br><span class="line"></span><br><span class="line">Send TPS: 115639 Max RT: 438 Average RT: 0.865 Send Failed: 0 Response Failed: 4</span><br><span class="line"></span><br><span class="line">Send TPS: 112787 Max RT: 438 Average RT: 0.889 Send Failed: 0 Response Failed: 4</span><br><span class="line"></span><br><span class="line">Send TPS: 106677 Max RT: 438 Average RT: 0.937 Send Failed: 0 Response Failed: 4</span><br><span class="line"></span><br><span class="line">Send TPS: 112635 Max RT: 438 Average RT: 0.888 Send Failed: 0 Response Failed: 4</span><br><span class="line"></span><br><span class="line">Send TPS: 108470 Max RT: 438 Average RT: 0.922 Send Failed: 0 Response Failed: 4</span><br></pre></td></tr></table></figure>



<h3 id="100个线程-消息3K-16个队列"><a href="#100个线程-消息3K-16个队列" class="headerlink" title="100个线程 消息3K 16个队列"></a>100个线程 消息3K 16个队列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh producer.sh -t zms-clusterB-perf-tst16 -w 100 -s 3072 -n 192.168.x.x:9876</span><br><span class="line"></span><br><span class="line">Send TPS: 93374 Max RT: 441 Average RT: 1.071 Send Failed: 0 Response Failed: 3</span><br><span class="line"></span><br><span class="line">Send TPS: 98421 Max RT: 441 Average RT: 1.017 Send Failed: 0 Response Failed: 3</span><br><span class="line"></span><br><span class="line">Send TPS: 103664 Max RT: 441 Average RT: 0.964 Send Failed: 0 Response Failed: 4</span><br><span class="line"></span><br><span class="line">Send TPS: 98234 Max RT: 441 Average RT: 0.995 Send Failed: 0 Response Failed: 6</span><br><span class="line"></span><br><span class="line">Send TPS: 103563 Max RT: 441 Average RT: 0.960 Send Failed: 0 Response Failed: 7</span><br><span class="line"></span><br><span class="line">Send TPS: 103807 Max RT: 441 Average RT: 0.962 Send Failed: 0 Response Failed: 7</span><br><span class="line"></span><br><span class="line">Send TPS: 102715 Max RT: 441 Average RT: 0.973 Send Failed: 0 Response Failed: 7</span><br></pre></td></tr></table></figure>



<h1 id="150个线程测试记录"><a href="#150个线程测试记录" class="headerlink" title="150个线程测试记录"></a>150个线程测试记录</h1><h3 id="150个线程-消息1K-8个队列"><a href="#150个线程-消息1K-8个队列" class="headerlink" title="150个线程 消息1K 8个队列"></a>150个线程 消息1K 8个队列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh producer.sh -t zms-clusterB-perf-tst8 -w 150 -s 1024 -n 192.168.x.x:9876</span><br><span class="line"></span><br><span class="line">Send TPS: 124458 Max RT: 633 Average RT: 1.205 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 124567 Max RT: 633 Average RT: 1.204 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 121324 Max RT: 633 Average RT: 1.236 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 124928 Max RT: 633 Average RT: 1.201 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 122830 Max RT: 633 Average RT: 1.242 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 118825 Max RT: 633 Average RT: 1.262 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 124085 Max RT: 633 Average RT: 1.209 Send Failed: 0 Response Failed: 0</span><br></pre></td></tr></table></figure>



<h3 id="150个线程-消息3K-8个队列"><a href="#150个线程-消息3K-8个队列" class="headerlink" title="150个线程 消息3K 8个队列"></a>150个线程 消息3K 8个队列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh producer.sh -t zms-clusterB-perf-tst8 -w 150 -s 3072 -n 192.168.x.x:9876</span><br><span class="line"></span><br><span class="line">Send TPS: 106575 Max RT: 582 Average RT: 1.404 Send Failed: 0 Response Failed: 1</span><br><span class="line"></span><br><span class="line">Send TPS: 101830 Max RT: 582 Average RT: 1.477 Send Failed: 0 Response Failed: 1</span><br><span class="line"></span><br><span class="line">Send TPS: 99666 Max RT: 582 Average RT: 1.505 Send Failed: 0 Response Failed: 1</span><br><span class="line"></span><br><span class="line">Send TPS: 102139 Max RT: 582 Average RT: 1.465 Send Failed: 0 Response Failed: 2</span><br><span class="line"></span><br><span class="line">Send TPS: 105405 Max RT: 582 Average RT: 1.419 Send Failed: 0 Response Failed: 3</span><br><span class="line"></span><br><span class="line">Send TPS: 107032 Max RT: 582 Average RT: 1.399 Send Failed: 0 Response Failed: 4</span><br><span class="line"></span><br><span class="line">Send TPS: 103416 Max RT: 582 Average RT: 1.448 Send Failed: 0 Response Failed: 5</span><br></pre></td></tr></table></figure>



<h3 id="150个线程-消息1K-16个队列"><a href="#150个线程-消息1K-16个队列" class="headerlink" title="150个线程 消息1K 16个队列"></a>150个线程 消息1K 16个队列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh producer.sh -t zms-clusterB-perf-tst16 -w 150 -s 1024 -n 192.168.x.x:9876</span><br><span class="line"></span><br><span class="line">Send TPS: 115151 Max RT: 574 Average RT: 1.299 Send Failed: 0 Response Failed: 1</span><br><span class="line"></span><br><span class="line">Send TPS: 106960 Max RT: 574 Average RT: 1.402 Send Failed: 0 Response Failed: 1</span><br><span class="line"></span><br><span class="line">Send TPS: 116382 Max RT: 574 Average RT: 1.289 Send Failed: 0 Response Failed: 1</span><br><span class="line"></span><br><span class="line">Send TPS: 110587 Max RT: 574 Average RT: 1.349 Send Failed: 0 Response Failed: 4</span><br><span class="line"></span><br><span class="line">Send TPS: 122832 Max RT: 574 Average RT: 1.220 Send Failed: 0 Response Failed: 4</span><br><span class="line"></span><br><span class="line">Send TPS: 124474 Max RT: 574 Average RT: 1.213 Send Failed: 0 Response Failed: 4</span><br><span class="line"></span><br><span class="line">Send TPS: 112153 Max RT: 574 Average RT: 1.337 Send Failed: 0 Response Failed: 4</span><br><span class="line"></span><br><span class="line">Send TPS: 120450 Max RT: 574 Average RT: 1.261 Send Failed: 0 Response Failed: 4</span><br></pre></td></tr></table></figure>



<h3 id="150个线程-消息3K-16个队列"><a href="#150个线程-消息3K-16个队列" class="headerlink" title="150个线程 消息3K 16个队列"></a>150个线程 消息3K 16个队列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh producer.sh -t zms-clusterB-perf-tst16 -w 150 -s 3072 -n 192.168.x.x:9876</span><br><span class="line"></span><br><span class="line">Send TPS: 105061 Max RT: 535 Average RT: 1.428 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 102117 Max RT: 535 Average RT: 1.465 Send Failed: 0 Response Failed: 1</span><br><span class="line"></span><br><span class="line">Send TPS: 105569 Max RT: 535 Average RT: 1.421 Send Failed: 0 Response Failed: 1</span><br><span class="line"></span><br><span class="line">Send TPS: 100689 Max RT: 535 Average RT: 1.489 Send Failed: 0 Response Failed: 2</span><br><span class="line"></span><br><span class="line">Send TPS: 108464 Max RT: 535 Average RT: 1.381 Send Failed: 0 Response Failed: 2</span><br><span class="line"></span><br><span class="line">Send TPS: 111285 Max RT: 535 Average RT: 1.348 Send Failed: 0 Response Failed: 2</span><br><span class="line"></span><br><span class="line">Send TPS: 103406 Max RT: 535 Average RT: 1.451 Send Failed: 0 Response Failed: 2</span><br><span class="line"></span><br><span class="line">Send TPS: 109203 Max RT: 535 Average RT: 1.388 Send Failed: 0 Response Failed: 2</span><br></pre></td></tr></table></figure>



<h1 id="200个线程测试记录"><a href="#200个线程测试记录" class="headerlink" title="200个线程测试记录"></a>200个线程测试记录</h1><h3 id="200个线程-消息1K-8个队列"><a href="#200个线程-消息1K-8个队列" class="headerlink" title="200个线程 消息1K 8个队列"></a>200个线程 消息1K 8个队列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh producer.sh -t zms-clusterB-perf-tst8 -w 200 -s 1024 -n 192.168.x.x:9876</span><br><span class="line"></span><br><span class="line">Send TPS: 117965 Max RT: 628 Average RT: 1.674 Send Failed: 0 Response Failed: 7</span><br><span class="line"></span><br><span class="line">Send TPS: 115583 Max RT: 628 Average RT: 1.715 Send Failed: 0 Response Failed: 12</span><br><span class="line"></span><br><span class="line">Send TPS: 118732 Max RT: 628 Average RT: 1.672 Send Failed: 0 Response Failed: 16</span><br><span class="line"></span><br><span class="line">Send TPS: 126170 Max RT: 628 Average RT: 1.582 Send Failed: 0 Response Failed: 17</span><br><span class="line"></span><br><span class="line">Send TPS: 116203 Max RT: 628 Average RT: 1.719 Send Failed: 0 Response Failed: 18</span><br><span class="line"></span><br><span class="line">Send TPS: 114793 Max RT: 628 Average RT: 1.739 Send Failed: 0 Response Failed: 19</span><br></pre></td></tr></table></figure>



<h3 id="200个线程-消息3K-8个队列"><a href="#200个线程-消息3K-8个队列" class="headerlink" title="200个线程 消息3K 8个队列"></a>200个线程 消息3K 8个队列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh producer.sh -t zms-clusterB-perf-tst8 -w 200 -s 3072 -n 192.168.x.x:9876</span><br><span class="line"></span><br><span class="line">Send TPS: 107240 Max RT: 761 Average RT: 1.865 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 104585 Max RT: 761 Average RT: 1.906 Send Failed: 0 Response Failed: 2</span><br><span class="line"></span><br><span class="line">Send TPS: 110892 Max RT: 761 Average RT: 1.803 Send Failed: 0 Response Failed: 2</span><br><span class="line"></span><br><span class="line">Send TPS: 105414 Max RT: 761 Average RT: 1.898 Send Failed: 0 Response Failed: 2</span><br><span class="line"></span><br><span class="line">Send TPS: 105904 Max RT: 761 Average RT: 1.885 Send Failed: 0 Response Failed: 3</span><br><span class="line"></span><br><span class="line">Send TPS: 110748 Max RT: 761 Average RT: 1.806 Send Failed: 0 Response Failed: 3</span><br></pre></td></tr></table></figure>



<h3 id="200个线程-消息1K-16个队列"><a href="#200个线程-消息1K-16个队列" class="headerlink" title="200个线程 消息1K 16个队列"></a>200个线程 消息1K 16个队列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh producer.sh -t zms-clusterB-perf-tst16 -w 200 -s 1024 -n 192.168.x.x:9876</span><br><span class="line"></span><br><span class="line">Send TPS: 118892 Max RT: 601 Average RT: 1.679 Send Failed: 0 Response Failed: 4</span><br><span class="line"></span><br><span class="line">Send TPS: 118839 Max RT: 601 Average RT: 1.668 Send Failed: 0 Response Failed: 12</span><br><span class="line"></span><br><span class="line">Send TPS: 117122 Max RT: 601 Average RT: 1.704 Send Failed: 0 Response Failed: 12</span><br><span class="line"></span><br><span class="line">Send TPS: 122670 Max RT: 601 Average RT: 1.630 Send Failed: 0 Response Failed: 12</span><br><span class="line"></span><br><span class="line">Send TPS: 119592 Max RT: 601 Average RT: 1.672 Send Failed: 0 Response Failed: 12</span><br><span class="line"></span><br><span class="line">Send TPS: 121243 Max RT: 601 Average RT: 1.649 Send Failed: 0 Response Failed: 12</span><br><span class="line"></span><br><span class="line">Send TPS: 124760 Max RT: 601 Average RT: 1.603 Send Failed: 0 Response Failed: 12</span><br><span class="line"></span><br><span class="line">Send TPS: 124354 Max RT: 601 Average RT: 1.608 Send Failed: 0 Response Failed: 12</span><br><span class="line"></span><br><span class="line">Send TPS: 119272 Max RT: 601 Average RT: 1.677 Send Failed: 0 Response Failed: 12</span><br></pre></td></tr></table></figure>



<h3 id="200个线程-消息3K-16个队列"><a href="#200个线程-消息3K-16个队列" class="headerlink" title="200个线程 消息3K 16个队列"></a>200个线程 消息3K 16个队列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh producer.sh -t zms-clusterB-perf-tst16 -w 200 -s 3072 -n 192.168.x.x:9876</span><br><span class="line"></span><br><span class="line">Send TPS: 105091 Max RT: 963 Average RT: 1.896 Send Failed: 0 Response Failed: 4</span><br><span class="line"></span><br><span class="line">Send TPS: 106243 Max RT: 963 Average RT: 1.882 Send Failed: 0 Response Failed: 4</span><br><span class="line"></span><br><span class="line">Send TPS: 103994 Max RT: 963 Average RT: 1.958 Send Failed: 0 Response Failed: 5</span><br><span class="line"></span><br><span class="line">Send TPS: 109741 Max RT: 963 Average RT: 1.822 Send Failed: 0 Response Failed: 5</span><br><span class="line"></span><br><span class="line">Send TPS: 103788 Max RT: 963 Average RT: 1.927 Send Failed: 0 Response Failed: 5</span><br><span class="line"></span><br><span class="line">Send TPS: 110597 Max RT: 963 Average RT: 1.805 Send Failed: 0 Response Failed: 6</span><br><span class="line"></span><br><span class="line">Send TPS: 111201 Max RT: 963 Average RT: 1.798 Send Failed: 0 Response Failed: 6</span><br></pre></td></tr></table></figure>

</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ37# RocketMQ消息发送（一）</title>
    <url>/posts/d473d7d3/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="消息发送代码"><a href="#消息发送代码" class="headerlink" title="消息发送代码"></a>消息发送代码</h1><p>* 需要设置produerGroup</p>
<p>* 需要设置NameServer地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DefaultMQProducer producer &#x3D; new DefaultMQProducer(&quot;melon-tst&quot;);</span><br><span class="line"></span><br><span class="line">producer.setNamesrvAddr(&quot;localhost:9876&quot;);</span><br><span class="line"></span><br><span class="line">producer.setVipChannelEnabled(false);</span><br><span class="line"></span><br><span class="line">producer.start();</span><br><span class="line"></span><br><span class="line">for(int i&#x3D;0;i&lt;100;i++)&#123;</span><br><span class="line"></span><br><span class="line">Message msg &#x3D; new Message(&quot;topic_online_test&quot;,(&quot;Hello RocketMQ&quot; + i).getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;msg.setDelayTimeLevel(10);</span><br><span class="line"></span><br><span class="line">SendResult sendResult &#x3D; producer.send(msg);</span><br><span class="line"></span><br><span class="line">System.out.printf(&quot;%s%n&quot;,sendResult);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">producer.shutdown();</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h1 id="方法启动所做的事情"><a href="#方法启动所做的事情" class="headerlink" title="方法启动所做的事情"></a>方法启动所做的事情</h1><p>* 将instanceName从默认值DEFAULT修改为PID</p>
<ol>
<li><p>MQClientInstance封装了网络通信的管道，存储于factoryTable（ConcurrentHashMap）</p>
</li>
<li><p>factoryTable为MQClientManager的成员变量，MQClientManager是单例模式</p>
</li>
<li><p>key为clientId对应一个MQClientInstance，被客户端共享使用</p>
</li>
<li><p>clientId的组成ClientIP@InstanceName，在同一个客户端连接多个集群时需要修改ClientIP或者InstanceName以确保clientId唯一</p>
</li>
</ol>
<p>* 注册producer到producerTable（ConcurrentHashMap）, key为producerGroup名称，不同的produer需要设置不同的producerGroup名称</p>
<p>* 客户端工厂实例启动</p>
<p>* 设置默认主题TBW102的路由信息</p>
<p>* 向各个broker发送心跳包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;defaultMQProducerImpl.start()</span><br><span class="line"></span><br><span class="line">public void start(final boolean startFactory) throws MQClientException &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;注意：此处的serviceState默认为CREATE_JUST 是DefaultMQProducer的成员变量</span><br><span class="line"></span><br><span class="line">switch (this.serviceState) &#123;</span><br><span class="line"></span><br><span class="line">case CREATE_JUST:</span><br><span class="line"></span><br><span class="line">this.serviceState &#x3D; ServiceState.START_FAILED;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;合法性校验</span><br><span class="line"></span><br><span class="line">this.checkConfig();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将实例的名称改成PID 避免一台机器上启动多个实例造成clientId重名</span><br><span class="line"></span><br><span class="line">if (!this.defaultMQProducer.getProducerGroup().equals(MixAll.CLIENT_INNER_PRODUCER_GROUP)) &#123;</span><br><span class="line"></span><br><span class="line">this.defaultMQProducer.changeInstanceNameToPID();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取MQClientInstance,作为生产者与NameServer,Broker沟通的通道</span><br><span class="line"></span><br><span class="line">this.mQClientFactory &#x3D; MQClientManager.getInstance().getAndCreateMQClientInstance(this.defaultMQProducer, rpcHook);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将当前生产者加入到MQClientInstance管理中，方便后续调用网络请求、进行心跳检测</span><br><span class="line"></span><br><span class="line">boolean registerOK &#x3D; mQClientFactory.registerProducer(this.defaultMQProducer.getProducerGroup(), this);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;一个ProductGroup只允许注册一次</span><br><span class="line"></span><br><span class="line">if (!registerOK) &#123;</span><br><span class="line"></span><br><span class="line">this.serviceState &#x3D; ServiceState.CREATE_JUST;</span><br><span class="line"></span><br><span class="line">throw new MQClientException(&quot;The producer group[&quot; + this.defaultMQProducer.getProducerGroup()</span><br><span class="line"></span><br><span class="line">\+ &quot;] has been created before, specify another name please.&quot; + FAQUrl.suggestTodo(FAQUrl.GROUP_NAME_DUPLICATE_URL),</span><br><span class="line"></span><br><span class="line">null);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设置默认主题TBW102的路由信息</span><br><span class="line"></span><br><span class="line">this.topicPublishInfoTable.put(this.defaultMQProducer.getCreateTopicKey(), new TopicPublishInfo());</span><br><span class="line"></span><br><span class="line">if (startFactory) &#123;</span><br><span class="line"></span><br><span class="line">mQClientFactory.start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.info(&quot;the producer [&#123;&#125;] start OK. sendMessageWithVIPChannel&#x3D;&#123;&#125;&quot;, this.defaultMQProducer.getProducerGroup(),</span><br><span class="line"></span><br><span class="line">this.defaultMQProducer.isSendMessageWithVIPChannel());</span><br><span class="line"></span><br><span class="line">this.serviceState &#x3D; ServiceState.RUNNING;</span><br><span class="line"></span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">case RUNNING:</span><br><span class="line"></span><br><span class="line">case START_FAILED:</span><br><span class="line"></span><br><span class="line">case SHUTDOWN_ALREADY:</span><br><span class="line"></span><br><span class="line">throw new MQClientException(&quot;The producer service state not OK, maybe started once, &quot;&#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">\+ this.serviceState&#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">\+ FAQUrl.suggestTodo(FAQUrl.CLIENT_SERVICE_NOT_OK),</span><br><span class="line"></span><br><span class="line">null);</span><br><span class="line"></span><br><span class="line">default:</span><br><span class="line"></span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">this.mQClientFactory.sendHeartbeatToAllBrokerWithLock();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"></span><br><span class="line">\* 同一个JVM中的不同消费者和不同生产者在启动时获取的MQClientInstance实例都是同一个</span><br><span class="line"></span><br><span class="line">\* MQClientInstance封装了RocketMQ网络处理的API，是消息生产者（Producer）、消息消费者(Consumer)与NameServer、Broker打交道的网络通道</span><br><span class="line"></span><br><span class="line">\* @param clientConfig</span><br><span class="line"></span><br><span class="line">\* @param rpcHook</span><br><span class="line"></span><br><span class="line">\* @return</span><br><span class="line"></span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">public MQClientInstance getAndCreateMQClientInstance(final ClientConfig clientConfig, RPCHook rpcHook) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;clientId由ip地址@实例名称构成</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;如果ProducerGroup为CLIENT_INNER_PRODUCER，实例名称为被更改为PID进程ID</span><br><span class="line"></span><br><span class="line">String clientId &#x3D; clientConfig.buildMQClientId();</span><br><span class="line"></span><br><span class="line">MQClientInstance instance &#x3D; this.factoryTable.get(clientId);</span><br><span class="line"></span><br><span class="line">if (null &#x3D;&#x3D; instance) &#123;</span><br><span class="line"></span><br><span class="line">instance &#x3D;</span><br><span class="line"></span><br><span class="line">new MQClientInstance(clientConfig.cloneClientConfig(),</span><br><span class="line"></span><br><span class="line">this.factoryIndexGenerator.getAndIncrement(), clientId, rpcHook);</span><br><span class="line"></span><br><span class="line">MQClientInstance prev &#x3D; this.factoryTable.putIfAbsent(clientId, instance);</span><br><span class="line"></span><br><span class="line">if (prev !&#x3D; null) &#123;</span><br><span class="line"></span><br><span class="line">instance &#x3D; prev;</span><br><span class="line"></span><br><span class="line">log.warn(&quot;Returned Previous MQClientInstance for clientId:[&#123;&#125;]&quot;, clientId);</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line"></span><br><span class="line">log.info(&quot;Created new MQClientInstance for clientId:[&#123;&#125;]&quot;, clientId);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return instance;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String buildMQClientId() &#123;</span><br><span class="line"></span><br><span class="line">StringBuilder sb &#x3D; new StringBuilder();</span><br><span class="line"></span><br><span class="line">sb.append(this.getClientIP());</span><br><span class="line"></span><br><span class="line">sb.append(&quot;@&quot;);</span><br><span class="line"></span><br><span class="line">sb.append(this.getInstanceName());</span><br><span class="line"></span><br><span class="line">if (!UtilAll.isBlank(this.unitName)) &#123;</span><br><span class="line"></span><br><span class="line">sb.append(&quot;@&quot;);</span><br><span class="line"></span><br><span class="line">sb.append(this.unitName);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return sb.toString();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<!--more-->



<h1 id="客户端工厂实例启动"><a href="#客户端工厂实例启动" class="headerlink" title="客户端工厂实例启动"></a>客户端工厂实例启动</h1><p>* 开启消息通道（Netty客户端启动）</p>
<p>* 启动系列定时任务</p>
<ol>
<li><p>每30秒定时从NameServer获取Topic的路由信息</p>
</li>
<li><p>每30秒定时清理下线的broker以及向broker发送心跳</p>
</li>
<li><p>持久化消息消费进度，默认5秒保存一次（本地存储和Broker存储）</p>
</li>
</ol>
<p>* 开启拉去消息的线程pullMessageService</p>
<p>* 队列消费负载实现</p>
<p>* 发送消息服务启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;MQClientInstance mQClientFactory.start()</span><br><span class="line"></span><br><span class="line">public void start(final boolean startFactory) throws MQClientException &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;注意：此处的serviceState默认为CREATE_JUST 是DefaultMQProducer的成员变量</span><br><span class="line"></span><br><span class="line">switch (this.serviceState) &#123;</span><br><span class="line"></span><br><span class="line">case CREATE_JUST:</span><br><span class="line"></span><br><span class="line">this.serviceState &#x3D; ServiceState.START_FAILED;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;合法性校验</span><br><span class="line"></span><br><span class="line">this.checkConfig();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将实例的名称改成PID 避免一台机器上启动多个实例造成clientId重名</span><br><span class="line"></span><br><span class="line">if (!this.defaultMQProducer.getProducerGroup().equals(MixAll.CLIENT_INNER_PRODUCER_GROUP)) &#123;</span><br><span class="line"></span><br><span class="line">this.defaultMQProducer.changeInstanceNameToPID();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取MQClientInstance,作为生产者与NameServer,Broker沟通的通道</span><br><span class="line"></span><br><span class="line">this.mQClientFactory &#x3D; MQClientManager.getInstance().getAndCreateMQClientInstance(this.defaultMQProducer, rpcHook);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将当前生产者加入到MQClientInstance管理中，方便后续调用网络请求、进行心跳检测</span><br><span class="line"></span><br><span class="line">boolean registerOK &#x3D; mQClientFactory.registerProducer(this.defaultMQProducer.getProducerGroup(), this);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;一个ProductGroup只允许注册一次</span><br><span class="line"></span><br><span class="line">if (!registerOK) &#123;</span><br><span class="line"></span><br><span class="line">this.serviceState &#x3D; ServiceState.CREATE_JUST;</span><br><span class="line"></span><br><span class="line">throw new MQClientException(&quot;The producer group[&quot; + this.defaultMQProducer.getProducerGroup()</span><br><span class="line"></span><br><span class="line">\+ &quot;] has been created before, specify another name please.&quot; + FAQUrl.suggestTodo(FAQUrl.GROUP_NAME_DUPLICATE_URL),</span><br><span class="line"></span><br><span class="line">null);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设置默认主题的路由信息</span><br><span class="line"></span><br><span class="line">this.topicPublishInfoTable.put(this.defaultMQProducer.getCreateTopicKey(), new TopicPublishInfo());</span><br><span class="line"></span><br><span class="line">if (startFactory) &#123;</span><br><span class="line"></span><br><span class="line">mQClientFactory.start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.info(&quot;the producer [&#123;&#125;] start OK. sendMessageWithVIPChannel&#x3D;&#123;&#125;&quot;, this.defaultMQProducer.getProducerGroup(),</span><br><span class="line"></span><br><span class="line">this.defaultMQProducer.isSendMessageWithVIPChannel());</span><br><span class="line"></span><br><span class="line">this.serviceState &#x3D; ServiceState.RUNNING;</span><br><span class="line"></span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">case RUNNING:</span><br><span class="line"></span><br><span class="line">case START_FAILED:</span><br><span class="line"></span><br><span class="line">case SHUTDOWN_ALREADY:</span><br><span class="line"></span><br><span class="line">throw new MQClientException(&quot;The producer service state not OK, maybe started once, &quot;&#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">\+ this.serviceState&#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">\+ FAQUrl.suggestTodo(FAQUrl.CLIENT_SERVICE_NOT_OK),</span><br><span class="line"></span><br><span class="line">null);</span><br><span class="line"></span><br><span class="line">default:</span><br><span class="line"></span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;向各个broker发送心跳包</span><br><span class="line"></span><br><span class="line">this.mQClientFactory.sendHeartbeatToAllBrokerWithLock();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h1><p>* 获取Topic路由信息</p>
<ol>
<li><p>先从缓存topicPublishInfoTable中获取</p>
</li>
<li><p>没有再从NameServer中请求获取</p>
</li>
<li><p>依然没有则使用默认topic（TBW102）的路由信息</p>
</li>
</ol>
<p>* 选择一个MessageQueue进行发送</p>
<p>* 组装requestHeader发送消息</p>
<ol>
<li><p>设置客户端MsgId</p>
</li>
<li><p>超过4K消息压缩设置压缩消息标记</p>
</li>
<li><p>设置事务消息标记</p>
</li>
<li><p>判断发送前钩子执行</p>
</li>
<li><p>消息发送完钩子执行</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SendResult <span class="title">sendDefaultImpl</span><span class="params">(//</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">Message msg, //待发送的消息</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">final</span> CommunicationMode communicationMode, //</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">final</span> SendCallback sendCallback, //</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">final</span> <span class="keyword">long</span> timeout//</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="keyword">throws</span> MQClientException, RemotingException, MQBrokerException, InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//确保初始化完成</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.makeSureStateOK();</span><br><span class="line"></span><br><span class="line"><span class="comment">//消息校验</span></span><br><span class="line"></span><br><span class="line">Validators.checkMessage(msg, <span class="keyword">this</span>.defaultMQProducer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">long</span> invokeID = random.nextLong();</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> beginTimestampFirst = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> beginTimestampPrev = beginTimestampFirst;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> endTimestamp = beginTimestampFirst;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取Topic的路由信息,1.本地缓存 2.NameServer 3.TBW102 默认Topic的路由信息</span></span><br><span class="line"></span><br><span class="line">TopicPublishInfo topicPublishInfo = <span class="keyword">this</span>.tryToFindTopicPublishInfo(msg.getTopic());</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (topicPublishInfo != <span class="keyword">null</span> &amp;&amp; topicPublishInfo.ok()) &#123;</span><br><span class="line"></span><br><span class="line">MessageQueue mq = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">Exception exception = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">SendResult sendResult = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同步发送默认3(1+2)次 其他1次</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//异步发送通过retryTimesWhenSendAsyncFailed来控制，在发送结果返回后再处理</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> timesTotal = communicationMode == CommunicationMode.SYNC ? <span class="number">1</span> + <span class="keyword">this</span>.defaultMQProducer.getRetryTimesWhenSendFailed() : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> times = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">String[] brokersSent = <span class="keyword">new</span> String[timesTotal];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (; times &lt; timesTotal; times++) &#123;</span><br><span class="line"></span><br><span class="line">String lastBrokerName = <span class="keyword">null</span> == mq ? <span class="keyword">null</span> : mq.getBrokerName();</span><br><span class="line"></span><br><span class="line"><span class="comment">//选一个MessageQueue进行发送</span></span><br><span class="line"></span><br><span class="line">MessageQueue tmpmq = <span class="keyword">this</span>.selectOneMessageQueue(topicPublishInfo, lastBrokerName);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tmpmq != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">mq = tmpmq;</span><br><span class="line"></span><br><span class="line">brokersSent[times] = mq.getBrokerName();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">beginTimestampPrev = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">sendResult = <span class="keyword">this</span>.sendKernelImpl(msg, mq, communicationMode, sendCallback, topicPublishInfo, timeout);</span><br><span class="line"></span><br><span class="line">endTimestamp = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (communicationMode) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> ASYNC:</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> ONEWAY:</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> SYNC:</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sendResult.getSendStatus() != SendStatus.SEND_OK) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.defaultMQProducer.isRetryAnotherBrokerWhenNotStoreOK()) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> sendResult;</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line"></span><br><span class="line">endTimestamp = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">log.warn(String.format(<span class="string">&quot;sendKernelImpl exception, resend at once, InvokeID: %s, RT: %sms, Broker: %s&quot;</span>, invokeID, endTimestamp - beginTimestampPrev, mq), e);</span><br><span class="line"></span><br><span class="line">log.warn(msg.toString());</span><br><span class="line"></span><br><span class="line">exception = e;</span><br><span class="line"></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (MQClientException e) &#123;</span><br><span class="line"></span><br><span class="line">endTimestamp = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">log.warn(String.format(<span class="string">&quot;sendKernelImpl exception, resend at once, InvokeID: %s, RT: %sms, Broker: %s&quot;</span>, invokeID, endTimestamp - beginTimestampPrev, mq), e);</span><br><span class="line"></span><br><span class="line">log.warn(msg.toString());</span><br><span class="line"></span><br><span class="line">exception = e;</span><br><span class="line"></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (MQBrokerException e) &#123;</span><br><span class="line"></span><br><span class="line">endTimestamp = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">log.warn(String.format(<span class="string">&quot;sendKernelImpl exception, resend at once, InvokeID: %s, RT: %sms, Broker: %s&quot;</span>, invokeID, endTimestamp - beginTimestampPrev, mq), e);</span><br><span class="line"></span><br><span class="line">log.warn(msg.toString());</span><br><span class="line"></span><br><span class="line">exception = e;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (e.getResponseCode()) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> ResponseCode.TOPIC_NOT_EXIST:</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> ResponseCode.SERVICE_NOT_AVAILABLE:</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> ResponseCode.SYSTEM_ERROR:</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> ResponseCode.NO_PERMISSION:</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> ResponseCode.NO_BUYER_ID:</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> ResponseCode.NOT_IN_CURRENT_UNIT:</span><br><span class="line"></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sendResult != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> sendResult;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">throw</span> e;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">endTimestamp = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">log.warn(String.format(<span class="string">&quot;sendKernelImpl exception, throw exception, InvokeID: %s, RT: %sms, Broker: %s&quot;</span>, invokeID, endTimestamp - beginTimestampPrev, mq), e);</span><br><span class="line"></span><br><span class="line">log.warn(msg.toString());</span><br><span class="line"></span><br><span class="line">log.warn(<span class="string">&quot;sendKernelImpl exception&quot;</span>, e);</span><br><span class="line"></span><br><span class="line">log.warn(msg.toString());</span><br><span class="line"></span><br><span class="line"><span class="keyword">throw</span> e;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sendResult != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> sendResult;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String info = String.format(<span class="string">&quot;Send [%d] times, still failed, cost [%d]ms, Topic: %s, BrokersSent: %s&quot;</span>,</span><br><span class="line"></span><br><span class="line">times,</span><br><span class="line"></span><br><span class="line">System.currentTimeMillis() - beginTimestampFirst,</span><br><span class="line"></span><br><span class="line">msg.getTopic(),</span><br><span class="line"></span><br><span class="line">Arrays.toString(brokersSent));</span><br><span class="line"></span><br><span class="line">info += FAQUrl.suggestTodo(FAQUrl.SEND_MSG_FAILED);</span><br><span class="line"></span><br><span class="line">MQClientException mqClientException = <span class="keyword">new</span> MQClientException(info, exception);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (exception <span class="keyword">instanceof</span> MQBrokerException) &#123;</span><br><span class="line"></span><br><span class="line">mqClientException.setResponseCode(((MQBrokerException) exception).getResponseCode());</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> RemotingConnectException) &#123;</span><br><span class="line"></span><br><span class="line">mqClientException.setResponseCode(ClientErrorCode.CONNECT_BROKER_EXCEPTION);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> RemotingTimeoutException) &#123;</span><br><span class="line"></span><br><span class="line">mqClientException.setResponseCode(ClientErrorCode.ACCESS_BROKER_TIMEOUT);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> MQClientException) &#123;</span><br><span class="line"></span><br><span class="line">mqClientException.setResponseCode(ClientErrorCode.BROKER_NOT_EXIST_EXCEPTION);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">throw</span> mqClientException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//没有设置NameServer地址错误</span></span><br><span class="line"></span><br><span class="line">List&lt;String&gt; nsList = <span class="keyword">this</span>.getmQClientFactory().getMQClientAPIImpl().getNameServerAddressList();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> == nsList || nsList.isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;No name server address, please set it.&quot;</span> + FAQUrl.suggestTodo(FAQUrl.NAME_SERVER_ADDR_NOT_EXIST_URL), <span class="keyword">null</span>).setResponseCode(ClientErrorCode.NO_NAME_SERVER_EXCEPTION);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送抛错没有找到Topic路由信息</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">&quot;No route info of this topic, &quot;</span> + msg.getTopic() + FAQUrl.suggestTodo(FAQUrl.NO_TOPIC_ROUTE_INFO),</span><br><span class="line"></span><br><span class="line"><span class="keyword">null</span>).setResponseCode(ClientErrorCode.NOT_FOUND_TOPIC_EXCEPTION);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> SendResult <span class="title">sendKernelImpl</span><span class="params">(<span class="keyword">final</span> Message msg, //待发送的消息</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">final</span> MessageQueue mq, //将消息发送到该队列上</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">final</span> CommunicationMode communicationMode, //消息发送模式，SYNC、ASYNC、ONEWAY</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">final</span> SendCallback sendCallback, //异步消息回调函数</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">final</span> TopicPublishInfo topicPublishInfo, //主题路由信息</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">final</span> <span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> MQClientException, RemotingException, MQBrokerException, InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">String brokerAddr = <span class="keyword">this</span>.mQClientFactory.findBrokerAddressInPublish(mq.getBrokerName());</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> == brokerAddr) &#123;</span><br><span class="line"></span><br><span class="line">tryToFindTopicPublishInfo(mq.getTopic());</span><br><span class="line"></span><br><span class="line">brokerAddr = <span class="keyword">this</span>.mQClientFactory.findBrokerAddressInPublish(mq.getBrokerName());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SendMessageContext context = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (brokerAddr != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">brokerAddr = MixAll.brokerVIPChannel(<span class="keyword">this</span>.defaultMQProducer.isSendMessageWithVIPChannel(), brokerAddr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] prevBody = msg.getBody();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//for MessageBatch,ID has been set in the generating process</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置客户端MsgId</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!(msg <span class="keyword">instanceof</span> MessageBatch)) &#123;</span><br><span class="line"></span><br><span class="line">MessageClientIDSetter.setUniqID(msg);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sysFlag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//超过4K消息压缩 压缩消息标记</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.tryToCompressMessage(msg)) &#123;</span><br><span class="line"></span><br><span class="line">sysFlag |= MessageSysFlag.COMPRESSED_FLAG;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//事务消息标记</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> String tranMsg = msg.getProperty(MessageConst.PROPERTY_TRANSACTION_PREPARED);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tranMsg != <span class="keyword">null</span> &amp;&amp; Boolean.parseBoolean(tranMsg)) &#123;</span><br><span class="line"></span><br><span class="line">sysFlag |= MessageSysFlag.TRANSACTION_PREPARED_TYPE;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//限制发送钩子</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (hasCheckForbiddenHook()) &#123;</span><br><span class="line"></span><br><span class="line">CheckForbiddenContext checkForbiddenContext = <span class="keyword">new</span> CheckForbiddenContext();</span><br><span class="line"></span><br><span class="line">checkForbiddenContext.setNameSrvAddr(<span class="keyword">this</span>.defaultMQProducer.getNamesrvAddr());</span><br><span class="line"></span><br><span class="line">checkForbiddenContext.setGroup(<span class="keyword">this</span>.defaultMQProducer.getProducerGroup());</span><br><span class="line"></span><br><span class="line">checkForbiddenContext.setCommunicationMode(communicationMode);</span><br><span class="line"></span><br><span class="line">checkForbiddenContext.setBrokerAddr(brokerAddr);</span><br><span class="line"></span><br><span class="line">checkForbiddenContext.setMessage(msg);</span><br><span class="line"></span><br><span class="line">checkForbiddenContext.setMq(mq);</span><br><span class="line"></span><br><span class="line">checkForbiddenContext.setUnitMode(<span class="keyword">this</span>.isUnitMode());</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.executeCheckForbiddenHook(checkForbiddenContext);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送前钩子</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.hasSendMessageHook()) &#123;</span><br><span class="line"></span><br><span class="line">context = <span class="keyword">new</span> SendMessageContext();</span><br><span class="line"></span><br><span class="line">context.setProducer(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">context.setProducerGroup(<span class="keyword">this</span>.defaultMQProducer.getProducerGroup());</span><br><span class="line"></span><br><span class="line">context.setCommunicationMode(communicationMode);</span><br><span class="line"></span><br><span class="line">context.setBornHost(<span class="keyword">this</span>.defaultMQProducer.getClientIP());</span><br><span class="line"></span><br><span class="line">context.setBrokerAddr(brokerAddr);</span><br><span class="line"></span><br><span class="line">context.setMessage(msg);</span><br><span class="line"></span><br><span class="line">context.setMq(mq);</span><br><span class="line"></span><br><span class="line">String isTrans = msg.getProperty(MessageConst.PROPERTY_TRANSACTION_PREPARED);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isTrans != <span class="keyword">null</span> &amp;&amp; isTrans.equals(<span class="string">&quot;true&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">context.setMsgType(MessageType.Trans_Msg_Half);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (msg.getProperty(<span class="string">&quot;__STARTDELIVERTIME&quot;</span>) != <span class="keyword">null</span> || msg.getProperty(MessageConst.PROPERTY_DELAY_TIME_LEVEL) != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">context.setMsgType(MessageType.Delay_Msg);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.executeSendMessageHookBefore(context);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//组装RequestHeader</span></span><br><span class="line"></span><br><span class="line">SendMessageRequestHeader requestHeader = <span class="keyword">new</span> SendMessageRequestHeader();</span><br><span class="line"></span><br><span class="line">requestHeader.setProducerGroup(<span class="keyword">this</span>.defaultMQProducer.getProducerGroup());<span class="comment">//生产者组</span></span><br><span class="line"></span><br><span class="line">requestHeader.setTopic(msg.getTopic());<span class="comment">//主题名称</span></span><br><span class="line"></span><br><span class="line">requestHeader.setDefaultTopic(<span class="keyword">this</span>.defaultMQProducer.getCreateTopicKey());<span class="comment">//默认创建主题key</span></span><br><span class="line"></span><br><span class="line">requestHeader.setDefaultTopicQueueNums(<span class="keyword">this</span>.defaultMQProducer.getDefaultTopicQueueNums());<span class="comment">//队列数量</span></span><br><span class="line"></span><br><span class="line">requestHeader.setQueueId(mq.getQueueId());<span class="comment">//队列ID</span></span><br><span class="line"></span><br><span class="line">requestHeader.setSysFlag(sysFlag);<span class="comment">//消息系统标记 标志压缩，事务消息</span></span><br><span class="line"></span><br><span class="line">requestHeader.setBornTimestamp(System.currentTimeMillis());<span class="comment">//消息发送时间</span></span><br><span class="line"></span><br><span class="line">requestHeader.setFlag(msg.getFlag());<span class="comment">//消息标记，RocketMQ中不做处理</span></span><br><span class="line"></span><br><span class="line">requestHeader.setProperties(MessageDecoder.messageProperties2String(msg.getProperties()));<span class="comment">//消息扩展属性</span></span><br><span class="line"></span><br><span class="line">requestHeader.setReconsumeTimes(<span class="number">0</span>);<span class="comment">//重试第一次为0</span></span><br><span class="line"></span><br><span class="line">requestHeader.setUnitMode(<span class="keyword">this</span>.isUnitMode());<span class="comment">//问题？：默认false不清楚做何使用</span></span><br><span class="line"></span><br><span class="line">requestHeader.setBatch(msg <span class="keyword">instanceof</span> MessageBatch);<span class="comment">//是否批量消息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//重试队列设置requestHeader</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (requestHeader.getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取已消费的次数</span></span><br><span class="line"></span><br><span class="line">String reconsumeTimes = MessageAccessor.getReconsumeTime(msg);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (reconsumeTimes != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">requestHeader.setReconsumeTimes(Integer.valueOf(reconsumeTimes));</span><br><span class="line"></span><br><span class="line">MessageAccessor.clearProperty(msg, MessageConst.PROPERTY_RECONSUME_TIME);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最大消费次数</span></span><br><span class="line"></span><br><span class="line">String maxReconsumeTimes = MessageAccessor.getMaxReconsumeTimes(msg);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (maxReconsumeTimes != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">requestHeader.setMaxReconsumeTimes(Integer.valueOf(maxReconsumeTimes));</span><br><span class="line"></span><br><span class="line">MessageAccessor.clearProperty(msg, MessageConst.PROPERTY_MAX_RECONSUME_TIMES);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用通道发送消息</span></span><br><span class="line"></span><br><span class="line">SendResult sendResult = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (communicationMode) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> ASYNC:</span><br><span class="line"></span><br><span class="line">sendResult = <span class="keyword">this</span>.mQClientFactory.getMQClientAPIImpl().sendMessage(<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">brokerAddr, <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">mq.getBrokerName(), <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">msg, <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">requestHeader, <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">timeout, <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">communicationMode, <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line">sendCallback, <span class="comment">// 7</span></span><br><span class="line"></span><br><span class="line">topicPublishInfo, <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.mQClientFactory, <span class="comment">// 9</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.defaultMQProducer.getRetryTimesWhenSendAsyncFailed(), <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">context, <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> ONEWAY:</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> SYNC:</span><br><span class="line"></span><br><span class="line">sendResult = <span class="keyword">this</span>.mQClientFactory.getMQClientAPIImpl().sendMessage(</span><br><span class="line"></span><br><span class="line">brokerAddr,</span><br><span class="line"></span><br><span class="line">mq.getBrokerName(),</span><br><span class="line"></span><br><span class="line">msg,</span><br><span class="line"></span><br><span class="line">requestHeader,</span><br><span class="line"></span><br><span class="line">timeout,</span><br><span class="line"></span><br><span class="line">communicationMode,</span><br><span class="line"></span><br><span class="line">context,</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消息发送完毕钩子</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.hasSendMessageHook()) &#123;</span><br><span class="line"></span><br><span class="line">context.setSendResult(sendResult);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.executeSendMessageHookAfter(context);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> sendResult;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.hasSendMessageHook()) &#123;</span><br><span class="line"></span><br><span class="line">context.setException(e);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.executeSendMessageHookAfter(context);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">throw</span> e;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (MQBrokerException e) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.hasSendMessageHook()) &#123;</span><br><span class="line"></span><br><span class="line">context.setException(e);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.executeSendMessageHookAfter(context);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">throw</span> e;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.hasSendMessageHook()) &#123;</span><br><span class="line"></span><br><span class="line">context.setException(e);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.executeSendMessageHookAfter(context);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">throw</span> e;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">msg.setBody(prevBody);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">&quot;The broker[&quot;</span> + mq.getBrokerName() + <span class="string">&quot;] not exist&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ41# RocketMQ特性--事物消息</title>
    <url>/posts/2f29fd72/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="问题思考"><a href="#问题思考" class="headerlink" title="问题思考"></a>问题思考</h1><p>从官方给的例子入手，代码如下:</p>
<p>示例类：org.apache.rocketmq.example.transaction.TransactionProducer.java</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) throws MQClientException, InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@1 定义TransactionListener</span><br><span class="line"></span><br><span class="line">TransactionListener transactionListener &#x3D; new TransactionListenerImpl();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@2 使用事务发送Producer</span><br><span class="line"></span><br><span class="line">TransactionMQProducer producer &#x3D; new TransactionMQProducer(&quot;please_rename_unique_group_name&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@3 定义线程池</span><br><span class="line"></span><br><span class="line">ExecutorService executorService &#x3D; new ThreadPoolExecutor(2, 5, 100, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(2000), new ThreadFactory() &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line"></span><br><span class="line">public Thread newThread(Runnable r) &#123;</span><br><span class="line"></span><br><span class="line">Thread thread &#x3D; new Thread(r);</span><br><span class="line"></span><br><span class="line">thread.setName(&quot;client-transaction-msg-check-thread&quot;);</span><br><span class="line"></span><br><span class="line">return thread;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设置线程池</span><br><span class="line"></span><br><span class="line">producer.setExecutorService(executorService);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设置监听器</span><br><span class="line"></span><br><span class="line">producer.setTransactionListener(transactionListener);</span><br><span class="line"></span><br><span class="line">producer.setNamesrvAddr(&quot;127.0.0.1:9876&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@4 发送者启动</span><br><span class="line"></span><br><span class="line">producer.start();</span><br><span class="line"></span><br><span class="line">String[] tags &#x3D; new String[] &#123;&quot;TagA&quot;, &quot;TagB&quot;, &quot;TagC&quot;, &quot;TagD&quot;, &quot;TagE&quot;&#125;;</span><br><span class="line"></span><br><span class="line">for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">Message msg &#x3D;</span><br><span class="line"></span><br><span class="line">new Message(&quot;TopicTest1234&quot;, tags[i % tags.length], &quot;KEY&quot; + i,</span><br><span class="line"></span><br><span class="line">(&quot;Hello RocketMQ &quot; + i).getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@5 消息发送</span><br><span class="line"></span><br><span class="line">SendResult sendResult &#x3D; producer.sendMessageInTransaction(msg, null);</span><br><span class="line"></span><br><span class="line">System.out.printf(&quot;%s%n&quot;, sendResult);</span><br><span class="line"></span><br><span class="line">Thread.sleep(10);</span><br><span class="line"></span><br><span class="line">&#125; catch (MQClientException | UnsupportedEncodingException e) &#123;</span><br><span class="line"></span><br><span class="line">e.printStackTrace();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (int i &#x3D; 0; i &lt; 100000; i++) &#123;</span><br><span class="line"></span><br><span class="line">Thread.sleep(1000);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;发送者关闭</span><br><span class="line"></span><br><span class="line">producer.shutdown();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>从上面客户端例子中思考一些问题：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. @1定义TransactionListener做什么用？</span><br><span class="line">2. @2定义的TransactionMQProducer与普通Produer区别在哪里？</span><br><span class="line">3. @3定义线程池executorService又是干啥的？</span><br><span class="line">4. @4事务发送者启动发送流程是怎么样？</span><br><span class="line">5. 发送事务消息如何和Broker进行交互的？</span><br></pre></td></tr></table></figure>



<h1 id="事务消息客户端发送流程"><a href="#事务消息客户端发送流程" class="headerlink" title="事务消息客户端发送流程"></a>事务消息客户端发送流程</h1><h2 id="事务发送与普通启动差异"><a href="#事务发送与普通启动差异" class="headerlink" title="事务发送与普通启动差异"></a>事务发送与普通启动差异</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@1 producer.start();</span><br><span class="line"></span><br><span class="line">@2 TransactionMQProducer#start</span><br><span class="line"></span><br><span class="line">this.defaultMQProducerImpl.initTransactionEnv();</span><br><span class="line"></span><br><span class="line">super.start();</span><br><span class="line"></span><br><span class="line">@3 DefaultMQProducerImpl#initTransactionEnv()</span><br><span class="line"></span><br><span class="line">this.checkExecutor &#x3D; producer.getExecutorService();</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：事务发送时比普通发送启动多了initTransactionEnv操作，即：给ExecutorService checkExecutor赋值。</span><br></pre></td></tr></table></figure>



<h2 id="事务消息发送调用链"><a href="#事务消息发送调用链" class="headerlink" title="事务消息发送调用链"></a>事务消息发送调用链</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@1 SendResult sendResult &#x3D; producer.sendMessageInTransaction</span><br><span class="line"></span><br><span class="line">@2 TransactionMQProducer#sendMessageInTransaction</span><br><span class="line"></span><br><span class="line">@3 DefaultMQProducerImpl#sendMessageInTransaction</span><br></pre></td></tr></table></figure>



<h2 id="事务消息发送分析"><a href="#事务消息发送分析" class="headerlink" title="事务消息发送分析"></a>事务消息发送分析</h2><p>方法：DefaultMQProducerImpl#sendMessageInTransaction</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;@1</span><br><span class="line"></span><br><span class="line">TransactionListener transactionListener &#x3D; getCheckListener();</span><br><span class="line"></span><br><span class="line">if (null &#x3D;&#x3D; localTransactionExecuter &amp;&amp; null &#x3D;&#x3D; transactionListener) &#123;</span><br><span class="line"></span><br><span class="line">throw new MQClientException(&quot;tranExecutor is null&quot;, null);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Validators.checkMessage(msg, this.defaultMQProducer);</span><br><span class="line"></span><br><span class="line">SendResult sendResult &#x3D; null;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@2 表示消息的prepare消息</span><br><span class="line"></span><br><span class="line">MessageAccessor.putProperty(msg, MessageConst.PROPERTY_TRANSACTION_PREPARED, &quot;true&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@3 生产者组，用于回查本地事务事，从生产者组中选择随机选择一个生产者即可</span><br><span class="line"></span><br><span class="line">MessageAccessor.putProperty(msg, MessageConst.PROPERTY_PRODUCER_GROUP, this.defaultMQProducer.getProducerGroup());</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@4 消息发送</span><br><span class="line"></span><br><span class="line">sendResult &#x3D; this.send(msg);</span><br><span class="line"></span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">throw new MQClientException(&quot;send message Exception&quot;, e);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>方法：DefaultMQProducerImpl#sendKernelImpl</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;事务消息发送，设置PREPARED标记</span><br><span class="line"></span><br><span class="line">final String tranMsg &#x3D; msg.getProperty(MessageConst.PROPERTY_TRANSACTION_PREPARED);</span><br><span class="line"></span><br><span class="line">if (tranMsg !&#x3D; null &amp;&amp; Boolean.parseBoolean(tranMsg)) &#123;</span><br><span class="line"></span><br><span class="line">sysFlag |&#x3D; MessageSysFlag.TRANSACTION_PREPARED_TYPE;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@5 请求header中设置事务标记</span><br><span class="line"></span><br><span class="line">requestHeader.setSysFlag(sysFlag);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@6 发送消息请求的RequestCode</span><br><span class="line"></span><br><span class="line">request &#x3D; RemotingCommand.createRequestCommand(RequestCode.SEND_MESSAGE, requestHeader);</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：</span><br><span class="line">@1获取TransactionListener即示例代码传入的Listener</span><br><span class="line">@2在消息属性中加入PROPERTY_TRANSACTION_PREPARED &#x3D; &quot;TRAN_MSG&quot;即事务半消息</span><br><span class="line">@3设置ProducerGroup Broker在事务回查时调用</span><br><span class="line">@4事务消息发送采用同步发送，发送流程与普通消息发送一致</span><br><span class="line">@5请求header中设置事务标记SEND_MESSAGE &#x3D; 10</span><br></pre></td></tr></table></figure>



<h2 id="事务消息发送结果分析"><a href="#事务消息发送结果分析" class="headerlink" title="事务消息发送结果分析"></a>事务消息发送结果分析</h2><p>方法：DefaultMQProducerImpl#sendMessageInTransaction</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LocalTransactionState localTransactionState &#x3D; LocalTransactionState.UNKNOW;</span><br><span class="line"></span><br><span class="line">switch (sendResult.getSendStatus()) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@1</span><br><span class="line"></span><br><span class="line">case SEND_OK: &#123;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@2 执行本地事务</span><br><span class="line"></span><br><span class="line">localTransactionState &#x3D; transactionListener.executeLocalTransaction(msg, arg);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">case FLUSH_DISK_TIMEOUT:</span><br><span class="line"></span><br><span class="line">case FLUSH_SLAVE_TIMEOUT:</span><br><span class="line"></span><br><span class="line">case SLAVE_NOT_AVAILABLE:</span><br><span class="line"></span><br><span class="line">localTransactionState &#x3D; LocalTransactionState.ROLLBACK_MESSAGE;</span><br><span class="line"></span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">default:</span><br><span class="line"></span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：</span><br><span class="line">@1 发送半消息（Prepared）消息成功，设置transactionId。</span><br><span class="line">@2 发送半消息成功后，通过transactionListener回调客户端查询本地事务执行情况，并返回事务执行状态。</span><br><span class="line">LocalTransactionState有COMMIT_MESSAGE、ROLLBACK_MESSAGE、UNKNOW三种状态。</span><br></pre></td></tr></table></figure>



<h2 id="结束事务分析"><a href="#结束事务分析" class="headerlink" title="结束事务分析"></a>结束事务分析</h2><p>方法：DefaultMQProducerImpl#sendMessageInTransaction</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@1 结束事务，根据返回的事务状态执行提交、回滚、暂时不处理</span><br><span class="line"></span><br><span class="line">this.endTransaction(sendResult, localTransactionState, localException);</span><br><span class="line"></span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">log.warn(&quot;local transaction execute &quot; + localTransactionState + &quot;, but end broker transaction failed&quot;, e);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TransactionSendResult transactionSendResult &#x3D; new TransactionSendResult();</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">return transactionSendResult;</span><br></pre></td></tr></table></figure>



<p>方法：DefaultMQProducerImpl#endTransaction</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">switch (localTransactionState) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@2 设置事务提交标记Header</span><br><span class="line"></span><br><span class="line">case COMMIT_MESSAGE: requestHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_COMMIT_TYPE);</span><br><span class="line"></span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@3 设置事务回滚标记Header</span><br><span class="line"></span><br><span class="line">case ROLLBACK_MESSAGE:</span><br><span class="line"></span><br><span class="line">requestHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_ROLLBACK_TYPE);</span><br><span class="line"></span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@4 设置事务未知标记Header</span><br><span class="line"></span><br><span class="line">case UNKNOW:</span><br><span class="line"></span><br><span class="line">requestHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_NOT_TYPE);</span><br><span class="line"></span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">default:</span><br><span class="line"></span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@5 通过一次发送方式向Broker提交事务 this.mQClientFactory.getMQClientAPIImpl().endTransactionOneway(brokerAddr, requestHeader, remark,</span><br><span class="line"></span><br><span class="line">this.defaultMQProducer.getSendMsgTimeout());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：</span><br><span class="line">@1 根据本地事务执行返回的状态localTransactionState，调用结束事务方法</span><br><span class="line">@2 requestHeader设置事务提交标记0x2 &lt;&lt; 2&#x3D;8</span><br><span class="line">@3 requestHeader设置事务回滚标记0x3 &lt;&lt; 2&#x3D;12</span><br><span class="line">@4 requestHeader设置未知标记0</span><br><span class="line">@5 通过一次发送方式向Broker提交事务 RequestCode为END_TRANSACTION &#x3D; 37</span><br></pre></td></tr></table></figure>



<h1 id="事务消息服务端存储流程"><a href="#事务消息服务端存储流程" class="headerlink" title="事务消息服务端存储流程"></a>事务消息服务端存储流程</h1><h2 id="事务消息存储调用链"><a href="#事务消息存储调用链" class="headerlink" title="事务消息存储调用链"></a>事务消息存储调用链</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@1 SendMessageProcessor#processRequest</span><br><span class="line"></span><br><span class="line">response &#x3D; this.sendMessage(ctx, request, mqtraceContext, requestHeader)</span><br><span class="line"></span><br><span class="line">@2 SendMessageProcessor#sendMessage</span><br></pre></td></tr></table></figure>



<h2 id="事务半消息存储代码分析（一）"><a href="#事务半消息存储代码分析（一）" class="headerlink" title="事务半消息存储代码分析（一）"></a>事务半消息存储代码分析（一）</h2><p>方法：SendMessageProcessor#sendMessage</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;@1 可以通过配置来是否接受事务消息存储</span><br><span class="line"></span><br><span class="line">if (traFlag !&#x3D; null &amp;&amp; Boolean.parseBoolean(traFlag)) &#123;</span><br><span class="line"></span><br><span class="line">if (this.brokerController.getBrokerConfig().isRejectTransactionMessage())&#123;</span><br><span class="line"></span><br><span class="line">response.setCode(ResponseCode.NO_PERMISSION);</span><br><span class="line"></span><br><span class="line">response.setRemark(</span><br><span class="line"></span><br><span class="line">&quot;the broker[&quot; + this.brokerController.getBrokerConfig().getBrokerIP1()</span><br><span class="line"></span><br><span class="line">\+ &quot;] sending transaction message is forbidden&quot;);</span><br><span class="line"></span><br><span class="line">return response;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@2 prepare消息存储</span><br><span class="line"></span><br><span class="line">putMessageResult &#x3D; this.brokerController.getTransactionalMessageService().prepareMessage(msgInner);</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line"></span><br><span class="line">putMessageResult &#x3D; this.brokerController.getMessageStore().putMessage(msgInner);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：</span><br><span class="line">@1 可以通过Broker配置属性rejectTransactionMessage来决定是否接受事务消息请求，默认为false即接受。</span><br><span class="line">@2 半消息存储</span><br></pre></td></tr></table></figure>



<!--more-->



<h2 id="事务半消息存储代码分析（二）"><a href="#事务半消息存储代码分析（二）" class="headerlink" title="事务半消息存储代码分析（二）"></a>事务半消息存储代码分析（二）</h2><p>方法：TransactionalMessageBridge#putHalfMessage</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public PutMessageResult putHalfMessage(MessageExtBrokerInner messageInner)&#123;</span><br><span class="line"></span><br><span class="line">return store.putMessage(parseHalfMessageInner(messageInner));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>方法：TransactionalMessageBridge#parseHalfMessageInner</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;@1 备份原主题</span><br><span class="line"></span><br><span class="line">MessageAccessor.putProperty(msgInner, MessageConst.PROPERTY_REAL_TOPIC, msgInner.getTopic());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@2 备份原queueID</span><br><span class="line"></span><br><span class="line">MessageAccessor.putProperty(msgInner, MessageConst.PROPERTY_REAL_QUEUE_ID,</span><br><span class="line"></span><br><span class="line">String.valueOf(msgInner.getQueueId()));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@3 重置sysFlag</span><br><span class="line"></span><br><span class="line">msgInner.setSysFlag(</span><br><span class="line"></span><br><span class="line">MessageSysFlag.resetTransactionValue(msgInner.getSysFlag(), MessageSysFlag.TRANSACTION_NOT_TYPE));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@3 主题变更 RMQ_SYS_TRANS_HALF_TOPIC</span><br><span class="line"></span><br><span class="line">msgInner.setTopic(TransactionalMessageUtil.buildHalfTopic());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@4 消息队列变更为0</span><br><span class="line"></span><br><span class="line">msgInner.setQueueId(0);</span><br><span class="line"></span><br><span class="line">msgInner.setPropertiesString(MessageDecoder.messageProperties2String(msgInner.getProperties()));</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：半消息在存储前将存储的主题设置为RMQ_SYS_TRANS_HALF_TOPIC，将原来的Topic备份到属性中，同时也备份了原来的QueueId。这也是为什么半消息不会被消费者消费的原因。</span><br></pre></td></tr></table></figure>

<h1 id="事务消息服务端响应结束事务请求"><a href="#事务消息服务端响应结束事务请求" class="headerlink" title="事务消息服务端响应结束事务请求"></a>事务消息服务端响应结束事务请求</h1><h2 id="处理未知类型请求"><a href="#处理未知类型请求" class="headerlink" title="处理未知类型请求"></a>处理未知类型请求</h2><p>方法：EndTransactionProcessor#processRequest</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">case MessageSysFlag.TRANSACTION_NOT_TYPE: &#123;</span><br><span class="line"></span><br><span class="line">LOGGER.warn(&quot;The producer[&#123;&#125;] end transaction in sending message, and it&#39;s pending status.&quot;</span><br><span class="line"></span><br><span class="line">\+ &quot;RequestHeader: &#123;&#125; Remark: &#123;&#125;&quot;,</span><br><span class="line"></span><br><span class="line">RemotingHelper.parseChannelRemoteAddr(ctx.channel()),</span><br><span class="line"></span><br><span class="line">requestHeader.toString(),</span><br><span class="line"></span><br><span class="line">request.getRemark());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@1</span><br><span class="line"></span><br><span class="line">return null;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：结束事务在处理未知类型TRANSACTION_NOT_TYPE时，只打印告警日志不做处理。</span><br></pre></td></tr></table></figure>



<h2 id="处理事务提交请求"><a href="#处理事务提交请求" class="headerlink" title="处理事务提交请求"></a>处理事务提交请求</h2><p>半消息查找。方法：EndTransactionProcessor#processRequest</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (MessageSysFlag.TRANSACTION_COMMIT_TYPE</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D; requestHeader.getCommitOrRollback())&#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@1 将prepare消息找出来</span><br><span class="line"></span><br><span class="line">result &#x3D; this.brokerController.getTransactionalMessageService()</span><br><span class="line"></span><br><span class="line">.commitMessage(requestHeader);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@2</span><br><span class="line"></span><br><span class="line">MessageExtBrokerInner msgInner &#x3D; endMessageTransaction(result.getPrepareMessage());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>半消息还原。方法：EndTransactionProcessor#endMessageTransaction</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MessageExtBrokerInner msgInner &#x3D; new MessageExtBrokerInner();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@3 置换为原来的Topic</span><br><span class="line"></span><br><span class="line">msgInner.setTopic(msgExt.getUserProperty(MessageConst.PROPERTY_REAL_TOPIC));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@4 置换为原来的QueueId</span><br><span class="line"></span><br><span class="line">msgInner.setQueueId(Integer.parseInt(msgExt.getUserProperty(MessageConst.PROPERTY_REAL_QUEUE_ID)));</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;清除属性设置</span><br><span class="line"></span><br><span class="line">MessageAccessor.clearProperty(msgInner, MessageConst.PROPERTY_REAL_TOPIC);</span><br><span class="line"></span><br><span class="line">MessageAccessor.clearProperty(msgInner, MessageConst.PROPERTY_REAL_QUEUE_ID);</span><br><span class="line"></span><br><span class="line">return msgInner;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：</span><br><span class="line">@1 根据偏移量将半消息查找出来</span><br><span class="line">@2 将存储在RMQ_SYS_TRANS_HALF_TOPIC还原</span><br><span class="line">@3 置换为原来的Topic</span><br><span class="line">@4 置换为原来的QueueId</span><br></pre></td></tr></table></figure>



<p>还原后消息存储。方法：EndTransactionProcessor#processRequest</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;@1 新组装的消息存储（提交）</span><br><span class="line"></span><br><span class="line">RemotingCommand sendResult &#x3D; sendFinalMessage(msgInner);</span><br><span class="line"></span><br><span class="line">if (sendResult.getCode() &#x3D;&#x3D; ResponseCode.SUCCESS) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@2 删除prepare消息 是将消息存储于RMQ_SYS_TRANS_OP_HALF_TOPIC中</span><br><span class="line"></span><br><span class="line">this.brokerController.getTransactionalMessageService().deletePrepareMessage(result.getPrepareMessage());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：</span><br><span class="line">@1 将还原后的消息存储</span><br><span class="line">@2 删除半消息消息</span><br></pre></td></tr></table></figure>

<p>半消息删除。方法：TransactionalMessageServiceImpl#putOpMessage</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean putOpMessage(MessageExt messageExt, String opType) &#123;</span><br><span class="line"></span><br><span class="line">MessageQueue messageQueue &#x3D; new MessageQueue(messageExt.getTopic(),</span><br><span class="line"></span><br><span class="line">this.brokerController.getBrokerConfig().getBrokerName(), messageExt.getQueueId());</span><br><span class="line"></span><br><span class="line">if (TransactionalMessageUtil.REMOVETAG.equals(opType)) &#123;</span><br><span class="line"></span><br><span class="line">return addRemoveTagInTransactionOp(messageExt, messageQueue);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return true;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private boolean addRemoveTagInTransactionOp(MessageExt messageExt, MessageQueue messageQueue) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@1 主题变更为RMQ_SYS_TRANS_OP_HALF_TOPIC</span><br><span class="line"></span><br><span class="line">Message message &#x3D; new Message(TransactionalMessageUtil.buildOpTopic(), TransactionalMessageUtil.REMOVETAG, String.valueOf(messageExt.getQueueOffset()).getBytes(TransactionalMessageUtil.charset));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@2 存储消息</span><br><span class="line"></span><br><span class="line">writeOp(message, messageQueue);</span><br><span class="line"></span><br><span class="line">return true;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：半消息的删除是将Topic从RMQ_SYS_TRANS_HALF_TOPIC变更为RMQ_SYS_TRANS_OP_HALF_TOPIC存储到日志文件，依靠文件删除机制删除。</span><br></pre></td></tr></table></figure>

<h2 id="处理事务回滚请求"><a href="#处理事务回滚请求" class="headerlink" title="处理事务回滚请求"></a>处理事务回滚请求</h2><p>方法：EndTransactionProcessor#processRequest</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;@1 查找半消息</span><br><span class="line"></span><br><span class="line">result &#x3D; this.brokerController.getTransactionalMessageService().rollbackMessage(requestHeader);</span><br><span class="line"></span><br><span class="line">if (result.getResponseCode() &#x3D;&#x3D; ResponseCode.SUCCESS) &#123;</span><br><span class="line"></span><br><span class="line">if (res.getCode() &#x3D;&#x3D; ResponseCode.SUCCESS) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@2 删除prepare消息 是将消息存储于RMQ_SYS_TRANS_OP_HALF_TOPIC中 this.brokerController.getTransactionalMessageService().deletePrepareMessage(result.getPrepareMessage());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return res;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：处理事务回滚请求，将半消息查找出来，将其删除即：将Topic从RMQ_SYS_TRANS_HALF_TOPIC变更为RMQ_SYS_TRANS_OP_HALF_TOPIC并存储，依靠文件删除机制删除。</span><br></pre></td></tr></table></figure>



<h1 id="事务消息服务端状态回查"><a href="#事务消息服务端状态回查" class="headerlink" title="事务消息服务端状态回查"></a>事务消息服务端状态回查</h1><h2 id="事务回查线程类调用链"><a href="#事务回查线程类调用链" class="headerlink" title="事务回查线程类调用链"></a>事务回查线程类调用链</h2><p>线程类初始化：TransactionalMessageCheckService</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@1 main(String[] args)</span><br><span class="line"></span><br><span class="line">start(createBrokerController(args));</span><br><span class="line"></span><br><span class="line">@2 createBrokerController</span><br><span class="line"></span><br><span class="line">@3 initialize()</span><br><span class="line"></span><br><span class="line">@4 initialTransaction()</span><br><span class="line"></span><br><span class="line">this.transactionalMessageCheckService &#x3D;</span><br><span class="line"></span><br><span class="line">new TransactionalMessageCheckService(this);</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：在Broker初始化启动时，TransactionalMessageCheckService线程类也随着启动初始化。</span><br></pre></td></tr></table></figure>



<h2 id="事务回查逻辑"><a href="#事务回查逻辑" class="headerlink" title="事务回查逻辑"></a>事务回查逻辑</h2><p>方法：TransactionalMessageCheckService#run</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;@1 时间间隔为60秒</span><br><span class="line"></span><br><span class="line">long checkInterval &#x3D; brokerController.getBrokerConfig().getTransactionCheckInterval();</span><br><span class="line"></span><br><span class="line">while (!this.isStopped()) &#123;</span><br><span class="line"></span><br><span class="line">this.waitForRunning(checkInterval);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>方法：TransactionalMessageCheckService#onWaitEnd</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;@2 transactionTimeOut默认6秒</span><br><span class="line"></span><br><span class="line">long timeout &#x3D; brokerController.getBrokerConfig().getTransactionTimeOut();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@3 最大核查次数为15次</span><br><span class="line"></span><br><span class="line">int checkMax &#x3D; brokerController.getBrokerConfig().getTransactionCheckMax();</span><br><span class="line"></span><br><span class="line">long begin &#x3D; System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">this.brokerController.getTransactionalMessageService().check(timeout, checkMax, this.brokerController.getTransactionalMessageCheckListener());</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：事务回查每隔60秒执行一次，一次执行超时时间为6秒，最大回查次数为15次。</span><br></pre></td></tr></table></figure>



<p>回查逻辑（一）。方法：TransactionalMessageServiceImpl#check</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;@1</span><br><span class="line"></span><br><span class="line">Set&lt;MessageQueue&gt; msgQueues &#x3D; transactionalMessageBridge.fetchMessageQueues(topic);</span><br><span class="line"></span><br><span class="line">for (MessageQueue messageQueue : msgQueues) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取对应的RMQ_SYS_TRANS_OP_HALF_TOPIC中的队列</span><br><span class="line"></span><br><span class="line">MessageQueue opQueue &#x3D; getOpQueue(messageQueue);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;半消息消费队列中偏移量</span><br><span class="line"></span><br><span class="line">long halfOffset &#x3D; transactionalMessageBridge.fetchConsumeOffset(messageQueue);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;OP已删除消费队列中的偏移量</span><br><span class="line"></span><br><span class="line">long opOffset &#x3D; transactionalMessageBridge.fetchConsumeOffset(opQueue);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@2</span><br><span class="line"></span><br><span class="line">PullResult pullResult &#x3D; fillOpRemoveMap(removeMap, opQueue, opOffset, halfOffset, doneOpOffset);</span><br></pre></td></tr></table></figure>



<p>方法：TransactionalMessageServiceImpl#fillOpRemoveMap</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;@3</span><br><span class="line"></span><br><span class="line">PullResult pullResult &#x3D; pullOpMsg(opQueue, pullOffsetOfOp, 32);</span><br><span class="line"></span><br><span class="line">List&lt;MessageExt&gt; opMsg &#x3D; pullResult.getMsgFoundList();</span><br><span class="line"></span><br><span class="line">for (MessageExt opMessageExt : opMsg) &#123;</span><br><span class="line"></span><br><span class="line">Long queueOffset &#x3D; getLong(new String(opMessageExt.getBody(), TransactionalMessageUtil.charset));</span><br><span class="line"></span><br><span class="line">if (TransactionalMessageUtil.REMOVETAG.equals(opMessageExt.getTags())) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;已经处理过的消息即commit和rollback</span><br><span class="line"></span><br><span class="line">if (queueOffset &lt; miniOffset) &#123;</span><br><span class="line"></span><br><span class="line">doneOpOffset.add(opMessageExt.getQueueOffset());</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;已经处理删除过了，但是半消息还没有更新</span><br><span class="line"></span><br><span class="line">removeMap.put(queueOffset, opMessageExt.getQueueOffset());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line"></span><br><span class="line">log.error(&quot;Found a illegal tag in opMessageExt&#x3D; &#123;&#125; &quot;, opMessageExt);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：</span><br><span class="line">@1 从半消息队列中查找消息队列</span><br><span class="line">@2 opQueue队列中的消息均为已经删除的半消息，需要检查下是否已经删除了，当时半消息队列还没有更新。</span><br><span class="line">@3 miniOffset为半消息消费队列中的最大偏移量；queueOffset为删除消费队列的消息偏移量；通过比较两者来确定是否已经删除了，而半消息状态还没有更新，并将这类消息存储在removeMap中。</span><br></pre></td></tr></table></figure>

<p>回查逻辑（二）。方法：TransactionalMessageServiceImpl#check</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while (true) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;查找消息</span><br><span class="line"></span><br><span class="line">GetResult getResult &#x3D; getHalfMsg(messageQueue, i);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@1 已经处理过了，半消息滞后了，偏移量继续递增往下走</span><br><span class="line"></span><br><span class="line">if (removeMap.containsKey(i)) &#123;</span><br><span class="line"></span><br><span class="line">log.info(&quot;Half offset &#123;&#125; has been committed&#x2F;rolled back&quot;, i);</span><br><span class="line"></span><br><span class="line">removeMap.remove(i);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@2 needSkip 超过存储时间（默认3天） needDiscard 超过回查次数，默认15次</span><br><span class="line"></span><br><span class="line">if (needDiscard(msgExt, transactionCheckMax) || needSkip(msgExt)) &#123;</span><br><span class="line"></span><br><span class="line">listener.resolveDiscardMsg(msgExt);</span><br><span class="line"></span><br><span class="line">newOffset &#x3D; i + 1;</span><br><span class="line"></span><br><span class="line">i++;</span><br><span class="line"></span><br><span class="line">continue;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@3 消息存储时间大于开始时间暂不处理</span><br><span class="line"></span><br><span class="line">if (msgExt.getStoreTimestamp() &gt;&#x3D; startTime) &#123;</span><br><span class="line"></span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@4 存储的时间小于需要回查的时间 跳过</span><br><span class="line"></span><br><span class="line">if (valueOfCurrentMinusBorn &lt; checkImmunityTime) &#123;</span><br><span class="line"></span><br><span class="line">if (checkPrepareQueueOffset(removeMap, doneOpOffset, msgExt)) &#123;</span><br><span class="line"></span><br><span class="line">newOffset &#x3D; i + 1;</span><br><span class="line"></span><br><span class="line">i++;</span><br><span class="line"></span><br><span class="line">continue;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;接着往下处理</span><br><span class="line"></span><br><span class="line">newOffset &#x3D; i + 1;</span><br><span class="line"></span><br><span class="line">i++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结</span><br><span class="line">@1 removeMap（即已删除队列有而半消息队列未更新的消息）有则不在处理跳过该消息。</span><br><span class="line">@2 超过存储时间或者回查次数超过15次不再处理</span><br><span class="line">@3 消息存储时间大于核查程序开始时间暂不处理</span><br><span class="line">@4 如果定义了回查的时间间隔需要判断是否到时间了</span><br></pre></td></tr></table></figure>

<p>回查逻辑（三）。方法：TransactionalMessageServiceImpl#check</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (isNeedCheck) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@1</span><br><span class="line"></span><br><span class="line">if (!putBackHalfMsgQueue(msgExt, i)) &#123;</span><br><span class="line"></span><br><span class="line">continue;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@2</span><br><span class="line"></span><br><span class="line">listener.resolveHalfMsg(msgExt);</span><br><span class="line"></span><br><span class="line">&#125;&#125; else &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@3</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;保存prepare消息队列的回查消费进度</span><br><span class="line"></span><br><span class="line">if (newOffset !&#x3D; halfOffset) &#123;</span><br><span class="line"></span><br><span class="line">transactionalMessageBridge.updateConsumeOffset(messageQueue, newOffset);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">long newOpOffset &#x3D; calculateOpOffset(doneOpOffset, opOffset);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;保存OP消费进度</span><br><span class="line"></span><br><span class="line">if (newOpOffset !&#x3D; opOffset) &#123;</span><br><span class="line"></span><br><span class="line">transactionalMessageBridge.updateConsumeOffset(opQueue, newOpOffset);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：</span><br><span class="line">@1 将半消息重新存储在RMQ_SYS_TRANS_HALF_TOPIC中，由于本次回查尚未知道结果，所以进行存储。</span><br><span class="line">@2 发到客户端进行回查，回查的RequestCode为CHECK_TRANSACTION_STATE &#x3D; 39，根据ProductGroup随机获取客户端通道Channel进行回查。</span><br><span class="line">@3 保存半消息和已处理消息的消费进度。</span><br></pre></td></tr></table></figure>



<h2 id="客户端响应事务回查"><a href="#客户端响应事务回查" class="headerlink" title="客户端响应事务回查"></a>客户端响应事务回查</h2><p>方法：ClientRemotingProcessor#checkTransactionState</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">producer.checkTransactionState(addr, messageExt, requestHeader);</span><br></pre></td></tr></table></figure>



<p>方法：MQProducerInner#checkTransactionState</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;@1</span><br><span class="line"></span><br><span class="line">localTransactionState &#x3D; transactionListener.checkLocalTransaction(message);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@2</span><br><span class="line"></span><br><span class="line">DefaultMQProducerImpl.this.mQClientFactory.getMQClientAPIImpl().endTransactionOneway(brokerAddr, thisHeader, remark,</span><br><span class="line"></span><br><span class="line">3000);</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：</span><br><span class="line">@1 执行本地事务回查并返回事务回查状态</span><br><span class="line">@2 将事务回查状态提交到Broker</span><br></pre></td></tr></table></figure>



<h1 id="事务消息交互示意图"><a href="#事务消息交互示意图" class="headerlink" title="事务消息交互示意图"></a>事务消息交互示意图</h1><p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219151320.png"></p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ43# Raft一致性算法整理</title>
    <url>/posts/86dc035b/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="Raft概述"><a href="#Raft概述" class="headerlink" title="Raft概述"></a>Raft概述</h1><h2 id="Raft定义"><a href="#Raft定义" class="headerlink" title="Raft定义"></a>Raft定义</h2><p>Raft是一种用来管理日志复制的一致性算法。一致性算法允许一组机器像一个整体一样工作，即使其中的一些机器出了错误也能正常工作。</p>
<a id="more"></a>

<h2 id="复制状态机"><a href="#复制状态机" class="headerlink" title="复制状态机"></a>复制状态机</h2><p>复制状态机(State Machine Replication)：通过复制服务副本，并和副本一起来协调客户端的交互，来实现容错服务。Raft复制状态机是通过复制日志来实现的，每一台服务器保存着一份日志。</p>
<h2 id="Raft一致性"><a href="#Raft一致性" class="headerlink" title="Raft一致性"></a>Raft一致性</h2><p>Raft实现一致性是首先选择一个确定的leader，然后leader负责管理日志复制。leader接受来自客户端的请求并追加到本地日志，然后把日志复制到其它的机器并告诉其它机器什么时候可以安全的将日志应用到状态机。<code>集群存在一个leader的好处可以简化日志复制的管理</code>。例如：leader可以决定日志的追加，而不需要经其它机器的同意。<code>整个集群的数据流向也是从leader流向其它机器</code>。如果leader宕机或者网络断开，其它的机器可以重新选举一个新的leader。</p>
<p>Raft一致性问题分解为3个相对独立的子问题</p>
<p>Leader election：当一个leader宕机后，一个新的leader必须被选举。</p>
<p>Log replication：leader必须响应客户端的请求，并把日志复制到整个集群来保证其它机器的日志和自己的相同。</p>
<p>Safety：状态机的安全是Raft优先保证的。如果任意一台机器将一条特定的日志应用到自己的状态机，那么其他的机器就不能应用一条不同的日志到自己的状态机。解决这个问题的方案就是在选举是增加额外的规则约束。</p>
<h2 id="Raft新的特性"><a href="#Raft新的特性" class="headerlink" title="Raft新的特性"></a>Raft新的特性</h2><p>强领导者（Strong Leader）：日志条目只从领导者发送向其他服务器。</p>
<p>领导选取（Leader Selection）：Raft使用了随机定时器来选择leader。</p>
<p>成员变化（Membership Change）：Raft使用了一种<code>联合一致性</code>的方法，使得集群中的机器发生变更的时候，整个集群也可以正常的工作。联合一致性配置是两个不同配置的大多数机器的重叠。</p>
<!--more-->



<h1 id="Raft一致性算法"><a href="#Raft一致性算法" class="headerlink" title="Raft一致性算法"></a>Raft一致性算法</h1><h2 id="State（状态）"><a href="#State（状态）" class="headerlink" title="State（状态）"></a>State（状态）</h2><p>所有机器需要持久化的状态（在RPC响应之前，需要更新稳定存储介质）</p>
<p>currentTerm 服务器存储的最新任期号从0开始递增</p>
<p>votedFor 在当前任期内收到选票的候选人id如果没有就为null</p>
<p>log[] 日志条目；每个条目包含状态机的要执行命令和从领导人处收到时的任期号</p>
<p>所有机器的可变状态</p>
<p>commitIndex 将被提交的日志记录的索引从0开始递增</p>
<p>lastApplied 已经被提交到状态机的最后一个日志的索引从0开始递增</p>
<p>leader的可变状态(每次选举后重新初始化)</p>
<p>nextIndex[] 每台机器在数组占据一个元素，元素的值为下条发送到该机器的日志索引(初始值为 leader最新一条日志的索引+1)</p>
<p>matchIndex[] 每台机器在数组中占据一个元素，元素的记录将要复制给该机器日志的索引的从0开始递增</p>
<h2 id="AppendEntries-RPC（日志追加远程过程调用）"><a href="#AppendEntries-RPC（日志追加远程过程调用）" class="headerlink" title="AppendEntries RPC（日志追加远程过程调用）"></a>AppendEntries RPC（日志追加远程过程调用）</h2><p>被leader用来复制日志；同时也被用作心跳。</p>
<p>Arguments：</p>
<p>term leader任期</p>
<p>leaderId 用来follower重定向到leader</p>
<p>prevLogIndex 前继日志记录的索引</p>
<p>prevLogTerm 前继日志的任期</p>
<p>entries[] 存储日志记录</p>
<p>leaderCommit leader的commitIndex</p>
<p>Results：</p>
<p>term 当前的任期号，用于领导人更新自己的任期号</p>
<p>success 如果follower包含索引为prevLogIndex和任期为prevLogItem的日志</p>
<p>接受者的实现</p>
<p>1.如果leader的任期小于自己的任期返回false。</p>
<p>2.如果自己不存在索引、任期和 prevLogIndex、prevLogItem匹配的日志返回false。</p>
<p>3.如果存在一条日志索引和prevLogIndex相等，但是任期和prevLogItem不相同的日志，需要删除这条日志及所有后继日志。</p>
<p>4.如果leader复制的日志本地没有，则直接追加存储。</p>
<p>5.如果leaderCommit&gt;commitIndex，设置本地commitIndex为leaderCommit和最新日志索引中较小的一个。</p>
<h2 id="RequestVote-RPC（投票请求RPC）"><a href="#RequestVote-RPC（投票请求RPC）" class="headerlink" title="RequestVote RPC（投票请求RPC）"></a>RequestVote RPC（投票请求RPC）</h2><p>被候选者用来收集选票</p>
<p>Arguments：</p>
<p>term 候选者的任期</p>
<p>candidateId 候选者编号</p>
<p>lastLogIndex 候选者最后一条日志记录的索引</p>
<p>lastLogTerm 候选者最后一条日志记录的索引的任期</p>
<p>Results：</p>
<p>term 当前任期，候选者用来更新自己</p>
<p>voteGranted 如果候选者当选则为true</p>
<p>接受者的实现：</p>
<p>1.如果leader的任期小于自己的任期返回false</p>
<p>2.如果本地voteFor为空，候选者日志和本地日志相同，则投票给该候选者</p>
<h2 id="Rules-for-Serve（服务器需要遵守的规则）"><a href="#Rules-for-Serve（服务器需要遵守的规则）" class="headerlink" title="Rules for Serve（服务器需要遵守的规则）"></a>Rules for Serve（服务器需要遵守的规则）</h2><p>所有机器</p>
<p>1.如果commitIndex &gt; lastApplied：增加lastApplied，并将日志log[lastApplied]应用到状态机</p>
<p>2.如果RPC的请求或者响应中包含一个term T大于currentTerm，则currentTerm赋值为T，并切换状态为追随者（Follower）</p>
<p>追随者/参与者（followers）</p>
<p>1.响应来自候选者或者leader的请求</p>
<p>2.如果在超过选取领导人时间之前没有收到来自当前领导人的AppendEntries RPC或者没有收到候选人的投票请求，则自己转换状态为候选人</p>
<p>候选人（candidate）</p>
<p>1.一旦变为候选者，则开始启动选举</p>
<p>1.1 currentTerm自增</p>
<p>1.2 选举自己</p>
<p>1.3 重置选举定时器</p>
<p>1.4 并行发送选举请求到其他所有机器</p>
<p>2.如果收到集群大多数机器的选票，则称为新的leader</p>
<p>3.如果收到了来自新领导人的AppendEntries RPC（heartbeat）转换为追随者</p>
<p>4.如果选举超时开始新一轮的选举</p>
<p>领导者（leaders）：</p>
<p>1.一旦成为领导人：向其他所有服务器发送空的AppendEntries RPC（heartbeat）; 在空闲时间重复发送以防止选举超时</p>
<p>2.如果接受到来自客户端的请求，追加日志记录到本地日志，如果成功应用日志记录到状态机则回应客户端。</p>
<p>3.如果某个参与者的最新日志索引大于等于本地存储该参与者的最新日志索引：给该参与者发送包含从 nextIndex开始的日志追加请求。</p>
<p>3.1 如果成功，更新该参与者的 nextIndex和matchIndex。</p>
<p>3.2 如果由于日志不一致而失败，减少nextIndex并重试。</p>
<p>4.如果存在N &gt; commitIndex（本地待提交日志的索引），majority(matchIndex[i]&gt;= N)（如果参与者大多数的最新日志的索引大于 N），并且这些参与者索引为N的日志的任期也等于leader的当前任期：commitIndex=N（leader的待提交的日志索引设置为N）</p>
<p>Raft 一致性算法的总结</p>
<p>选举安全原则（Election Safety） 在一个给定的任期最多只可以选举出一个leader。</p>
<p>领导人只增加原则（Leader Append-Only）对于一个leader它永远不会重写和删除日志中的日志记录，它只会追加日志记录。</p>
<p>日志匹配原则（Log Matching） 如果两个日志文件中存在相同索引和任期的日志记录那么两个日志文件所有的日志记录在给定索引情况下是相同的。</p>
<p>领导人完全原则（Leader Completeness) 如果一条日志在一个给定的任期已经提交，那么这条日志将会出现在所有任期大于给定任期的leader的日志中。</p>
<p>状态机安全原则（State Machine Safety）如果一个server已经将给定索引的日志应用到状态机，别的server将不能应用一个相同索引但内容不同的日志记录到自己的状态机。</p>
<h2 id="三种角色"><a href="#三种角色" class="headerlink" title="三种角色"></a>三种角色</h2><p>任意时刻，一台server会处在三种状态中的一种：<code>leader、follower和candidate</code>。</p>
<p>正常情况下，集群中包含一个leader和参与者。集群中的参与者是被动的，它们不会主动解决问题而是被动的响应leader或者参与者的请求。集群中leader负责处理所有的客户端请求，如果一个客户端的请求连接到了参与者，这个参与者会将请求重定向到leader。候选者是在选举中可能成为leader的状态。</p>
<h2 id="任期"><a href="#任期" class="headerlink" title="任期"></a>任期</h2><p>Raft将时间分为任意长度的间隔，每个间隔是一个任期。每个任期会由一个连续的整数进行表示。每个任期都是从选举开始的，在这个阶段会有一个或者多个候选者参与竞选。一旦某个候选者在选举中胜出，这个任期剩下的时间将有这个候选者作为leader。</p>
<p>一些特殊的情况下，一次选举可能出现选举分裂的情况。<code>选举分裂的情况下，当前任期将不会选举出leader。紧接着一个新的任期将会启动重新进行选举。Raft通过上面的过程保证每个任期只会选举出至多一个leader</code>。</p>
<p>当servers进行通讯的时候，也会交换当前的任期。如果一个 server 存储的任期小于其他机器存储的任期，那么它将更新自己的任期到其它机器存储的最大任期。如果是一个候选者或者leader发现自己的任期已经过期，它们会转变到参与者的状态。如果一个server接受到一个请求，这个请求中的任期是过时的，它将直接拒绝该请求。</p>
<h2 id="选主"><a href="#选主" class="headerlink" title="选主"></a>选主</h2><p>Raft使用心跳机制来触发选主的过程。当servers启动的时候，都是作为参与者。如果一个参与者收到来自leader或者候选者的合法请求，它将保持在参与者的状态。leader会发送心跳到其它的server来授权延长自己的任期。如果一个参与者的选举定时器超时的时候还没有收到任何请求，它可以假设整个集群没有可用的leader或者候选者，然后发起新的选举。</p>
<p>一次选举开始时，参与者增加自己本地存储的当前任期然后转变为候选者状态。这个候选者先选举自己，并行的给集群中的其它机器发送 RequestVote RPCs。</p>
<p>候选者将会一直保持候选状态直到下面三件事情中的任意一件发生：（a）：候选者本次选举胜出（b）：另外一台机器确认自己是leader（c）：僵持一段时候没有人胜出。</p>
<p>一个候选者如果接受到集群中大多数机器在同一个任期的选票，么它将胜出成为leader。每台机器在一个任期只能投票给一个候选者，按照先到先服务的原则。<code>大多数投票胜出规则可以保证在一个特定的任期至多选出一个leader。</code>。一旦一个候选者胜出将成为集群的leader，它将会并行的给集群的其它机器发送心跳来宣示自己胜出，并阻止进行新的选举。</p>
<p>在等待选票的过程中，一个候选者可能接受到来自其它server的请求，该请求声明自己已经成为 leader。如果请求中的leader的任期大于候选者本地存储的任期，那么当前候选者认为这个leader 是合法的并转变为参与者状态。<code>如果请求中leader的任期小于当前候选者本地存储的任期，那么候选将拒绝这个请求并保持在候选者状态</code>。</p>
<p>第三种可能是是整个集群的所有候选者都没有胜出。如果集群中所有的参与者同一时刻转变为候选者，</p>
<p>由于每个机器只能投票给一个候选者，这种情况新会很容易发生选举分裂即没有一个候选者获得半数以上选票。当这种情况发生，<code>所有的候选者的选举定时器将会超时，它们增加自己本地存储的任期并启动新一轮的选举</code>。从上面可以看出如果没有额外的规则约束，选举分裂的情况将极易发生。</p>
<p><code>Raft通过随机选举定时器来阻止选举分裂的发生，即使选举分裂发生也可以很快的被解决。选举超时将在 [150,300]ms之间随机生成，这样就大概率保证集群中会有一个机器会先超时，而避免所有机器同时超时从而降低选举分裂情况发生的概率</code>。如果首先超时的机器将会首先转变为候选者，它将会大概率的选举胜出成为leader，然后发送心跳续阻止其它机器定时器超时。</p>
<h2 id="日志复制"><a href="#日志复制" class="headerlink" title="日志复制"></a>日志复制</h2><p>一旦一个候选者成为leader，它将开始处理客户端的请求。客户端的每个请求包含了一条需要执行到状态机的命令。leader将命令追加到自己的日志记录，同时并发AppendEntries RPCs请求来进行日志复制。当日志安全的复制之后，leader 将日志应用到自己的状态机并将结果返回给客户端。<code>如果集群中有参与者宕机、处理速度慢、网络丢包等情况发生，leader将重试AppendEntries RPCs请求直到日志被安全的复制</code>。</p>
<p><code>leader来决定将一条日志应用到状态机的安全时机。这样的一条日志被称为committed</code>。Raft来保证日志的持久化并且所有已提交的日志将会都会被应用到状态机。一旦leader将一条日志成功的复制到集群的大多数机器，那么这条日志就是已提交状态。如果当前日志记录已提交，那么由前任leader或者当前leader创建的前继日志记录都会被提交。leader维护了即将被提交的日志记录的索引，并把这个索引放在未来的AppendEntries RPCs请求中。当参与者从请求获知已提交的索引，它会将本地该索引的日志应用到状态机。</p>
<p>###### Log Matching Property</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果两个日志的两条日志记录有相同的索引和任期，那么这两条日志记录中的命令必然也是相同的。</span><br><span class="line">如果两个日志的两条日志记录有相同的索引和任期，那么这两个日志中的前继日志记录也是相同的。</span><br></pre></td></tr></table></figure>

<p>在一个给定的任期，leader创建的日志索引是递增不重复的，一旦日志某条日志创建后是不会改变它在日志中位置。上面的事实保证了第一个性质的成立。每次当leader发送AppendEntries RPCs请求的时候，请求中会包含当前正在复制的日志记录的直接前继的任期和索引，如果参与者在自己的日志中没有发现有相同任期和索引的日志记录，它将直接拒绝请求。上面描述的一致性检测保证第二个性质的成立。`一致性检测的步骤如下：初始化时候是满足Log Matching Property的；当有追加日志的时候进行一次一致性检测来保护Log Matching Property。这样当leader接受到返回成功的</p>
<p>AppendEntries RPCs请求时，说明了参与者与自己的日志是相同的。`</p>
<p>正常情况下，leader 和参与者的日志都是相同的，日志一致性检测也不失败。当leader崩溃的时候就会导致日志的不一致，例如旧的leader没有将自己的日志记录安全的复制到其它机器。这些不一致可能聚合多个leader和参与者的崩溃。一个参与者可能缺失了leader有的日志记录，它也可能多出了leader没有的日志，或者上面的两种情况同时发生。缺失或多余的日志可能存在在多个任期。</p>
<p>Raft 是通过强制参与者只能复制leader的日志来解决不一致。这就意味者参与者的日志和leader的日志发生冲突的时候，参与者的日志将会重写或者删除。在额外附加的约束下上面的过程是安全的。</p>
<p>如果一致性检测失败后，为了保证参与者和自己的日志一致，<code>leader需要先确认参与者和自己一致的最后一条日志记录。然后通知参与者删除这条日志记录后面的日志，并将这条日志记录之后的日志复制给参与者</code>。leader为每个参与者维护了nextIndex，这个索引记录了leader将复制给该参与者的日志索引。当一个leader选举生效后，它将初始化nextIndex为它自己日志记录中最后一条日志记录的索引。如果leader的日志和参与者的日志不一致那么下一轮的AppendEntries RPCs进行AppendEntries一致性检测的时候就会发现。如果检测发生不一致，leader将会减少nextIndex并重试。经过多次重试leader就会确定参与者和自己一致的日志索引，然后通知参与者删除后面不一致的日志，然后复制自己的日志给参与者。经过上面的过程leader和参与者的一致就可以恢复一致。</p>
<p>上面过程中每次nextIndex减少1进行重试效率是存在问题的，但是也是可以优化的。一旦参与者进行日志一致性检测发现不一致之后，在响应leader请求中包含自己在这个任期存储的第一条日志。这样 leader接受到响应后，就可以直接跳过所有冲突的日志（其中可能包含了一致的日志）。这样就可以减少寻找一致点的过程。但是在实际中我们怀疑这种优化的必要性，因为失败发生的概率本来就很低，也不会同时存在大量不一致的日志记录。</p>
<p>使用上面的机制，一个leader生效的时候就不需要进行额外的操作来恢复日志的一致性。它只需按照正常的流程，日志的不一致经过多次AppendEntries RPCs一致性检测后会自动收敛。leader也不需要重写和删除本地日志。</p>
<p>Raft可以在集群只有半数以上存活的情况下接受、复制和应用新的日志记录；正常情况下只需要一轮 RPCs可以将日志记录复制到集群的大多数；单个速度慢的参与者不会影响整个集群的性能。</p>
<h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><p>上面描述了Raft的选主和日志复制。但是目前所描述的机制还不能安全的保证日志是按照相同顺序被应用到状态机。例如：在leader提交了若干条日志后，某个参与者宕机并被选为新的leader。新的leader重写其它机器的日志，结果导致不同的状态机有不同的命令序。我们通过添加额外约束控制某些机器能被选举为leader来完善Raft算法。<code>这个约束保证当选的leader包含了前任所有提交的日志。</code>通过约束我们可以精准的控制日志的提交。</p>
<p><strong>选举约束:</strong></p>
<p>Raft使用的方法是每个当选的leader必须之前所提交的所有日志，这种方法带来的好处是<code>集群中数据的流向只能是从leader到参与者，leader永远仅需要追加即可</code>。</p>
<p>Raft 使用选举过程来保证一个候选者必须包含有所有已提交的日志才能胜出。候选者为了胜出必须联系集群中的大多数机器，这就意味着每条日志至少出现在机群中的某一台机器上。<code>如果候选者的日志如果比集群其它任意一台机器的日志更新（下面精确定义“更新”），那么它将包含所有已提交的日志。</code>RequestVote RPCs来实现这个约束：请求中包含了 leader 的日志信息，<code>如果投票者的日志比候选者的日志更新，那么它就拒绝投票。</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">两个日志文件谁的日志更新是通过比较日志中最后一条日志记录的任期和索引。如果两个日志文件的最后一条日志的任期不相同，谁的任期更大谁的的日志将更新。如果两条日志记录的任期相同，那么谁的索引越大，谁的日志将更新。</span><br></pre></td></tr></table></figure>

<p><strong>提交上一个任期的日志</strong></p>
<p>如果当前任期的一条日志已经被复制到集群中的大多数，那么leader可以确定这条已经已经处于提交状态。如果上任leader在提交日志之前宕机，下一任leader将尝试完成日志的复制。然而，尽管上一任期的某条日志已经被复制到了大多数机器，但是新任leader还是不能准确断定这条日志是否是已提交。</p>
<p>Raft不能根据上一任期的日志是否被复制到大多数机器来决定是否提交日志。一旦当前任期看到一条日志被提交，由于Log Matching Property保证，那么这条日志之前的日志已自动被提交。</p>
<h1 id="集群成员变更"><a href="#集群成员变更" class="headerlink" title="集群成员变更"></a>集群成员变更</h1><p>在实际系统中，我们有时候可能需要变更配置，例如需要替换宕机的机器或者增加日志的副本数。为了保证安全，配置变更采用两阶段的方法。这里有很多方法可以实现两阶段，例如：有的系统在第一个阶段来停止旧配置，这样就不能响应客户端的请求；然后第二阶段切换到新配置。Raft集群第一阶段</p>
<p>会过渡到迁移配置（我们称之为联合一致性配置joint consensus）；一旦联合一致性被提交，系统将切换到新配置。<code>joint consensus配置组合了老配置和新配置</code>。</p>
<h1 id="客户端交互"><a href="#客户端交互" class="headerlink" title="客户端交互"></a>客户端交互</h1><p>Raft的客户端将自己的请求发送到leader。当一个客户端首次启动，它会随机的选择集群的一台机器。如果客户端的首次选择不是leader，这台机器将拒绝客户端的请求，并会告知自己最近监听到的 leader。如果leader宕机，客户端的请求将会超时，客户端可以随机的选择机器进行重试。</p>
<p>Raft的目标是实现线性语义（每个操作都是立刻被执行的），然而，目前为止我们描述的 Raft可以重复多次的执行一条命令；例如，如果leader提交了日志但是还没有来得及响应客户端就宕机，那么客户端将会换一个leader重试之前的命令。<code>解决方法就是客户端给每个命令一个唯一的编号，那么，状态机记录每个客户端处理的最新的编号。一旦接受到一条命令它的序列号已经被执行过，直接响应这个请求但是不重新执行这个请求</code>。</p>
<h1 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h1><p>本文笔记整理自Raft论文译文，全文详见以下链接。</p>
<p>Raft论文译文</p>
<p><a href="https://github.com/brandonwang001/raft_translation/blob/master/raft_translation.pdf">https://github.com/brandonwang001/raft_translation/blob/master/raft_translation.pdf</a></p>
<p>Raft论文原文</p>
<p><a href="https://ramcloud.atlassian.net/wiki/download/attachments/6586375/raft.pdf">https://ramcloud.atlassian.net/wiki/download/attachments/6586375/raft.pdf</a></p>
<p>Raft动画</p>
<p><a href="http://thesecretlivesofdata.com/raft/">http://thesecretlivesofdata.com/raft/</a></p>
<p>Raft可视化操作</p>
<p><a href="https://raft.github.io/">https://raft.github.io/</a></p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>Nacos13# 配置管理客户端流程</title>
    <url>/posts/11be6e51/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>Nacos注册中心的主要流程基本上撸完了，下面开始撸配置中心。本文从示例入手走查了客户端的初始化流程，Listener的注册逻辑和执行逻辑。</p>
<h1 id="内容提要"><a href="#内容提要" class="headerlink" title="内容提要"></a>内容提要</h1><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><ul>
<li>通过示例构建ConfigService、注册了Listener分析其流程</li>
</ul>
<h3 id="Client初始化概览"><a href="#Client初始化概览" class="headerlink" title="Client初始化概览"></a>Client初始化概览</h3><ul>
<li>支持多种获取server地址方式（本地、endpoint）</li>
<li>支持多种namespace设置（本地、阿里云）</li>
<li>支持超时时间、重试时间等参数设置</li>
<li>支持用户名和密码验证</li>
<li>长轮询会从BlockingQueue中获取元素，队列有元素立即执行executeConfigListen，队列无元素阻塞5秒钟执行executeConfigListen()</li>
</ul>
<h3 id="Listener注册逻辑"><a href="#Listener注册逻辑" class="headerlink" title="Listener注册逻辑"></a>Listener注册逻辑</h3><ul>
<li>client添加Listener后会在cacheMap中缓存CacheData</li>
<li>cacheMap中key由「dataId+group+tenant」拼接而成</li>
<li>每个CacheData会绑定注册的Listener列表</li>
<li>每个CacheData会绑定taskId，3000个不同的CacheData对应一个taskId</li>
<li>设置isSyncWithServer=false表示 cache md5 data不是来自server同步</li>
<li>BlockingQueue中添加new Object() 供长轮询判断立即执行使用</li>
</ul>
<h3 id="配置变更执行逻辑"><a href="#配置变更执行逻辑" class="headerlink" title="配置变更执行逻辑"></a>配置变更执行逻辑</h3><ul>
<li>执行逻辑由executeConfigListen方法实现</li>
<li>当CacheData从Server同步后，会校验md5是否变更了，变更则回调注册的Listener完成通知</li>
<li>注册Listener后会构建与server的RPC通道rpcClient</li>
<li>向server发起变更查询请求configChangeListenRequest</li>
<li>Server端通过比较缓存的md5值，返回client变更的key列表</li>
<li>Client通过变更的key列表向server发起配置查询请求ConfigQueryRequest</li>
<li>获取变更内容，并回调注册的Listener完成通知</li>
<li>回调注册的Listener是通过线程池异步执行Runnble Job实现的</li>
</ul>
<a id="more"></a>



<h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a><strong>示例</strong></h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  String serverAddr = <span class="string">&quot;localhost:8848&quot;</span>;</span><br><span class="line">  String dataId = <span class="string">&quot;test&quot;</span>;</span><br><span class="line">  String group = <span class="string">&quot;DEFAULT_GROUP&quot;</span>;</span><br><span class="line">  Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">  properties.put(<span class="string">&quot;serverAddr&quot;</span>, serverAddr);</span><br><span class="line">  <span class="comment">// 构建ConfigService</span></span><br><span class="line">  ConfigService configService = NacosFactory.createConfigService(properties);</span><br><span class="line">  configService.addListener(dataId, group, <span class="keyword">new</span> Listener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveConfigInfo</span><span class="params">(String configInfo)</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;receive:&quot;</span> + configInfo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Executor <span class="title">getExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  System.in.read();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>备注：</strong> 示例中构建了ConfigService，注入Listener接受server配置变更通知。</p>
<h1 id="Client初始化概览-1"><a href="#Client初始化概览-1" class="headerlink" title="Client初始化概览"></a>Client初始化概览</h1><p><strong>NacosConfigService构造方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NacosConfigService</span><span class="params">(Properties properties)</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">  ValidatorUtils.checkInitParam(properties);</span><br><span class="line">  <span class="comment">// 注解@1</span></span><br><span class="line">  initNamespace(properties);</span><br><span class="line">  <span class="comment">// 注解@2</span></span><br><span class="line">  ServerListManager serverListManager = <span class="keyword">new</span> ServerListManager(properties);</span><br><span class="line">  <span class="comment">// 注解@3</span></span><br><span class="line">  serverListManager.start();</span><br><span class="line">  <span class="comment">// 注解@4</span></span><br><span class="line">  <span class="keyword">this</span>.worker = <span class="keyword">new</span> ClientWorker(<span class="keyword">this</span>.configFilterChainManager, serverListManager, properties);</span><br><span class="line">  <span class="comment">// 将被废弃HttpAgent，先忽略</span></span><br><span class="line">  <span class="comment">// will be deleted in 2.0 later versions</span></span><br><span class="line">  agent = <span class="keyword">new</span> ServerHttpAgent(serverListManager);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@1</strong> 设置namespace可以通过properties.setProperty(PropertyKeyConst.NAMESPACE)，代码中会兼容阿里云环境，在此忽略，默认为空。</p>
<p><strong>注解@2</strong> 初始化namespace、server地址等信息</p>
<p><strong>注解@3</strong> 启动主要用于endpoint方式定时获取server地址，当本地传入isFixed=true</p>
<p><strong>注解@4</strong> clientWorker初始化</p>
<p><strong>ClientWorker初始化</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClientWorker</span><span class="params">(<span class="keyword">final</span> ConfigFilterChainManager configFilterChainManager, ServerListManager serverListManager,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">final</span> Properties properties)</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.configFilterChainManager = configFilterChainManager;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注解@5</span></span><br><span class="line">  init(properties);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注解@6</span></span><br><span class="line">  agent = <span class="keyword">new</span> ConfigRpcTransportClient(properties, serverListManager);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调度线程池，「处理器核数」</span></span><br><span class="line">  ScheduledExecutorService executorService = Executors</span><br><span class="line">    .newScheduledThreadPool(Runtime.getRuntime().availableProcessors(), <span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        t.setName(<span class="string">&quot;com.alibaba.nacos.client.Worker&quot;</span>);</span><br><span class="line">        t.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  agent.setExecutor(executorService);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注解@7</span></span><br><span class="line">  agent.start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@5</strong> 初始化超时时间、重试时间等</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 超时时间，默认30秒</span></span><br><span class="line">    timeout = Math.max(ConvertUtils.toInt(properties.getProperty(PropertyKeyConst.CONFIG_LONG_POLL_TIMEOUT),</span><br><span class="line">            Constants.CONFIG_LONG_POLL_TIMEOUT), Constants.MIN_CONFIG_LONG_POLL_TIMEOUT);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重试时间，默认2秒</span></span><br><span class="line">    taskPenaltyTime = ConvertUtils</span><br><span class="line">            .toInt(properties.getProperty(PropertyKeyConst.CONFIG_RETRY_TIME), Constants.CONFIG_RETRY_TIME);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开启配置删除同步，默认false</span></span><br><span class="line">    <span class="keyword">this</span>.enableRemoteSyncConfig = Boolean</span><br><span class="line">            .parseBoolean(properties.getProperty(PropertyKeyConst.ENABLE_REMOTE_SYNC_CONFIG));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@6</strong> gRPC config agent初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConfigTransportClient</span><span class="params">(Properties properties, ServerListManager serverListManager)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认编码UTF-8</span></span><br><span class="line">    String encodeTmp = properties.getProperty(PropertyKeyConst.ENCODE);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(encodeTmp)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.encode = Constants.ENCODE;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.encode = encodeTmp.trim();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// namespace租户，默认空</span></span><br><span class="line">    <span class="keyword">this</span>.tenant = properties.getProperty(PropertyKeyConst.NAMESPACE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.serverListManager = serverListManager;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用户名和密码验证</span></span><br><span class="line">    <span class="keyword">this</span>.securityProxy = <span class="keyword">new</span> SecurityProxy(properties,</span><br><span class="line">            ConfigHttpClientManager.getInstance().getNacosRestTemplate());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@7</strong> gRPC agent启动</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">    <span class="comment">// 简单用户名和密码验证</span></span><br><span class="line">    <span class="keyword">if</span> (securityProxy.isEnabled()) &#123;</span><br><span class="line">        securityProxy.login(serverListManager.getServerUrls());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.executor.scheduleWithFixedDelay(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                securityProxy.login(serverListManager.getServerUrls());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>, <span class="keyword">this</span>.securityInfoRefreshIntervalMills, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    startInternal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">    executor.schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123; <span class="comment">// 一直运行</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 最长等待5秒</span></span><br><span class="line">                    listenExecutebell.poll(<span class="number">5L</span>, TimeUnit.SECONDS);</span><br><span class="line">                    executeConfigListen();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    LOGGER.error(<span class="string">&quot;[ rpc listen execute ] [rpc listen] exception&quot;</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">0L</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>小结：</strong> 线程会一直运行，从BlockingQueue中获取元素。队里不为空，获取后立即执行executeConfigListen()；队列为空等待5秒后执行</p>
<p>executeConfigListen()。</p>
<h1 id="Listener注册逻辑-1"><a href="#Listener注册逻辑-1" class="headerlink" title="Listener注册逻辑"></a>Listener注册逻辑</h1><p>executeConfigListen的逻辑有点复杂，先看示例代码中的添加Listener部分。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">configService.addListener(dataId, group, <span class="keyword">new</span> Listener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveConfigInfo</span><span class="params">(String configInfo)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;receive:&quot;</span> + configInfo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Executor <span class="title">getExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTenantListeners</span><span class="params">(String dataId, String group, List&lt;? extends Listener&gt; listeners)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认DEFAULT_GROUP</span></span><br><span class="line">    group = null2defaultGroup(group);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 租户，默认空</span></span><br><span class="line">    String tenant = agent.getTenant();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注解@8</span></span><br><span class="line">    CacheData cache = addCacheDataIfAbsent(dataId, group, tenant);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (cache) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Listener listener : listeners) &#123;</span><br><span class="line">            cache.addListener(listener);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// cache md5 data是否来自server同步</span></span><br><span class="line">        cache.setSyncWithServer(<span class="keyword">false</span>);</span><br><span class="line">      	<span class="comment">// BlockingQueue中添加new Object()</span></span><br><span class="line">        agent.notifyListenConfig();</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@8</strong>  构建缓存数据CacheData并放入cacheMap中，缓存的key为 「dataId+group+tenant」例如：test+DEFAULT_GROUP。</p>
<p>每个CacheData会绑定对应的taskId，每3000个CacheData对应一个taskId。其实从后面的代码中可以看出，每个taskId会对应一个gRPC Client。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CacheData <span class="title">addCacheDataIfAbsent</span><span class="params">(String dataId, String group, String tenant)</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从缓存中获取</span></span><br><span class="line">    CacheData cache = getCache(dataId, group, tenant);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != cache) &#123;</span><br><span class="line">        <span class="keyword">return</span> cache;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构造缓存key以+连接，test+DEFAULT_GROUP</span></span><br><span class="line">    String key = GroupKey.getKeyTenant(dataId, group, tenant);</span><br><span class="line">    <span class="keyword">synchronized</span> (cacheMap) &#123;</span><br><span class="line">        CacheData cacheFromMap = getCache(dataId, group, tenant);</span><br><span class="line">        <span class="comment">// multiple listeners on the same dataid+group and race condition,so</span></span><br><span class="line">        <span class="comment">// double check again</span></span><br><span class="line">        <span class="comment">// other listener thread beat me to set to cacheMap</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != cacheFromMap) &#123; <span class="comment">// 再检查一遍</span></span><br><span class="line">            cache = cacheFromMap;</span><br><span class="line">            <span class="comment">// reset so that server not hang this check</span></span><br><span class="line">            cache.setInitializing(<span class="keyword">true</span>); <span class="comment">// 缓存正在初始化</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 构造缓存数据对象</span></span><br><span class="line">            cache = <span class="keyword">new</span> CacheData(configFilterChainManager, agent.getName(), dataId, group, tenant);</span><br><span class="line">            <span class="comment">// 初始值taskId=0，注意此处每3000个CacheData共用一个taskId</span></span><br><span class="line">            <span class="keyword">int</span> taskId = cacheMap.get().size() / (<span class="keyword">int</span>) ParamUtil.getPerTaskConfigSize();</span><br><span class="line">            cache.setTaskId(taskId);</span><br><span class="line">            <span class="comment">// fix issue # 1317</span></span><br><span class="line">            <span class="keyword">if</span> (enableRemoteSyncConfig) &#123; <span class="comment">// 默认false</span></span><br><span class="line">                String[] ct = getServerConfig(dataId, group, tenant, <span class="number">3000L</span>, <span class="keyword">false</span>);</span><br><span class="line">                cache.setContent(ct[<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;String, CacheData&gt; copy = <span class="keyword">new</span> HashMap&lt;String, CacheData&gt;(<span class="keyword">this</span>.cacheMap.get());</span><br><span class="line">        <span class="comment">// key = test+DEFAULT_GROUP</span></span><br><span class="line">        copy.put(key, cache);</span><br><span class="line">        <span class="comment">// cacheMap = &#123;test+DEFAULT_GROUP=CacheData [test, DEFAULT_GROUP]&#125;</span></span><br><span class="line">        cacheMap.set(copy);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    LOGGER.info(<span class="string">&quot;[&#123;&#125;] [subscribe] &#123;&#125;&quot;</span>, agent.getName(), key);</span><br><span class="line"></span><br><span class="line">    MetricsMonitor.getListenConfigCountMonitor().set(cacheMap.get().size());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cache;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>具体缓存内容</strong> </p>
<table>
<thead>
<tr>
<th>属性</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>name</td>
<td>ConfigTransportClient名称，config_rpc_client</td>
</tr>
<tr>
<td>configFilterChainManager</td>
<td>filter拦截链条，可以执行一些列拦截器</td>
</tr>
<tr>
<td>dataId</td>
<td>dataId</td>
</tr>
<tr>
<td>group</td>
<td>group名称，默认为DEFAULT_GROUP</td>
</tr>
<tr>
<td>tenant</td>
<td>租户名称</td>
</tr>
<tr>
<td>listeners</td>
<td>添加的Listener列表，线程安全CopyOnWriteArrayList</td>
</tr>
<tr>
<td>content</td>
<td>启动时会从本地文件读入，默认为null</td>
</tr>
<tr>
<td>md5</td>
<td>content的md5字符串</td>
</tr>
</tbody></table>
<p><strong>小结</strong>：添加监听器逻辑如下：构建CacheData，并缓存在cacheMap中，key是由「dataId+group+tenant」组成；每个CacheData会绑定了Listener列表，也绑定了taskId，3000个不同的CacheData对应一个taskId，对应一个gRPC通道实例；设置isSyncWithServer=false表示 cache md5 data不是来自server同步，BlockingQueue中添加new Object() 供前面提到的长轮询判断使用。</p>
<h1 id="配置变更执行逻辑-1"><a href="#配置变更执行逻辑-1" class="headerlink" title="配置变更执行逻辑"></a>配置变更执行逻辑</h1><p>上文中提到一个线程一直在轮询，轮询执行executeConfigListen方法，这个方法比较关键。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeConfigListen</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Map&lt;String<span class="comment">/*taskId*/</span>, List&lt;CacheData&gt;&gt; listenCachesMap = <span class="keyword">new</span> HashMap&lt;String, List&lt;CacheData&gt;&gt;(<span class="number">16</span>);</span><br><span class="line">    Map&lt;String, List&lt;CacheData&gt;&gt; removeListenCachesMap = <span class="keyword">new</span> HashMap&lt;String, List&lt;CacheData&gt;&gt;(<span class="number">16</span>);</span><br><span class="line">    <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">// 超过5分钟</span></span><br><span class="line">    <span class="keyword">boolean</span> needAllSync = now - lastAllSyncTime &gt;= ALL_SYNC_INTERNAL;</span><br><span class="line">    <span class="keyword">for</span> (CacheData cache : cacheMap.get().values()) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (cache) &#123;</span><br><span class="line">            <span class="comment">// --------注解@9开始--------</span></span><br><span class="line">            <span class="keyword">if</span> (cache.isSyncWithServer()) &#123; </span><br><span class="line">                cache.checkListenerMd5(); <span class="comment">// 内容有变更通知Listener执行</span></span><br><span class="line">                <span class="keyword">if</span> (!needAllSync) &#123; <span class="comment">// 不超过5分钟则不再全局校验</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">						<span class="comment">// --------注解@9结束--------</span></span><br><span class="line">            <span class="keyword">if</span> (!CollectionUtils.isEmpty(cache.getListeners())) &#123; <span class="comment">// 有添加Listeners</span></span><br><span class="line">                <span class="comment">// get listen config 默认 false</span></span><br><span class="line">                <span class="keyword">if</span> (!cache.isUseLocalConfigInfo()) &#123;</span><br><span class="line">                    List&lt;CacheData&gt; cacheDatas = listenCachesMap.get(String.valueOf(cache.getTaskId()));</span><br><span class="line">                    <span class="keyword">if</span> (cacheDatas == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        cacheDatas = <span class="keyword">new</span> LinkedList&lt;CacheData&gt;();</span><br><span class="line">                        listenCachesMap.put(String.valueOf(cache.getTaskId()), cacheDatas);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// CacheData [test, DEFAULT_GROUP]</span></span><br><span class="line">                    cacheDatas.add(cache);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (CollectionUtils.isEmpty(cache.getListeners())) &#123; <span class="comment">// 没有添加Listeners</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!cache.isUseLocalConfigInfo()) &#123;</span><br><span class="line">                    List&lt;CacheData&gt; cacheDatas = removeListenCachesMap.get(String.valueOf(cache.getTaskId()));</span><br><span class="line">                    <span class="keyword">if</span> (cacheDatas == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        cacheDatas = <span class="keyword">new</span> LinkedList&lt;CacheData&gt;();</span><br><span class="line">                        removeListenCachesMap.put(String.valueOf(cache.getTaskId()), cacheDatas);</span><br><span class="line">                    &#125;</span><br><span class="line">                    cacheDatas.add(cache);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> hasChangedKeys = <span class="keyword">false</span>;</span><br><span class="line">  </span><br><span class="line">		<span class="comment">//-------------------注解@10开始---------------------------------</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (!listenCachesMap.isEmpty()) &#123; <span class="comment">// 有Listeners</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, List&lt;CacheData&gt;&gt; entry : listenCachesMap.entrySet()) &#123;</span><br><span class="line">            String taskId = entry.getKey();</span><br><span class="line">            List&lt;CacheData&gt; listenCaches = entry.getValue();</span><br><span class="line"></span><br><span class="line">            ConfigBatchListenRequest configChangeListenRequest = buildConfigRequest(listenCaches);</span><br><span class="line">            configChangeListenRequest.setListen(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 注解@10.1 每个taskId构建rpcClient</span></span><br><span class="line">                RpcClient rpcClient = ensureRpcClient(taskId);</span><br><span class="line">                <span class="comment">// 注解@10.2</span></span><br><span class="line">                ConfigChangeBatchListenResponse configChangeBatchListenResponse = (ConfigChangeBatchListenResponse) requestProxy(</span><br><span class="line">                        rpcClient, configChangeListenRequest);</span><br><span class="line">                <span class="keyword">if</span> (configChangeBatchListenResponse != <span class="keyword">null</span> &amp;&amp; configChangeBatchListenResponse.isSuccess()) &#123;</span><br><span class="line"></span><br><span class="line">                    Set&lt;String&gt; changeKeys = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">                    <span class="comment">// handle changed keys,notify listener</span></span><br><span class="line">                    <span class="comment">// 有变化的configContext</span></span><br><span class="line">                    <span class="keyword">if</span> (!CollectionUtils.isEmpty(configChangeBatchListenResponse.getChangedConfigs())) &#123;</span><br><span class="line">                        hasChangedKeys = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">for</span> (ConfigChangeBatchListenResponse.ConfigContext changeConfig : configChangeBatchListenResponse.getChangedConfigs()) &#123;</span><br><span class="line">                            String changeKey = GroupKey</span><br><span class="line">                                    .getKeyTenant(changeConfig.getDataId(), changeConfig.getGroup(),</span><br><span class="line">                                            changeConfig.getTenant());</span><br><span class="line">                            changeKeys.add(changeKey);</span><br><span class="line">                            <span class="keyword">boolean</span> isInitializing = cacheMap.get().get(changeKey).isInitializing();</span><br><span class="line">                            <span class="comment">// 注解@10.3 回调Listener</span></span><br><span class="line">                            refreshContentAndCheck(changeKey, !isInitializing);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//handler content configs</span></span><br><span class="line">                    <span class="keyword">for</span> (CacheData cacheData : listenCaches) &#123;</span><br><span class="line">                        String groupKey = GroupKey</span><br><span class="line">                                .getKeyTenant(cacheData.dataId, cacheData.group, cacheData.getTenant());</span><br><span class="line">                        <span class="keyword">if</span> (!changeKeys.contains(groupKey)) &#123; <span class="comment">// 注解@10.4</span></span><br><span class="line">                            <span class="comment">//sync:cache data md5 = server md5 &amp;&amp; cache data md5 = all listeners md5.</span></span><br><span class="line">                            <span class="keyword">synchronized</span> (cacheData) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (!cacheData.getListeners().isEmpty()) &#123;</span><br><span class="line">                                    cacheData.setSyncWithServer(<span class="keyword">true</span>);</span><br><span class="line">                                    <span class="keyword">continue</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        cacheData.setInitializing(<span class="keyword">false</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">                LOGGER.error(<span class="string">&quot;Async listen config change error &quot;</span>, e);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">50L</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException interruptedException) &#123;</span><br><span class="line">                    <span class="comment">//ignore</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//-------------------注解@10结束---------------------------------</span></span><br><span class="line">    <span class="keyword">if</span> (!removeListenCachesMap.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, List&lt;CacheData&gt;&gt; entry : removeListenCachesMap.entrySet()) &#123;</span><br><span class="line">            String taskId = entry.getKey();</span><br><span class="line">            List&lt;CacheData&gt; removeListenCaches = entry.getValue();</span><br><span class="line">            ConfigBatchListenRequest configChangeListenRequest = buildConfigRequest(removeListenCaches);</span><br><span class="line">            configChangeListenRequest.setListen(<span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 向server发送Listener取消订阅请求ConfigBatchListenRequest#listen为false</span></span><br><span class="line">                RpcClient rpcClient = ensureRpcClient(taskId);</span><br><span class="line">                <span class="keyword">boolean</span> removeSuccess = unListenConfigChange(rpcClient, configChangeListenRequest);</span><br><span class="line">                <span class="keyword">if</span> (removeSuccess) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (CacheData cacheData : removeListenCaches) &#123;</span><br><span class="line">                        <span class="keyword">synchronized</span> (cacheData) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (cacheData.getListeners().isEmpty()) &#123;</span><br><span class="line">                                <span class="comment">// 移除本地缓存</span></span><br><span class="line">                                ClientWorker.<span class="keyword">this</span></span><br><span class="line">                                        .removeCache(cacheData.dataId, cacheData.group, cacheData.tenant);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                LOGGER.error(<span class="string">&quot;async remove listen config change error &quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">50L</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException interruptedException) &#123;</span><br><span class="line">                <span class="comment">//ignore</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (needAllSync) &#123;</span><br><span class="line">        lastAllSyncTime = now;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//If has changed keys,notify re sync md5.</span></span><br><span class="line">    <span class="keyword">if</span> (hasChangedKeys) &#123; <span class="comment">// key有变化触发下一轮轮询</span></span><br><span class="line">        notifyListenConfig();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@9</strong> isSyncWithServer初始为false，在下文代码中校验结束后会设置为true，表示md5 cache data同步来自server。如果为true会校验Md5.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkListenerMd5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (ManagerListenerWrap wrap : listeners) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!md5.equals(wrap.lastCallMd5)) &#123; <span class="comment">// 注解@9.1</span></span><br><span class="line">            safeNotifyListener(dataId, group, content, type, md5, wrap);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@9.1</strong>  配置内容有变更时，回调到我们示例中注册的Listener中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">safeNotifyListener</span><span class="params">(<span class="keyword">final</span> String dataId, <span class="keyword">final</span> String group, <span class="keyword">final</span> String content, <span class="keyword">final</span> String type,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> String md5, <span class="keyword">final</span> ManagerListenerWrap listenerWrap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Listener listener = listenerWrap.listener;</span><br><span class="line">    <span class="keyword">if</span> (listenerWrap.inNotifying) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Runnable job = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">            ClassLoader myClassLoader = Thread.currentThread().getContextClassLoader();</span><br><span class="line">            ClassLoader appClassLoader = listener.getClass().getClassLoader();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (listener <span class="keyword">instanceof</span> AbstractSharedListener) &#123;</span><br><span class="line">                    AbstractSharedListener adapter = (AbstractSharedListener) listener;</span><br><span class="line">                    adapter.fillContext(dataId, group);</span><br><span class="line">                   <span class="comment">// ...</span></span><br><span class="line">                &#125;</span><br><span class="line">                Thread.currentThread().setContextClassLoader(appClassLoader);</span><br><span class="line"></span><br><span class="line">                ConfigResponse cr = <span class="keyword">new</span> ConfigResponse();</span><br><span class="line">                cr.setDataId(dataId);</span><br><span class="line">                cr.setGroup(group);</span><br><span class="line">                cr.setContent(content);</span><br><span class="line">                <span class="comment">// filter拦截继续过滤</span></span><br><span class="line">                configFilterChainManager.doFilter(<span class="keyword">null</span>, cr);</span><br><span class="line"></span><br><span class="line">                String contentTmp = cr.getContent();</span><br><span class="line">                listenerWrap.inNotifying = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 注解@9.2</span></span><br><span class="line">                listener.receiveConfigInfo(contentTmp);</span><br><span class="line">                <span class="comment">// compare lastContent and content</span></span><br><span class="line">                <span class="keyword">if</span> (listener <span class="keyword">instanceof</span> AbstractConfigChangeListener) &#123;</span><br><span class="line">                    Map data = ConfigChangeHandler.getInstance()</span><br><span class="line">                            .parseChangeData(listenerWrap.lastContent, content, type);</span><br><span class="line">                    ConfigChangeEvent event = <span class="keyword">new</span> ConfigChangeEvent(data);</span><br><span class="line">                    <span class="comment">// 回调变更事件方法</span></span><br><span class="line">                    ((AbstractConfigChangeListener) listener).receiveConfigChange(event);</span><br><span class="line">                    listenerWrap.lastContent = content;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                listenerWrap.lastCallMd5 = md5;</span><br><span class="line">                <span class="comment">// ..</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (NacosException ex) &#123;</span><br><span class="line">               <span class="comment">// ...</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">               <span class="comment">// ...</span></span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                listenerWrap.inNotifying = <span class="keyword">false</span>;</span><br><span class="line">                Thread.currentThread().setContextClassLoader(myClassLoader);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> startNotify = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      	<span class="comment">// 注解@9.3</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != listener.getExecutor()) &#123;</span><br><span class="line">            listener.getExecutor().execute(job);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                INTERNAL_NOTIFIER.submit(job); <span class="comment">// 默认线程池执行，为5个线程</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (RejectedExecutionException rejectedExecutionException) &#123;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">                job.run();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">                job.run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">       <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> finishNotify = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@9.2</strong> 回调注册Listener的receiveConfigInfo方法或者receiveConfigChange逻辑</p>
<p><strong>注解@9.3</strong> 优先使用我们示例中注册提供的线程池执行job，如果没有设置使用默认线程池「INTERNAL_NOTIFIER」，默认5个线程</p>
<p><strong>备注：</strong> 当CacheData从server同步后，会校验md5是否变更了，当变更时会回调到我们注册的Listener完成通知。通知任务被封装成Runnable任务，执行线程池可以自定义，默认为5个线程。</p>
<p><strong>注解@10.1</strong> 每个taskId构建rpcClient，例如：taskId= config-0-c70e0314-4770-43f5-add4-f258a4083fd7；结合上下文每3000个CacheData对应一个rpcClient。</p>
<p><strong>注解@10.2</strong> 向server发起configChangeListenRequest，server端由ConfigChangeBatchListenRequestHandler处理，还是比较md5</p>
<p>是否变更了，变更后server端返回变更的key列表。</p>
<p><strong>注解@10.3</strong> 当server返回变更key列表时执行refreshContentAndCheck方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">refreshContentAndCheck</span><span class="params">(CacheData cacheData, <span class="keyword">boolean</span> notify)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 注解@10.3.1</span></span><br><span class="line">        String[] ct = getServerConfig(cacheData.dataId, cacheData.group, cacheData.tenant, <span class="number">3000L</span>, notify);</span><br><span class="line">        cacheData.setContent(ct[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != ct[<span class="number">1</span>]) &#123;</span><br><span class="line">            cacheData.setType(ct[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (notify) &#123; <span class="comment">// 记录日志</span></span><br><span class="line">           <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注解@10.3.2</span></span><br><span class="line">        cacheData.checkListenerMd5();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@10.3.1</strong> 向server发起ConfigQueryRequest，查询配置内容</p>
<p><strong>注解@10.3.2</strong> 回调注册的Listener逻辑见 <strong>注解@9</strong> </p>
<p> <strong>注解@10.4</strong>  key没有变化的，内容由server同步，设置SyncWithServer=true，下一轮逻辑会由 <strong>注解@9</strong> 部分执行</p>
<p><strong>备注：</strong> 从整个<strong>注解@10</strong> 注册Listener后，会构建与server的RPC通道rpcClient；向server发起变更查询请求configChangeListenRequest，server端通过比较缓存的md5值，返回client变更的key列表；client通过变更的key列表向server发起配置查询请求ConfigQueryRequest，获取变更内容，并回调我们注册的Listener。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>Nacos</category>
      </categories>
      <tags>
        <tag>Nacos</tag>
      </tags>
  </entry>
  <entry>
    <title>Nacos2# 服务注册与发现客户端示例与源码解析（二）</title>
    <url>/posts/9fe0a5df/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>上一篇客户端初始化没有撸完，这篇继续。Nacos从2.0以后增加了对grpc的支持，代码中HTTP的代理初始化还有保留，我们注册发现通常为临时节点，这部分已由gRPC接管。可以对比下新旧逻辑的实现差异。</p>
<h1 id="内容提要"><a href="#内容提要" class="headerlink" title="内容提要"></a>内容提要</h1><h3 id="HTTP代理初始化"><a href="#HTTP代理初始化" class="headerlink" title="HTTP代理初始化"></a>HTTP代理初始化</h3><p><strong>HTTP心跳检测器</strong> </p>
<ul>
<li>HTTP心跳检测只适用于注册的节点持久节点，临时节点会使用grpc代理（HTTP的心跳检测默认废弃由grpc替代）</li>
<li>在初始化时客户端注册代理NamingClientProxy时，初始化了一个HTTP心跳器用于向Nacos Server发起心跳</li>
<li>在注册节点时通过向心跳执行器添加心跳任务addBeatInfo触发</li>
<li>心跳执行器通过每隔五秒中向Nacos Server发起HTTP请求</li>
<li>如果返回的server not found会向Nacos Server发起注册请求重新注册</li>
</ul>
<p><strong>UDP接受服务端推送</strong> </p>
<ul>
<li>Client通过UDP接受到nacos server推动的消息</li>
<li>如果服务端推送的为服务信息通过processServiceInfo处理逻辑见上篇，主要实例变更时的通知机制</li>
<li>如果dump类型，则客户端发送服务信息serviceInfoMap的ack信息到服务端</li>
</ul>
<h3 id="gRPC代理初始化"><a href="#gRPC代理初始化" class="headerlink" title="gRPC代理初始化"></a>gRPC代理初始化</h3><p><strong>gRPC初始化逻辑概览</strong> </p>
<ul>
<li> gRPC 客户端代理的初始化主要逻辑为创建gRPC Client并启动</li>
<li>并注册ServerRequestHandler用于处理Nacos Server推送的NotifySubscriberRequest请求</li>
<li>注册ConnectionListener用于处理gRPC建立和断开连接事件</li>
<li>请求超时时间可以通过「namingRequestTimeout」设置，默认为3秒</li>
</ul>
<p><strong>gRPC Client启动逻辑</strong> </p>
<ul>
<li>gRPC Client启动逻辑主要在于建立与nacos server的grpc连接，其中两个守护线程一直在运行</li>
<li>守护线程1用于处理grpc连接的建立和关闭事件</li>
<li>守护线程2用于与nacos server的心跳保鲜，并负责异步建立grpc连接</li>
<li>守护线程2同时负责当nacos server的地址信息发生变更时重新与新server建立连接</li>
<li>nacos server的地址变更通过grpc通道由server推送ConnectResetRequest到client</li>
<li>grpc client只与nacos server集群中一台建立grpc连接。</li>
</ul>
<a id="more"></a>



<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NamingClientProxyDelegate</span><span class="params">(String namespace, ServiceInfoHolder serviceInfoHolder, Properties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">            InstancesChangeNotifier changeNotifier)</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.serviceInfoUpdateService = <span class="keyword">new</span> ServiceInfoUpdateService(properties, serviceInfoHolder, <span class="keyword">this</span>,</span><br><span class="line">                changeNotifier);</span><br><span class="line">  		  <span class="keyword">this</span>.serverListManager = <span class="keyword">new</span> ServerListManager(properties);</span><br><span class="line">  		  <span class="keyword">this</span>.serviceInfoHolder = serviceInfoHolder;</span><br><span class="line">        <span class="keyword">this</span>.securityProxy = <span class="keyword">new</span> SecurityProxy(properties, NamingHttpClientManager.getInstance().getNacosRestTemplate());</span><br><span class="line">        initSecurityProxy();</span><br><span class="line">  		  <span class="comment">// @注解7.4</span></span><br><span class="line">        <span class="keyword">this</span>.httpClientProxy = <span class="keyword">new</span> NamingHttpClientProxy(namespace, securityProxy, serverListManager, properties,serviceInfoHolder);</span><br><span class="line">  			<span class="comment">// @注解7.5</span></span><br><span class="line">        <span class="keyword">this</span>.grpcClientProxy = <span class="keyword">new</span> NamingGrpcClientProxy(namespace, securityProxy, serverListManager, properties,serviceInfoHolder);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="HTTP代理初始化-1"><a href="#HTTP代理初始化-1" class="headerlink" title="HTTP代理初始化"></a>HTTP代理初始化</h1><p><strong>@注解7.4</strong> Http代理的初始化，该代理主要在nacos 2.0以前版本使用，2.0之后通过grpc与nacos server通信。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NamingHttpClientProxy</span><span class="params">(String namespaceId, SecurityProxy securityProxy, ServerListManager serverListManager,</span></span></span><br><span class="line"><span class="function"><span class="params">            Properties properties, ServiceInfoHolder serviceInfoHolder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(securityProxy, properties);</span><br><span class="line">        <span class="keyword">this</span>.serverListManager = serverListManager;</span><br><span class="line">        <span class="keyword">this</span>.setServerPort(DEFAULT_SERVER_PORT);</span><br><span class="line">        <span class="keyword">this</span>.namespaceId = namespaceId;</span><br><span class="line">  			<span class="comment">// @注解7.4.1</span></span><br><span class="line">        <span class="keyword">this</span>.beatReactor = <span class="keyword">new</span> BeatReactor(<span class="keyword">this</span>, properties);</span><br><span class="line">  			<span class="comment">// @注解7.4.2</span></span><br><span class="line">        <span class="keyword">this</span>.pushReceiver = <span class="keyword">new</span> PushReceiver(serviceInfoHolder);</span><br><span class="line">  			<span class="comment">// @注解7.4.3</span></span><br><span class="line">        <span class="keyword">this</span>.maxRetry = ConvertUtils.toInt(properties.getProperty(PropertyKeyConst.NAMING_REQUEST_DOMAIN_RETRY_COUNT,</span><br><span class="line">                String.valueOf(UtilAndComs.REQUEST_DOMAIN_RETRY_COUNT)));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<h3 id="HTTP心跳检测器"><a href="#HTTP心跳检测器" class="headerlink" title="HTTP心跳检测器"></a>HTTP心跳检测器</h3><p><strong>@注解7.4.1</strong> 初始化BeatReactor，用于向nacos server发送心跳</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BeatReactor</span><span class="params">(NamingHttpClientProxy serverProxy, Properties properties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.serverProxy = serverProxy;</span><br><span class="line">        <span class="comment">// 心跳线程池大小，默认为核数的二分之一，最小为1，可通过properties参数「namingClientBeatThreadCount」设置</span></span><br><span class="line">        <span class="keyword">int</span> threadCount = initClientBeatThreadCount(properties);</span><br><span class="line">  			<span class="comment">// 初始化线程执行器</span></span><br><span class="line">        <span class="keyword">this</span>.executorService = <span class="keyword">new</span> ScheduledThreadPoolExecutor(threadCount, <span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">                Thread thread = <span class="keyword">new</span> Thread(r);</span><br><span class="line">                thread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">                thread.setName(<span class="string">&quot;com.alibaba.nacos.naming.beat.sender&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> thread;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着一下这个执行器再做什么事情。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBeatInfo</span><span class="params">(String serviceName, BeatInfo beatInfo)</span> </span>&#123;</span><br><span class="line">        NAMING_LOGGER.info(<span class="string">&quot;[BEAT] adding beat: &#123;&#125; to beat map.&quot;</span>, beatInfo);</span><br><span class="line">        String key = buildKey(serviceName, beatInfo.getIp(), beatInfo.getPort());</span><br><span class="line">        BeatInfo existBeat = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//fix #1733</span></span><br><span class="line">        <span class="keyword">if</span> ((existBeat = dom2Beat.remove(key)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            existBeat.setStopped(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        dom2Beat.put(key, beatInfo);</span><br><span class="line">        <span class="comment">// 默认延迟5秒</span></span><br><span class="line">        executorService.schedule(<span class="keyword">new</span> BeatTask(beatInfo), beatInfo.getPeriod(), TimeUnit.MILLISECONDS);</span><br><span class="line">        MetricsMonitor.getDom2BeatSizeMonitor().set(dom2Beat.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当通过addBeatInfo增加一个心跳信息BeatInfo时，执行器会创建BeatTask（Runnable）延迟5秒运行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BeatTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">			  BeatInfo beatInfo;</span><br><span class="line">			  <span class="function"><span class="keyword">public</span> <span class="title">BeatTask</span><span class="params">(BeatInfo beatInfo)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.beatInfo = beatInfo;</span><br><span class="line">        &#125;</span><br><span class="line">			  <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (beatInfo.isStopped()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">long</span> nextTime = beatInfo.getPeriod();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              	<span class="comment">// 向nacos server「/nacos/v1/ns/instance/beat」发送心跳</span></span><br><span class="line">                JsonNode result = serverProxy.sendBeat(beatInfo, BeatReactor.<span class="keyword">this</span>.lightBeatEnabled);</span><br><span class="line">                <span class="keyword">long</span> interval = result.get(<span class="string">&quot;clientBeatInterval&quot;</span>).asLong();</span><br><span class="line">                <span class="keyword">boolean</span> lightBeatEnabled = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (result.has(CommonParams.LIGHT_BEAT_ENABLED)) &#123;</span><br><span class="line">                    lightBeatEnabled = result.get(CommonParams.LIGHT_BEAT_ENABLED).asBoolean();</span><br><span class="line">                &#125;</span><br><span class="line">                BeatReactor.<span class="keyword">this</span>.lightBeatEnabled = lightBeatEnabled;</span><br><span class="line">                <span class="keyword">if</span> (interval &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    nextTime = interval;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> code = NamingResponseCode.OK;</span><br><span class="line">                <span class="keyword">if</span> (result.has(CommonParams.CODE)) &#123;</span><br><span class="line">                    code = result.get(CommonParams.CODE).asInt();</span><br><span class="line">                &#125;</span><br><span class="line">              	<span class="comment">// 如果nacos server返回NOT FOUND则重新发起注册请求</span></span><br><span class="line">                <span class="keyword">if</span> (code == NamingResponseCode.RESOURCE_NOT_FOUND) &#123;</span><br><span class="line">                    Instance instance = <span class="keyword">new</span> Instance();</span><br><span class="line">                    instance.setPort(beatInfo.getPort());</span><br><span class="line">                    instance.setIp(beatInfo.getIp());</span><br><span class="line">                    instance.setWeight(beatInfo.getWeight());</span><br><span class="line">                    instance.setMetadata(beatInfo.getMetadata());</span><br><span class="line">                    instance.setClusterName(beatInfo.getCluster());</span><br><span class="line">                    instance.setServiceName(beatInfo.getServiceName());</span><br><span class="line">                    instance.setInstanceId(instance.getInstanceId());</span><br><span class="line">                    instance.setEphemeral(<span class="keyword">true</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        serverProxy.registerService(beatInfo.getServiceName(),</span><br><span class="line">                                NamingUtils.getGroupName(beatInfo.getServiceName()), instance);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception ignore) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NacosException ex) &#123;</span><br><span class="line">                NAMING_LOGGER.error(<span class="string">&quot;[CLIENT-BEAT] failed to send beat: &#123;&#125;, code: &#123;&#125;, msg: &#123;&#125;&quot;</span>,</span><br><span class="line">                        JacksonUtils.toJson(beatInfo), ex.getErrCode(), ex.getErrMsg());</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">          	<span class="comment">// 默认为5秒，可以通过PreservedMetadataKeys.HEART_BEAT_INTERVAL设置</span></span><br><span class="line">            executorService.schedule(<span class="keyword">new</span> BeatTask(beatInfo), nextTime, TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>addBeatInfo调用时机，当节点在注册时如果实例为临时节点，则会创建心跳任务发起</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerService</span><span class="params">(String serviceName, String groupName, Instance instance)</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">        </span><br><span class="line">        NAMING_LOGGER.info(<span class="string">&quot;[REGISTER-SERVICE] &#123;&#125; registering service &#123;&#125; with instance: &#123;&#125;&quot;</span>, namespaceId, serviceName,instance);</span><br><span class="line">        String groupedServiceName = NamingUtils.getGroupedName(serviceName, groupName);</span><br><span class="line">        <span class="keyword">if</span> (instance.isEphemeral()) &#123;</span><br><span class="line">            BeatInfo beatInfo = beatReactor.buildBeatInfo(groupedServiceName, instance);</span><br><span class="line">          	<span class="comment">// 添加心跳任务</span></span><br><span class="line">            beatReactor.addBeatInfo(groupedServiceName, beatInfo);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> Map&lt;String, String&gt; params = <span class="keyword">new</span> HashMap&lt;String, String&gt;(<span class="number">16</span>);</span><br><span class="line">        params.put(CommonParams.NAMESPACE_ID, namespaceId);</span><br><span class="line">        params.put(CommonParams.SERVICE_NAME, groupedServiceName);</span><br><span class="line">        params.put(CommonParams.GROUP_NAME, groupName);</span><br><span class="line">        params.put(CommonParams.CLUSTER_NAME, instance.getClusterName());</span><br><span class="line">        params.put(<span class="string">&quot;ip&quot;</span>, instance.getIp());</span><br><span class="line">        params.put(<span class="string">&quot;port&quot;</span>, String.valueOf(instance.getPort()));</span><br><span class="line">        params.put(<span class="string">&quot;weight&quot;</span>, String.valueOf(instance.getWeight()));</span><br><span class="line">        params.put(<span class="string">&quot;enable&quot;</span>, String.valueOf(instance.isEnabled()));</span><br><span class="line">        params.put(<span class="string">&quot;healthy&quot;</span>, String.valueOf(instance.isHealthy()));</span><br><span class="line">        params.put(<span class="string">&quot;ephemeral&quot;</span>, String.valueOf(instance.isEphemeral()));</span><br><span class="line">        params.put(<span class="string">&quot;metadata&quot;</span>, JacksonUtils.toJson(instance.getMetadata()));</span><br><span class="line">        </span><br><span class="line">        reqApi(UtilAndComs.nacosUrlInstance, params, HttpMethod.POST);</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再跟踪下注册入口，判读使用哪个ClientProxy</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerService</span><span class="params">(String serviceName, String groupName, Instance instance)</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">    getExecuteClientProxy(instance).registerService(serviceName, groupName, instance);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> NamingClientProxy <span class="title">getExecuteClientProxy</span><span class="params">(Instance instance)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 是否为临时节点，临时节点使用grpc，持久节点使用http；默认为true，也就是默认使用grpcClientProxy</span></span><br><span class="line">        <span class="keyword">return</span> instance.isEphemeral() ? grpcClientProxy : httpClientProxy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>小结：</strong> HTTP心跳检测只适用于注册的节点持久节点，临时节点会使用grpc代理，即HTTP的心跳检测默认废弃由grpc替代；在初始化时客户端注册代理NamingClientProxy时，初始化了一个HTTP心跳器用于向Nacos Server发起心跳；在注册节点时通过向心跳执行器添加心跳任务addBeatInfo触发；心跳执行器通过每隔五秒中向Nacos Server发起HTTP请求，如果返回的server not found会向Nacos Server发起注册请求重新注册；</p>
<h3 id="UDP接受服务端推送"><a href="#UDP接受服务端推送" class="headerlink" title="UDP接受服务端推送"></a>UDP接受服务端推送</h3><p><strong>@注解7.4.2</strong> 初始化PushReceiver用于接受nacos server信息推送，使用UDP协议。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">PushReceiver</span><span class="params">(ServiceInfoHolder serviceInfoHolder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.serviceInfoHolder = serviceInfoHolder;</span><br><span class="line">            <span class="keyword">this</span>.udpSocket = <span class="keyword">new</span> DatagramSocket();</span><br><span class="line">            <span class="keyword">this</span>.executorService = <span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">1</span>, <span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">                    Thread thread = <span class="keyword">new</span> Thread(r);</span><br><span class="line">                    thread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">                    thread.setName(<span class="string">&quot;com.alibaba.nacos.naming.push.receiver&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> thread;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">this</span>.executorService.execute(<span class="keyword">this</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            NAMING_LOGGER.error(<span class="string">&quot;[NA] init udp socket failed&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>备注：</strong> PushReceiver实现Runnable接口，在构造方法中通过守护线程运行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (!closed) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// byte[] is initialized with 0 full filled by default</span></span><br><span class="line">      <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[UDP_MSS];</span><br><span class="line">      DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(buffer, buffer.length);</span><br><span class="line">      <span class="comment">// 接受nacos server推送</span></span><br><span class="line">      udpSocket.receive(packet);</span><br><span class="line">      <span class="comment">// 将推送内容转换为json字符串</span></span><br><span class="line">      String json = <span class="keyword">new</span> String(IoUtils.tryDecompress(packet.getData()), UTF_8).trim();</span><br><span class="line">      NAMING_LOGGER.info(<span class="string">&quot;received push data: &quot;</span> + json + <span class="string">&quot; from &quot;</span> + packet.getAddress().toString());</span><br><span class="line">      PushPacket pushPacket = JacksonUtils.toObj(json, PushPacket.class);</span><br><span class="line">      String ack;</span><br><span class="line">      <span class="comment">// 推送类型服务信息（例如订阅实例的变更）会通知订阅者逻辑已在上篇分析</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="string">&quot;dom&quot;</span>.equals(pushPacket.type) || <span class="string">&quot;service&quot;</span>.equals(pushPacket.type)) &#123;</span><br><span class="line">        serviceInfoHolder.processServiceInfo(pushPacket.data);</span><br><span class="line">        <span class="comment">// send ack to server</span></span><br><span class="line">        ack = <span class="string">&quot;&#123;\&quot;type\&quot;: \&quot;push-ack\&quot;&quot;</span> + <span class="string">&quot;, \&quot;lastRefTime\&quot;:\&quot;&quot;</span> + pushPacket.lastRefTime + <span class="string">&quot;\&quot;, \&quot;data\&quot;:&quot;</span></span><br><span class="line">          + <span class="string">&quot;\&quot;\&quot;&#125;&quot;</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;dump&quot;</span>.equals(pushPacket.type)) &#123;</span><br><span class="line">        <span class="comment">// dump data to server</span></span><br><span class="line">        ack = <span class="string">&quot;&#123;\&quot;type\&quot;: \&quot;dump-ack\&quot;&quot;</span> + <span class="string">&quot;, \&quot;lastRefTime\&quot;: \&quot;&quot;</span> + pushPacket.lastRefTime + <span class="string">&quot;\&quot;, \&quot;data\&quot;:&quot;</span></span><br><span class="line">          + <span class="string">&quot;\&quot;&quot;</span> + StringUtils.escapeJavaScript(JacksonUtils.toJson(serviceInfoHolder.getServiceInfoMap()))</span><br><span class="line">          + <span class="string">&quot;\&quot;&#125;&quot;</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// do nothing send ack only</span></span><br><span class="line">        ack = <span class="string">&quot;&#123;\&quot;type\&quot;: \&quot;unknown-ack\&quot;&quot;</span> + <span class="string">&quot;, \&quot;lastRefTime\&quot;:\&quot;&quot;</span> + pushPacket.lastRefTime</span><br><span class="line">          + <span class="string">&quot;\&quot;, \&quot;data\&quot;:&quot;</span> + <span class="string">&quot;\&quot;\&quot;&#125;&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">			<span class="comment">// 向Server发送ack消息</span></span><br><span class="line">      udpSocket.send(<span class="keyword">new</span> DatagramPacket(ack.getBytes(UTF_8), ack.getBytes(UTF_8).length,</span><br><span class="line">                                        packet.getSocketAddress()));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      NAMING_LOGGER.error(<span class="string">&quot;[NA] error while receiving push data&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>小结：</strong> Client通过UDP接受到nacos server推动的消息：@1如果推送的为服务信息通过processServiceInfo处理，逻辑见上篇；@2 如果dump类型，则客户端发送服务信息serviceInfoMap的ack信息到服务端。</p>
<h3 id="HTTP重试次数"><a href="#HTTP重试次数" class="headerlink" title="HTTP重试次数"></a>HTTP重试次数</h3><p><strong>@注解7.4.3</strong>  client通过HTTP向Nacos Server请求的重试次数，默认为3次。可以通过「namingRequestDomainMaxRetryCount」指定</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">reqApi</span><span class="params">(String api, Map&lt;String, String&gt; params, Map&lt;String, String&gt; body, List&lt;String&gt; servers,</span></span></span><br><span class="line"><span class="function"><span class="params">           String method)</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">		<span class="keyword">if</span> (serverListManager.isDomain()) &#123;</span><br><span class="line">           String nacosDomain = serverListManager.getNacosDomain();</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxRetry; i++) &#123; <span class="comment">// 请求发送异常最大重试次数</span></span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="keyword">return</span> callServer(api, params, body, nacosDomain, method);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (NacosException e) &#123;</span><br><span class="line">                   exception = e;</span><br><span class="line">                   <span class="keyword">if</span> (NAMING_LOGGER.isDebugEnabled()) &#123;</span><br><span class="line">                       NAMING_LOGGER.debug(<span class="string">&quot;request &#123;&#125; failed.&quot;</span>, nacosDomain, e);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="gRPC代理初始化-1"><a href="#gRPC代理初始化-1" class="headerlink" title="gRPC代理初始化"></a>gRPC代理初始化</h1><h3 id="gRPC初始化逻辑概览"><a href="#gRPC初始化逻辑概览" class="headerlink" title="gRPC初始化逻辑概览"></a>gRPC初始化逻辑概览</h3><p><strong>@注解7.5</strong> 下面接着gRPC 客户端代理的初始化逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NamingGrpcClientProxy</span><span class="params">(String namespaceId, SecurityProxy securityProxy, ServerListFactory serverListFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">            Properties properties, ServiceInfoHolder serviceInfoHolder)</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(securityProxy, properties);</span><br><span class="line">        <span class="keyword">this</span>.namespaceId = namespaceId;</span><br><span class="line">        <span class="keyword">this</span>.uuid = UUID.randomUUID().toString();</span><br><span class="line">        <span class="comment">// 设置请求超时时间，默认为3秒。可以通过参数「namingRequestTimeout」设置</span></span><br><span class="line">        <span class="keyword">this</span>.requestTimeout = Long.parseLong(properties.getProperty(CommonParams.NAMING_REQUEST_TIMEOUT, <span class="string">&quot;-1&quot;</span>));</span><br><span class="line">        Map&lt;String, String&gt; labels = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">        <span class="comment">// 设置source=sdk，module=naming</span></span><br><span class="line">        labels.put(RemoteConstants.LABEL_SOURCE, RemoteConstants.LABEL_SOURCE_SDK);</span><br><span class="line">        labels.put(RemoteConstants.LABEL_MODULE, RemoteConstants.LABEL_MODULE_NAMING);</span><br><span class="line">        <span class="comment">// 创建gRPC Client：clientName=uuid，ConnectionType=GRPC</span></span><br><span class="line">        <span class="keyword">this</span>.rpcClient = RpcClientFactory.createClient(uuid, ConnectionType.GRPC, labels);</span><br><span class="line">        <span class="comment">// 创建ConnectionEventListener用于建立和断开gRPC连接时的事件响应</span></span><br><span class="line">        <span class="keyword">this</span>.namingGrpcConnectionEventListener = <span class="keyword">new</span> NamingGrpcConnectionEventListener(<span class="keyword">this</span>);</span><br><span class="line"> 			  <span class="comment">// 启动grpc client</span></span><br><span class="line">        start(serverListFactory, serviceInfoHolder);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(ServerListFactory serverListFactory, ServiceInfoHolder serviceInfoHolder)</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">        rpcClient.serverListFactory(serverListFactory);</span><br><span class="line">  			<span class="comment">// @注解7.5.1 gRPC Client启动</span></span><br><span class="line">        rpcClient.start();</span><br><span class="line">  			<span class="comment">// 注册registerServerRequestHandler用于处理从Nacos Push到Client的请求</span></span><br><span class="line">        rpcClient.registerServerRequestHandler(<span class="keyword">new</span> NamingPushRequestHandler(serviceInfoHolder));</span><br><span class="line">  			<span class="comment">// 注册连接事件Listener，当连接建立和断开时处理事件</span></span><br><span class="line">        rpcClient.registerConnectionListener(namingGrpcConnectionEventListener);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>小结：</strong> gRPC 客户端代理的初始化主要逻辑为创建gRPC Client并启动；并注册ServerRequestHandler用于处理Nacos Server推送的NotifySubscriberRequest请求；注册ConnectionListener用于处理gRPC建立和断开连接事件；另外，请求超时时间可以通过「namingRequestTimeout」设置，默认为3秒。</p>
<h3 id="gRPC-Client启动逻辑"><a href="#gRPC-Client启动逻辑" class="headerlink" title="gRPC Client启动逻辑"></a>gRPC Client启动逻辑</h3><p><strong>@注解7.5.1</strong>  gRPC Client启动逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">  <span class="comment">// 将Client状态由INITIALIZED变更为STARTING</span></span><br><span class="line">  <span class="keyword">boolean</span> success = rpcClientStatus.compareAndSet(RpcClientStatus.INITIALIZED, RpcClientStatus.STARTING);</span><br><span class="line">  <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// -------------------------@1 satart---------------------------------------------</span></span><br><span class="line">  <span class="comment">// 守护线程执行器</span></span><br><span class="line">  clientEventExecutor = <span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">2</span>, <span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">      Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line">      t.setName(<span class="string">&quot;com.alibaba.nacos.client.remote.worker&quot;</span>);</span><br><span class="line">      t.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">      <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">	</span><br><span class="line">  <span class="comment">// 从BlockingQueue中不断获取连接Event，根据事件类型回调onConnected()/onDisConnect()事件</span></span><br><span class="line">  clientEventExecutor.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        ConnectionEvent take = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          take = eventLinkedBlockingQueue.take();</span><br><span class="line">          <span class="keyword">if</span> (take.isConnected()) &#123;</span><br><span class="line">            notifyConnected();</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (take.isDisConnected()) &#123;</span><br><span class="line">            notifyDisConnected();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">          <span class="comment">//Do nothing</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">	<span class="comment">// -------------------------@1 end---------------------------------------------</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// -------------------------@2 start---------------------------------------------</span></span><br><span class="line">  clientEventExecutor.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 获取重定向连接上下文，指重新连接到其他server节点</span></span><br><span class="line">          ReconnectContext reconnectContext = reconnectionSignal</span><br><span class="line">            .poll(keepAliveTime, TimeUnit.MILLISECONDS);</span><br><span class="line">          <span class="keyword">if</span> (reconnectContext == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// check alive time.</span></span><br><span class="line">            <span class="comment">// client活动时间超过5秒钟，向Nacos Server发起健康检测</span></span><br><span class="line">            <span class="keyword">if</span> (System.currentTimeMillis() - lastActiveTimeStamp &gt;= keepAliveTime) &#123;</span><br><span class="line">              <span class="comment">// 发送健康检查</span></span><br><span class="line">              <span class="keyword">boolean</span> isHealthy = healthCheck();</span><br><span class="line">              <span class="comment">// 非健康节点</span></span><br><span class="line">              <span class="keyword">if</span> (!isHealthy) &#123;</span><br><span class="line">                <span class="keyword">if</span> (currentConnection == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                LoggerUtils.printIfInfoEnabled(LOGGER,</span><br><span class="line">                                               <span class="string">&quot;[&#123;&#125;]Server healthy check fail,currentConnection=&#123;&#125;&quot;</span>, name,</span><br><span class="line">                                               currentConnection.getConnectionId());</span><br><span class="line">                <span class="comment">// 标记客户端状态为unhealthy</span></span><br><span class="line">                rpcClientStatus.set(RpcClientStatus.UNHEALTHY);</span><br><span class="line">                <span class="comment">// 重置ReconnectContext移除serverInfo</span></span><br><span class="line">                reconnectContext = <span class="keyword">new</span> ReconnectContext(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 健康连接更新时间戳</span></span><br><span class="line">                lastActiveTimeStamp = System.currentTimeMillis();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// 心跳保鲜未过期，跳过本次检测</span></span><br><span class="line">              <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (reconnectContext.serverInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// clear recommend server if server is not in server list.</span></span><br><span class="line">            <span class="keyword">boolean</span> serverExist = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 判断连接上下文的reconnectContext.serverInfo是否在我们推荐设置的列表中</span></span><br><span class="line">            <span class="keyword">for</span> (String server : getServerListFactory().getServerList()) &#123;</span><br><span class="line">              ServerInfo serverInfo = resolveServerInfo(server);</span><br><span class="line">              <span class="keyword">if</span> (serverInfo.getServerIp().equals(reconnectContext.serverInfo.getServerIp())) &#123;</span><br><span class="line">                serverExist = <span class="keyword">true</span>;</span><br><span class="line">                reconnectContext.serverInfo.serverPort = serverInfo.serverPort;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 不再推荐的列表中则移除，改为随机选择</span></span><br><span class="line">            <span class="keyword">if</span> (!serverExist) &#123;</span><br><span class="line">              LoggerUtils.printIfInfoEnabled(LOGGER,</span><br><span class="line">                                             <span class="string">&quot;[&#123;&#125;] Recommend server is not in server list ,ignore recommend server &#123;&#125;&quot;</span>, name,</span><br><span class="line">                                             reconnectContext.serverInfo.getAddress());</span><br><span class="line"></span><br><span class="line">              reconnectContext.serverInfo = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 发起重新连接</span></span><br><span class="line">          reconnect(reconnectContext.serverInfo, reconnectContext.onRequestFail);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">          <span class="comment">//Do nothing</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// -------------------------@2 end---------------------------------------------</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// -------------------------@3 start---------------------------------------------</span></span><br><span class="line">  <span class="comment">// 异步连接nacos server失败，改为同步连接</span></span><br><span class="line">  <span class="comment">//connect to server ,try to connect to server sync once, async starting if fail.</span></span><br><span class="line">  Connection connectToServer = <span class="keyword">null</span>;</span><br><span class="line">  rpcClientStatus.set(RpcClientStatus.STARTING);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> startUpRetryTimes = RETRY_TIMES;</span><br><span class="line">  <span class="keyword">while</span> (startUpRetryTimes &gt; <span class="number">0</span> &amp;&amp; connectToServer == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      startUpRetryTimes--;</span><br><span class="line">      ServerInfo serverInfo = nextRpcServer();</span><br><span class="line"></span><br><span class="line">      LoggerUtils.printIfInfoEnabled(LOGGER, <span class="string">&quot;[&#123;&#125;] Try to connect to server on start up, server: &#123;&#125;&quot;</span>, name,</span><br><span class="line">                                     serverInfo);</span><br><span class="line"></span><br><span class="line">      connectToServer = connectToServer(serverInfo);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">      LoggerUtils.printIfWarnEnabled(LOGGER,</span><br><span class="line">                                     <span class="string">&quot;[&#123;&#125;]Fail to connect to server on start up, error message=&#123;&#125;, start up retry times left: &#123;&#125;&quot;</span>,</span><br><span class="line">                                     name, e.getMessage(), startUpRetryTimes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// -------------------------@3 end---------------------------------------------</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">	<span class="comment">// -------------------------@4 start---------------------------------------------</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (connectToServer != <span class="keyword">null</span>) &#123;</span><br><span class="line">    LoggerUtils.printIfInfoEnabled(LOGGER, <span class="string">&quot;[&#123;&#125;] Success to connect to server [&#123;&#125;] on start up,connectionId=&#123;&#125;&quot;</span>,name, connectToServer.serverInfo.getAddress(),connectToServer.getConnectionId());</span><br><span class="line">      <span class="keyword">this</span>.currentConnection = connectToServer;</span><br><span class="line">      rpcClientStatus.set(RpcClientStatus.RUNNING);</span><br><span class="line">      <span class="comment">// 连接成功添加ConnectionEvent</span></span><br><span class="line">      eventLinkedBlockingQueue.offer(<span class="keyword">new</span> ConnectionEvent(ConnectionEvent.CONNECTED));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	<span class="comment">// 未成功建立连接重新发起异步建立连接需求</span></span><br><span class="line">      switchServerAsync();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">	<span class="comment">// 注册ConnectResetRequestHandler用于处理nacos server推送的重置连接请求</span></span><br><span class="line">  registerServerRequestHandler(<span class="keyword">new</span> ConnectResetRequestHandler());</span><br><span class="line"></span><br><span class="line">  <span class="comment">//register client detection request.</span></span><br><span class="line">  registerServerRequestHandler(<span class="keyword">new</span> ServerRequestHandler() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Response <span class="title">requestReply</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (request <span class="keyword">instanceof</span> ClientDetectionRequest) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ClientDetectionResponse();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        RpcClient.<span class="keyword">this</span>.shutdown();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (NacosException e) &#123;</span><br><span class="line">        LoggerUtils.printIfErrorEnabled(LOGGER, <span class="string">&quot;[&#123;&#125;]RpcClient shutdown exception, errorMessage =&#123;&#125;&quot;</span>, name,</span><br><span class="line">                                        e.getMessage());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// -------------------------@4 end---------------------------------------------</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>备注：</strong> grpc client启动时的逻辑：<strong>逻辑块@1</strong>  守护线程不断从阻塞队列eventLinkedBlockingQueue获取grpc连接/断开事件，并调用上文中注册的namingGrpcConnectionEventListener回调其onConnected/onDisConnect方法。 其中事件添加时机为：</p>
<p>grpc连接建立时，添加连接事件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 连接成功添加ConnectionEvent</span></span><br><span class="line">eventLinkedBlockingQueue.offer(<span class="keyword">new</span> ConnectionEvent(ConnectionEvent.CONNECTED));</span><br></pre></td></tr></table></figure>

<p>grpc连接关闭时，添加关闭事件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">closeConnection</span><span class="params">(Connection connection)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">            connection.close();</span><br><span class="line">            <span class="comment">// 断开连接添加DISCONNECTED事件</span></span><br><span class="line">            eventLinkedBlockingQueue.add(<span class="keyword">new</span> ConnectionEvent(ConnectionEvent.DISCONNECTED));</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>逻辑块@2</strong>  守护线程不断从阻塞队列reconnectionSignal获取重新连接事件（ReconnectContext）也就是更换nacos server的连接grpc通道：</p>
<p>阻塞队列没有重新连接事件：则做心跳保鲜检测，心跳频率为5秒。当超过5秒时会向Nacos Server发起健康检查，当返回不健康时，将grpc client标记为unhealthy；返回健康则刷新心跳时间lastActiveTimeStamp。</p>
<p>阻塞队列有重新连接事件：重连事件上下文reconnectContext的的server ip在我们设置的nacos server 列表则使用，否则改为随机选择nacos server ip地址，并与新server建立连接。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reconnect</span><span class="params">(<span class="keyword">final</span> ServerInfo recommendServerInfo, <span class="keyword">boolean</span> onRequestFail)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">    AtomicReference&lt;ServerInfo&gt; recommendServer = <span class="keyword">new</span> AtomicReference&lt;ServerInfo&gt;(recommendServerInfo);</span><br><span class="line">    <span class="comment">// onRequestFail=true表示当健康检查失败grpcClient被设置为unhealthy，重连时重新发起健康检查，如果检查通过则不再执行重连</span></span><br><span class="line">    <span class="keyword">if</span> (onRequestFail &amp;&amp; healthCheck()) &#123;</span><br><span class="line">      LoggerUtils.printIfInfoEnabled(LOGGER, <span class="string">&quot;[&#123;&#125;] Server check success,currentServer is&#123;&#125; &quot;</span>, name,</span><br><span class="line">                                     currentConnection.serverInfo.getAddress());</span><br><span class="line">      rpcClientStatus.set(RpcClientStatus.RUNNING);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LoggerUtils.printIfInfoEnabled(LOGGER, <span class="string">&quot;[&#123;&#125;] try to re connect to a new server ,server is &#123;&#125;&quot;</span>, name,</span><br><span class="line">                                   recommendServerInfo == <span class="keyword">null</span> ? <span class="string">&quot; not appointed,will choose a random server.&quot;</span></span><br><span class="line">                                   : (recommendServerInfo.getAddress() + <span class="string">&quot;, will try it once.&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// loop until start client success.</span></span><br><span class="line">    <span class="keyword">boolean</span> switchSuccess = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> reConnectTimes = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> retryTurns = <span class="number">0</span>;</span><br><span class="line">    Exception lastException = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 切换nacos server没有成功则会一直重试</span></span><br><span class="line">    <span class="keyword">while</span> (!switchSuccess &amp;&amp; !isShutdown()) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//1.get a new server</span></span><br><span class="line">      ServerInfo serverInfo = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取需要重新连接的server地址</span></span><br><span class="line">        serverInfo = recommendServer.get() == <span class="keyword">null</span> ? nextRpcServer() : recommendServer.get();</span><br><span class="line">        <span class="comment">//2.create a new channel to new server</span></span><br><span class="line">        <span class="comment">// 与新的server建立grpc连接，如果连接失败返回null</span></span><br><span class="line">        Connection connectionNew = connectToServer(serverInfo);</span><br><span class="line">        <span class="comment">// 关闭缓存的当前连接并重定向到新的连接</span></span><br><span class="line">        <span class="keyword">if</span> (connectionNew != <span class="keyword">null</span>) &#123;</span><br><span class="line">          LoggerUtils.printIfInfoEnabled(LOGGER, <span class="string">&quot;[&#123;&#125;] success to connect a server  [&#123;&#125;],connectionId=&#123;&#125;&quot;</span>,</span><br><span class="line">                                         name, serverInfo.getAddress(), connectionNew.getConnectionId());</span><br><span class="line">          <span class="comment">//successfully create a new connect.</span></span><br><span class="line">          <span class="keyword">if</span> (currentConnection != <span class="keyword">null</span>) &#123;</span><br><span class="line">            LoggerUtils.printIfInfoEnabled(LOGGER,<span class="string">&quot;[&#123;&#125;] Abandon prev connection ,server is  &#123;&#125;, connectionId is &#123;&#125;&quot;</span>, name,currentConnection.serverInfo.getAddress(), currentConnection.getConnectionId());</span><br><span class="line">            <span class="comment">//set current connection to enable connection event.</span></span><br><span class="line">            currentConnection.setAbandon(<span class="keyword">true</span>);</span><br><span class="line">            closeConnection(currentConnection);</span><br><span class="line">          &#125;</span><br><span class="line">          currentConnection = connectionNew;</span><br><span class="line">          rpcClientStatus.set(RpcClientStatus.RUNNING);</span><br><span class="line">          switchSuccess = <span class="keyword">true</span>;</span><br><span class="line">          <span class="comment">// 添加连接成功时间到阻塞队列</span></span><br><span class="line">          <span class="keyword">boolean</span> s = eventLinkedBlockingQueue.add(<span class="keyword">new</span> ConnectionEvent(ConnectionEvent.CONNECTED));</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//close connection if client is already shutdown.</span></span><br><span class="line">        <span class="keyword">if</span> (isShutdown()) &#123;</span><br><span class="line">          closeConnection(currentConnection);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        lastException = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        lastException = e;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 清理本次重连请求</span></span><br><span class="line">        recommendServer.set(<span class="keyword">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 执行到这里表示上面没有成功建立连接，打印重试次数日志</span></span><br><span class="line">      <span class="keyword">if</span> (reConnectTimes &gt; <span class="number">0</span></span><br><span class="line">          &amp;&amp; reConnectTimes % RpcClient.<span class="keyword">this</span>.serverListFactory.getServerList().size() == <span class="number">0</span>) &#123;</span><br><span class="line">        LoggerUtils.printIfInfoEnabled(LOGGER,<span class="string">&quot;[&#123;&#125;] fail to connect server,after trying &#123;&#125; times, last try server is &#123;&#125;,error=&#123;&#125;&quot;</span>, name,reConnectTimes, serverInfo, lastException == <span class="keyword">null</span> ? <span class="string">&quot;unknown&quot;</span> : lastException);</span><br><span class="line">        <span class="keyword">if</span> (Integer.MAX_VALUE == retryTurns) &#123;</span><br><span class="line">          retryTurns = <span class="number">50</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          retryTurns++;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      reConnectTimes++;</span><br><span class="line">			<span class="comment">// 重试时等待特定的时间</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//sleep x milliseconds to switch next server.</span></span><br><span class="line">        <span class="keyword">if</span> (!isRunning()) &#123;</span><br><span class="line">          <span class="comment">// first round ,try servers at a delay 100ms;second round ,200ms; max delays 5s. to be reconsidered.</span></span><br><span class="line">          Thread.sleep(Math.min(retryTurns + <span class="number">1</span>, <span class="number">50</span>) * <span class="number">100L</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="comment">// Do  nothing.</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isShutdown()) &#123;</span><br><span class="line">      LoggerUtils.printIfInfoEnabled(LOGGER, <span class="string">&quot;[&#123;&#125;] Client is shutdown ,stop reconnect to server&quot;</span>, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    LoggerUtils.printIfWarnEnabled(LOGGER, <span class="string">&quot;[&#123;&#125;] Fail to  re connect to server ,error is &#123;&#125;&quot;</span>, name, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>备注：</strong> 重新切换连接server逻辑：@1当检查失败grpc client会被标记为unhealthy这类型onRequestFail为true，重连时重新发起健康检查，如果检查成功，则退出本次重连。@2 获取重连的server地址和端口，并建立grpc连接，关闭当前缓存的旧连接并重定向到新连接，同时添加连接成功时间到阻塞队列。@3 一直重试直到连接建立成功，每次重试等待一些时间（100ms,200ms…最大为5秒）。</p>
<p><strong>逻辑块@3</strong> 当异步与nacos server建立失败时，改为尝试同步建立连接。</p>
<p><strong>逻辑块@4</strong> 如果连接建立成功添加连接事件到阻塞队列；连接建立失败发起异步建立连接请求；注册ConnectResetRequestHandler用于处理nacos server推送的重置连接请求；jvm退出时通过hook关闭grpc client。</p>
<p><strong>小结：</strong>  gRPC Client启动逻辑主要在于建立与nacos server的grpc连接，其中两个守护线程一直在运行。一个用于处理grpc连接的建立和关闭事件；一个用于与nacos server的心跳保鲜，并负责异步建立grpc连接，当nacos server的地址信息发生变更时负责重新与新server建立连接；grpc client只与nacos server集群中一台建立grpc连接。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>Nacos</category>
      </categories>
      <tags>
        <tag>Nacos</tag>
      </tags>
  </entry>
  <entry>
    <title>Nacos4# 服务端响应连接和注册源码分析（一）</title>
    <url>/posts/d65dffb2/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>上篇文章分析了Nacos服务端启动的逻辑，本文分析启动时加载了哪些Handler，以及处理连接请求和注册请求的逻辑。</p>
<h1 id="内容提要"><a href="#内容提要" class="headerlink" title="内容提要"></a>内容提要</h1><h3 id="加载RequestHandler"><a href="#加载RequestHandler" class="headerlink" title="加载RequestHandler"></a>加载RequestHandler</h3><ul>
<li>容器启动时加载了13个RequestHandler由他们实际处理各种请求逻辑后面章节再细撸</li>
<li>当然也加载了InstanceRequest-&gt;InstanceRequestHandler</li>
</ul>
<h3 id="服务端响应客户端连接"><a href="#服务端响应客户端连接" class="headerlink" title="服务端响应客户端连接"></a>服务端响应客户端连接</h3><ul>
<li>处理客户端的连接请求由GrpcBiStreamRequestAcceptor#requestBiStream负责</li>
<li>构建和缓存了GrpcConnection对象和Client对象</li>
</ul>
<h3 id="服务端处理注册请求"><a href="#服务端处理注册请求" class="headerlink" title="服务端处理注册请求"></a>服务端处理注册请求</h3><ul>
<li> 处理注册请求的逻辑由InstanceRequestHandler执行</li>
<li> 建立起了client与service、instance的关系</li>
<li>发布了三个事件ClientEvent.ClientChangedEvent、ClientOperationEvent.ClientRegisterServiceEvent、MetadataEvent.InstanceMetadataEvent</li>
</ul>
<a id="more"></a>



<h1 id="加载RequestHandler-1"><a href="#加载RequestHandler-1" class="headerlink" title="加载RequestHandler"></a>加载RequestHandler</h1><p>com.alibaba.nacos.core.remote#RequestHandlerRegistry实现了ApplicationListener，在spring启动后回调onApplicationEvent。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ContextRefreshedEvent event)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 注解@1</span></span><br><span class="line">  Map&lt;String, RequestHandler&gt; beansOfType = event.getApplicationContext().getBeansOfType(RequestHandler.class);</span><br><span class="line">  Collection&lt;RequestHandler&gt; values = beansOfType.values();</span><br><span class="line">  <span class="keyword">for</span> (RequestHandler requestHandler : values) &#123;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; clazz = requestHandler.getClass();</span><br><span class="line">    <span class="keyword">boolean</span> skip = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (!clazz.getSuperclass().equals(RequestHandler.class)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (clazz.getSuperclass().equals(Object.class)) &#123;</span><br><span class="line">        skip = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      clazz = clazz.getSuperclass();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (skip) &#123; <span class="comment">// 注解@2 </span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 注解@3</span></span><br><span class="line">      Method method = clazz.getMethod(<span class="string">&quot;handle&quot;</span>, Request.class, RequestMeta.class);</span><br><span class="line">      <span class="keyword">if</span> (method.isAnnotationPresent(TpsControl.class) &amp;&amp; TpsControlConfig.isTpsControlEnabled()) &#123;</span><br><span class="line">        TpsControl tpsControl = method.getAnnotation(TpsControl.class);</span><br><span class="line">        String pointName = tpsControl.pointName();</span><br><span class="line">        TpsMonitorPoint tpsMonitorPoint = <span class="keyword">new</span> TpsMonitorPoint(pointName);</span><br><span class="line">        tpsMonitorManager.registerTpsControlPoint(tpsMonitorPoint);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="comment">//ignore.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注解@4</span></span><br><span class="line">    Class tClass = (Class) ((ParameterizedType) clazz.getGenericSuperclass()).getActualTypeArguments()[<span class="number">0</span>];</span><br><span class="line">    registryHandlers.putIfAbsent(tClass.getSimpleName(), requestHandler);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@1：</strong> 获取RequestHandler的众多实现类</p>
<p><strong>注解@2：</strong> 跳过超类RequestHandler</p>
<p><strong>注解@3：</strong> 获取需要带有「TpsControl」注解的方法，表示需要对流量Tps控制</p>
<p><strong>注解@4：</strong> 将Handler装载到缓存 例如：InstanceRequest-&gt;InstanceRequestHandler</p>
<p><strong>小结：</strong> 在spring启动时转载了众多的RequestHandler，这些Handler是真正的逻辑所在。下面列表时加载的13个RequestHandler</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Value</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>ConfigBatchListenRequest</td>
<td>ConfigChangeBatchListenRequestHandler</td>
<td></td>
</tr>
<tr>
<td>ConfigChangeClusterSyncRequest</td>
<td>ConfigChangeClusterSyncRequestHandler</td>
<td></td>
</tr>
<tr>
<td>ConfigPublishRequest</td>
<td>ConfigPublishRequestHandler</td>
<td></td>
</tr>
<tr>
<td>ConfigQueryRequest</td>
<td>ConfigQueryRequestHandler</td>
<td></td>
</tr>
<tr>
<td>ConfigRemoveRequest</td>
<td>ConfigRemoveRequestHandler</td>
<td></td>
</tr>
<tr>
<td>HealthCheckRequest</td>
<td>HealthCheckRequestHandler</td>
<td></td>
</tr>
<tr>
<td>ServerLoaderInfoRequest</td>
<td>ServerLoaderInfoRequestHandler</td>
<td></td>
</tr>
<tr>
<td>ServerReloadRequest</td>
<td>ServerReloaderRequestHandler</td>
<td></td>
</tr>
<tr>
<td>DistroDataRequest</td>
<td>DistroDataRequestHandler</td>
<td></td>
</tr>
<tr>
<td>InstanceRequest</td>
<td>InstanceRequestHandler</td>
<td></td>
</tr>
<tr>
<td>ServiceListRequest</td>
<td>ServiceListRequestHandler</td>
<td></td>
</tr>
<tr>
<td>ConfigPublishRequest</td>
<td>ConfigPublishRequestHandler</td>
<td></td>
</tr>
<tr>
<td>SubscribeServiceRequest</td>
<td>SubscribeServiceRequestHandler</td>
<td></td>
</tr>
</tbody></table>
<h1 id="服务端响应客户端连接-1"><a href="#服务端响应客户端连接-1" class="headerlink" title="服务端响应客户端连接"></a>服务端响应客户端连接</h1><h3 id="client连接server"><a href="#client连接server" class="headerlink" title="client连接server"></a>client连接server</h3><p>在前面《Nacos2# 服务注册与发现客户端示例与源码解析（二）》中client会与server建立连接具体方法为connectToServer()。</p>
<p>在分下《Nacos3# 服务注册与发现服务端启动源码解析》时protobuf文件装载了两类grpc请求类型，其中一类为双向流调用方式BiRequestStream#biRequestStream。</p>
<p>客户端发起connectToServer()时正式双向流调用类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> Connection <span class="title">connectToServer</span><span class="params">(ServerInfo serverInfo)</span> </span>&#123;</span><br><span class="line"> 		<span class="comment">// ... </span></span><br><span class="line">    BiRequestStreamGrpc.BiRequestStreamStub biRequestStreamStub = BiRequestStreamGrpc</span><br><span class="line">                        .newStub(newChannelStubTemp.getChannel());</span><br><span class="line">    </span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> StreamObserver&lt;Payload&gt; <span class="title">bindRequestStream</span><span class="params">(<span class="keyword">final</span> BiRequestStreamGrpc.BiRequestStreamStub streamStub,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">final</span> GrpcConnection grpcConn)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> streamStub.requestBiStream(<span class="keyword">new</span> StreamObserver&lt;Payload&gt;() &#123;</span><br><span class="line">          </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那在nacos server端如何响应的呢？</p>
<h3 id="Nacos-server响应连接"><a href="#Nacos-server响应连接" class="headerlink" title="Nacos server响应连接"></a>Nacos server响应连接</h3><p>在分析《Nacos3# 服务注册与发现服务端启动源码解析》服务端grpc启动构建暴露的服务定义信息时添加了requestBiStream</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addServices</span><span class="params">(MutableHandlerRegistry handlerRegistry, ServerInterceptor... serverInterceptor)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">		<span class="comment">// 服务接口处理类</span></span><br><span class="line">  <span class="keyword">final</span> ServerCallHandler&lt;Payload, Payload&gt; biStreamHandler = ServerCalls.asyncBidiStreamingCall(</span><br><span class="line">    (responseObserver) -&gt; grpcBiStreamRequestAcceptor.requestBiStream(responseObserver));</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">   <span class="keyword">final</span> ServerServiceDefinition serviceDefOfBiStream = ServerServiceDefinition</span><br><span class="line">               .builder(REQUEST_BI_STREAM_SERVICE_NAME).addMethod(biStreamMethod, biStreamHandler).build();    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来看其处理连接请求逻辑。坐标GrpcBiStreamRequestAcceptor#requestBiStream</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StreamObserver&lt;Payload&gt; <span class="title">requestBiStream</span><span class="params">(StreamObserver&lt;Payload&gt; responseObserver)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  StreamObserver&lt;Payload&gt; streamObserver = <span class="keyword">new</span> StreamObserver&lt;Payload&gt;() &#123;</span><br><span class="line">		<span class="comment">// 连接标识 eg. connectionId=1623495108814_127.0.0.1_54314</span></span><br><span class="line">    <span class="keyword">final</span> String connectionId = CONTEXT_KEY_CONN_ID.get();</span><br><span class="line">		<span class="comment">// eg. localPort=9848</span></span><br><span class="line">    <span class="keyword">final</span> Integer localPort = CONTEXT_KEY_CONN_LOCAL_PORT.get();</span><br><span class="line">		<span class="comment">// eg. remotePort=54314</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> remotePort = CONTEXT_KEY_CONN_REMOTE_PORT.get();</span><br><span class="line">		<span class="comment">// eg. remoteIp=127.0.0.1</span></span><br><span class="line">    String remoteIp = CONTEXT_KEY_CONN_REMOTE_IP.get();</span><br><span class="line">		<span class="comment">// eg. clientIp=192.168.0.110</span></span><br><span class="line">    String clientIp = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Payload payload)</span> </span>&#123;</span><br><span class="line">			<span class="comment">// 解析客户端IP</span></span><br><span class="line">      clientIp = payload.getMetadata().getClientIp();</span><br><span class="line">      traceDetailIfNecessary(payload);</span><br><span class="line"></span><br><span class="line">      Object parseObj = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        parseObj = GrpcUtils.parse(payload); <span class="comment">// 将二进制转换为对象</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">        </span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      <span class="keyword">if</span> (parseObj <span class="keyword">instanceof</span> ConnectionSetupRequest) &#123;</span><br><span class="line">        ConnectionSetupRequest setUpRequest = (ConnectionSetupRequest) parseObj;</span><br><span class="line">        Map&lt;String, String&gt; labels = setUpRequest.getLabels();</span><br><span class="line">        String appName = <span class="string">&quot;-&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (labels != <span class="keyword">null</span> &amp;&amp; labels.containsKey(Constants.APPNAME)) &#123;</span><br><span class="line">          appName = labels.get(Constants.APPNAME);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       ConnectionMeta metaInfo = <span class="keyword">new</span> ConnectionMeta(connectionId, payload.getMetadata().getClientIp(),</span><br><span class="line">           remoteIp, remotePort, localPort,ConnectionType.GRPC.getType(),setUpRequest.getClientVersion(), appName, setUpRequest.getLabels());</span><br><span class="line">        metaInfo.setTenant(setUpRequest.getTenant());</span><br><span class="line">        <span class="comment">// 注解@5</span></span><br><span class="line">        Connection connection = <span class="keyword">new</span> GrpcConnection(metaInfo, responseObserver, CONTEXT_KEY_CHANNEL.get());</span><br><span class="line">        connection.setAbilities(setUpRequest.getAbilities());</span><br><span class="line">        <span class="keyword">boolean</span> rejectSdkOnStarting = metaInfo.isSdkSource() &amp;&amp; !ApplicationUtils.isStarted();</span><br><span class="line">				<span class="comment">// 注解@6</span></span><br><span class="line">        <span class="keyword">if</span> (rejectSdkOnStarting || !connectionManager.register(connectionId, connection)) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">           </span><br><span class="line">            connection.request(<span class="keyword">new</span> ConnectResetRequest(), <span class="number">3000L</span>);</span><br><span class="line">            connection.close();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">//Do nothing.</span></span><br><span class="line">            <span class="keyword">if</span> (connectionManager.traced(clientIp)) &#123;</span><br><span class="line">             </span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parseObj != <span class="keyword">null</span> &amp;&amp; parseObj <span class="keyword">instanceof</span> Response) &#123;</span><br><span class="line">        Response response = (Response) parseObj;</span><br><span class="line">        <span class="keyword">if</span> (connectionManager.traced(clientIp)) &#123;</span><br><span class="line">         </span><br><span class="line">        &#125;</span><br><span class="line">        RpcAckCallbackSynchronizer.ackNotify(connectionId, response);</span><br><span class="line">        connectionManager.refreshActiveTime(connectionId);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> streamObserver;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@5</strong> 构建连接对象</p>
<p><strong>注解@6</strong>  注册连接信息，一个是缓存连接信息到Map connections中；另一个是触发client连接通知</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">register</span><span class="params">(String connectionId, Connection connection)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (connection.isConnected()) &#123;</span><br><span class="line">    </span><br><span class="line">    connections.put(connectionId, connection);</span><br><span class="line">    connectionForClientIp.get(connection.getMetaInfo().clientIp).getAndIncrement();</span><br><span class="line"></span><br><span class="line">    clientConnectionEventListenerRegistry.notifyClientConnected(connection);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>client连接通知处理逻辑：坐标ConnectionBasedClientManager#clientConnected。主要构建Client对象并缓存，clientId=connectId</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clientConnected</span><span class="params">(Connection connect)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!RemoteConstants.LABEL_MODULE_NAMING.equals(connect.getMetaInfo().getLabel(RemoteConstants.LABEL_MODULE)))	&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  String type = connect.getMetaInfo().getConnectType();</span><br><span class="line">  ClientFactory clientFactory = ClientFactoryHolder.getInstance().findClientFactory(type);</span><br><span class="line">  <span class="comment">// 构建Client对象</span></span><br><span class="line">  clientConnected(clientFactory.newClient(connect.getMetaInfo().getConnectionId()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">clientConnected</span><span class="params">(Client client)</span> </span>&#123;</span><br><span class="line">    Loggers.SRV_LOG.info(<span class="string">&quot;Client connection &#123;&#125; connect&quot;</span>, client.getClientId());</span><br><span class="line">    <span class="keyword">if</span> (!clients.containsKey(client.getClientId())) &#123;</span><br><span class="line">      <span class="comment">// 缓存Client信息</span></span><br><span class="line">      clients.putIfAbsent(client.getClientId(), (ConnectionBasedClient) client);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>小结：</strong> Nacos Server响应客户端连接主要干了两件事：@1 构建和缓存GrpcConnection对象，包含ConnectionMeta、channel和StreamObserver；@2 构建和缓存Client对象包含；clientId即connectionId。</p>
<p><strong>ConnectionMeta属性</strong></p>
<table>
<thead>
<tr>
<th>属性</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>connectType</td>
<td>ConnectionType，例如：GRPC</td>
</tr>
<tr>
<td>clientIp</td>
<td>客户端IP，例如：clientIp=192.168.0.110</td>
</tr>
<tr>
<td>remoteIp</td>
<td>远程节点IP，例如：remoteIp=127.0.0.1</td>
</tr>
<tr>
<td>remotePort</td>
<td>远程节点端口，例如：remotePort=54314</td>
</tr>
<tr>
<td>localPort</td>
<td>本地节点端口，例如：localPort=9848</td>
</tr>
<tr>
<td>version</td>
<td>client 版本</td>
</tr>
<tr>
<td>connectionId</td>
<td>连接标识</td>
</tr>
<tr>
<td>createTime</td>
<td>连接创建时间</td>
</tr>
<tr>
<td>lastActiveTime</td>
<td>最新保活时间</td>
</tr>
<tr>
<td>appName</td>
<td>app名称默认为“-”</td>
</tr>
<tr>
<td>tenant</td>
<td>租户</td>
</tr>
</tbody></table>
<p><strong>ConnectionBasedClient属性</strong></p>
<table>
<thead>
<tr>
<th>属性</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>connectionId</td>
<td>连接标识</td>
</tr>
<tr>
<td>isNative</td>
<td>true表示client直接连接到该server；false表示该连接是被从其他server同步而来</td>
</tr>
<tr>
<td>lastRenewTime</td>
<td>当isNative为false时，上次从源server校验的时间戳</td>
</tr>
<tr>
<td>lastUpdatedTime</td>
<td>最新保鲜时间</td>
</tr>
</tbody></table>
<h1 id="服务端处理注册请求-1"><a href="#服务端处理注册请求-1" class="headerlink" title="服务端处理注册请求"></a>服务端处理注册请求</h1><p>在上面文章《服务注册与发现服务端启动源码解析》有提到由RequestAcceptor.request会处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 服务接口处理类</span></span><br><span class="line"><span class="keyword">final</span> ServerCallHandler&lt;Payload, Payload&gt; payloadHandler = ServerCalls</span><br><span class="line">  .asyncUnaryCall((request, responseObserver) -&gt; &#123;</span><br><span class="line">    grpcCommonRequestAcceptor.request(request, responseObserver);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>下面看下request处理逻辑，忽略一些校验</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">(Payload grpcRequest, StreamObserver&lt;Payload&gt; responseObserver)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 查看是否在监控列表</span></span><br><span class="line">  traceIfNecessary(grpcRequest, <span class="keyword">true</span>);</span><br><span class="line">  String type = grpcRequest.getMetadata().getType();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// server启动校验、server校验</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 注解@7</span></span><br><span class="line">  RequestHandler requestHandler = requestHandlerRegistry.getByRequestType(type);</span><br><span class="line">  <span class="comment">// 没有Handler校验</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">  String connectionId = CONTEXT_KEY_CONN_ID.get();</span><br><span class="line">  <span class="keyword">boolean</span> requestValid = connectionManager.checkValid(connectionId);</span><br><span class="line">  <span class="comment">// 校验connId是否有效无效返回</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  Object parseObj = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    parseObj = GrpcUtils.parse(grpcRequest); <span class="comment">// 注解@8</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 非null校验</span></span><br><span class="line">  <span class="keyword">if</span> (parseObj == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 非request校验</span></span><br><span class="line">  <span class="keyword">if</span> (!(parseObj <span class="keyword">instanceof</span> Request)) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Request request = (Request) parseObj;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Connection connection = connectionManager.getConnection(CONTEXT_KEY_CONN_ID.get());</span><br><span class="line">    RequestMeta requestMeta = <span class="keyword">new</span> RequestMeta();</span><br><span class="line">    <span class="comment">// 注解@9</span></span><br><span class="line">    requestMeta.setClientIp(connection.getMetaInfo().getClientIp());</span><br><span class="line">    requestMeta.setConnectionId(CONTEXT_KEY_CONN_ID.get());</span><br><span class="line">    requestMeta.setClientVersion(connection.getMetaInfo().getVersion());</span><br><span class="line">    requestMeta.setLabels(connection.getMetaInfo().getLabels());</span><br><span class="line">    <span class="comment">// 注解@10</span></span><br><span class="line">    connectionManager.refreshActiveTime(requestMeta.getConnectionId());</span><br><span class="line">    <span class="comment">// 注解@11</span></span><br><span class="line">    Response response = requestHandler.handleRequest(request, requestMeta);</span><br><span class="line">    Payload payloadResponse = GrpcUtils.convert(response);</span><br><span class="line">    traceIfNecessary(payloadResponse, <span class="keyword">false</span>);</span><br><span class="line">    responseObserver.onNext(payloadResponse);</span><br><span class="line">    responseObserver.onCompleted();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@7</strong>  根据请求类型获取处理的RequestHandler，处理注册的为InstanceRequest-&gt;InstanceRequestHandler</p>
<p><strong>注解@8</strong> 解析成Request对象</p>
<p><strong>注解@9</strong> 装载clientIP、connId、version、其他map信息</p>
<p><strong>注解@10</strong> 刷新连接保鲜时间</p>
<p><strong>注解@11</strong> 执行RequestHandler逻辑，具体为registerInstance</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Secured(action = ActionTypes.WRITE, parser = NamingResourceParser.class)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> InstanceResponse <span class="title">handle</span><span class="params">(InstanceRequest request, RequestMeta meta)</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">  <span class="comment">// 构建注册service</span></span><br><span class="line">  Service service = Service</span><br><span class="line">    .newService(request.getNamespace(), request.getGroupName(), request.getServiceName(), <span class="keyword">true</span>);</span><br><span class="line">  <span class="keyword">switch</span> (request.getType()) &#123;</span><br><span class="line">      <span class="comment">// 处理注册请求</span></span><br><span class="line">    <span class="keyword">case</span> NamingRemoteConstants.REGISTER_INSTANCE:</span><br><span class="line">      <span class="keyword">return</span> registerInstance(service, request, meta);</span><br><span class="line">      <span class="comment">// 处理注销请求</span></span><br><span class="line">    <span class="keyword">case</span> NamingRemoteConstants.DE_REGISTER_INSTANCE:</span><br><span class="line">      <span class="keyword">return</span> deregisterInstance(service, request, meta);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NacosException(NacosException.INVALID_PARAM,</span><br><span class="line">                               String.format(<span class="string">&quot;Unsupported request type %s&quot;</span>, request.getType()));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210607141823.png"></p>
<p>接着分析注册干了点啥？坐标：EphemeralClientOperationServiceImpl#registerInstance</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerInstance</span><span class="params">(Service service, Instance instance, String clientId)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 注解@12</span></span><br><span class="line">  Service singleton = ServiceManager.getInstance().getSingleton(service);</span><br><span class="line">  <span class="comment">// 注解@13</span></span><br><span class="line">  Client client = clientManager.getClient(clientId);</span><br><span class="line">  InstancePublishInfo instanceInfo = getPublishInfo(instance);</span><br><span class="line">  <span class="comment">// 注解@14</span></span><br><span class="line">  client.addServiceInstance(singleton, instanceInfo);</span><br><span class="line">  client.setLastUpdatedTime();</span><br><span class="line">  <span class="comment">// 注解@15</span></span><br><span class="line">  NotifyCenter.publishEvent(<span class="keyword">new</span> ClientOperationEvent.ClientRegisterServiceEvent(singleton, clientId));</span><br><span class="line">  <span class="comment">// 注解@16</span></span><br><span class="line">  NotifyCenter</span><br><span class="line">    .publishEvent(<span class="keyword">new</span> MetadataEvent.InstanceMetadataEvent(singleton, instanceInfo.getMetadataId(), <span class="keyword">false</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@12</strong> singletonRepository缓存Singleton（service），namespaceSingletonMaps建立namespace和Singleton关系</p>
<p><strong>注解@13</strong> 从缓存中获取client信息，也就是上一小节建立连接被缓存的client</p>
<p><strong>注解@14</strong> 建立client与service、instance关系并发布事件ClientEvent.ClientChangedEvent</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addServiceInstance</span><span class="params">(Service service, InstancePublishInfo instancePublishInfo)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">null</span> == publishers.put(service, instancePublishInfo)) &#123;</span><br><span class="line">    MetricsMonitor.incrementInstanceCount();</span><br><span class="line">  &#125;</span><br><span class="line">  NotifyCenter.publishEvent(<span class="keyword">new</span> ClientEvent.ClientChangedEvent(<span class="keyword">this</span>));</span><br><span class="line">  Loggers.SRV_LOG.info(<span class="string">&quot;Client change for service &#123;&#125;, &#123;&#125;&quot;</span>, service, getClientId());</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@15</strong> 发布ClientOperationEvent.ClientRegisterServiceEvent事件</p>
<p><strong>注解@16</strong> 发布MetadataEvent.InstanceMetadataEvent事件</p>
<p><strong>小结：</strong> 处理注册请求的逻辑由InstanceRequestHandler执行，建立起了client与service、instance的关系。并通过NotifyCenter发布了三个事件：@1 ClientEvent.ClientChangedEvent；@2 ClientOperationEvent.ClientRegisterServiceEvent事件；@3 MetadataEvent.InstanceMetadataEvent事件。</p>
<p>那谁订阅了这些事件呢？他们又做了啥？下回接着撸。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>Nacos</category>
      </categories>
      <tags>
        <tag>Nacos</tag>
      </tags>
  </entry>
  <entry>
    <title>Nacos6# Distro协议全量同步与校验</title>
    <url>/posts/c1f9abd4/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>本文接着撸Distro协议，上文中分析了寻址模式。有了地址就要建立连接，有了连接就能通信了。集群之间都交互啥数据？本文就扒一扒全量同步和节点之间数据校验。</p>
<h1 id="内容提要"><a href="#内容提要" class="headerlink" title="内容提要"></a>内容提要</h1><h3 id="节点间建立RCP连接"><a href="#节点间建立RCP连接" class="headerlink" title="节点间建立RCP连接"></a>节点间建立RCP连接</h3><ul>
<li>订阅了MembersChangeEvent事件，集群节点有变更能够收到回调通知</li>
<li>与集群中其他节点建立grpc连接并缓存到Map其中key格式为「Cluster-IP:Port」</li>
</ul>
<h3 id="节点间校验数据通信"><a href="#节点间校验数据通信" class="headerlink" title="节点间校验数据通信"></a>节点间校验数据通信</h3><ul>
<li>节点之间发送校验数据是在全量同步后进行的</li>
<li>发送校验的频率默认为5秒钟一次</li>
<li>校验数据包括clientId和version，其中version为保留字段当前为0</li>
<li>接受到校验数据后如果缓存中存在该client表示校验成功，同时更新保鲜时间，否则校验失败</li>
</ul>
<h3 id="全量数据同步"><a href="#全量数据同步" class="headerlink" title="全量数据同步"></a>全量数据同步</h3><ul>
<li>在节点启动时会从集群中其他节点中的一个节点同步快照数据并缓存在Map中</li>
<li>缓存的数据类型分类两类分别为HTTP和gRPC</li>
<li>具体数据即客户端注册节点信息含命名空间、分组名称、服务名称、节点Instance信息等</li>
<li>集群中每个节点都拥有所有的快照数据</li>
</ul>
<a id="more"></a>



<h1 id="节点间建立RPC连接"><a href="#节点间建立RPC连接" class="headerlink" title="节点间建立RPC连接"></a>节点间建立RPC连接</h1><p>节点之间要通信，需要建立连接。Nacos集群节点之间也不例外，下面看下Nacos是如何和集群之间建立连接的，以gRPC为例。</p>
<p>Nacos中ClusterRpcClientProxy封装了集群中节点之间的通道。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 注解@1</span></span><br><span class="line">    NotifyCenter.registerSubscriber(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 注解@2</span></span><br><span class="line">    List&lt;Member&gt; members = serverMemberManager.allMembersWithoutSelf(); </span><br><span class="line">    <span class="comment">// 注解@3</span></span><br><span class="line">    refresh(members);</span><br><span class="line">    Loggers.CLUSTER</span><br><span class="line">      .warn(<span class="string">&quot;[ClusterRpcClientProxy] success to refresh cluster rpc client on start up,members =&#123;&#125; &quot;</span>,</span><br><span class="line">            members);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (NacosException e) &#123;</span><br><span class="line">    Loggers.CLUSTER.warn(<span class="string">&quot;[ClusterRpcClientProxy] fail to refresh cluster rpc client,&#123;&#125; &quot;</span>, e.getMessage());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@1</strong> 注册自己订阅MembersChangeEvent事件</p>
<p><strong>注解@2</strong> 获取集群中的节点列表剔除自身节点</p>
<p><strong>注解@3</strong> 与各个节点建立rpc通道</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">(List&lt;Member&gt; members)</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">	  <span class="keyword">for</span> (Member member : members) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (MemberUtil.isSupportedLongCon(member)) &#123;</span><br><span class="line">            <span class="comment">// 注解@3.1</span></span><br><span class="line">            createRpcClientAndStart(member, ConnectionType.GRPC);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	  Set&lt;Map.Entry&lt;String, RpcClient&gt;&gt; allClientEntrys = RpcClientFactory.getAllClientEntries();</span><br><span class="line">    Iterator&lt;Map.Entry&lt;String, RpcClient&gt;&gt; iterator = allClientEntrys.iterator();</span><br><span class="line">    List&lt;String&gt; newMemberKeys = members.stream().filter(a -&gt; MemberUtil.isSupportedLongCon(a))</span><br><span class="line">            .map(a -&gt; memberClientKey(a)).collect(Collectors.toList());</span><br><span class="line">    <span class="comment">// 注解@3.2</span></span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        Map.Entry&lt;String, RpcClient&gt; next1 = iterator.next();</span><br><span class="line">        <span class="keyword">if</span> (next1.getKey().startsWith(<span class="string">&quot;Cluster-&quot;</span>) &amp;&amp; !newMemberKeys.contains(next1.getKey())) &#123;</span><br><span class="line">            Loggers.CLUSTER.info(<span class="string">&quot;member leave,destroy client of member - &gt; : &#123;&#125;&quot;</span>, next1.getKey());</span><br><span class="line">            RpcClientFactory.getClient(next1.getKey()).shutdown();</span><br><span class="line">            iterator.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@3.1</strong> 为集群中每个节点member创建rcp client</p>
<p><strong>注解@3.2</strong> 关闭旧的grpc连接</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createRpcClientAndStart</span><span class="params">(Member member, ConnectionType type)</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; labels = <span class="keyword">new</span> HashMap&lt;String, String&gt;(<span class="number">2</span>);</span><br><span class="line">    labels.put(RemoteConstants.LABEL_SOURCE, RemoteConstants.LABEL_SOURCE_CLUSTER);</span><br><span class="line">    <span class="comment">// 注解@3.1.1</span></span><br><span class="line">    String memberClientKey = memberClientKey(member);</span><br><span class="line">    RpcClient client = RpcClientFactory.createClusterClient(memberClientKey, type, labels);</span><br><span class="line">    <span class="keyword">if</span> (!client.getConnectionType().equals(type)) &#123;</span><br><span class="line">        Loggers.CLUSTER.info(<span class="string">&quot;,connection type changed,destroy client of member - &gt; : &#123;&#125;&quot;</span>, member);</span><br><span class="line">        RpcClientFactory.destroyClient(memberClientKey);</span><br><span class="line">        <span class="comment">// 注解@3.1.2</span></span><br><span class="line">        client = RpcClientFactory.createClusterClient(memberClientKey, type, labels);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (client.isWaitInitiated()) &#123;</span><br><span class="line">        Loggers.CLUSTER.info(<span class="string">&quot;start a new rpc client to member - &gt; : &#123;&#125;&quot;</span>, member);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注解@3.1.3</span></span><br><span class="line">        client.serverListFactory(<span class="keyword">new</span> ServerListFactory() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">genNextServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> member.getAddress(); <span class="comment">// 返回连接集群其他节点地址</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">getCurrentServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> member.getAddress();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getServerList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> Lists.newArrayList(member.getAddress());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 注解@3.1.4</span></span><br><span class="line">        client.start(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@3.1.1</strong> memberClientKey由「Cluster-IP:Port」构成，例如：Cluster-1.2.3.4:2008</p>
<p><strong>注解@3.1.2</strong> 创建grpc client并缓存在 clientMap，key为memberClientKey 此时client的状态为WAIT_INIT</p>
<p><strong>注解@3.1.3</strong> 集群中固定的某一台节点</p>
<p><strong>注解@3.1.4</strong>  grpc连接集群中的member节点设置client的状态RUNNING</p>
<p><strong>小结：</strong> 在与Nacos集群其他节点建立连接的过程中做了两件事情：@1.订阅了MembersChangeEvent事件 @2.与集群中其他节点建立grpc连接并缓存到Map其中key格式为「Cluster-IP:Port」。</p>
<h1 id="节点间校验数据通信-1"><a href="#节点间校验数据通信-1" class="headerlink" title="节点间校验数据通信"></a>节点间校验数据通信</h1><p>节点之间建立rpc通道必然是为了互相之间能通信，其中一个通信是节点之间发送校验数据。那为什么要发这些校验数据？这些数据都是些什么内容？下面咱就去扒一扒。</p>
<p>在DistroProtocol的构造函数中的最后一个行有一个startDistroTask()，主要分析startVerifyTask的逻辑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DistroProtocol</span><span class="params">(ServerMemberManager memberManager, DistroComponentHolder distroComponentHolder,</span></span></span><br><span class="line"><span class="function"><span class="params">        DistroTaskEngineHolder distroTaskEngineHolder, DistroConfig distroConfig)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.memberManager = memberManager;</span><br><span class="line">    <span class="keyword">this</span>.distroComponentHolder = distroComponentHolder;</span><br><span class="line">    <span class="keyword">this</span>.distroTaskEngineHolder = distroTaskEngineHolder;</span><br><span class="line">    <span class="keyword">this</span>.distroConfig = distroConfig;</span><br><span class="line">    startDistroTask();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startDistroTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 单机模式直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (EnvUtil.getStandaloneMode()) &#123;</span><br><span class="line">        isInitialized = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    startVerifyTask();</span><br><span class="line">    startLoadTask();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startVerifyTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  	<span class="comment">// 注解@4</span></span><br><span class="line">    GlobalExecutor.schedulePartitionDataTimedSync(<span class="keyword">new</span> DistroVerifyTimedTask(memberManager, distroComponentHolder,</span><br><span class="line">            distroTaskEngineHolder.getExecuteWorkersManager()), distroConfig.getVerifyIntervalMillis());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@4</strong>  每隔5秒执行，也就是节点之间发送校验时间的默认频率是5秒。</p>
<p>​               可以通过配置参数「nacos.core.protocol.distro.data.verify_interval_ms」自定义。</p>
<p>接着看DistroVerifyTimedTask的run方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 注解@5</span></span><br><span class="line">        List&lt;Member&gt; targetServer = serverMemberManager.allMembersWithoutSelf();</span><br><span class="line">        <span class="keyword">if</span> (Loggers.DISTRO.isDebugEnabled()) &#123;</span><br><span class="line">            Loggers.DISTRO.debug(<span class="string">&quot;server list is: &#123;&#125;&quot;</span>, targetServer);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注解@6</span></span><br><span class="line">        <span class="keyword">for</span> (String each : distroComponentHolder.getDataStorageTypes()) &#123;</span><br><span class="line">            verifyForDataStorage(each, targetServer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        Loggers.DISTRO.error(<span class="string">&quot;[DISTRO-FAILED] verify task failed.&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@5</strong> 拿到集群中其他节点</p>
<p><strong>注解@6</strong> 在Nacos server启动时初始化时两种类型HTTP和gRPC，本文以gRPC为例进行分析。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">verifyForDataStorage</span><span class="params">(String type, List&lt;Member&gt; targetServer)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 注解@7</span></span><br><span class="line">    DistroDataStorage dataStorage = distroComponentHolder.findDataStorage(type);</span><br><span class="line">    <span class="comment">// 注解@8</span></span><br><span class="line">    <span class="keyword">if</span> (!dataStorage.isFinishInitial()) &#123;  <span class="comment">// 未完成全量数据同步退出</span></span><br><span class="line">        Loggers.DISTRO.warn(<span class="string">&quot;data storage &#123;&#125; has not finished initial step, do not send verify data&quot;</span>,</span><br><span class="line">                dataStorage.getClass().getSimpleName());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注解@9</span></span><br><span class="line">    List&lt;DistroData&gt; verifyData = dataStorage.getVerifyData();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == verifyData || verifyData.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Member member : targetServer) &#123;</span><br><span class="line">        DistroTransportAgent agent = distroComponentHolder.findTransportAgent(type);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == agent) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">// 注解@10</span></span><br><span class="line">        executeTaskExecuteEngine.addTask(member.getAddress() + type,</span><br><span class="line">                <span class="keyword">new</span> DistroVerifyExecuteTask(agent, verifyData, member.getAddress(), type));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@7</strong> Nacos启动时缓存在dataStorageMap中两种类型处理器分别用于处理gRPC和HTTP通信方式。</p>
<p>「Nacos:Naming:v2:ClientData-&gt;DistroClientDataProcessor」和 「com.alibaba.nacos.naming.iplist.-&gt;DistroDataStorageImpl」</p>
<p><strong>注解@8</strong> 当从其他节点同步了全部数据后，则完成了初始化finished initial，全量数据同步下小节分析。</p>
<p><strong>注解@9</strong>  获取校验的数据，数据为由本节点负责的clientId列表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;DistroData&gt; <span class="title">getVerifyData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;DistroData&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;(); <span class="comment">// 一组DistroData</span></span><br><span class="line">    <span class="keyword">for</span> (String each : clientManager.allClientId()) &#123;</span><br><span class="line">        Client client = clientManager.getClient(each);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == client || !client.isEphemeral()) &#123; <span class="comment">// 无效client或者非临时节点</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注解@9.1</span></span><br><span class="line">        <span class="keyword">if</span> (clientManager.isResponsibleClient(client)) &#123;</span><br><span class="line">            <span class="comment">// 注解@9.2</span></span><br><span class="line">            DistroClientVerifyInfo verifyData = <span class="keyword">new</span> DistroClientVerifyInfo(client.getClientId(), <span class="number">0</span>);</span><br><span class="line">            DistroKey distroKey = <span class="keyword">new</span> DistroKey(client.getClientId(), TYPE);</span><br><span class="line">            DistroData data = <span class="keyword">new</span> DistroData(distroKey,</span><br><span class="line">                    ApplicationUtils.getBean(Serializer.class).serialize(verifyData)); <span class="comment">// 序列化校验数据</span></span><br><span class="line">            data.setType(DataOperation.VERIFY);</span><br><span class="line">            result.add(data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@9.1</strong> 判断client是否为本几点负责的逻辑为ClientManagerDelegate#isResponsibleClient。即：属于ConnectionBasedClient并且</p>
<p>isNative为true表示该client是直连到该节点的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isResponsibleClient</span><span class="params">(Client client)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (client <span class="keyword">instanceof</span> ConnectionBasedClient) &amp;&amp; ((ConnectionBasedClient) client).isNative();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@9.2</strong> 构造Verify Data 主要信息为clientId，还有一个版本信息作为保留字段，目前都是0。</p>
<p><strong>注解@10</strong> 向集群其他节点发送校验数据DistroVerifyExecuteTask#run</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (DistroData each : verifyData) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (transportAgent.supportCallbackTransport()) &#123; <span class="comment">// grpc支持回调</span></span><br><span class="line">                doSyncVerifyDataWithCallback(each);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// http不支持回调使用同步</span></span><br><span class="line">                doSyncVerifyData(each);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syncVerifyData</span><span class="params">(DistroData verifyData, String targetServer, DistroCallback callback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isNoExistTarget(targetServer)) &#123;</span><br><span class="line">        callback.onSuccess();</span><br><span class="line">    &#125;</span><br><span class="line">    DistroDataRequest request = <span class="keyword">new</span> DistroDataRequest(verifyData, DataOperation.VERIFY);</span><br><span class="line">    Member member = memberManager.find(targetServer);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        DistroVerifyCallbackWrapper wrapper = <span class="keyword">new</span> DistroVerifyCallbackWrapper(targetServer,</span><br><span class="line">                verifyData.getDistroKey().getResourceKey(), callback, member);</span><br><span class="line">       	<span class="comment">// 注解@11         </span></span><br><span class="line">        clusterRpcClientProxy.asyncRequest(member, request, wrapper); </span><br><span class="line">    &#125; <span class="keyword">catch</span> (NacosException nacosException) &#123;</span><br><span class="line">        callback.onFailed(nacosException);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@11</strong> 向其他节点发送本节点负责的clientId信息</p>
<p><strong>那集群其他节点接收到校验数据做什么处理呢?</strong> </p>
<p>翻到DistroDataRequestHandler#handle，此处包含了处理校验数据的逻辑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DistroDataResponse <span class="title">handle</span><span class="params">(DistroDataRequest request, RequestMeta meta)</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (request.getDataOperation()) &#123;</span><br><span class="line">            <span class="keyword">case</span> VERIFY:</span><br><span class="line">                <span class="keyword">return</span> handleVerify(request.getDistroData(), meta);</span><br><span class="line">            <span class="keyword">case</span> SNAPSHOT:</span><br><span class="line">                <span class="keyword">return</span> handleSnapshot();</span><br><span class="line">            <span class="keyword">case</span> ADD:</span><br><span class="line">            <span class="keyword">case</span> CHANGE:</span><br><span class="line">            <span class="keyword">case</span> DELETE:</span><br><span class="line">                <span class="keyword">return</span> handleSyncData(request.getDistroData());</span><br><span class="line">            <span class="keyword">case</span> QUERY:</span><br><span class="line">                <span class="keyword">return</span> handleQueryData(request.getDistroData());</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> DistroDataResponse();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> DistroDataResponse <span class="title">handleVerify</span><span class="params">(DistroData distroData, RequestMeta meta)</span> </span>&#123;</span><br><span class="line">    DistroDataResponse result = <span class="keyword">new</span> DistroDataResponse();</span><br><span class="line">  	<span class="comment">// 注解@12</span></span><br><span class="line">    <span class="keyword">if</span> (!distroProtocol.onVerify(distroData, meta.getClientIp())) &#123;</span><br><span class="line">        result.setErrorInfo(ResponseCode.FAIL.getCode(), <span class="string">&quot;[DISTRO-FAILED] distro data verify failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@12</strong> 数据校验，下面可以看到，如果缓存存在client则校验成功，刷新client保鲜时间，否则校验失败。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verifyClient</span><span class="params">(String clientId)</span> </span>&#123;</span><br><span class="line">    ConnectionBasedClient client = clients.get(clientId);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != client) &#123;</span><br><span class="line">        client.setLastRenewTime();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>小结：</strong> 节点之间发送校验数据是在全量同步后进行的；发送校验的频率默认为5秒钟一次；校验数据包括clientId和version，其中version为保留字段当前为0；接受到校验数据后如果缓存中存在该client表示校验成功，同时更新保鲜时间，否则校验失败。</p>
<h1 id="全量数据同步-1"><a href="#全量数据同步-1" class="headerlink" title="全量数据同步"></a>全量数据同步</h1><p>上文中提到在发送校验数据之前需要先完成全量数据同步，先翻回DistroProtocol#startDistroTask()方法的startLoadTask()部分。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startLoadTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DistroCallback loadCallback = <span class="keyword">new</span> DistroCallback() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            isInitialized = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailed</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">            isInitialized = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    GlobalExecutor.submitLoadDataTask(</span><br><span class="line">            <span class="keyword">new</span> DistroLoadDataTask(memberManager, distroComponentHolder, distroConfig, loadCallback));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DistroLoadDataTask#run</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    load(); <span class="comment">// 注解@13</span></span><br><span class="line">    <span class="keyword">if</span> (!checkCompleted()) &#123; <span class="comment">// 注解@14</span></span><br><span class="line">      GlobalExecutor.submitLoadDataTask(<span class="keyword">this</span>, distroConfig.getLoadDataRetryDelayMillis());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      loadCallback.onSuccess();</span><br><span class="line">      Loggers.DISTRO.info(<span class="string">&quot;[DISTRO-INIT] load snapshot data success&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    loadCallback.onFailed(e);</span><br><span class="line">    Loggers.DISTRO.error(<span class="string">&quot;[DISTRO-INIT] load snapshot data failed. &quot;</span>, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@13</strong> 从集群中其他节点全量加载数据</p>
<p><strong>注解@14</strong> 如果没有加载成功延迟30秒钟重新执行一次，可以通过参数「nacos.core.protocol.distro.data.load_retry_delay_ms」指定</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (memberManager.allMembersWithoutSelf().isEmpty()) &#123;</span><br><span class="line">        Loggers.DISTRO.info(<span class="string">&quot;[DISTRO-INIT] waiting server list init...&quot;</span>);</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (distroComponentHolder.getDataStorageTypes().isEmpty()) &#123;</span><br><span class="line">        Loggers.DISTRO.info(<span class="string">&quot;[DISTRO-INIT] waiting distro data storage register...&quot;</span>);</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (String each : distroComponentHolder.getDataStorageTypes()) &#123; <span class="comment">// 注解@15</span></span><br><span class="line">        <span class="keyword">if</span> (!loadCompletedMap.containsKey(each) || !loadCompletedMap.get(each)) &#123;</span><br><span class="line">            loadCompletedMap.put(each, loadAllDataSnapshotFromRemote(each)); <span class="comment">// 加载快照</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@15</strong> 为不同的数据类型缓存快照，此处有gRPC和http两类数据类型。即： Nacos:Naming:v2:ClientData和com.alibaba.nacos.naming.iplist.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">loadAllDataSnapshotFromRemote</span><span class="params">(String resourceType)</span> </span>&#123;</span><br><span class="line">    DistroTransportAgent transportAgent = distroComponentHolder.findTransportAgent(resourceType);</span><br><span class="line">    DistroDataProcessor dataProcessor = distroComponentHolder.findDataProcessor(resourceType);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == transportAgent || <span class="keyword">null</span> == dataProcessor) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Member each : memberManager.allMembersWithoutSelf()) &#123; <span class="comment">// 注解@16</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          	DistroData distroData = transportAgent.getDatumSnapshot(each.getAddress());</span><br><span class="line">            <span class="keyword">boolean</span> result = dataProcessor.processSnapshot(distroData);</span><br><span class="line">            <span class="keyword">if</span> (result) &#123;</span><br><span class="line">                distroComponentHolder.findDataStorage(resourceType).finishInitial(); <span class="comment">// 设置为完成初始化</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@16</strong> 获取集群中除了本节点的其他节点，循环重试获取快照，直到有成功节点返回快照，成功后设置状态状态完成初始化「finishInitial」。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DistroData <span class="title">getDatumSnapshot</span><span class="params">(String targetServer)</span> </span>&#123;</span><br><span class="line">    Member member = memberManager.find(targetServer);</span><br><span class="line">    <span class="keyword">if</span> (checkTargetServerStatusUnhealthy(member)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> DistroException(</span><br><span class="line">                String.format(<span class="string">&quot;[DISTRO] Cancel get snapshot caused by target server %s unhealthy&quot;</span>, targetServer));</span><br><span class="line">    &#125;</span><br><span class="line">    DistroDataRequest request = <span class="keyword">new</span> DistroDataRequest();</span><br><span class="line">  	<span class="comment">// 设置请求操作为SNAPSHOT</span></span><br><span class="line">    request.setDataOperation(DataOperation.SNAPSHOT); </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      	<span class="comment">// 发起请求快照数据</span></span><br><span class="line">        Response response = clusterRpcClientProxy.sendRequest(member, request);</span><br><span class="line">        <span class="keyword">if</span> (checkResponse(response)) &#123;</span><br><span class="line">            <span class="keyword">return</span> ((DistroDataResponse) response).getDistroData();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> DistroException(</span><br><span class="line">                    String.format(<span class="string">&quot;[DISTRO-FAILED] Get snapshot request to %s failed, code: %d, message: %s&quot;</span>,</span><br><span class="line">                            targetServer, response.getErrorCode(), response.getMessage()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NacosException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> DistroException(<span class="string">&quot;[DISTRO-FAILED] Get distro snapshot failed! &quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>接下来看看其他节点收到快照请求如何响应的</strong> </p>
<p>还是翻到DistroDataRequestHandler#handle，具体由handleSnapshot()方法来处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> DistroDataResponse <span class="title">handleSnapshot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DistroDataResponse result = <span class="keyword">new</span> DistroDataResponse();</span><br><span class="line">    DistroData distroData = distroProtocol.onSnapshot(DistroClientDataProcessor.TYPE);</span><br><span class="line">    result.setDistroData(distroData);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DistroData <span class="title">getDatumSnapshot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;ClientSyncData&gt; datum = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 把本节点的所有client数据全部封装</span></span><br><span class="line">    <span class="keyword">for</span> (String each : clientManager.allClientId()) &#123;</span><br><span class="line">        Client client = clientManager.getClient(each);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == client || !client.isEphemeral()) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        datum.add(client.generateSyncData());</span><br><span class="line">    &#125;</span><br><span class="line">    ClientSyncDatumSnapshot snapshot = <span class="keyword">new</span> ClientSyncDatumSnapshot();</span><br><span class="line">    snapshot.setClientSyncDataList(datum);</span><br><span class="line">    <span class="keyword">byte</span>[] data = ApplicationUtils.getBean(Serializer.class).serialize(snapshot); <span class="comment">// 序列化数据</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DistroData(<span class="keyword">new</span> DistroKey(DataOperation.SNAPSHOT.name(), TYPE), data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面看下client数据信息，命名空间、分组名称、服务名称、节点Instance信息（IP、端口等等）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ClientSyncData <span class="title">generateSyncData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; namespaces = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    List&lt;String&gt; groupNames = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    List&lt;String&gt; serviceNames = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    List&lt;InstancePublishInfo&gt; instances = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Service, InstancePublishInfo&gt; entry : publishers.entrySet()) &#123;</span><br><span class="line">        namespaces.add(entry.getKey().getNamespace());</span><br><span class="line">        groupNames.add(entry.getKey().getGroup());</span><br><span class="line">        serviceNames.add(entry.getKey().getName());</span><br><span class="line">        instances.add(entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ClientSyncData(getClientId(), namespaces, groupNames, serviceNames, instances);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>小结：</strong>集群中每个节点都拥有所有的快照数据； 在节点启动时会从集群中其他节点中的一个节点同步快照数据并缓存在Map中；缓存的数据类型分类两类分别为HTTP和gRPC；具体数据即客户端注册节点信息含命名空间、分组名称、服务名称、节点Instance信息等。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>Nacos</category>
      </categories>
      <tags>
        <tag>Nacos</tag>
      </tags>
  </entry>
  <entry>
    <title>Nacos7# Distro协议增量同步</title>
    <url>/posts/67c008b5/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>本文接着撸Distro协议，上文中分析了在Nacos server启动时会进行全量数据同步和数据校验，具体数据即客户端注册节点信息含命名空间、分组名称、服务名称、节点Instance信息等。什么时候会触发增量同步？增量同步都干了些啥，下文接着撸撸增量数据同步。</p>
<h1 id="内容提要"><a href="#内容提要" class="headerlink" title="内容提要"></a>内容提要</h1><h3 id="增量数据同步"><a href="#增量数据同步" class="headerlink" title="增量数据同步"></a>增量数据同步</h3><ul>
<li>在Nacos节点启动时通过事件驱动模式订阅了ClientChangedEvent、ClientDisconnectEvent和ClientVerifyFailedEvent事件</li>
<li>当节点收到ClientChangedEvent事件时，会向集群中其他节点发送更新Client信息请求，其他节点收到后更新缓存</li>
<li>当节点收到ClientVerifyFailedEvent事件时，向该Event指定的目标节点发起新增该Event指定的Client信息请求，目标节点收到后更新到自己缓存中</li>
<li>当节点收到ClientDisconnectEvent事件时，会向集群中其他节点发送删除Client信息请求，其他节点收到后将该Client缓存删除</li>
</ul>
<h3 id="增量事件触发"><a href="#增量事件触发" class="headerlink" title="增量事件触发"></a>增量事件触发</h3><ul>
<li>当有服务注册或者注销时会触发ClientEvent.ClientChangedEvent事件，即客户端调用naming.registerInstance或者naming.deregisterInstance</li>
<li>定时任务每隔3秒钟定时检查缓存中的所有连接，如果超过保鲜期20秒则再次发起连接请求，连接未成功则注销关闭该连接并发布ClientEvent.ClientDisconnectEvent事件</li>
<li>Nacos集群之间通过每5秒发送心跳校验数据请求（具体为本节点负责Client信息），其他节点接受到校验请求，如果缓存中存在该client表示校验成功，同时更新保鲜时间；否则校验失败，回调返回失败Response，请求节点收到失败的Response后会发布ClientVerifyFailedEvent事件</li>
</ul>
<a id="more"></a>



<h1 id="增量数据同步-1"><a href="#增量数据同步-1" class="headerlink" title="增量数据同步"></a>增量数据同步</h1><p>将代码翻到DistroClientDataProcessor类中，该类继承了SmartSubscriber，遵循Subscriber/Notify模式，即事件驱动模式。该模式前面文章中分析过，当有订阅的事件时会进行回调通知。</p>
<h3 id="订阅的事件"><a href="#订阅的事件" class="headerlink" title="订阅的事件"></a>订阅的事件</h3><p>DistroClientDataProcessor订阅了ClientChangedEvent、ClientDisconnectEvent和ClientVerifyFailedEvent事件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Class&lt;? extends Event&gt;&gt; subscribeTypes() &#123;</span><br><span class="line">  List&lt;Class&lt;? extends Event&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">  result.add(ClientEvent.ClientChangedEvent.class);</span><br><span class="line">  result.add(ClientEvent.ClientDisconnectEvent.class);</span><br><span class="line">  result.add(ClientEvent.ClientVerifyFailedEvent.class);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当有上述三个事件产生时，DefaultPublisher回调onEvent方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(Event event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (EnvUtil.getStandaloneMode()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!upgradeJudgement.isUseGrpcFeatures()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ClientEvent.ClientVerifyFailedEvent) &#123;</span><br><span class="line">      	<span class="comment">// 注解@1</span></span><br><span class="line">        syncToVerifyFailedServer((ClientEvent.ClientVerifyFailedEvent) event);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 注解@2</span></span><br><span class="line">        syncToAllServer((ClientEvent) event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@1</strong> 将ClientVerifyFailedEvent同步给校验失败的节点，操作类型为ADD</p>
<p><strong>注解@2</strong> 将同步给集群中的其他节</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">syncToAllServer</span><span class="params">(ClientEvent event)</span> </span>&#123;</span><br><span class="line">    Client client = event.getClient();</span><br><span class="line">    <span class="comment">// Only ephemeral data sync by Distro, persist client should sync by raft.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == client || !client.isEphemeral() || !clientManager.isResponsibleClient(client)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ClientEvent.ClientDisconnectEvent) &#123;</span><br><span class="line">      	<span class="comment">// 注解@3</span></span><br><span class="line">        DistroKey distroKey = <span class="keyword">new</span> DistroKey(client.getClientId(), TYPE);</span><br><span class="line">        distroProtocol.sync(distroKey, DataOperation.DELETE);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ClientEvent.ClientChangedEvent) &#123;</span><br><span class="line">      	<span class="comment">// 注解@4</span></span><br><span class="line">        DistroKey distroKey = <span class="keyword">new</span> DistroKey(client.getClientId(), TYPE);</span><br><span class="line">        distroProtocol.sync(distroKey, DataOperation.CHANGE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@3</strong> 当客户端断开连接事件ClientDisconnectEvent时，向其他节点同步DELETE操作</p>
<p><strong>注解@4</strong> 当客户端变更事件ClientChangedEvent时，向其他节点同步CHANGE操作</p>
<p>接着看下不同操作类型的处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(NacosTask task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(task <span class="keyword">instanceof</span> DistroDelayTask)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    DistroDelayTask distroDelayTask = (DistroDelayTask) task;</span><br><span class="line">    DistroKey distroKey = distroDelayTask.getDistroKey();</span><br><span class="line">    <span class="keyword">switch</span> (distroDelayTask.getAction()) &#123;</span><br><span class="line">        <span class="keyword">case</span> DELETE: <span class="comment">// 删除操作</span></span><br><span class="line">            DistroSyncDeleteTask syncDeleteTask = <span class="keyword">new</span> DistroSyncDeleteTask(distroKey, distroComponentHolder);</span><br><span class="line">            distroTaskEngineHolder.getExecuteWorkersManager().addTask(distroKey, syncDeleteTask);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">case</span> CHANGE:</span><br><span class="line">        <span class="keyword">case</span> ADD: <span class="comment">// 更新和新增操作</span></span><br><span class="line">            DistroSyncChangeTask syncChangeTask = <span class="keyword">new</span> DistroSyncChangeTask(distroKey, distroComponentHolder);</span><br><span class="line">            distroTaskEngineHolder.getExecuteWorkersManager().addTask(distroKey, syncChangeTask);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>向指定的集群节点同步更新数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">syncData</span><span class="params">(DistroData data, String targetServer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isNoExistTarget(targetServer)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构造请求数据并设置数据类型</span></span><br><span class="line">    DistroDataRequest request = <span class="keyword">new</span> DistroDataRequest(data, data.getType());</span><br><span class="line">    <span class="comment">// 查找目标节点缓存数据</span></span><br><span class="line">    Member member = memberManager.find(targetServer);</span><br><span class="line">    <span class="comment">// 节点状态检查需UP状态，即：可通信状态</span></span><br><span class="line">    <span class="keyword">if</span> (checkTargetServerStatusUnhealthy(member)) &#123;</span><br><span class="line">        Loggers.DISTRO.warn(<span class="string">&quot;[DISTRO] Cancel distro sync caused by target server &#123;&#125; unhealthy&quot;</span>, targetServer);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 向目标节点发送数据</span></span><br><span class="line">        Response response = clusterRpcClientProxy.sendRequest(member, request);</span><br><span class="line">        <span class="keyword">return</span> checkResponse(response);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NacosException e) &#123;</span><br><span class="line">        Loggers.DISTRO.error(<span class="string">&quot;[DISTRO-FAILED] Sync distro data failed! &quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>异步更新操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syncData</span><span class="params">(DistroData data, String targetServer, DistroCallback callback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isNoExistTarget(targetServer)) &#123;</span><br><span class="line">        callback.onSuccess();</span><br><span class="line">    &#125;</span><br><span class="line">    DistroDataRequest request = <span class="keyword">new</span> DistroDataRequest(data, data.getType());</span><br><span class="line">    Member member = memberManager.find(targetServer);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 异步更新操作</span></span><br><span class="line">        clusterRpcClientProxy.asyncRequest(member, request, <span class="keyword">new</span> DistroRpcCallbackWrapper(callback, member));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NacosException nacosException) &#123;</span><br><span class="line">        callback.onFailed(nacosException);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>节点收到这些操作请求如何处理呢？</strong> </p>
<p>代码翻到DistroDataRequestHandler#handle()，集群中节点收到请求后处理逻辑在这里：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DistroDataResponse <span class="title">handle</span><span class="params">(DistroDataRequest request, RequestMeta meta)</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (request.getDataOperation()) &#123;</span><br><span class="line">            <span class="keyword">case</span> VERIFY:</span><br><span class="line">                <span class="keyword">return</span> handleVerify(request.getDistroData(), meta);</span><br><span class="line">            <span class="keyword">case</span> SNAPSHOT:</span><br><span class="line">                <span class="keyword">return</span> handleSnapshot();</span><br><span class="line">            <span class="keyword">case</span> ADD:</span><br><span class="line">            <span class="keyword">case</span> CHANGE:</span><br><span class="line">            <span class="keyword">case</span> DELETE:</span><br><span class="line">                <span class="keyword">return</span> handleSyncData(request.getDistroData());</span><br><span class="line">            <span class="keyword">case</span> QUERY:</span><br><span class="line">                <span class="keyword">return</span> handleQueryData(request.getDistroData());</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> DistroDataResponse();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        Loggers.DISTRO.error(<span class="string">&quot;[DISTRO-FAILED] distro handle with exception&quot;</span>, e);</span><br><span class="line">        DistroDataResponse result = <span class="keyword">new</span> DistroDataResponse();</span><br><span class="line">        result.setErrorCode(ResponseCode.FAIL.getCode());</span><br><span class="line">        result.setMessage(<span class="string">&quot;handle distro request with exception&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出ADD、CHANGE和DELETE均由handleSyncData处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> DistroDataResponse <span class="title">handleSyncData</span><span class="params">(DistroData distroData)</span> </span>&#123;</span><br><span class="line">    DistroDataResponse result = <span class="keyword">new</span> DistroDataResponse();</span><br><span class="line">    <span class="keyword">if</span> (!distroProtocol.onReceive(distroData)) &#123;</span><br><span class="line">        result.setErrorCode(ResponseCode.FAIL.getCode());</span><br><span class="line">        result.setMessage(<span class="string">&quot;[DISTRO-FAILED] distro data handle failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">processData</span><span class="params">(DistroData distroData)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (distroData.getType()) &#123;</span><br><span class="line">        <span class="keyword">case</span> ADD:</span><br><span class="line">        <span class="keyword">case</span> CHANGE:</span><br><span class="line">            ClientSyncData clientSyncData = ApplicationUtils.getBean(Serializer.class)</span><br><span class="line">                    .deserialize(distroData.getContent(), ClientSyncData.class);</span><br><span class="line">            handlerClientSyncData(clientSyncData); <span class="comment">// 注解@5</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">case</span> DELETE:</span><br><span class="line">            String deleteClientId = distroData.getDistroKey().getResourceKey();</span><br><span class="line">            Loggers.DISTRO.info(<span class="string">&quot;[Client-Delete] Received distro client sync data &#123;&#125;&quot;</span>, deleteClientId);</span><br><span class="line">            clientManager.clientDisconnected(deleteClientId); <span class="comment">// 注解@6</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@5</strong> 将同步过来的Client信息进行缓存</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handlerClientSyncData</span><span class="params">(ClientSyncData clientSyncData)</span> </span>&#123;</span><br><span class="line">    Loggers.DISTRO.info(<span class="string">&quot;[Client-Add] Received distro client sync data &#123;&#125;&quot;</span>, clientSyncData.getClientId());</span><br><span class="line">    clientManager.syncClientConnected(clientSyncData.getClientId(), clientSyncData.getAttributes());</span><br><span class="line">    Client client = clientManager.getClient(clientSyncData.getClientId());</span><br><span class="line">  	<span class="comment">// 注解@5.1</span></span><br><span class="line">    upgradeClient(client, clientSyncData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要的是从其他节点通过过来的Client信息，ConnectionBasedClient属性isNative为false表示该连接时从其他节点同步过来的；true表示该连接客户端直接连接的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">syncClientConnected</span><span class="params">(String clientId, ClientSyncAttributes attributes)</span> </span>&#123;</span><br><span class="line">    String type = attributes.getClientAttribute(ClientConstants.CONNECTION_TYPE);</span><br><span class="line">    ClientFactory clientFactory = ClientFactoryHolder.getInstance().findClientFactory(type);</span><br><span class="line">    <span class="keyword">return</span> clientConnected(clientFactory.newSyncedClient(clientId, attributes));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ConnectionBasedClient <span class="title">newSyncedClient</span><span class="params">(String clientId, ClientSyncAttributes attributes)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ConnectionBasedClient(clientId, <span class="keyword">false</span>); <span class="comment">// false表示从其他节点同步过来的client</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">clientConnected</span><span class="params">(Client client)</span> </span>&#123;</span><br><span class="line">  Loggers.SRV_LOG.info(<span class="string">&quot;Client connection &#123;&#125; connect&quot;</span>, client.getClientId());</span><br><span class="line">  <span class="keyword">if</span> (!clients.containsKey(client.getClientId())) &#123;</span><br><span class="line">    clients.putIfAbsent(client.getClientId(), (ConnectionBasedClient) client); <span class="comment">// 缓存client</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@5.1</strong>  更新Client的Service以及Instance信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">upgradeClient</span><span class="params">(Client client, ClientSyncData clientSyncData)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; namespaces = clientSyncData.getNamespaces();</span><br><span class="line">    List&lt;String&gt; groupNames = clientSyncData.getGroupNames();</span><br><span class="line">    List&lt;String&gt; serviceNames = clientSyncData.getServiceNames();</span><br><span class="line">    List&lt;InstancePublishInfo&gt; instances = clientSyncData.getInstancePublishInfos();</span><br><span class="line">    Set&lt;Service&gt; syncedService = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; namespaces.size(); i++) &#123;</span><br><span class="line">        Service service = Service.newService(namespaces.get(i), groupNames.get(i), serviceNames.get(i));</span><br><span class="line">        Service singleton = ServiceManager.getInstance().getSingleton(service);</span><br><span class="line">        syncedService.add(singleton);</span><br><span class="line">        InstancePublishInfo instancePublishInfo = instances.get(i);</span><br><span class="line">        <span class="keyword">if</span> (!instancePublishInfo.equals(client.getInstancePublishInfo(singleton))) &#123;</span><br><span class="line">            client.addServiceInstance(singleton, instancePublishInfo);</span><br><span class="line">            NotifyCenter.publishEvent(</span><br><span class="line">                    <span class="keyword">new</span> ClientOperationEvent.ClientRegisterServiceEvent(singleton, client.getClientId()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Service each : client.getAllPublishedService()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!syncedService.contains(each)) &#123;</span><br><span class="line">            client.removeServiceInstance(each);</span><br><span class="line">            NotifyCenter.publishEvent(</span><br><span class="line">                    <span class="keyword">new</span> ClientOperationEvent.ClientDeregisterServiceEvent(each, client.getClientId()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@6</strong> 响应删除操作，从clients缓存中移除。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">clientDisconnected</span><span class="params">(String clientId)</span> </span>&#123;</span><br><span class="line">    Loggers.SRV_LOG.info(<span class="string">&quot;Client connection &#123;&#125; disconnect, remove instances and subscribers&quot;</span>, clientId);</span><br><span class="line">    ConnectionBasedClient client = clients.remove(clientId);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == client) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    client.release();</span><br><span class="line">    NotifyCenter.publishEvent(<span class="keyword">new</span> ClientEvent.ClientDisconnectEvent(client));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>小结：</strong> 增量同步的逻辑如下：当本节点DistroClientDataProcessor收到ClientChangedEvent、ClientDisconnectEvent和ClientVerifyFailedEvent事件时，会向Nacos集群的其他节点同步Client信息；集群中其他节点收到同步信息后更新或者删除本地缓存的Client信息；通过增量同步的Client信息isNative为false表示不是由客户端直连的。</p>
<h1 id="增量事件触发-1"><a href="#增量事件触发-1" class="headerlink" title="增量事件触发"></a>增量事件触发</h1><p>在Nacos server启动时从运行时内存信息可以看出，总共缓存了17个事件类型。当然也包括ClientChangedEvent、ClientDisconnectEvent和ClientVerifyFailedEvent。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210629174459.png"></p>
<h3 id="ClientChangedEvent事件触发"><a href="#ClientChangedEvent事件触发" class="headerlink" title="ClientChangedEvent事件触发"></a>ClientChangedEvent事件触发</h3><p>当处理服务注册和注销事件时会触发ClientChangeEvent事件，详见InstanceRequestHandler#handle处理逻辑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> InstanceResponse <span class="title">handle</span><span class="params">(InstanceRequest request, RequestMeta meta)</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">    Service service = Service</span><br><span class="line">            .newService(request.getNamespace(), request.getGroupName(), request.getServiceName(), <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">switch</span> (request.getType()) &#123;</span><br><span class="line">        <span class="comment">// 注解@7</span></span><br><span class="line">        <span class="keyword">case</span> NamingRemoteConstants.REGISTER_INSTANCE:</span><br><span class="line">            <span class="keyword">return</span> registerInstance(service, request, meta);</span><br><span class="line">        <span class="comment">// 注解@8</span></span><br><span class="line">        <span class="keyword">case</span> NamingRemoteConstants.DE_REGISTER_INSTANCE:</span><br><span class="line">            <span class="keyword">return</span> deregisterInstance(service, request, meta);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NacosException(NacosException.INVALID_PARAM,</span><br><span class="line">                    String.format(<span class="string">&quot;Unsupported request type %s&quot;</span>, request.getType()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@7</strong> 处理注册请求，会调用到addServiceInstance方法，该方法中发布了ClientEvent.ClientChangedEvent事件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addServiceInstance</span><span class="params">(Service service, InstancePublishInfo instancePublishInfo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == publishers.put(service, instancePublishInfo)) &#123;</span><br><span class="line">        MetricsMonitor.incrementInstanceCount();</span><br><span class="line">    &#125;</span><br><span class="line">    NotifyCenter.publishEvent(<span class="keyword">new</span> ClientEvent.ClientChangedEvent(<span class="keyword">this</span>));</span><br><span class="line">    Loggers.SRV_LOG.info(<span class="string">&quot;Client change for service &#123;&#125;, &#123;&#125;&quot;</span>, service, getClientId());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@8</strong> 处理注销请求，会调用到removeServiceInstance方法，该方法中发布了ClientEvent.ClientChangedEvent事件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> InstancePublishInfo <span class="title">removeServiceInstance</span><span class="params">(Service service)</span> </span>&#123;</span><br><span class="line">        InstancePublishInfo result = publishers.remove(service);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != result) &#123;</span><br><span class="line">            MetricsMonitor.decrementInstanceCount();</span><br><span class="line">            NotifyCenter.publishEvent(<span class="keyword">new</span> ClientEvent.ClientChangedEvent(<span class="keyword">this</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        Loggers.SRV_LOG.info(<span class="string">&quot;Client remove for service &#123;&#125;, &#123;&#125;&quot;</span>, service, getClientId());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>小结：</strong> 当有服务注册或者注销时会触发ClientEvent.ClientChangedEvent事件。</p>
<h3 id="ClientDisconnectEvent事件触发"><a href="#ClientDisconnectEvent事件触发" class="headerlink" title="ClientDisconnectEvent事件触发"></a>ClientDisconnectEvent事件触发</h3><p>下面一段代码通过检测连接是否超过保鲜期，超过保鲜期的会被注销关闭，翻到代码ConnectionManager#start()。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定时任务每3秒执行一次</span></span><br><span class="line">    RpcScheduledExecutor.COMMON_SERVER_EXECUTOR.scheduleWithFixedDelay(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 获取缓存连接</span></span><br><span class="line">                <span class="keyword">int</span> totalCount = connections.size();</span><br><span class="line">                Loggers.REMOTE_DIGEST.info(<span class="string">&quot;Connection check task start&quot;</span>);</span><br><span class="line">                MetricsMonitor.getLongConnectionMonitor().set(totalCount);</span><br><span class="line">                <span class="comment">// 所有连接集合</span></span><br><span class="line">                Set&lt;Map.Entry&lt;String, Connection&gt;&gt; entries = connections.entrySet();</span><br><span class="line">                <span class="comment">// 获取通过SDK连接的数量</span></span><br><span class="line">                <span class="keyword">int</span> currentSdkClientCount = currentSdkClientCount();</span><br><span class="line">                <span class="keyword">boolean</span> isLoaderClient = loadClient &gt;= <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> currentMaxClient = isLoaderClient ? loadClient : connectionLimitRule.countLimit;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> expelCount = currentMaxClient &lt; <span class="number">0</span> ? <span class="number">0</span> : Math.max(currentSdkClientCount - currentMaxClient, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                List&lt;String&gt; expelClient = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">                Map&lt;String, AtomicInteger&gt; expelForIp = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 1. calculate expel count  of ip.</span></span><br><span class="line">                <span class="comment">// 加载Connection ConnectionLimitRule</span></span><br><span class="line">                <span class="comment">// 默认路径为 $&#123;usr.home&#125;/nacos/data/loader/limitRule</span></span><br><span class="line">                <span class="keyword">for</span> (Map.Entry&lt;String, Connection&gt; entry : entries) &#123;</span><br><span class="line"></span><br><span class="line">                    Connection client = entry.getValue();</span><br><span class="line">                    String appName = client.getMetaInfo().getAppName();</span><br><span class="line">                    String clientIp = client.getMetaInfo().getClientIp();</span><br><span class="line">                    <span class="keyword">if</span> (client.getMetaInfo().isSdkSource() &amp;&amp; !expelForIp.containsKey(clientIp)) &#123;</span><br><span class="line">                        <span class="comment">//get limit for current ip.</span></span><br><span class="line">                        <span class="comment">// 默认无limit限制</span></span><br><span class="line">                        <span class="keyword">int</span> countLimitOfIp = connectionLimitRule.getCountLimitOfIp(clientIp);</span><br><span class="line">                        <span class="comment">// 默认无limit限制</span></span><br><span class="line">                        <span class="keyword">if</span> (countLimitOfIp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">int</span> countLimitOfApp = connectionLimitRule.getCountLimitOfApp(appName);</span><br><span class="line">                            countLimitOfIp = countLimitOfApp &lt; <span class="number">0</span> ? countLimitOfIp : countLimitOfApp;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (countLimitOfIp &lt; <span class="number">0</span>) &#123; <span class="comment">// 默认无限制</span></span><br><span class="line">                            countLimitOfIp = connectionLimitRule.getCountLimitPerClientIpDefault();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (countLimitOfIp &gt;= <span class="number">0</span> &amp;&amp; connectionForClientIp.containsKey(clientIp)) &#123;</span><br><span class="line">                            AtomicInteger currentCountIp = connectionForClientIp.get(clientIp);</span><br><span class="line">                            <span class="keyword">if</span> (currentCountIp != <span class="keyword">null</span> &amp;&amp; currentCountIp.get() &gt; countLimitOfIp) &#123;</span><br><span class="line">                                expelForIp.put(clientIp, <span class="keyword">new</span> AtomicInteger(currentCountIp.get() - countLimitOfIp));</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (expelForIp.size() &gt; <span class="number">0</span>) &#123; <span class="comment">// 默认等于0</span></span><br><span class="line">                    Loggers.REMOTE_DIGEST.info(<span class="string">&quot;Over limit ip expel info,&quot;</span>, expelForIp);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                Set&lt;String&gt; outDatedConnections = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">                <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">                <span class="comment">// 2.get expel connection for ip limit.</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="keyword">for</span> (Map.Entry&lt;String, Connection&gt; entry : entries) &#123;</span><br><span class="line">                    Connection client = entry.getValue();</span><br><span class="line">                    String clientIp = client.getMetaInfo().getClientIp();</span><br><span class="line">                    AtomicInteger integer = expelForIp.get(clientIp);</span><br><span class="line">                    <span class="keyword">if</span> (integer != <span class="keyword">null</span> &amp;&amp; integer.intValue() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        integer.decrementAndGet();</span><br><span class="line">                        expelClient.add(client.getMetaInfo().getConnectionId());</span><br><span class="line">                        expelCount--;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (now - client.getMetaInfo().getLastActiveTime() &gt;= KEEP_ALIVE_TIME) &#123; <span class="comment">// 保鲜时间超过20秒放入outDatedConnections集合</span></span><br><span class="line">                        outDatedConnections.add(client.getMetaInfo().getConnectionId());</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3. if total count is still over limit.</span></span><br><span class="line">                <span class="comment">// expelCount 默认为0</span></span><br><span class="line">                <span class="keyword">if</span> (expelCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (Map.Entry&lt;String, Connection&gt; entry : entries) &#123;</span><br><span class="line">                        Connection client = entry.getValue();</span><br><span class="line">                        <span class="keyword">if</span> (!expelForIp.containsKey(client.getMetaInfo().clientIp) &amp;&amp; client.getMetaInfo()</span><br><span class="line">                                .isSdkSource() &amp;&amp; expelCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            expelClient.add(client.getMetaInfo().getConnectionId());</span><br><span class="line">                            expelCount--;</span><br><span class="line">                            outDatedConnections.remove(client.getMetaInfo().getConnectionId());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                String serverIp = <span class="keyword">null</span>;</span><br><span class="line">                String serverPort = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (StringUtils.isNotBlank(redirectAddress) &amp;&amp; redirectAddress.contains(Constants.COLON)) &#123;</span><br><span class="line">                    String[] split = redirectAddress.split(Constants.COLON);</span><br><span class="line">                    serverIp = split[<span class="number">0</span>];</span><br><span class="line">                    serverPort = split[<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (String expelledClientId : expelClient) &#123; <span class="comment">// 默认空集合</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Connection connection = getConnection(expelledClientId);</span><br><span class="line">                        <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            ConnectResetRequest connectResetRequest = <span class="keyword">new</span> ConnectResetRequest();</span><br><span class="line">                            connectResetRequest.setServerIp(serverIp);</span><br><span class="line">                            connectResetRequest.setServerPort(serverPort);</span><br><span class="line">                            connection.asyncRequest(connectResetRequest, <span class="keyword">null</span>);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (ConnectionAlreadyClosedException e) &#123;</span><br><span class="line">                        unregister(expelledClientId);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        Loggers.REMOTE_DIGEST.error(<span class="string">&quot;Error occurs when expel connection :&quot;</span>, expelledClientId, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//4.client active detection.</span></span><br><span class="line">                Loggers.REMOTE_DIGEST.info(<span class="string">&quot;Out dated connection ,size=&#123;&#125;&quot;</span>, outDatedConnections.size());</span><br><span class="line">                <span class="comment">// 超过保鲜期的链接集合</span></span><br><span class="line">                <span class="keyword">if</span> (CollectionUtils.isNotEmpty(outDatedConnections)) &#123;</span><br><span class="line">                    Set&lt;String&gt; successConnections = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">                    <span class="keyword">final</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(outDatedConnections.size());</span><br><span class="line">                    <span class="keyword">for</span> (String outDateConnectionId : outDatedConnections) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            Connection connection = getConnection(outDateConnectionId);</span><br><span class="line">                            <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                ClientDetectionRequest clientDetectionRequest = <span class="keyword">new</span> ClientDetectionRequest();</span><br><span class="line">                                <span class="comment">// 超过保鲜时间的连接，重新异步发起连接</span></span><br><span class="line">                                connection.asyncRequest(clientDetectionRequest, <span class="keyword">new</span> RequestCallBack() &#123;</span><br><span class="line">                                    <span class="meta">@Override</span></span><br><span class="line">                                    <span class="function"><span class="keyword">public</span> Executor <span class="title">getExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                                    &#125;</span><br><span class="line"></span><br><span class="line">                                    <span class="meta">@Override</span></span><br><span class="line">                                    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getTimeout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                                        <span class="keyword">return</span> <span class="number">1000L</span>;</span><br><span class="line">                                    &#125;</span><br><span class="line"></span><br><span class="line">                                    <span class="meta">@Override</span></span><br><span class="line">                                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Response response)</span> </span>&#123;</span><br><span class="line">                                        latch.countDown();</span><br><span class="line">                                        <span class="keyword">if</span> (response != <span class="keyword">null</span> &amp;&amp; response.isSuccess()) &#123;</span><br><span class="line">                                            <span class="comment">// 刷新激活时间</span></span><br><span class="line">                                            connection.freshActiveTime();</span><br><span class="line">                                            successConnections.add(outDateConnectionId);</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line"></span><br><span class="line">                                    <span class="meta">@Override</span></span><br><span class="line">                                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onException</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">                                        latch.countDown();</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;);</span><br><span class="line">							</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                latch.countDown();</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                        &#125; <span class="keyword">catch</span> (ConnectionAlreadyClosedException e) &#123;</span><br><span class="line">                            latch.countDown();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                           	<span class="comment">// ... </span></span><br><span class="line">                            latch.countDown();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    latch.await(<span class="number">3000L</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">                    Loggers.REMOTE_DIGEST</span><br><span class="line">                            .info(<span class="string">&quot;Out dated connection check successCount=&#123;&#125;&quot;</span>, successConnections.size());</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 无效连接集合</span></span><br><span class="line">                    <span class="keyword">for</span> (String outDateConnectionId : outDatedConnections) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!successConnections.contains(outDateConnectionId)) &#123;</span><br><span class="line">                            Loggers.REMOTE_DIGEST</span><br><span class="line">                                    .info(<span class="string">&quot;[&#123;&#125;]Unregister Out dated connection....&quot;</span>, outDateConnectionId);</span><br><span class="line">                            <span class="comment">// 注销关闭connection</span></span><br><span class="line">                            unregister(outDateConnectionId);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (isLoaderClient) &#123;  <span class="comment">// 重置</span></span><br><span class="line">                    loadClient = -<span class="number">1</span>;</span><br><span class="line">                    redirectAddress = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">               </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">1000L</span>, <span class="number">3000L</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unregister</span><span class="params">(String connectionId)</span> </span>&#123;</span><br><span class="line">    Connection remove = <span class="keyword">this</span>.connections.remove(connectionId);</span><br><span class="line">    <span class="keyword">if</span> (remove != <span class="keyword">null</span>) &#123;</span><br><span class="line">        String clientIp = remove.getMetaInfo().clientIp;</span><br><span class="line">        AtomicInteger atomicInteger = connectionForClientIp.get(clientIp);</span><br><span class="line">        <span class="keyword">if</span> (atomicInteger != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> count = atomicInteger.decrementAndGet();</span><br><span class="line">            <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                connectionForClientIp.remove(clientIp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        remove.close();</span><br><span class="line">        Loggers.REMOTE_DIGEST.info(<span class="string">&quot;[&#123;&#125;]Connection unregistered successfully. &quot;</span>, connectionId);</span><br><span class="line">        clientConnectionEventListenerRegistry.notifyClientDisConnected(remove); <span class="comment">// 异步</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyClientDisConnected</span><span class="params">(<span class="keyword">final</span> Connection connection)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (ClientConnectionEventListener clientConnectionEventListener : clientConnectionEventListeners) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                clientConnectionEventListener.clientDisConnected(connection);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">                Loggers.REMOTE.info(<span class="string">&quot;[NotifyClientDisConnected] failed for listener &#123;&#125;&quot;</span>,</span><br><span class="line">                        clientConnectionEventListener.getName(), throwable);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">clientDisconnected</span><span class="params">(String clientId)</span> </span>&#123;</span><br><span class="line">  Loggers.SRV_LOG.info(<span class="string">&quot;Client connection &#123;&#125; disconnect, remove instances and subscribers&quot;</span>, clientId);</span><br><span class="line">  ConnectionBasedClient client = clients.remove(clientId);</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">null</span> == client) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  client.release();</span><br><span class="line">  NotifyCenter.publishEvent(<span class="keyword">new</span> ClientEvent.ClientDisconnectEvent(client)); <span class="comment">// 发布ClientDisconnectEvent事件</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>小结：</strong> 连接可以配置限制规则具体在${usr.home}/nacos/data/loader/limitRule文件配置，默认无限制；通过定时任务每隔3秒钟定时检查缓存中的所有连接包括通过来源sdk的连接和集群的连接；如果连接超过保鲜期20秒，并再次发起连接请求，未能连接成功则注销关闭该连接；注销关闭时发布ClientEvent.ClientDisconnectEvent事件。</p>
<h3 id="ClientVerifyFailedEvent事件触发"><a href="#ClientVerifyFailedEvent事件触发" class="headerlink" title="ClientVerifyFailedEvent事件触发"></a>ClientVerifyFailedEvent事件触发</h3><p>上一篇文章中梳理了Nacos集群中，每个节点会对集群中其他节点每隔5秒发送校验数据，也就是心跳。当校验的结果会进行回调（gRPC为例），我们翻着看看这部分。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syncVerifyData</span><span class="params">(DistroData verifyData, String targetServer, DistroCallback callback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isNoExistTarget(targetServer)) &#123;</span><br><span class="line">        callback.onSuccess();</span><br><span class="line">    &#125;</span><br><span class="line">    DistroDataRequest request = <span class="keyword">new</span> DistroDataRequest(verifyData, DataOperation.VERIFY);</span><br><span class="line">    Member member = memberManager.find(targetServer);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        DistroVerifyCallbackWrapper wrapper = <span class="keyword">new</span> DistroVerifyCallbackWrapper(targetServer,</span><br><span class="line">                verifyData.getDistroKey().getResourceKey(), callback, member);</span><br><span class="line">        clusterRpcClientProxy.asyncRequest(member, request, wrapper); <span class="comment">// 向其他节点发送本节点负责的cleintId信息</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (NacosException nacosException) &#123;</span><br><span class="line">        callback.onFailed(nacosException);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重点看下DistroVerifyCallbackWrapper部分，校验失败发布ClientVerifyFailedEvent事件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Response response)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (checkResponse(response)) &#123;</span><br><span class="line">        NamingTpsMonitor.distroVerifySuccess(member.getAddress(), member.getIp());</span><br><span class="line">        distroCallback.onSuccess();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Loggers.DISTRO.info(<span class="string">&quot;Target &#123;&#125; verify client &#123;&#125; failed, sync new client&quot;</span>, targetServer, clientId);</span><br><span class="line">      	<span class="comment">// 校验失败发布ClientVerifyFailedEvent事件</span></span><br><span class="line">        NotifyCenter.publishEvent(<span class="keyword">new</span> ClientEvent.ClientVerifyFailedEvent(clientId, targetServer));</span><br><span class="line">        NamingTpsMonitor.distroVerifyFail(member.getAddress(), member.getIp());</span><br><span class="line">        distroCallback.onFailed(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后看下ClientVerifyFailedEvent这个类，关注下成员变量包含了clientId和targetServer。当收到ClientVerifyFailedEvent时用于向targetServer目标节点添加客户端clientId信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientVerifyFailedEvent</span> <span class="keyword">extends</span> <span class="title">ClientEvent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2023951686223780851L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String clientId;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String targetServer;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClientVerifyFailedEvent</span><span class="params">(String clientId, String targetServer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">this</span>.clientId = clientId;</span><br><span class="line">        <span class="keyword">this</span>.targetServer = targetServer;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getClientId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> clientId;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTargetServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> targetServer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>小结：</strong> Nacos集群之间通过每5秒发送心跳校验数据请求（具体为本节点负责Client信息），其他节点接受到校验请求，如果缓存中存在该client表示校验成功，同时更新保鲜时间；否则校验失败，回调返回失败Response，请求节点收到失败的Response后会发布ClientVerifyFailedEvent事件。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>Nacos</category>
      </categories>
      <tags>
        <tag>Nacos</tag>
      </tags>
  </entry>
  <entry>
    <title>Nacos9# 服务端响应连接和注册源码分析（二）</title>
    <url>/posts/ec5551b4/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在《Nacos4# 服务端响应连接和注册源码分析（一）》在服务注册后发布了三个事件ClientEvent.ClientChangedEvent、ClientOperationEvent.ClientRegisterServiceEvent、MetadataEvent.InstanceMetadataEvent。这三个事件后来都干了点啥还没撸。</p>
<p>Nacos的CP协议使用Distro，中间穿插了几篇关于该协议的主要逻辑，本文接着撸服务端响应。</p>
<h1 id="内容提要"><a href="#内容提要" class="headerlink" title="内容提要"></a>内容提要</h1><h3 id="ClientRegisterServiceEvent事件"><a href="#ClientRegisterServiceEvent事件" class="headerlink" title="ClientRegisterServiceEvent事件"></a>ClientRegisterServiceEvent事件</h3><ul>
<li><p>当注册请求到服务端时，服务端会给订阅该服务的Clients发送推送请求，通知实例变了</p>
</li>
<li><p>当注册请求到服务端时，服务端发布了客户端注册事件ClientRegisterServiceEvent</p>
</li>
<li><p>ClientRegisterServiceEvent事件被ClientServiceIndexesManager订阅后发布服务变更事件ServiceChangedEvent</p>
</li>
<li><p>ServiceChangedEvent被NamingSubscriberServiceV2Impl订阅，创建PushDelayTask被PushExecuteTask执行，负责向订阅该服务的订阅者发起推送serviceInfo请求</p>
</li>
<li><p>推送的请求被NamingPushRequestHandler处理并发布InstancesChangeEvent，最终回调到我们的代码逻辑AbstractEventListener</p>
</li>
</ul>
<h3 id="ClientChangedEvent-事件"><a href="#ClientChangedEvent-事件" class="headerlink" title="ClientChangedEvent 事件"></a>ClientChangedEvent 事件</h3><ul>
<li><p>当注册请求到服务端时，该节点会向集群中其他节点增量同步新增的Client信息</p>
</li>
<li><p>当注册请求到服务端时，发布ClientChangedEvent事件</p>
</li>
<li><p>该事件被DistroClientDataProcessor订阅发起与其他节点的增量同步</p>
</li>
</ul>
<h3 id="InstanceMetadataEvent事件"><a href="#InstanceMetadataEvent事件" class="headerlink" title="InstanceMetadataEvent事件"></a>InstanceMetadataEvent事件</h3><ul>
<li>当注册请求到服务端时，发布ClientChangedEvent事件，属性expired为false</li>
<li>NamingMetadataManager订阅了该事件主要判断元数据是否过期</li>
</ul>
<a id="more"></a>

<h1 id="ClientRegisterServiceEvent事件-1"><a href="#ClientRegisterServiceEvent事件-1" class="headerlink" title="ClientRegisterServiceEvent事件"></a>ClientRegisterServiceEvent事件</h1><p>代码翻到ClientServiceIndexesManager#subscribeTypes()，这里订阅ClientRegisterServiceEvent时间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Class&lt;? extends Event&gt;&gt; subscribeTypes() &#123;</span><br><span class="line">    List&lt;Class&lt;? extends Event&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    result.add(ClientOperationEvent.ClientRegisterServiceEvent.class);</span><br><span class="line">    result.add(ClientOperationEvent.ClientDeregisterServiceEvent.class);</span><br><span class="line">    result.add(ClientOperationEvent.ClientSubscribeServiceEvent.class);</span><br><span class="line">    result.add(ClientOperationEvent.ClientUnsubscribeServiceEvent.class);</span><br><span class="line">    result.add(ClientEvent.ClientDisconnectEvent.class);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当接收到事件会调用到onEvent()方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(Event event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ClientEvent.ClientDisconnectEvent) &#123;</span><br><span class="line">        handleClientDisconnect((ClientEvent.ClientDisconnectEvent) event);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ClientOperationEvent) &#123;</span><br><span class="line">        handleClientOperation((ClientOperationEvent) event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleClientOperation</span><span class="params">(ClientOperationEvent event)</span> </span>&#123;</span><br><span class="line">  Service service = event.getService();</span><br><span class="line">  String clientId = event.getClientId();</span><br><span class="line">  <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ClientOperationEvent.ClientRegisterServiceEvent) &#123;</span><br><span class="line">    addPublisherIndexes(service, clientId); </span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ClientOperationEvent.ClientDeregisterServiceEvent) &#123;</span><br><span class="line">    removePublisherIndexes(service, clientId);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ClientOperationEvent.ClientSubscribeServiceEvent) &#123;</span><br><span class="line">    addSubscriberIndexes(service, clientId);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ClientOperationEvent.ClientUnsubscribeServiceEvent) &#123;</span><br><span class="line">    removeSubscriberIndexes(service, clientId);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addPublisherIndexes</span><span class="params">(Service service, String clientId)</span> </span>&#123;</span><br><span class="line">   publisherIndexes.computeIfAbsent(service, (key) -&gt; <span class="keyword">new</span> ConcurrentHashSet&lt;&gt;());</span><br><span class="line">   <span class="comment">// 注解@1</span></span><br><span class="line">   publisherIndexes.get(service).add(clientId);</span><br><span class="line">   <span class="comment">// 注解@2</span></span><br><span class="line">   NotifyCenter.publishEvent(<span class="keyword">new</span> ServiceEvent.ServiceChangedEvent(service, <span class="keyword">true</span>));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@1</strong> 一个服务通常有多个ClientId，clientId缓存在ConcurrentHashSet，通过ConcurrentHashMap关联。</p>
<p><strong>注解@2</strong> 又发布了一个ServiceChangedEvent事件</p>
<p>谁订阅了服务变更事件ServiceChangedEvent？接着跟</p>
<p>代码翻到NamingSubscriberServiceV2Impl#subscribeTypes()，该类订阅了ServiceChangedEvent事件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Class&lt;? extends Event&gt;&gt; subscribeTypes() &#123;</span><br><span class="line">    List&lt;Class&lt;? extends Event&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    result.add(ServiceEvent.ServiceChangedEvent.class);</span><br><span class="line">    result.add(ServiceEvent.ServiceSubscribedEvent.class);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>同样收到ServiceChangedEvent事件后回调到onEvent()方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(Event event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!upgradeJudgement.isUseGrpcFeatures()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ServiceEvent.ServiceChangedEvent) &#123;</span><br><span class="line">        <span class="comment">// If service changed, push to all subscribers.</span></span><br><span class="line">        ServiceEvent.ServiceChangedEvent serviceChangedEvent = (ServiceEvent.ServiceChangedEvent) event;</span><br><span class="line">        Service service = serviceChangedEvent.getService();</span><br><span class="line">      	<span class="comment">// 注解@3</span></span><br><span class="line">        delayTaskEngine.addTask(service, <span class="keyword">new</span> PushDelayTask(service, <span class="number">500L</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ServiceEvent.ServiceSubscribedEvent) &#123;</span><br><span class="line">        <span class="comment">// If service is subscribed by one client, only push this client.</span></span><br><span class="line">        ServiceEvent.ServiceSubscribedEvent subscribedEvent = (ServiceEvent.ServiceSubscribedEvent) event;</span><br><span class="line">        Service service = subscribedEvent.getService();</span><br><span class="line">        delayTaskEngine.addTask(service, <span class="keyword">new</span> PushDelayTask(service, <span class="number">500L</span>, subscribedEvent.getClientId()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@3</strong>  向delayTaskEngine引擎添加PushDelayTask，接着看该引擎的工作过程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NacosDelayTaskExecuteEngine</span><span class="params">(String name, <span class="keyword">int</span> initCapacity, Logger logger, <span class="keyword">long</span> processInterval)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(logger);</span><br><span class="line">    tasks = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(initCapacity);</span><br><span class="line">    processingExecutor = ExecutorFactory.newSingleScheduledExecutorService(<span class="keyword">new</span> NameThreadFactory(name));</span><br><span class="line">  	<span class="comment">// 注解@4</span></span><br><span class="line">    processingExecutor</span><br><span class="line">            .scheduleWithFixedDelay(<span class="keyword">new</span> ProcessRunnable(), processInterval, processInterval, TimeUnit.MILLISECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@4</strong> NacosDelayTaskExecuteEngine构造函数时启动了一个定时任务来运行，默认间隔为100ms。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PushDelayTaskProcessor</span> <span class="keyword">implements</span> <span class="title">NacosTaskProcessor</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PushDelayTaskExecuteEngine executeEngine;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PushDelayTaskProcessor</span><span class="params">(PushDelayTaskExecuteEngine executeEngine)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.executeEngine = executeEngine;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(NacosTask task)</span> </span>&#123;</span><br><span class="line">        PushDelayTask pushDelayTask = (PushDelayTask) task;</span><br><span class="line">        Service service = pushDelayTask.getService();</span><br><span class="line">      	<span class="comment">// 注解@5</span></span><br><span class="line">        NamingExecuteTaskDispatcher.getInstance()</span><br><span class="line">                .dispatchAndExecuteTask(service, <span class="keyword">new</span> PushExecuteTask(service, executeEngine, pushDelayTask));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@5</strong> 具体到PushDelayTask是由PushExecuteTask运行，下面看其run方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    		<span class="comment">// 注解@6</span></span><br><span class="line">        PushDataWrapper wrapper = generatePushData();</span><br><span class="line">        <span class="comment">// 注解@7</span></span><br><span class="line">        <span class="keyword">for</span> (String each : getTargetClientIds()) &#123;</span><br><span class="line">            Client client = delayTaskEngine.getClientManager().getClient(each);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == client) &#123;</span><br><span class="line">                <span class="comment">// means this client has disconnect</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 注解@8</span></span><br><span class="line">            Subscriber subscriber = delayTaskEngine.getClientManager().getClient(each).getSubscriber(service);</span><br><span class="line">            <span class="comment">// 注解@9</span></span><br><span class="line">            delayTaskEngine.getPushExecutor().doPushWithCallback(each, subscriber, wrapper,</span><br><span class="line">                    <span class="keyword">new</span> NamingPushCallback(each, subscriber, wrapper.getOriginalData()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        Loggers.PUSH.error(<span class="string">&quot;Push task for service&quot;</span> + service.getGroupedServiceName() + <span class="string">&quot; execute failed &quot;</span>, e);</span><br><span class="line">        delayTaskEngine.addTask(service, <span class="keyword">new</span> PushDelayTask(service, <span class="number">1000L</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@6</strong> 组织推送数据，主要为service信息以及注册host等。</p>
<p><strong>注解@7</strong> 获取需要通知的客户端集合ClientIds</p>
<p><strong>注解@8</strong> 获取服务的订阅者Subscriber</p>
<p><strong>注解@9</strong> 根据clientId从connections集合中获取连接，将变更推送给客户端</p>
<p><strong>客户端如何接受的呢？</strong> </p>
<p>NamingGrpcClientProxy#start()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(ServerListFactory serverListFactory, ServiceInfoHolder serviceInfoHolder)</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">    rpcClient.serverListFactory(serverListFactory);</span><br><span class="line">    <span class="comment">// gRPC Client启动</span></span><br><span class="line">    rpcClient.start();</span><br><span class="line">    <span class="comment">// 注解@10</span></span><br><span class="line">    rpcClient.registerServerRequestHandler(<span class="keyword">new</span> NamingPushRequestHandler(serviceInfoHolder));</span><br><span class="line">    <span class="comment">// 注册连接事件Listener，当连接建立和断开时处理事件</span></span><br><span class="line">    rpcClient.registerConnectionListener(namingGrpcConnectionEventListener);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@10</strong> 在客户端构建gRPC时，注册registerServerRequestHandler用于处理从Nacos Push到Client的请求，添加到了serverRequestHandlers集合。</p>
<p>GrpcClient#connectToServer()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Connection <span class="title">connectToServer</span><span class="params">(ServerInfo serverInfo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">       </span><br><span class="line">        RequestGrpc.RequestFutureStub newChannelStubTemp = createNewChannelStub(serverInfo.getServerIp(),</span><br><span class="line">                serverInfo.getServerPort() + rpcPortOffset());</span><br><span class="line">        <span class="keyword">if</span> (newChannelStubTemp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Response response = serverCheck(newChannelStubTemp);</span><br><span class="line">            BiRequestStreamGrpc.BiRequestStreamStub biRequestStreamStub = BiRequestStreamGrpc</span><br><span class="line">                    .newStub(newChannelStubTemp.getChannel());</span><br><span class="line">            GrpcConnection grpcConn = <span class="keyword">new</span> GrpcConnection(serverInfo, grpcExecutor);</span><br><span class="line">            grpcConn.setConnectionId(((ServerCheckResponse) response).getConnectionId());</span><br><span class="line">            <span class="comment">//create stream request and bind connection event to this connection.</span></span><br><span class="line">            <span class="comment">// 注解@11</span></span><br><span class="line">            StreamObserver&lt;Payload&gt; payloadStreamObserver = bindRequestStream(biRequestStreamStub, grpcConn);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">return</span> grpcConn;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">       <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@11</strong> 在连接server时绑定相关事件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> StreamObserver&lt;Payload&gt; <span class="title">bindRequestStream</span><span class="params">(<span class="keyword">final</span> BiRequestStreamGrpc.BiRequestStreamStub streamStub,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> GrpcConnection grpcConn)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> streamStub.requestBiStream(<span class="keyword">new</span> StreamObserver&lt;Payload&gt;() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Payload payload)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            LoggerUtils.printIfDebugEnabled(LOGGER, <span class="string">&quot;[&#123;&#125;]Stream server request receive, original info: &#123;&#125;&quot;</span>,</span><br><span class="line">                    grpcConn.getConnectionId(), payload.toString());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Object parseBody = GrpcUtils.parse(payload);</span><br><span class="line">                <span class="keyword">final</span> Request request = (Request) parseBody;</span><br><span class="line">                <span class="keyword">if</span> (request != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 注解@12</span></span><br><span class="line">                        Response response = handleServerRequest(request);</span><br><span class="line">                        <span class="keyword">if</span> (response != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            response.setRequestId(request.getRequestId());</span><br><span class="line">                            sendResponse(response);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                          	</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">							</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@12</strong>  接受server push处理，本事件具体回调到NamingPushRequestHandler#requestReply</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">requestReply</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (request <span class="keyword">instanceof</span> NotifySubscriberRequest) &#123;</span><br><span class="line">        NotifySubscriberRequest notifyResponse = (NotifySubscriberRequest) request;</span><br><span class="line">        serviceInfoHolder.processServiceInfo(notifyResponse.getServiceInfo());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> NotifySubscriberResponse();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面这部分代码在以前的文章已经分析过了，当serviceInfo变更时发布InstancesChangeEvent，InstancesChangeNotifier订阅了该事件，进而回调到我们示例代码的AbstractEventListener实现中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ServiceInfo <span class="title">processServiceInfo</span><span class="params">(ServiceInfo serviceInfo)</span> </span>&#123;</span><br><span class="line">    String serviceKey = serviceInfo.getKey();</span><br><span class="line">    <span class="keyword">if</span> (serviceKey == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ServiceInfo oldService = serviceInfoMap.get(serviceInfo.getKey());</span><br><span class="line">    <span class="keyword">if</span> (isEmptyOrErrorPush(serviceInfo)) &#123;</span><br><span class="line">        <span class="comment">//empty or error push, just ignore</span></span><br><span class="line">        <span class="keyword">return</span> oldService;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 缓存服务信息</span></span><br><span class="line">    serviceInfoMap.put(serviceInfo.getKey(), serviceInfo);</span><br><span class="line">    <span class="comment">// 判断注册的实例信息是否已变更</span></span><br><span class="line">    <span class="keyword">boolean</span> changed = isChangedServiceInfo(oldService, serviceInfo);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(serviceInfo.getJsonFromServer())) &#123;</span><br><span class="line">        serviceInfo.setJsonFromServer(JacksonUtils.toJson(serviceInfo));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过prometheus-simpleclient监控服务缓存Map的大小</span></span><br><span class="line">    MetricsMonitor.getServiceInfoMapSizeMonitor().set(serviceInfoMap.size());</span><br><span class="line">    <span class="comment">// 服务实例已变更</span></span><br><span class="line">    <span class="keyword">if</span> (changed) &#123;</span><br><span class="line">        NAMING_LOGGER.info(<span class="string">&quot;current ips:(&quot;</span> + serviceInfo.ipCount() + <span class="string">&quot;) service: &quot;</span> + serviceInfo.getKey() + <span class="string">&quot; -&gt; &quot;</span></span><br><span class="line">                + JacksonUtils.toJson(serviceInfo.getHosts()));</span><br><span class="line">        <span class="comment">// 添加实例变更事件，会被推动到订阅者执行</span></span><br><span class="line">        NotifyCenter.publishEvent(<span class="keyword">new</span> InstancesChangeEvent(serviceInfo.getName(), serviceInfo.getGroupName(),</span><br><span class="line">                serviceInfo.getClusters(), serviceInfo.getHosts()));</span><br><span class="line">        <span class="comment">// 记录Service本地文件</span></span><br><span class="line">        DiskCache.write(serviceInfo, cacheDir);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> serviceInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>小结：</strong> 当注册请求到服务端时，服务端发布了客户端注册事件（ClientRegisterServiceEvent）；ClientRegisterServiceEvent事件被ClientServiceIndexesManager订阅后发布服务变更事件（ServiceChangedEvent）；ServiceChangedEvent被NamingSubscriberServiceV2Impl订阅并创建PushDelayTask并被PushExecuteTask执行，负责向订阅该服务的订阅者发起推送serviceInfo请求；推送的请求被NamingPushRequestHandler处理并发布InstancesChangeEvent，最终回调到我们的代码逻辑AbstractEventListener。</p>
<h1 id="ClientChangedEvent-事件-1"><a href="#ClientChangedEvent-事件-1" class="headerlink" title="ClientChangedEvent 事件"></a>ClientChangedEvent 事件</h1><p>还是看ClientChangedEvent事件的订阅者，代码翻到DistroClientDataProcessor#subscribeTypes()。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Class&lt;? extends Event&gt;&gt; subscribeTypes() &#123;</span><br><span class="line">    List&lt;Class&lt;? extends Event&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    result.add(ClientEvent.ClientChangedEvent.class);</span><br><span class="line">    result.add(ClientEvent.ClientDisconnectEvent.class);</span><br><span class="line">    result.add(ClientEvent.ClientVerifyFailedEvent.class);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当收到该事件时会执行到onEvent方法()也就是增量同步，增量同步逻辑在《Nacos7# Distro协议增量同步》已梳理。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onEvent(Event event) &#123;</span><br><span class="line">    if (EnvUtil.getStandaloneMode()) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!upgradeJudgement.isUseGrpcFeatures()) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (event instanceof ClientEvent.ClientVerifyFailedEvent) &#123;</span><br><span class="line">        syncToVerifyFailedServer((ClientEvent.ClientVerifyFailedEvent) event);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; 同步给其他节点信息</span><br><span class="line">        syncToAllServer((ClientEvent) event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>小结：</strong>  当注册请求到服务端时，发布ClientChangedEvent事件；该事件被DistroClientDataProcessor订阅发起与其他节点的增量同步。</p>
<h1 id="InstanceMetadataEvent事件-1"><a href="#InstanceMetadataEvent事件-1" class="headerlink" title="InstanceMetadataEvent事件"></a>InstanceMetadataEvent事件</h1><p>翻到NamingMetadataManager#subscribeTypes()，订阅了该事件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Class&lt;? extends Event&gt;&gt; subscribeTypes() &#123;</span><br><span class="line">    List&lt;Class&lt;? extends Event&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 订阅实例变更事件</span></span><br><span class="line">    result.add(MetadataEvent.InstanceMetadataEvent.class);</span><br><span class="line">    result.add(MetadataEvent.ServiceMetadataEvent.class);</span><br><span class="line">    result.add(ClientEvent.ClientDisconnectEvent.class);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还是onEvent()处理事件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(Event event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 处理实例元数据变更事件</span></span><br><span class="line">    <span class="keyword">if</span> (event <span class="keyword">instanceof</span> MetadataEvent.InstanceMetadataEvent) &#123;</span><br><span class="line">        handleInstanceMetadataEvent((MetadataEvent.InstanceMetadataEvent) event);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event <span class="keyword">instanceof</span> MetadataEvent.ServiceMetadataEvent) &#123;</span><br><span class="line">        handleServiceMetadataEvent((MetadataEvent.ServiceMetadataEvent) event);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        handleClientDisconnectEvent((ClientEvent.ClientDisconnectEvent) event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleInstanceMetadataEvent</span><span class="params">(MetadataEvent.InstanceMetadataEvent event)</span> </span>&#123;</span><br><span class="line">        Service service = event.getService();</span><br><span class="line">        <span class="comment">// 格式 ip:port:cluster</span></span><br><span class="line">        String metadataId = event.getMetadataId();</span><br><span class="line">        <span class="keyword">if</span> (containInstanceMetadata(service, metadataId)) &#123;</span><br><span class="line">            updateExpiredInfo(event.isExpired(),</span><br><span class="line">                    ExpiredMetadataInfo.newExpiredInstanceMetadata(event.getService(), event.getMetadataId()));</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateExpiredInfo</span><span class="params">(<span class="keyword">boolean</span> expired, ExpiredMetadataInfo expiredMetadataInfo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (expired) &#123;</span><br><span class="line">            expiredMetadataInfos.add(expiredMetadataInfo);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">// false</span></span><br><span class="line">            expiredMetadataInfos.remove(expiredMetadataInfo);</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>小结：</strong> 当注册请求到服务端时，发布ClientChangedEvent事件，expired为false；NamingMetadataManager订阅了该事件主要判断元数据是否过期。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>Nacos</category>
      </categories>
      <tags>
        <tag>Nacos</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty14# 池化内存之线程缓存</title>
    <url>/posts/8631788a/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在前面文章『Netty12# 池化内存框架流程』Netty会将不同的内存尺寸缓存起来，每个线程绑定了专属逻辑内存区域（PoolArena），减少资源竞争。每个线程绑定了缓存PoolThreadCache，内存分配时，先从当前线程绑定的PoolThreadCache缓存分配。下图为涉及到相关类的关系图：</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6%20(3).png"></p>
<p>工作过程：</p>
<p>@1 通过引导类传入NioEventLoopGroup，线程工厂创建的线程均为FastThreadLocalThread</p>
<p>@2 FastThreadLocalThread持有InternalThreadLocalMap（内部维护一个对象数组）</p>
<p>@3 当通过PooledByteBufAllocator#newDirectBuffer分配内存时，通过调用PoolThreadLocalCache#get()完成对InternalThreadLocalMap的第一次填充，对象数组下标为线程索引号，其对应的值为PoolThreadCache。</p>
<p>@4 PoolThreadCache是被当前线程缓存的对象</p>
<a id="more"></a>



<h1 id="线程缓存梳理"><a href="#线程缓存梳理" class="headerlink" title="线程缓存梳理"></a>线程缓存梳理</h1><p>PoolThreadLocalCache继承了线程类FastThreadLocal，FastThreadLocal的作用类似ThreadLocal，传递线程上下文变量。本小节梳理PoolThreadLocalCache工作流程。</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PoolThreadLocalCache</span> <span class="keyword">extends</span> <span class="title">FastThreadLocal</span>&lt;<span class="title">PoolThreadCache</span>&gt; </span>&#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> useCacheForAllThreads;</span><br><span class="line"></span><br><span class="line">       PoolThreadLocalCache(<span class="keyword">boolean</span> useCacheForAllThreads) &#123;</span><br><span class="line">           <span class="keyword">this</span>.useCacheForAllThreads = useCacheForAllThreads;</span><br><span class="line">       &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>小结：构造函数就一个变量useCacheForAllThreads，默认true，使用线程缓存，可以通过-Dio.netty.allocator.useCacheForAllThread制定。</p>
<h3 id="初始化方法赋值"><a href="#初始化方法赋值" class="headerlink" title="初始化方法赋值"></a>初始化方法赋值</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> PoolThreadCache <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> PoolArena&lt;<span class="keyword">byte</span>[]&gt; heapArena = leastUsedArena(heapArenas);</span><br><span class="line">    <span class="keyword">final</span> PoolArena&lt;ByteBuffer&gt; directArena = leastUsedArena(directArenas); <span class="comment">// 注解@1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">if</span> (useCacheForAllThreads || current <span class="keyword">instanceof</span> FastThreadLocalThread) &#123; <span class="comment">// 注解@2</span></span><br><span class="line">      <span class="keyword">final</span> PoolThreadCache cache = <span class="keyword">new</span> PoolThreadCache(</span><br><span class="line">        heapArena, directArena, tinyCacheSize, smallCacheSize, normalCacheSize,</span><br><span class="line">        DEFAULT_MAX_CACHED_BUFFER_CAPACITY, DEFAULT_CACHE_TRIM_INTERVAL);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (DEFAULT_CACHE_TRIM_INTERVAL_MILLIS &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> EventExecutor executor = ThreadExecutorMap.currentExecutor();</span><br><span class="line">        <span class="keyword">if</span> (executor != <span class="keyword">null</span>) &#123;</span><br><span class="line">          executor.scheduleAtFixedRate(trimTask, DEFAULT_CACHE_TRIM_INTERVAL_MILLIS,</span><br><span class="line">          DEFAULT_CACHE_TRIM_INTERVAL_MILLIS, TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> cache;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// No caching so just use 0 as sizes.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PoolThreadCache(heapArena, directArena, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 注解@3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注解@1：heapArenas/directArenas：Arena数组，元素为HeapArena/DirectArena。调用了同一个方法leastUsedArena()。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">PoolArena&lt;T&gt; <span class="title">leastUsedArena</span><span class="params">(PoolArena&lt;T&gt;[] arenas)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (arenas == <span class="keyword">null</span> || arenas.length == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  PoolArena&lt;T&gt; minArena = arenas[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arenas.length; i++) &#123;</span><br><span class="line">    PoolArena&lt;T&gt; arena = arenas[i];</span><br><span class="line">    <span class="keyword">if</span> (arena.numThreadCaches.get() &lt; minArena.numThreadCaches.get()) &#123;</span><br><span class="line">      minArena = arena;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> minArena;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个线程都会绑定PoolArena，在leastUsedArena()轮询一遍，获取当前绑定线程数最少的PoolArena。</p>
<p>注解@2：当useCacheForAllThreads=true（默认true）和当前thread属于FastThreadLocalThread才构造PoolThreadCache进行缓存。</p>
<p>DEFAULT_CACHE_TRIM_INTERVAL_MILLIS：定时释放缓存。默认为0表示关闭，可以通过-Dio.netty.allocator.cacheTrimIntervalMillis指定。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Runnable trimTask = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            PooledByteBufAllocator.<span class="keyword">this</span>.trimCurrentThreadCache();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">trimCurrentThreadCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        PoolThreadCache cache = threadCache.getIfExists();</span><br><span class="line">        <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">            cache.trim();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过定时调度调用PoolThreadCache的trim()方法将线程缓存释放。</p>
<p>注解@3：禁用线程缓存依然是构造PoolThreadCache，只是传入的参数为0.</p>
<p>小结：初始化赋值过程实际是为了创建一个PoolThreadCache对象。</p>
<h3 id="初始化方法调用"><a href="#初始化方法调用" class="headerlink" title="初始化方法调用"></a>初始化方法调用</h3><p>初始化方法PoolThreadLocalCache#initialValue()什么时候调用的呢？在第一次调用FastThreadLocal#get()时进行的初始化。例如：在PooledByteBufAllocator#newDirectBuffer()方法中PoolThreadCache cache = threadCache.get();</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        InternalThreadLocalMap threadLocalMap = InternalThreadLocalMap.get();</span><br><span class="line">        Object v = threadLocalMap.indexedVariable(index);</span><br><span class="line">        <span class="keyword">if</span> (v != InternalThreadLocalMap.UNSET) &#123;</span><br><span class="line">            <span class="keyword">return</span> (V) v;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> initialize(threadLocalMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化后，会将放入InternalThreadLocalMap, 其中维护了一个对象数组Object[]，下标即为index，每创建一个线程FastThreadLocal，都会递增一个index。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">initialize</span><span class="params">(InternalThreadLocalMap threadLocalMap)</span> </span>&#123;</span><br><span class="line">        V v = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            v = initialValue();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            PlatformDependent.throwException(e);</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="comment">// 放入InternalThreadLocalMap中实际为数组</span></span><br><span class="line">        threadLocalMap.setIndexedVariable(index, v); </span><br><span class="line">        addToVariablesToRemove(threadLocalMap, <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FastThreadLocal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 每创建一个fast线程都会分配一个index</span></span><br><span class="line">	index = InternalThreadLocalMap.nextVariableIndex();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>小结：初始化方法initialValue()，在第一次调用threadCache.get()的时候执行。并将初始化的结果PoolThreadCache放入InternalThreadLocalMap（实际为对象数组）。</p>
<h3 id="FastThreadLocalThread的调用"><a href="#FastThreadLocalThread的调用" class="headerlink" title="FastThreadLocalThread的调用"></a>FastThreadLocalThread的调用</h3><p>在初始化赋值注解@2中，只有满足两个条件才会缓存，if (useCacheForAllThreads || current instanceof FastThreadLocalThread) 。其中一个是当前线程属于FastThreadLocalThread。那问题是我们有用FastThreadLocalThread吗？</p>
<p>在通过引导类构建Netty客户端和服务端时会传入EventLoopGroup，我们以NioEventLoopGroup看下它创建的是什么线程。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EventLoopGroup group &#x3D; new NioEventLoopGroup();</span><br></pre></td></tr></table></figure>

<p>通过NioEventLoopGroup的构造函数可以跟到下面内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">MultithreadEventExecutorGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            EventExecutorChooserFactory chooserFactory, Object... args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nThreads &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(<span class="string">&quot;nThreads: %d (expected: &gt; 0)&quot;</span>, nThreads));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (executor == <span class="keyword">null</span>) &#123;</span><br><span class="line">            executor = <span class="keyword">new</span> ThreadPerTaskExecutor(newDefaultThreadFactory());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过newDefaultThreadFactory()看下线程工厂类DefaultThreadFactory中如何创建线程的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">       Thread t = newThread(FastThreadLocalRunnable.wrap(r), prefix + nextId.incrementAndGet());</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (t.isDaemon() != daemon) &#123;</span><br><span class="line">               t.setDaemon(daemon);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (t.getPriority() != priority) &#123;</span><br><span class="line">               t.setPriority(priority);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception ignored) &#123;</span><br><span class="line">           <span class="comment">// Doesn&#x27;t matter even if failed to set.</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> Thread <span class="title">newThread</span><span class="params">(Runnable r, String name)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> FastThreadLocalThread(threadGroup, r, name); <span class="comment">// 实际为FastThreadLocalThread实例。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过newThread创建的实际为FastThreadLocalThread实例。</p>
<p>小结：我们通过Bootstrap引导类传入的NioEventLoopGroup，使用的线程为FastThreadLocalThread。</p>
<h1 id="构造缓存数组"><a href="#构造缓存数组" class="headerlink" title="构造缓存数组"></a>构造缓存数组</h1><p>PoolThreadCache 缓存了三个级别的缓存类型，分别为tiny、small、normal。</p>
<h3 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PoolThreadCache(PoolArena&lt;<span class="keyword">byte</span>[]&gt; heapArena, PoolArena&lt;ByteBuffer&gt; directArena,</span><br><span class="line">                    <span class="keyword">int</span> tinyCacheSize, <span class="keyword">int</span> smallCacheSize, <span class="keyword">int</span> normalCacheSize,</span><br><span class="line">                    <span class="keyword">int</span> maxCachedBufferCapacity, <span class="keyword">int</span> freeSweepAllocationThreshold) &#123;</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">if</span> (directArena != <span class="keyword">null</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        tinySubPageDirectCaches = createSubPageCaches(</span><br><span class="line">          tinyCacheSize, PoolArena.numTinySubpagePools, SizeClass.Tiny);</span><br><span class="line">        </span><br><span class="line">        smallSubPageDirectCaches = createSubPageCaches(</span><br><span class="line">          smallCacheSize, directArena.numSmallSubpagePools, SizeClass.Small);</span><br><span class="line"></span><br><span class="line">        numShiftsNormalDirect = log2(directArena.pageSize);</span><br><span class="line">        normalDirectCaches = createNormalCaches(</span><br><span class="line">          normalCacheSize, maxCachedBufferCapacity, directArena);</span><br><span class="line"></span><br><span class="line">        directArena.numThreadCaches.getAndIncrement();</span><br><span class="line">      &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>参数说明</strong> </p>
<p>heapArena：最少持有线程数(使用率最少)的逻辑堆内存PoolArena，PoolArena[]数组长度默认为核数的2倍</p>
<p>directArena：最少持有线程数(使用率最少)的逻辑堆外直接内存PoolArena，PoolArena[]数组长度默认为核数的2倍</p>
<p>tinyCacheSize：默认tiny类型缓存池大小512</p>
<p>smallCacheSize：默认small类型缓存池大小为256</p>
<p>normalCacheSize：默认normal类型缓存池大小为64</p>
<p>maxCachedBufferCapacity：默认为32KB，用于限制normal缓存数组的长度</p>
<p>freeSweepAllocationThreshold：默认8192，分配次数阈值，超过后释放内存池</p>
<p>构造函数中，主要给三种类型的缓存数组赋值，包括堆内存和堆外直接内存，结构一致，只走查堆外直接内存。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tiny类型缓存数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MemoryRegionCache&lt;ByteBuffer&gt;[] tinySubPageDirectCaches;</span><br><span class="line"><span class="comment">// small类型缓存数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MemoryRegionCache&lt;ByteBuffer&gt;[] smallSubPageDirectCaches;</span><br><span class="line"><span class="comment">// normal类型缓存数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MemoryRegionCache&lt;ByteBuffer&gt;[] normalDirectCaches;</span><br></pre></td></tr></table></figure>



<h3 id="createSubPageCaches"><a href="#createSubPageCaches" class="headerlink" title="createSubPageCaches"></a>createSubPageCaches</h3><p>tiny类型缓存数组与small类型缓存数组调用调用相同的createSubPageCaches()方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; MemoryRegionCache&lt;T&gt;[] createSubPageCaches(</span><br><span class="line">            <span class="keyword">int</span> cacheSize, <span class="keyword">int</span> numCaches, SizeClass sizeClass) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cacheSize &gt; <span class="number">0</span> &amp;&amp; numCaches &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            MemoryRegionCache&lt;T&gt;[] cache = <span class="keyword">new</span> MemoryRegionCache[numCaches];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cache.length; i++) &#123;</span><br><span class="line">                cache[i] = <span class="keyword">new</span> SubPageMemoryRegionCache&lt;T&gt;(cacheSize, sizeClass);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> cache;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法入参</strong></p>
<p>cacheSize：MemoryRegionCache包含队列Queue的大小，tiny类型512，small类型256</p>
<p>numCaches：不同缓存类型的规格数量。</p>
<p>tiny类型规格数量为32，计算方式 PoolArena.numTinySubpagePools=512 &gt;&gt;&gt; 4=32</p>
<p>small类型规格数量为4，计算方式 heapArena.numSmallSubpagePools=pageShifts - 9=13 - 9 = 4</p>
<p>小结：tiny类型会构建MemoryRegionCache的数组长度为32，每个数组元素为SubPageMemoryRegionCache（包含Queue的大小为512）；</p>
<p>small类型会构建MemoryRegionCache的数组长度为4，每个数组元素为SubPageMemoryRegionCache（包含Queue的大小为256）</p>
<h3 id="createNormalCaches"><a href="#createNormalCaches" class="headerlink" title="createNormalCaches"></a>createNormalCaches</h3><p>Normal类型缓存数组调用createNormalCaches()方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; MemoryRegionCache&lt;T&gt;[] createNormalCaches(</span><br><span class="line">            <span class="keyword">int</span> cacheSize, <span class="keyword">int</span> maxCachedBufferCapacity, PoolArena&lt;T&gt; area) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cacheSize &gt; <span class="number">0</span> &amp;&amp; maxCachedBufferCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> max = Math.min(area.chunkSize, maxCachedBufferCapacity);</span><br><span class="line">            <span class="keyword">int</span> arraySize = Math.max(<span class="number">1</span>, log2(max / area.pageSize) + <span class="number">1</span>);</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            MemoryRegionCache&lt;T&gt;[] cache = <span class="keyword">new</span> MemoryRegionCache[arraySize];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cache.length; i++) &#123;</span><br><span class="line">                cache[i] = <span class="keyword">new</span> NormalMemoryRegionCache&lt;T&gt;(cacheSize);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> cache;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法入参</strong> </p>
<p>cacheSize：Normal类型64</p>
<p>maxCachedBufferCapacity：32K</p>
<p><strong>数组大小计算</strong> </p>
<p>int arraySize = Math.max(1, log2(max / area.pageSize) + 1);</p>
<p>int max：maxCachedBufferCapacity=32KB；area.chunkSize = 16M，Max.min(32KB，16M) = 32K</p>
<p>pageSize：area.pageSize=8K</p>
<p>log2(max / area.pageSize)，代入log2(4)公式 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">log2</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span> (val &gt; <span class="number">1</span>) &#123;</span><br><span class="line">           val &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">           res++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>经过计算数组大小arraySize= 3</p>
<p>小结：Normal类型会构建MemoryRegionCache的数组长度为3，每个数组元素为SubPageMemoryRegionCache（包含Queue的大小为64）。</p>
<h1 id="缓存数组结构"><a href="#缓存数组结构" class="headerlink" title="缓存数组结构"></a>缓存数组结构</h1><h3 id="缓存数组结构-1"><a href="#缓存数组结构-1" class="headerlink" title="缓存数组结构"></a>缓存数组结构</h3><p>上面tiny、small、normal无论哪种类型都在构建MemoryRegionCache数组，通过看下MemoryRegionCache的结构看下缓存的不同点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MemoryRegionCache</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> size;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;Entry&lt;T&gt;&gt; queue;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> SizeClass sizeClass;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> allocations;</span><br><span class="line"></span><br><span class="line">        MemoryRegionCache(<span class="keyword">int</span> size, SizeClass sizeClass) &#123;</span><br><span class="line">            <span class="keyword">this</span>.size = MathUtil.safeFindNextPositivePowerOfTwo(size);</span><br><span class="line">            queue = PlatformDependent.newFixedMpscQueue(<span class="keyword">this</span>.size);</span><br><span class="line">            <span class="keyword">this</span>.sizeClass = sizeClass;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以对外直接内存Queue&lt;Entry<T>&gt; queue封装的均为ByteBuffer。下面看下不同类型缓存的ByteBuffer是如何分布的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(PoolArena&lt;?&gt; area, PoolChunk chunk, ByteBuffer nioBuffer,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">long</span> handle, <span class="keyword">int</span> normCapacity, SizeClass sizeClass)</span> </span>&#123;</span><br><span class="line">       MemoryRegionCache&lt;?&gt; cache = cache(area, normCapacity, sizeClass);</span><br><span class="line">       <span class="keyword">if</span> (cache == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> cache.add(chunk, nioBuffer, handle);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>通过cache()方法来判断缓存的三种类型判断</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> MemoryRegionCache&lt;?&gt; cache(PoolArena&lt;?&gt; area, <span class="keyword">int</span> normCapacity, SizeClass sizeClass) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (sizeClass) &#123;</span><br><span class="line">        <span class="keyword">case</span> Normal:</span><br><span class="line">            <span class="keyword">return</span> cacheForNormal(area, normCapacity);</span><br><span class="line">        <span class="keyword">case</span> Small:</span><br><span class="line">            <span class="keyword">return</span> cacheForSmall(area, normCapacity);</span><br><span class="line">        <span class="keyword">case</span> Tiny:</span><br><span class="line">            <span class="keyword">return</span> cacheForTiny(area, normCapacity);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>下面逐个看看每个里面的结构，先看Tiny类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> MemoryRegionCache&lt;?&gt; cacheForTiny(PoolArena&lt;?&gt; area, <span class="keyword">int</span> normCapacity) &#123;</span><br><span class="line">        <span class="comment">// idx = normCapacity 除以 16</span></span><br><span class="line">        <span class="keyword">int</span> idx = PoolArena.tinyIdx(normCapacity);</span><br><span class="line">        <span class="keyword">if</span> (area.isDirect()) &#123;</span><br><span class="line">            <span class="comment">// tiny有32个规格类型即32个MemoryRegionCache实例</span></span><br><span class="line">          	<span class="comment">// 例如：normCapacity=32 则返回第2个数组元素MemoryRegionCache</span></span><br><span class="line">            <span class="keyword">return</span> cache(tinySubPageDirectCaches, idx);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cache(tinySubPageHeapCaches, idx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">tinyIdx</span><span class="params">(<span class="keyword">int</span> normCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> normCapacity &gt;&gt;&gt; <span class="number">4</span>; <span class="comment">// 相当于直接将normCapacity除以16</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>过程：Tiny类型中根据需要分配的大小除以16<br>示例1：normCapacity=0，idx=0，返回 tinySubPageDirectCaches[0]，也就是 tinySubPageDirectCaches[0]没有缓存。</p>
<p>示例2：normCapacity=16，idx=1，返回 tinySubPageDirectCaches[1]，也就是 tinySubPageDirectCaches[1]中的Queue的buffer大小均为16字节。</p>
<p>示例3：normCapacity=32，idx=2，返回 tinySubPageDirectCaches[2]，也就是 tinySubPageDirectCaches[2]中的Queue的buffer大小均为32字节。</p>
<p>…</p>
<p>示例4：   normCapacity=496，idx=31，返回 tinySubPageDirectCaches[31]，也就是 tinySubPageDirectCaches[31]中的Queue的buffer大小均为496字节。</p>
<p>接着看Small类型的存储格式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> MemoryRegionCache&lt;?&gt; cacheForSmall(PoolArena&lt;?&gt; area, <span class="keyword">int</span> normCapacity) &#123;</span><br><span class="line">   <span class="keyword">int</span> idx = PoolArena.smallIdx(normCapacity);</span><br><span class="line">   <span class="keyword">if</span> (area.isDirect()) &#123;</span><br><span class="line">        <span class="keyword">return</span> cache(smallSubPageDirectCaches, idx);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> cache(smallSubPageHeapCaches, idx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">smallIdx</span><span class="params">(<span class="keyword">int</span> normCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tableIdx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = normCapacity &gt;&gt;&gt; <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">while</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">            i &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            tableIdx ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tableIdx;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>过程：Small类型的分配normCapacity &gt;&gt;&gt; 10，代入计算看看System.out.println(smallIdx(normCapacity))。</p>
<p>示例1：normCapacity=512，idx = 0，返回smallSubPageDirectCaches[0]，也就是smallSubPageDirectCaches[0]中Queue的Buffer大小均为512字节。</p>
<p>示例2：normCapacity=1024，idx = 1，返回smallSubPageDirectCaches[1]，也就是smallSubPageDirectCaches[1]中Queue的Buffer大小均为1024字节。</p>
<p>示例3：normCapacity=2048，idx = 2，返回smallSubPageDirectCaches[2]，也就是smallSubPageDirectCaches[2]中Queue的Buffer大小均为2048字节。</p>
<p>示例3：normCapacity=4096，idx = 3，返回smallSubPageDirectCaches[3]，也就是smallSubPageDirectCaches[3]中Queue的Buffer大小均为4096字节。</p>
<p>最后看下Normal类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> MemoryRegionCache&lt;?&gt; cacheForNormal(PoolArena&lt;?&gt; area, <span class="keyword">int</span> normCapacity) &#123;</span><br><span class="line">        <span class="keyword">if</span> (area.isDirect()) &#123;</span><br><span class="line">            <span class="keyword">int</span> idx = log2(normCapacity &gt;&gt; numShiftsNormalDirect);</span><br><span class="line">            <span class="keyword">return</span> cache(normalDirectCaches, idx);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> idx = log2(normCapacity &gt;&gt; numShiftsNormalHeap);</span><br><span class="line">        <span class="keyword">return</span> cache(normalHeapCaches, idx);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>过程：先把numShiftsNormalDirect算下</p>
<p>numShiftsNormalDirect = log2(directArena.pageSize) = log2(8192) = 13.</p>
<p>代入公式计算下 int idx = log2(normCapacity &gt;&gt; 13)</p>
<p>示例1：normCapacity=8192（8K），idx = 0，返回normalDirectCaches[0]，也就是normalDirectCaches[0]中Queue的Buffer大小均为8KB。</p>
<p>示例2：normCapacity=16384（16K），idx = 1，返回normalDirectCaches[1]，也就是normalDirectCaches[0]中Queue的Buffer大小均为16KB。</p>
<p>示例3：normCapacity=32768（32K），idx = 2，返回normalDirectCaches[2]，也就是normalDirectCaches[0]中Queue的Buffer大小均为32KB。</p>
<p>小结：通过上面的过程分析，能够得出MemoryRegionCache的缓存结构如下，其中每个数组元素的队列中缓存的大小都是相同的，也就是Queue&lt;Entry<T>&gt; queue中的T即ByteBuffer。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/%E7%BC%93%E5%AD%98%E7%BB%93%E6%9E%84%E5%9B%BE%E7%A4%BA.png"></p>
<h3 id="缓存归队"><a href="#缓存归队" class="headerlink" title="缓存归队"></a>缓存归队</h3><p>再回到添加方法中，上面通过cache()方法分析了缓存数组结构，返回不同类型的MemoryRegionCache。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(PoolArena&lt;?&gt; area, PoolChunk chunk, ByteBuffer nioBuffer,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">long</span> handle, <span class="keyword">int</span> normCapacity, SizeClass sizeClass)</span> </span>&#123;</span><br><span class="line">        MemoryRegionCache&lt;?&gt; cache = cache(area, normCapacity, sizeClass);</span><br><span class="line">        <span class="keyword">if</span> (cache == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cache.add(chunk, nioBuffer, handle); <span class="comment">// 注解@1</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>注解@1：下面是将chunk（真正一块连续内存）, nioBuffer, handle（指向内存的指针）放入队列的过程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(PoolChunk&lt;T&gt; chunk, ByteBuffer nioBuffer, <span class="keyword">long</span> handle)</span> </span>&#123;</span><br><span class="line">     Entry&lt;T&gt; entry = newEntry(chunk, nioBuffer, handle); <span class="comment">// 注解@2 </span></span><br><span class="line">     <span class="keyword">boolean</span> queued = queue.offer(entry); <span class="comment">// 注解@3</span></span><br><span class="line">     <span class="keyword">if</span> (!queued) &#123;</span><br><span class="line">       <span class="comment">// If it was not possible to cache the chunk, immediately recycle the entry</span></span><br><span class="line">       entry.recycle();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> queued;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注解@2：构造Entry对象</p>
<p>注解@3：将Entry放入所在规格的队列Queue中。</p>
<p>小结：还有allocate()方法留在下节梳理，就内存数组结构简单做个小结：</p>
<p>@1 Netty以chunk为单位（16M）向系统申请物理内存，Netty池化内存分成了4种内存类型。Tiny（0<del>512Byte），Small（512Byte</del>8KB），Normal（8KB~16MB），Huge（&gt;16M）</p>
<p>@2 Netty对Tiny、Small、Normal做了缓存，针对不同的类型通过”数组+队列“继续切成不同的尺寸，每个尺寸内的缓存ByteBuffer大小相同，不同尺寸之间缓存的Buffer大小以2的N次增长。</p>
<p>@3 Tiny类型从0到496被划分为32个尺寸（数组）</p>
<p>@4 Small类型从512到4096（4K）被划分4个尺寸</p>
<p>@5 Normal类型从8192（8K）到32768（32K）被划分为3个尺寸</p>
<p>@6 在内存分配时，先根据需要分配的内存大小判断属于那种内存类型；进而计算出属于该内存类型的哪个尺寸。</p>
<p>@7 每个尺寸都维护有队列Queue，定位到尺寸规格也就拿到Queue中的实际缓存（PoolChunk）和指针（handle）并完成所需分配内存buffer的初始化。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty7# Netty之事件传递</title>
    <url>/posts/8c88e43/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前面的文章中写了Channel实例化、Channel初始化、Channel注册、异步通知机制、客户端发起连接、事件的轮询和处理机制。Netty作为client/server高效通信框架，事件在ChannelPipeline是如何传递的，本文就聊聊这事。</p>
<a id="more"></a>



<h1 id="事件传递过程"><a href="#事件传递过程" class="headerlink" title="事件传递过程"></a>事件传递过程</h1><p>ChannelPipeline随着Channel的创建而创建，在 <a href="https://mp.weixin.qq.com/s/tvy0j0Mo9H82SK4jztqu0w">Netty2# Netty组件之Channel初始化 </a> 文章中梳理了ChannelPipeline、ChannelHandlerContext、ChannelHandler的关系如下图。</p>
<p>ChannelPipeline大管道维护了一个ChannelHandlerContext链表，头部为HeadContext，尾部为TailContext。事件传播会沿着链表逐级向下传递。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201226112641.png"></p>
<h3 id="Inbound-amp-Outbound标识"><a href="#Inbound-amp-Outbound标识" class="headerlink" title="Inbound&amp;Outbound标识"></a>Inbound&amp;Outbound标识</h3><p>当ChannelHandlerContext创建时，它是Inbound还是Outbound，是哪个方向的就确定了。下面分析是这种身份是如何确定的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AbstractChannelHandlerContext(DefaultChannelPipeline pipeline, EventExecutor executor,</span><br><span class="line">                              String name, Class&lt;? extends ChannelHandler&gt; handlerClass) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = ObjectUtil.checkNotNull(name, <span class="string">&quot;name&quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>.pipeline = pipeline;</span><br><span class="line">    <span class="keyword">this</span>.executor = executor;</span><br><span class="line">    <span class="keyword">this</span>.executionMask = mask(handlerClass); <span class="comment">// 注解@1</span></span><br><span class="line">    ordered = executor == <span class="keyword">null</span> || executor <span class="keyword">instanceof</span> OrderedEventExecutor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@1</strong> 父类的构造函数中有一个mask(handlerClass)方法，这个方法确定了ChannelHandlerContext的身份。如下代码ChannelInboundHandler.class.isAssignableFrom(handlerType)即如果是ChannelInboundHandler类型mask |= MASK_ALL_INBOUND；反之如果是ChannelOutboundHandler类型，mask |= MASK_ALL_OUTBOUND；<strong>通过赋予mask不同的值来区分是哪个方向的Handler</strong>。isSkippable中的逻辑判断主要对加注解@Skip的方法不再进行事件回调。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mask0</span><span class="params">(Class&lt;? extends ChannelHandler&gt; handlerType)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mask = MASK_EXCEPTION_CAUGHT;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ChannelInboundHandler.class.isAssignableFrom(handlerType)) &#123;</span><br><span class="line">            mask |= MASK_ALL_INBOUND; <span class="comment">// 标识为INBOUND</span></span><br><span class="line">            <span class="keyword">if</span> (isSkippable(handlerType, <span class="string">&quot;channelRegistered&quot;</span>, ChannelHandlerContext.class))&#123;</span><br><span class="line">                mask &amp;= ~MASK_CHANNEL_REGISTERED;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ChannelOutboundHandler.class.isAssignableFrom(handlerType)) &#123;</span><br><span class="line">            mask |= MASK_ALL_OUTBOUND; <span class="comment">// 标识为OUTBOUND</span></span><br><span class="line">            <span class="keyword">if</span> (isSkippable(handlerType, <span class="string">&quot;bind&quot;</span>, ChannelHandlerContext.class,</span><br><span class="line">                    SocketAddress.class, ChannelPromise.class)) &#123;</span><br><span class="line">                mask &amp;= ~MASK_BIND;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">       <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Outbound传递过程"><a href="#Outbound传递过程" class="headerlink" title="Outbound传递过程"></a>Outbound传递过程</h3><p><strong>示例入口</strong> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ChannelFuture future = b.connect(HOST, PORT).sync(); </span><br><span class="line">future.channel().writeAndFlush(<span class="string">&quot;Hi&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>以writeAndFlush方法跟踪下Outbound事件在ChannelPipeline的传递过程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelFuture <span class="title">writeAndFlush</span><span class="params">(Object msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tail.writeAndFlush(msg); <span class="comment">// 注解@2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">private <span class="keyword">void</span> <span class="function"><span class="title">write</span>(<span class="params"><span class="built_in">Object</span> msg, boolean flush, ChannelPromise promise</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  	final AbstractChannelHandlerContext next = findContextOutbound(flush ?</span><br><span class="line">            (MASK_WRITE | MASK_FLUSH) : MASK_WRITE); <span class="comment">// 注解@3</span></span><br><span class="line">    final <span class="built_in">Object</span> m = pipeline.touch(msg, next);</span><br><span class="line">    EventExecutor executor = next.executor();</span><br><span class="line">    <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flush) &#123;</span><br><span class="line">            next.invokeWriteAndFlush(m, promise);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            next.invokeWrite(m, promise);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        final WriteTask task = WriteTask.newInstance(next, m, promise, flush);</span><br><span class="line">        <span class="keyword">if</span> (!safeExecute(executor, task, promise, m, !flush)) &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            task.cancel();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> AbstractChannelHandlerContext <span class="title">findContextOutbound</span><span class="params">(<span class="keyword">int</span> mask)</span> </span>&#123;</span><br><span class="line">    AbstractChannelHandlerContext ctx = <span class="keyword">this</span>;</span><br><span class="line">    EventExecutor currentExecutor = executor();</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        ctx = ctx.prev;</span><br><span class="line">    &#125; <span class="keyword">while</span> (skipContext(ctx, currentExecutor, mask, MASK_ONLY_OUTBOUND)); <span class="comment">// 注解@4</span></span><br><span class="line">    <span class="keyword">return</span> ctx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">skipContext</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        AbstractChannelHandlerContext ctx, EventExecutor currentExecutor, <span class="keyword">int</span> mask, <span class="keyword">int</span> onlyMask)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (ctx.executionMask &amp; (onlyMask | mask)) == <span class="number">0</span> ||</span><br><span class="line">            (ctx.executor() == currentExecutor &amp;&amp; (ctx.executionMask &amp; mask) == <span class="number">0</span>); <span class="comment">// 注解@5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@2</strong> 从链表尾部TailContext开始执行。</p>
<p><strong>注解@3</strong> 我们示例writeAndFlush所以findContextOutbound的mask为(MASK_WRITE | MASK_FLUSH)</p>
<p><strong>注解@4</strong> 循环链表查找，注意skipContext是判断的跳过逻辑。我们查找Outbound的ChannelHandlerContext，遇到Inbound的都会跳过。</p>
<p><strong>注解@5</strong> 判断是否跳过，这段逻辑是位操作，不好阅读。下面示例抽取各个入参的值测试下：如果下一个ChannelHandlerContext为inBound，则skipContext返回true，从而在查找outBound的do/while循环中跳过。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> executionMask =  MASK_EXCEPTION_CAUGHT |= MASK_ALL_INBOUND; <span class="comment">// inBound 身份标识</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mask = MASK_WRITE | MASK_FLUSH; <span class="comment">// writeAndFlush 标识</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> onlyMask = MASK_ONLY_OUTBOUND; <span class="comment">// outBound操作集合</span></span><br><span class="line"></span><br><span class="line">System.out.println((executionMask &amp; (onlyMask | mask))==<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">输出为：<span class="keyword">true</span></span><br></pre></td></tr></table></figure>



<p><strong>小结：</strong> outBound事件在ChannelPipeline中传递时，只会选择身份为outBound的ChannelHandlerContext执行。</p>
<h3 id="Inbound传递过程"><a href="#Inbound传递过程" class="headerlink" title="Inbound传递过程"></a>Inbound传递过程</h3><p>以上一篇文章 <a href="https://mp.weixin.qq.com/s/rcVDX0tNMhRGchjYHddARw">Netty6# Netty之事件轮询与处理</a> 当有新的客户端的连接时触发unsafe.read()执行。具体为NioMessageUnsafe#read()方法。具体为上文中<strong>注解@17</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 入口</span></span><br><span class="line">pipeline.fireChannelRead(readBuf.get(i));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">fireChannelRead</span><span class="params">(Object msg)</span> </span>&#123;</span><br><span class="line">  AbstractChannelHandlerContext.invokeChannelRead(head, msg);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeChannelRead</span><span class="params">(Object msg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (invokeHandler()) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      ((ChannelInboundHandler) handler()).channelRead(<span class="keyword">this</span>, msg);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      notifyHandlerException(t);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fireChannelRead(msg); <span class="comment">// 注解@6</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@6</strong> 下面的方法findContextInbound(MASK_CHANNEL_READ)，只查找Inbound的ChannelHandlerContext。具体逻辑与Outbound传递过程相似，不再重复。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelHandlerContext <span class="title">fireChannelRead</span><span class="params">(<span class="keyword">final</span> Object msg)</span> </span>&#123;</span><br><span class="line">    invokeChannelRead(findContextInbound(MASK_CHANNEL_READ), msg);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>小结：</strong> inBound事件在ChannelPipeline中传递时，只会选择身份为inBound的ChannelHandlerContext执行。</p>
<h1 id="ChannelPipeline重要API"><a href="#ChannelPipeline重要API" class="headerlink" title="ChannelPipeline重要API"></a>ChannelPipeline重要API</h1><p>ChannelPipeline的默认实现为DefaultChannelPipeline，以下API源码梳理均来自该实现类。</p>
<table>
<thead>
<tr>
<th>接口</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>ChannelPipeline addFirst(ChannelHandler… handlers)</td>
<td>在ChannelPipeline中，将ChannelHandlerContext添加HeadContext的后面。</td>
</tr>
<tr>
<td>ChannelPipeline addLast(ChannelHandler… handlers);</td>
<td>在ChannelPipeline中，将ChannelHandlerContext添加到TailContext的前面。</td>
</tr>
<tr>
<td>ChannelPipeline addBefore(String baseName, String name, ChannelHandler handler);</td>
<td>在ChannelPipeline中，将ChannelHandlerContext添加到某ChannelHandlerContext的前面。</td>
</tr>
<tr>
<td>ChannelPipeline addAfter(String baseName, String name, ChannelHandler handler);</td>
<td>在ChannelPipeline中，将ChannelHandlerContext添加到指定的ChannelHandlerContext的后面。</td>
</tr>
<tr>
<td>ChannelPipeline remove(ChannelHandler handler);</td>
<td>在ChannelPipeline中，将ChannelHandlerContext从链表中移除。</td>
</tr>
<tr>
<td>ChannelPipeline replace(ChannelHandler oldHandler, String newName, ChannelHandler newHandler);</td>
<td>在ChannelPipeline中，将新newCtx在链表中替换就得oldCtx。</td>
</tr>
</tbody></table>
<h3 id="addFirst"><a href="#addFirst" class="headerlink" title="addFirst"></a>addFirst</h3><p>说明：在ChannelPipeline中，将ChannelHandlerContext添加HeadContext的后面。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">addFirst</span><span class="params">(EventExecutorGroup group, String name, ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> AbstractChannelHandlerContext newCtx;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            checkMultiplicity(handler); <span class="comment">// 注解@7</span></span><br><span class="line">            name = filterName(name, handler); <span class="comment">// 注解@8</span></span><br><span class="line"></span><br><span class="line">            newCtx = newContext(group, name, handler); </span><br><span class="line"></span><br><span class="line">            addFirst0(newCtx); <span class="comment">// 注解@9</span></span><br><span class="line">						</span><br><span class="line">          	<span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        callHandlerAdded0(newCtx); <span class="comment">// 注解@10</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@7：</strong>checkMultiplicity()方法校验ChannelHandler是否重复。如果ChannelHandler中有注解@Sharable标识，则允许同一个ChannelHandler添加到不同的ChannelPipeline中。<strong>未加@Sharable注解的ChannelHandler只允许添加到一个ChannelPipeline</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkMultiplicity</span><span class="params">(ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> ChannelHandlerAdapter) &#123;</span><br><span class="line">        ChannelHandlerAdapter h = (ChannelHandlerAdapter) handler;</span><br><span class="line">        <span class="keyword">if</span> (!h.isSharable() &amp;&amp; h.added) &#123; <span class="comment">// 判断@Sharable注解和该Handler是否已经被添加</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ChannelPipelineException(</span><br><span class="line">                    h.getClass().getName() +</span><br><span class="line">                    <span class="string">&quot; is not a @Sharable handler, so can&#x27;t be added or removed multiple times.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        h.added = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@Sharable使用示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Sharable</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToMessageEncoder</span>&lt;<span class="title">CharSequence</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@8：</strong> ChannelHandler名字判断，没有设置Handler名字则自动生成一个；设置了Handler名字，不能与该ChannelPipeline其他ChannelHandler名字重复。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">filterName</span><span class="params">(String name, ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> generateName(handler); </span><br><span class="line">    &#125;</span><br><span class="line">    checkDuplicateName(name);</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@9：</strong>创建DefaultChannelHandlerContext，并加入将其加入到链表中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addFirst0</span><span class="params">(AbstractChannelHandlerContext newCtx)</span> </span>&#123;</span><br><span class="line">	AbstractChannelHandlerContext nextCtx = head.next;</span><br><span class="line">	newCtx.prev = head;</span><br><span class="line">	newCtx.next = nextCtx;</span><br><span class="line">	head.next = newCtx;</span><br><span class="line">	nextCtx.prev = newCtx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>经过上面链表的顺序调整，addFirst将ChannelHandlerContext添加到了HeadContext的后面。</strong></p>
<p><strong>注解@10</strong> ：当ChannelHandler添加ChannelPipeline后，回调该Handler的handlerAdded方法，也是通知机制的常用做法。</p>
<h3 id="addLast"><a href="#addLast" class="headerlink" title="addLast"></a>addLast</h3><p>说明：在ChannelPipeline中，将ChannelHandlerContext添加到TailContext的前面。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">addLast</span><span class="params">(EventExecutorGroup group, String name, ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AbstractChannelHandlerContext newCtx;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        checkMultiplicity(handler);</span><br><span class="line"></span><br><span class="line">        newCtx = newContext(group, filterName(name, handler), handler);</span><br><span class="line"></span><br><span class="line">        addLast0(newCtx); <span class="comment">// 注解@11</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    callHandlerAdded0(newCtx);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@11</strong>  <strong>其他逻辑同addFirst，addLast0将HandlerContext添加到TailContext的前一个位置。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addLast0</span><span class="params">(AbstractChannelHandlerContext newCtx)</span> </span>&#123;</span><br><span class="line">    AbstractChannelHandlerContext prev = tail.prev;</span><br><span class="line">    newCtx.prev = prev;</span><br><span class="line">    newCtx.next = tail;</span><br><span class="line">    prev.next = newCtx;</span><br><span class="line">    tail.prev = newCtx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>addBefore</strong></p>
<p>说明：在ChannelPipeline中，将ChannelHandlerContext添加到某ChannelHandlerContext的前面。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">addBefore</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        EventExecutorGroup group, String baseName, String name, ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AbstractChannelHandlerContext newCtx;</span><br><span class="line">    <span class="keyword">final</span> AbstractChannelHandlerContext ctx;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        checkMultiplicity(handler);</span><br><span class="line">        name = filterName(name, handler);</span><br><span class="line">        ctx = getContextOrDie(baseName); <span class="comment">// 注解@12</span></span><br><span class="line"></span><br><span class="line">        newCtx = newContext(group, name, handler); </span><br><span class="line"></span><br><span class="line">        addBefore0(ctx, newCtx); <span class="comment">// 注解@13</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    callHandlerAdded0(newCtx);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@12</strong> 根据传入的baseName在ChannelPipleline查找对应的HandlerContext。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> AbstractChannelHandlerContext <span class="title">getContextOrDie</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    AbstractChannelHandlerContext ctx = (AbstractChannelHandlerContext) context(name);</span><br><span class="line">    <span class="keyword">if</span> (ctx == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(name);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ctx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@13</strong> 添加到链表中，添加到baseName的前面。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addBefore0</span><span class="params">(AbstractChannelHandlerContext ctx, AbstractChannelHandlerContext newCtx)</span> </span>&#123;</span><br><span class="line">    newCtx.prev = ctx.prev;</span><br><span class="line">    newCtx.next = ctx;</span><br><span class="line">    ctx.prev.next = newCtx;</span><br><span class="line">    ctx.prev = newCtx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>addAfter</strong></p>
<p>说明：在ChannelPipeline中，将ChannelHandlerContext添加到指定的ChannelHandlerContext的后面。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">addAfter</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        EventExecutorGroup group, String baseName, String name, ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AbstractChannelHandlerContext newCtx;</span><br><span class="line">    <span class="keyword">final</span> AbstractChannelHandlerContext ctx;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        checkMultiplicity(handler);</span><br><span class="line">        name = filterName(name, handler);</span><br><span class="line">        ctx = getContextOrDie(baseName);</span><br><span class="line"></span><br><span class="line">        newCtx = newContext(group, name, handler);</span><br><span class="line"></span><br><span class="line">        addAfter0(ctx, newCtx); <span class="comment">// 注解@14</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    callHandlerAdded0(newCtx);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@14：</strong>调整链表顺序，调整方式同上。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addAfter0</span><span class="params">(AbstractChannelHandlerContext ctx, AbstractChannelHandlerContext newCtx)</span> </span>&#123;</span><br><span class="line">    newCtx.prev = ctx;</span><br><span class="line">    newCtx.next = ctx.next;</span><br><span class="line">    ctx.next.prev = newCtx;</span><br><span class="line">    ctx.next = newCtx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h3><p>说明：在ChannelPipeline中，将ChannelHandlerContext从链表中移除。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> AbstractChannelHandlerContext <span class="title">remove</span><span class="params">(<span class="keyword">final</span> AbstractChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> ctx != head &amp;&amp; ctx != tail; <span class="comment">// 注解@15</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        atomicRemoveFromHandlerList(ctx); <span class="comment">// 注解@16</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">    callHandlerRemoved0(ctx);</span><br><span class="line">    <span class="keyword">return</span> ctx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@15</strong> 被移除的ChannelHandlerContext不能是HeadContext和TailContext。</p>
<p><strong>注解@16</strong> 通过调整前后ChannelHandlerContext的指针指向实现移除操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">atomicRemoveFromHandlerList</span><span class="params">(AbstractChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">    AbstractChannelHandlerContext prev = ctx.prev;</span><br><span class="line">    AbstractChannelHandlerContext next = ctx.next;</span><br><span class="line">    prev.next = next;</span><br><span class="line">    next.prev = prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h3><p>说明：在ChannelPipeline中，将新newCtx在链表中替换就得oldCtx。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ChannelHandler <span class="title">replace</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> AbstractChannelHandlerContext ctx, String newName, ChannelHandler newHandler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> ctx != head &amp;&amp; ctx != tail; <span class="comment">// 注解@17</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> AbstractChannelHandlerContext newCtx;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        checkMultiplicity(newHandler);</span><br><span class="line">        <span class="keyword">if</span> (newName == <span class="keyword">null</span>) &#123;</span><br><span class="line">            newName = generateName(newHandler);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> sameName = ctx.name().equals(newName);</span><br><span class="line">            <span class="keyword">if</span> (!sameName) &#123;</span><br><span class="line">                checkDuplicateName(newName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        newCtx = newContext(ctx.executor, newName, newHandler);</span><br><span class="line">        replace0(ctx, newCtx); <span class="comment">// 注解@18</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> ctx.handler();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@17</strong> 被替换的ChannelHandlerContext不能是HeadContext和TailContext。</p>
<p><strong>注解@18</strong> 下面替换逻辑中，首先将oldCtx的前后指针暂存；newCtx前后指针指向刚才的暂存；把暂存的pre的next指向newCtx，暂存的next的prev指向newCtx，此时newCtx已经替换到了链表中；将oldCtx的prev和next都指向了newCtx，目的为了已经进入了oldCtx的数据正确流转无论是inbound还是outbound数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">replace0</span><span class="params">(AbstractChannelHandlerContext oldCtx, AbstractChannelHandlerContext newCtx)</span> </span>&#123;</span><br><span class="line">    AbstractChannelHandlerContext prev = oldCtx.prev;</span><br><span class="line">    AbstractChannelHandlerContext next = oldCtx.next;</span><br><span class="line">    newCtx.prev = prev;</span><br><span class="line">    newCtx.next = next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Finish the replacement of oldCtx with newCtx in the linked list.</span></span><br><span class="line">    <span class="comment">// Note that this doesn&#x27;t mean events will be sent to the new handler immediately</span></span><br><span class="line">    <span class="comment">// because we are currently at the event handler thread and no more than one handler methods can be invoked</span></span><br><span class="line">    <span class="comment">// at the same time (we ensured that in replace().)</span></span><br><span class="line">    prev.next = newCtx;</span><br><span class="line">    next.prev = newCtx;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// update the reference to the replacement so forward of buffered content will work correctly</span></span><br><span class="line">    oldCtx.prev = newCtx;</span><br><span class="line">    oldCtx.next = newCtx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>小结：</strong> ChannelPipeline提供了方便的API对链表中的ChannelHandlerContext进行插入、删除、添加、替换操作。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>Nacos1# 服务注册与发现客户端示例与源码解析（一）</title>
    <url>/posts/5e23f663/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>Nacos在业界注册中心的选型中举足轻重，值得去深入分析和研究。本文就注册和发现客户端的初始话逻辑从源码角度分析其做了什么事情，另外，其服务发现的设计架构可作为我们相似场景设计的模型作为参考。</p>
<h1 id="内容提要"><a href="#内容提要" class="headerlink" title="内容提要"></a>内容提要</h1><h3 id="可配置参数"><a href="#可配置参数" class="headerlink" title="可配置参数"></a>可配置参数</h3><ul>
<li>默认命名空间public，可通过System.setProperty(PropertyKeyConst.NAMESPACE, “”）设置</li>
<li>默认web根目录为/nacos/v1/ns，可通过System.setProperty(PropertyKeyConst.CONTEXT_PATH, “”）设置</li>
<li>默认日志文件名称为naming.log，可通过System.setProperty(UtilAndComs.NACOS_NAMING_LOG_NAME, “”）设置</li>
<li>支持通过动态刷新EndPoint获取server地址列表，EndPoint地址可通过properties.setProperty(PropertyKeyConst.ENDPOINT,””)设置，EndPoint刷新的频率是30秒</li>
<li>支持直接传入Server地址properties.setProperty(PropertyKeyConst.SERVER_ADD,””)</li>
</ul>
<h3 id="服务发现逻辑"><a href="#服务发现逻辑" class="headerlink" title="服务发现逻辑"></a>服务发现逻辑</h3><p>服务发现逻辑也就是当实例变更时通知给订阅者逻辑，详细逻辑如下：</p>
<ul>
<li>当我们开启订阅时subscribe时，会通过调度器生成一个UpdateTask；UpdateTask每个6秒钟（最长为1分钟）会从注册中心获取实例Instance列表，当检测到实例Instance列表有变更时会通过NotifyCenter.publishEvent发布实例变更事件</li>
<li>NotifyCenter是个门面类，对DefaultPublisher的操作，以及DefaultPublisher与关联事件的映射，例如：会绑定ChangeEvent与EventPublisher的关系；上面发布的实例变更事件实际为添加到DefaultPublisher的阻塞队列</li>
<li>DefaultPublisher中维护一个订阅者集合subscribers；DefaultPublisher中维护一个事件阻塞队列queue默认大小为16384；DefaultPublisher同时也是一个线程类初始化时通过for死循环从阻塞队列queue中获取Event，并循环回调订阅者subscribers执行该Event</li>
<li>subscribers执行Event，具体回调到InstancesChangeNotifier#onEvent，进而回调到我们订阅时提供的AbstractEventListener#onEvent，从而实现我们的发现逻辑。</li>
</ul>
<h3 id="故障转移逻辑"><a href="#故障转移逻辑" class="headerlink" title="故障转移逻辑"></a>故障转移逻辑</h3><ul>
<li>在ServiceInfoHolder初始化初始化时，会生成本地缓存目录 ${user.home}/nacos/naming</li>
<li>每10秒钟将ServiceInfo备份到缓存文件中</li>
<li>故障转移开启生效实例化延迟5秒钟会从本地文件将ServiceInfo读入缓存serviceMap</li>
<li>如果配置参数「namingLoadCacheAtStart」设置为true启动时会从本地缓存文件读取ServiceInfo信息，默认为false</li>
</ul>
<a id="more"></a>



<h1 id="注册与发现示例"><a href="#注册与发现示例" class="headerlink" title="注册与发现示例"></a>注册与发现示例</h1><p><strong>服务注册示例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerTest</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">  System.setProperty(<span class="string">&quot;serverAddr&quot;</span>, <span class="string">&quot;127.0.0.1:8848&quot;</span>);</span><br><span class="line">  System.setProperty(<span class="string">&quot;namespace&quot;</span>, <span class="string">&quot;public&quot;</span>);</span><br><span class="line"></span><br><span class="line">  Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">  properties.setProperty(<span class="string">&quot;serverAddr&quot;</span>, System.getProperty(<span class="string">&quot;serverAddr&quot;</span>));</span><br><span class="line">  properties.setProperty(<span class="string">&quot;namespace&quot;</span>, System.getProperty(<span class="string">&quot;namespace&quot;</span>));</span><br><span class="line"></span><br><span class="line">  NamingService naming = NamingFactory.createNamingService(properties);</span><br><span class="line"></span><br><span class="line">  naming.registerInstance(<span class="string">&quot;nacos.test.3&quot;</span>, <span class="string">&quot;11.11.11.11&quot;</span>, <span class="number">8888</span>, <span class="string">&quot;TEST1&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  System.out.println(naming.getAllInstances(<span class="string">&quot;nacos.test.3&quot;</span>));</span><br><span class="line"></span><br><span class="line">	System.in.read();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Instance&#123;instanceId&#x3D;&#39;null&#39;, ip&#x3D;&#39;11.11.11.11&#39;, port&#x3D;8888, weight&#x3D;1.0, healthy&#x3D;true, enabled&#x3D;true, ephemeral&#x3D;true, clusterName&#x3D;&#39;TEST1&#39;, serviceName&#x3D;&#39;DEFAULT_GROUP@@nacos.test.3&#39;, metadata&#x3D;&#123;&#125;&#125;]</span><br></pre></td></tr></table></figure>



<p><strong>服务发现示例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribeTest</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.setProperty(<span class="string">&quot;serverAddr&quot;</span>, <span class="string">&quot;127.0.0.1:8848&quot;</span>);</span><br><span class="line">        System.setProperty(<span class="string">&quot;namespace&quot;</span>, <span class="string">&quot;public&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        properties.setProperty(<span class="string">&quot;serverAddr&quot;</span>, System.getProperty(<span class="string">&quot;serverAddr&quot;</span>));</span><br><span class="line">        properties.setProperty(<span class="string">&quot;namespace&quot;</span>, System.getProperty(<span class="string">&quot;namespace&quot;</span>));</span><br><span class="line"></span><br><span class="line">        NamingService naming = NamingFactory.createNamingService(properties);</span><br><span class="line">        Executor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">            <span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">                    Thread thread = <span class="keyword">new</span> Thread(r);</span><br><span class="line">                    thread.setName(<span class="string">&quot;test-thread&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> thread;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        naming.subscribe(<span class="string">&quot;nacos.test.3&quot;</span>, <span class="keyword">new</span> AbstractEventListener() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Executor <span class="title">getExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> executor;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(Event event)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;订阅到的服务：&quot;</span> + ((NamingEvent) event).getServiceName());</span><br><span class="line">                System.out.println(<span class="string">&quot;订阅到的实例：&quot;</span> + ((NamingEvent) event).getInstances());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        System.in.read();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">订阅的服务：nacos.test.3</span><br><span class="line">订阅的实例：[Instance&#123;instanceId&#x3D;&#39;null&#39;, ip&#x3D;&#39;11.11.11.11&#39;, port&#x3D;8888, weight&#x3D;1.0, healthy&#x3D;true, enabled&#x3D;true, ephemeral&#x3D;true, clusterName&#x3D;&#39;TEST1&#39;, serviceName&#x3D;&#39;DEFAULT_GROUP@@nacos.test.3&#39;, metadata&#x3D;&#123;&#125;&#125;]</span><br></pre></td></tr></table></figure>





<h1 id="NacosNamingService初始化源码分析"><a href="#NacosNamingService初始化源码分析" class="headerlink" title="NacosNamingService初始化源码分析"></a>NacosNamingService初始化源码分析</h1><p>反射实例化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; driverImplClass = Class.forName(<span class="string">&quot;com.alibaba.nacos.client.naming.NacosNamingService&quot;</span>);</span><br><span class="line">Constructor constructor = driverImplClass.getConstructor(Properties.class);</span><br><span class="line">NamingService vendorImpl = (NamingService) constructor.newInstance(properties);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NacosNamingService</span><span class="params">(Properties properties)</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">        init(properties);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Properties properties)</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">        ValidatorUtils.checkInitParam(properties); <span class="comment">// 注解@1 </span></span><br><span class="line">  </span><br><span class="line">				<span class="keyword">this</span>.namespace = InitUtils.initNamespaceForNaming(properties); <span class="comment">// 注解@2</span></span><br><span class="line"></span><br><span class="line">        InitUtils.initSerialization();</span><br><span class="line"></span><br><span class="line">        InitUtils.initWebRootContext(properties); <span class="comment">// 注解@3</span></span><br><span class="line"></span><br><span class="line">        initLogName(properties); <span class="comment">// 注解@4</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注解@5...............................................</span></span><br><span class="line">  			<span class="keyword">this</span>.changeNotifier = <span class="keyword">new</span> InstancesChangeNotifier();</span><br><span class="line"></span><br><span class="line">        NotifyCenter.registerToPublisher(InstancesChangeEvent.class, <span class="number">16384</span>);</span><br><span class="line"></span><br><span class="line">        NotifyCenter.registerSubscriber(changeNotifier);</span><br><span class="line">  			<span class="comment">// ................................................</span></span><br><span class="line">				</span><br><span class="line">  			<span class="comment">// 注解@6</span></span><br><span class="line">        <span class="keyword">this</span>.serviceInfoHolder = <span class="keyword">new</span> ServiceInfoHolder(namespace, properties);</span><br><span class="line">  		  <span class="comment">// 注解@7</span></span><br><span class="line">        <span class="keyword">this</span>.clientProxy = <span class="keyword">new</span> NamingClientProxyDelegate(<span class="keyword">this</span>.namespace, serviceInfoHolder, properties, changeNotifier);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>代码注解：</p>
<p><strong>注解@1</strong>  校验contextPath非法字符，默认路径为/nacos</p>
<p><strong>注解@2</strong> 获取命名空间，可以通过System.setProperty和Properties设置命名空间，默认为public </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">initNamespaceForNaming</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line">        String tmpNamespace = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 阿里云上也提供注册发现产品服务，兼容云上的命名空间设置</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        String isUseCloudNamespaceParsing = properties.getProperty(PropertyKeyConst.IS_USE_CLOUD_NAMESPACE_PARSING,</span><br><span class="line">                System.getProperty(SystemPropertyKeyConst.IS_USE_CLOUD_NAMESPACE_PARSING,</span><br><span class="line">                        String.valueOf(Constants.DEFAULT_USE_CLOUD_NAMESPACE_PARSING)));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Boolean.parseBoolean(isUseCloudNamespaceParsing)) &#123;</span><br><span class="line"></span><br><span class="line">            tmpNamespace = TenantUtil.getUserTenantForAns();</span><br><span class="line">            tmpNamespace = TemplateUtils.stringEmptyAndThenExecute(tmpNamespace, <span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    String namespace = System.getProperty(SystemPropertyKeyConst.ANS_NAMESPACE);</span><br><span class="line">                    LogUtils.NAMING_LOGGER.info(<span class="string">&quot;initializer namespace from System Property :&quot;</span> + namespace);</span><br><span class="line">                    <span class="keyword">return</span> namespace;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            tmpNamespace = TemplateUtils.stringEmptyAndThenExecute(tmpNamespace, <span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    String namespace = System.getenv(PropertyKeyConst.SystemEnv.ALIBABA_ALIWARE_NAMESPACE);</span><br><span class="line">                    LogUtils.NAMING_LOGGER.info(<span class="string">&quot;initializer namespace from System Environment :&quot;</span> + namespace);</span><br><span class="line">                    <span class="keyword">return</span> namespace;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 非阿里云注册产品，使用自定义的</span></span><br><span class="line"><span class="comment">         * 获取服务启动设置的namespace</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        tmpNamespace = TemplateUtils.stringEmptyAndThenExecute(tmpNamespace, <span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                String namespace = System.getProperty(PropertyKeyConst.NAMESPACE);</span><br><span class="line">                LogUtils.NAMING_LOGGER.info(<span class="string">&quot;initializer namespace from System Property :&quot;</span> + namespace);</span><br><span class="line">                <span class="keyword">return</span> namespace;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 也可以通过properties获取namespace</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(tmpNamespace) &amp;&amp; properties != <span class="keyword">null</span>) &#123;</span><br><span class="line">            tmpNamespace = properties.getProperty(PropertyKeyConst.NAMESPACE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果System.getProperty和Properties都没有设置命名空间，使用默认的public</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        tmpNamespace = TemplateUtils.stringEmptyAndThenExecute(tmpNamespace, <span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> UtilAndComs.DEFAULT_NAMESPACE_ID;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> tmpNamespace;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@3</strong> 设置web root context，其中：</p>
<p>webContext：/nacos</p>
<p>nacosUrlBase：webContext + “/v1/ns”，默认 /nacos/v1/ns</p>
<p>nacosUrlInstance：nacosUrlBase + “/instance”，默认为 /nacos/v1/ns/instance</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initWebRootContext</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String webContext = properties.getProperty(PropertyKeyConst.CONTEXT_PATH);</span><br><span class="line">        TemplateUtils.stringNotEmptyAndThenExecute(webContext, <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                UtilAndComs.webContext = ContextPathUtil.normalizeContextPath(webContext);</span><br><span class="line">                UtilAndComs.nacosUrlBase = UtilAndComs.webContext + <span class="string">&quot;/v1/ns&quot;</span>;</span><br><span class="line">                UtilAndComs.nacosUrlInstance = UtilAndComs.nacosUrlBase + <span class="string">&quot;/instance&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 已废弃：通过-Dnacos.naming.web.context设置contextPath</span></span><br><span class="line">        initWebRootContext();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>@注解4</strong>  自定义日志名称，可以通过properties或者System中设置com.alibaba.nacos.naming.log.filename指定名称，默认为naming.log</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initLogName</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line">        logName = System.getProperty(UtilAndComs.NACOS_NAMING_LOG_NAME);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(logName)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (properties != <span class="keyword">null</span> &amp;&amp; StringUtils</span><br><span class="line">                    .isNotEmpty(properties.getProperty(UtilAndComs.NACOS_NAMING_LOG_NAME))) &#123;</span><br><span class="line">                logName = properties.getProperty(UtilAndComs.NACOS_NAMING_LOG_NAME);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                logName = <span class="string">&quot;naming.log&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><u><strong>小结：</strong> 默认为命名空间为public，可以通过<strong>System.setProperty(PropertyKeyConst.NAMESPACE, “”）</strong>和Properties设置；默认web root context为 「/nacos/v1/ns」，可以通过参数<strong>System.setProperty(PropertyKeyConst.CONTEXT_PATH, “”）</strong>设置；nacos日志文件名称默认为naming.log，可以通过参数<strong>System.setProperty(UtilAndComs.NACOS_NAMING_LOG_NAME, “”）</strong>设置。</u></p>
<p><strong>@注解5</strong>  通过NotifyCenter注册了一个Publisher和Subscriber，另起一小节。</p>
<h1 id="NotifyCenter与DefaultPublisher源码分析"><a href="#NotifyCenter与DefaultPublisher源码分析" class="headerlink" title="NotifyCenter与DefaultPublisher源码分析"></a>NotifyCenter与DefaultPublisher源码分析</h1><p><strong>NotifyCenter静态块赋值</strong> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// @注解5.1 默认为DefaultPublisher中的BlockingQueue长度</span></span><br><span class="line">        <span class="comment">// 长度默认16384，可以通过System.setProperty(&quot;nacos.core.notify.ring-buffer-size&quot;,&quot;intx&quot;)设置</span></span><br><span class="line">        String ringBufferSizeProperty = <span class="string">&quot;nacos.core.notify.ring-buffer-size&quot;</span>;</span><br><span class="line">        ringBufferSize = Integer.getInteger(ringBufferSizeProperty, <span class="number">16384</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// @注解5.2 BlockingQueue长度默认1024</span></span><br><span class="line">  		  <span class="comment">// 可以通过System.setProperty(&quot;nacos.core.notify.share-buffer-size&quot;,&quot;intx&quot;)设置</span></span><br><span class="line">        String shareBufferSizeProperty = <span class="string">&quot;nacos.core.notify.share-buffer-size&quot;</span>;</span><br><span class="line">        shareBufferSize = Integer.getInteger(shareBufferSizeProperty, <span class="number">1024</span>);</span><br><span class="line">				</span><br><span class="line">        <span class="comment">// @注解5.3 指定Class EventPublisher默认为DefaultPublisher，可以通过SPI设置</span></span><br><span class="line">  		  <span class="keyword">final</span> Collection&lt;EventPublisher&gt; publishers = NacosServiceLoader.load(EventPublisher.class);</span><br><span class="line">        Iterator&lt;EventPublisher&gt; iterator = publishers.iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (iterator.hasNext()) &#123;</span><br><span class="line">            clazz = iterator.next().getClass(); <span class="comment">// 赋值 SPI EventPublisher</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            clazz = DefaultPublisher.class; <span class="comment">// 赋值默认值</span></span><br><span class="line">        &#125;</span><br><span class="line">				</span><br><span class="line">        <span class="comment">// @注解5.4 EventPublisher初始化，默认为DefaultPublisher的初始化</span></span><br><span class="line">        publisherFactory = <span class="keyword">new</span> BiFunction&lt;Class&lt;? extends Event&gt;, Integer, EventPublisher&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> EventPublisher <span class="title">apply</span><span class="params">(Class&lt;? extends Event&gt; cls, Integer buffer)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 实例化EventPublisher（默认DefaultPublisher）</span></span><br><span class="line">                    EventPublisher publisher = clazz.newInstance();</span><br><span class="line">                    publisher.init(cls, buffer);</span><br><span class="line">                    <span class="keyword">return</span> publisher;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                    LOGGER.error(<span class="string">&quot;Service class newInstance has error : &#123;&#125;&quot;</span>, ex);</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> NacosRuntimeException(SERVER_ERROR, ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// @注解5.5 DefaultSharePublisher初始化</span></span><br><span class="line">            INSTANCE.sharePublisher = <span class="keyword">new</span> DefaultSharePublisher();</span><br><span class="line">            INSTANCE.sharePublisher.init(SlowEvent.class, shareBufferSize);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">&quot;Service class newInstance has error : &#123;&#125;&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ThreadUtils.addShutdownHook(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                shutdown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>@注解5.4</strong> DefaultPublisher的初始化，其本身继承了Thread，初始化了ArrayBlockingQueue其大小为ringBufferSize默认16384</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Class&lt;? extends Event&gt; type, <span class="keyword">int</span> bufferSize)</span> </span>&#123;</span><br><span class="line">        setDaemon(<span class="keyword">true</span>); <span class="comment">// 守护线程</span></span><br><span class="line">        setName(<span class="string">&quot;nacos.publisher-&quot;</span> + type.getName()); <span class="comment">// 设置线程名字</span></span><br><span class="line">        <span class="keyword">this</span>.eventType = type;</span><br><span class="line">        <span class="keyword">this</span>.queueMaxSize = bufferSize;</span><br><span class="line">        <span class="comment">// 阻塞队列初始化</span></span><br><span class="line">        <span class="keyword">this</span>.queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;Event&gt;(bufferSize);</span><br><span class="line">        start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看下其线程启动时在做什么事情，可以看到一个for死循环不断的从队列中取出Event，并通知订阅者Subscriber执行Event</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">openEventHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> waitTimes = <span class="number">60</span>;</span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                <span class="keyword">if</span> (shutdown || hasSubscriber() || waitTimes &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ThreadUtils.sleep(<span class="number">1000L</span>);</span><br><span class="line">                waitTimes--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                <span class="keyword">if</span> (shutdown) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">final</span> Event event = queue.take(); <span class="comment">// 从队列取出Event</span></span><br><span class="line">                receiveEvent(event);</span><br><span class="line">                UPDATER.compareAndSet(<span class="keyword">this</span>, lastEventSequence, Math.max(lastEventSequence, event.sequence()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">&quot;Event listener exception : &#123;&#125;&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">receiveEvent</span><span class="params">(Event event)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">long</span> currentEventSequence = event.sequence();</span><br><span class="line">       <span class="comment">// 通知订阅者执行Event</span></span><br><span class="line">       <span class="keyword">for</span> (Subscriber subscriber : subscribers) &#123;</span><br><span class="line">           <span class="comment">// Whether to ignore expiration events</span></span><br><span class="line">           <span class="keyword">if</span> (subscriber.ignoreExpireEvent() &amp;&amp; lastEventSequence &gt; currentEventSequence) &#123;</span><br><span class="line">               LOGGER.debug(<span class="string">&quot;[NotifyCenter] the &#123;&#125; is unacceptable to this subscriber, because had expire&quot;</span>,</span><br><span class="line">                       event.getClass());</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           notifySubscriber(subscriber, event);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifySubscriber</span><span class="params">(<span class="keyword">final</span> Subscriber subscriber, <span class="keyword">final</span> Event event)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       LOGGER.debug(<span class="string">&quot;[NotifyCenter] the &#123;&#125; will received by &#123;&#125;&quot;</span>, event, subscriber);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">final</span> Runnable job = () -&gt; subscriber.onEvent(event); <span class="comment">// 执行订阅者Event</span></span><br><span class="line">       <span class="keyword">final</span> Executor executor = subscriber.executor();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (executor != <span class="keyword">null</span>) &#123;</span><br><span class="line">           executor.execute(job);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               job.run();</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">               LOGGER.error(<span class="string">&quot;Event callback exception: &quot;</span>, e);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<p><strong>@注解5.5</strong> DefaultSharePublisher继承自DefaultPublisher，处理SlowEvent事件，处理架构与DefaultPublisher一致。</p>
<p><strong>绑定ChangeEvent与Publisher</strong> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.changeNotifier = <span class="keyword">new</span> InstancesChangeNotifier();</span><br><span class="line"></span><br><span class="line">NotifyCenter.registerToPublisher(InstancesChangeEvent.class, <span class="number">16384</span>)</span><br></pre></td></tr></table></figure>

<p>Publisher的注册过程在于建立InstancesChangeEvent.class与EventPublisher的关系。</p>
<p>默认为Map&lt;String, EventPublisher&gt; publisherMap，key为com.alibaba.nacos.client.naming.event.InstancesChangeEvent，value为DefaultPublisher实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EventPublisher <span class="title">registerToPublisher</span><span class="params">(<span class="keyword">final</span> Class&lt;? extends Event&gt; eventType, <span class="keyword">final</span> <span class="keyword">int</span> queueMaxSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ClassUtils.isAssignableFrom(SlowEvent.class, eventType)) &#123;</span><br><span class="line">            <span class="keyword">return</span> INSTANCE.sharePublisher;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// topic = com.alibaba.nacos.client.naming.event.InstancesChangeEvent</span></span><br><span class="line">        <span class="keyword">final</span> String topic = ClassUtils.getCanonicalName(eventType);</span><br><span class="line">        <span class="keyword">synchronized</span> (NotifyCenter.class) &#123;</span><br><span class="line">            <span class="comment">// MapUtils.computeIfAbsent is a unsafe method.</span></span><br><span class="line">            MapUtil.computeIfAbsent(INSTANCE.publisherMap, topic, publisherFactory, eventType, queueMaxSize);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE.publisherMap.get(topic);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>将Subscribe注册到Publisher</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.changeNotifier = <span class="keyword">new</span> InstancesChangeNotifier();</span><br><span class="line"></span><br><span class="line">NotifyCenter.registerSubscriber(changeNotifier);</span><br></pre></td></tr></table></figure>

<p>上面提到Publisher中维护了一个subscribers集合，这行代码即将InstancesChangeNotifier,添加到该集合，InstancesChangeNotifier继承了Subscriber。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addSubscriber</span><span class="params">(<span class="keyword">final</span> Subscriber consumer, Class&lt;? extends Event&gt; subscribeType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String topic = ClassUtils.getCanonicalName(subscribeType);</span><br><span class="line">   <span class="keyword">synchronized</span> (NotifyCenter.class) &#123;</span><br><span class="line">   		<span class="comment">// MapUtils.computeIfAbsent is a unsafe method.</span></span><br><span class="line">   		MapUtil.computeIfAbsent(INSTANCE.publisherMap, topic, publisherFactory, subscribeType, ringBufferSize);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 获取时间对应的Publisher</span></span><br><span class="line">   <span class="comment">// key = com.alibaba.nacos.client.naming.event.InstancesChangeEvent</span></span><br><span class="line">   <span class="comment">// value = DefaultPublisher</span></span><br><span class="line">   EventPublisher publisher = INSTANCE.publisherMap.get(topic);</span><br><span class="line">   <span class="comment">// 添加到subscribers集合</span></span><br><span class="line">   publisher.addSubscriber(consumer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><u><strong>小结：</strong> DefaultPublisher中维护一个订阅者集合subscribers；DefaultPublisher中维护一个事件阻塞队列queue默认大小为16384；DefaultPublisher同时也是一个线程类初始化时通过for死循环从阻塞队列queue中获取Event，并循环回调订阅者subscribers执行该Event；NotifyCenter是操作DefaultPublisher的门面类，会绑定ChangeEvent与EventPublisher的关系，并将InstancesChangeNotifier添加到了DefaultPublisher的subscribers集合。</u></p>
<p><strong>注解@6</strong> ServiceInfoHolder初始化，另起一小节分析</p>
<h1 id="ServiceInfoHolder初始化源码分析"><a href="#ServiceInfoHolder初始化源码分析" class="headerlink" title="ServiceInfoHolder初始化源码分析"></a>ServiceInfoHolder初始化源码分析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ServiceInfoHolder</span><span class="params">(String namespace, Properties properties)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 注解@6.1 </span></span><br><span class="line">    initCacheDir(namespace);</span><br><span class="line">    <span class="comment">// 注解@6.2</span></span><br><span class="line">    <span class="keyword">if</span> (isLoadCacheAtStart(properties)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.serviceInfoMap = <span class="keyword">new</span> ConcurrentHashMap&lt;String, ServiceInfo&gt;(DiskCache.read(<span class="keyword">this</span>.cacheDir));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.serviceInfoMap = <span class="keyword">new</span> ConcurrentHashMap&lt;String, ServiceInfo&gt;(<span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注解@6.3</span></span><br><span class="line">    <span class="keyword">this</span>.failoverReactor = <span class="keyword">new</span> FailoverReactor(<span class="keyword">this</span>, cacheDir);</span><br><span class="line">    <span class="keyword">this</span>.pushEmptyProtection = isPushEmptyProtect(properties);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>@注解6.1</strong> 生成缓存目录：默认为${user.home}/nacos/naming/public，可以通过System.setProperty(“JM.SNAPSHOT.PATH”)自定义根目录</p>
<p><strong>@注解6.2</strong> 启动时是否从缓存目录读取信息，默认false。设置为true会读取缓存文件</p>
<p><strong>@注解6.3</strong> 故障转移相关</p>
<p>故障转移目录：${user.home}/nacos/naming/public/failover</p>
<p>故障转移开关文件：${user.home}/nacos/naming/public/failover/00-00—000-VIPSRV_FAILOVER_SWITCH-000—00-00</p>
<p>故障转移关闭：当故障转移开关文件不存在时或者文件的值为0</p>
<p>故障转移开启：当故障转移开关文件存在时或者文件的值为1</p>
<p>故障转移检查：延迟5秒将缓存文件ServiceInfo信息读入缓存（由FailoverReactor#SwitchRefresher负责）</p>
<p>当故障转移开关开启，更新缓存switchParams.put(“failover-mode”, “true”)，同时启动FailoverFileReader线程读取目录failover文件ServiceInfo内容。例如：DEFAULT_GROUP%40%40nacos.test.3，这些信息被读入到内存Map&lt;String, ServiceInfo&gt; serviceMap中。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;nacos.test.3&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;groupName&quot;</span>: <span class="string">&quot;DEFAULT_GROUP&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;clusters&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;cacheMillis&quot;</span>: <span class="number">10000</span>,</span><br><span class="line">    <span class="attr">&quot;hosts&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;ip&quot;</span>: <span class="string">&quot;11.11.11.11&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;port&quot;</span>: <span class="number">8888</span>,</span><br><span class="line">            <span class="attr">&quot;weight&quot;</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">&quot;healthy&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">&quot;enabled&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">&quot;ephemeral&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">&quot;clusterName&quot;</span>: <span class="string">&quot;TEST1&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;serviceName&quot;</span>: <span class="string">&quot;DEFAULT_GROUP@@nacos.test.3&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;metadata&quot;</span>: &#123;&#125;,</span><br><span class="line">            <span class="attr">&quot;instanceHeartBeatTimeOut&quot;</span>: <span class="number">15000</span>,</span><br><span class="line">            <span class="attr">&quot;ipDeleteTimeout&quot;</span>: <span class="number">30000</span>,</span><br><span class="line">            <span class="attr">&quot;instanceIdGenerator&quot;</span>: <span class="string">&quot;simple&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;instanceHeartBeatInterval&quot;</span>: <span class="number">5000</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;lastRefTime&quot;</span>: <span class="number">1618601660155</span>,</span><br><span class="line">    <span class="attr">&quot;checksum&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;allIPs&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">&quot;reachProtectionThreshold&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">&quot;valid&quot;</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>故障数据备份：每10秒钟备份一次（FailoverReactor#DiskFileWriter），会把ServiceInfo即上面json内容备份到文件中。</p>
<p>SwitchRefresher工作过程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SwitchRefresher</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">long</span> lastModifiedMillis = <span class="number">0L</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                File switchFile = <span class="keyword">new</span> File(failoverDir + UtilAndComs.FAILOVER_SWITCH);</span><br><span class="line">                <span class="comment">// 文件不存在退出</span></span><br><span class="line">                <span class="keyword">if</span> (!switchFile.exists()) &#123;</span><br><span class="line">                    switchParams.put(<span class="string">&quot;failover-mode&quot;</span>, <span class="string">&quot;false&quot;</span>);</span><br><span class="line">                    NAMING_LOGGER.debug(<span class="string">&quot;failover switch is not found, &quot;</span> + switchFile.getName());</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">long</span> modified = switchFile.lastModified();</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (lastModifiedMillis &lt; modified) &#123;</span><br><span class="line">                    lastModifiedMillis = modified;</span><br><span class="line">                    <span class="comment">// 获取故障转移文件内容</span></span><br><span class="line">                    String failover = ConcurrentDiskUtil.getFileContent(failoverDir + UtilAndComs.FAILOVER_SWITCH,Charset.defaultCharset().toString());</span><br><span class="line">                    <span class="keyword">if</span> (!StringUtils.isEmpty(failover)) &#123;</span><br><span class="line">                        String[] lines = failover.split(DiskCache.getLineSeparator());</span><br><span class="line">                        <span class="keyword">for</span> (String line : lines) &#123;</span><br><span class="line">                            String line1 = line.trim();</span><br><span class="line">                            <span class="comment">// 1表示开启故障转移模式</span></span><br><span class="line">                            <span class="keyword">if</span> (<span class="string">&quot;1&quot;</span>.equals(line1)) &#123;</span><br><span class="line">                                switchParams.put(<span class="string">&quot;failover-mode&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">                                NAMING_LOGGER.info(<span class="string">&quot;failover-mode is on&quot;</span>);</span><br><span class="line">                                <span class="keyword">new</span> FailoverFileReader().run();</span><br><span class="line">                            <span class="comment">// 0表示关闭故障转移模式</span></span><br><span class="line">                            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;0&quot;</span>.equals(line1)) &#123;</span><br><span class="line">                                switchParams.put(<span class="string">&quot;failover-mode&quot;</span>, <span class="string">&quot;false&quot;</span>);</span><br><span class="line">                                NAMING_LOGGER.info(<span class="string">&quot;failover-mode is off&quot;</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        switchParams.put(<span class="string">&quot;failover-mode&quot;</span>, <span class="string">&quot;false&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                NAMING_LOGGER.error(<span class="string">&quot;[NA] failed to read failover switch.&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>FailoverFileReader工作过程，主要将Json内容读取缓存</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FailoverFileReader</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	 <span class="comment">// ...</span></span><br><span class="line">  String dataString = ConcurrentDiskUtil</span><br><span class="line">                               .getFileContent(file, Charset.defaultCharset().toString());</span><br><span class="line">  reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> StringReader(dataString));</span><br><span class="line">                       </span><br><span class="line">  String json;</span><br><span class="line">  <span class="keyword">if</span> ((json = reader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      dom = JacksonUtils.toObj(json, ServiceInfo.class);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      NAMING_LOGGER.error(<span class="string">&quot;[NA] error while parsing cached dom : &quot;</span> + json, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ... 读入缓存</span></span><br><span class="line">  <span class="keyword">if</span> (!CollectionUtils.isEmpty(dom.getHosts())) &#123;</span><br><span class="line">       domMap.put(dom.getKey(), dom);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (domMap.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      serviceMap = domMap;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>DiskFileWriter工作过程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DiskFileWriter</span> <span class="keyword">extends</span> <span class="title">TimerTask</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     Map&lt;String, ServiceInfo&gt; map = serviceInfoHolder.getServiceInfoMap();</span><br><span class="line">          <span class="keyword">for</span> (Map.Entry&lt;String, ServiceInfo&gt; entry : map.entrySet()) &#123;</span><br><span class="line">                ServiceInfo serviceInfo = entry.getValue();</span><br><span class="line">                <span class="keyword">if</span> (StringUtils.equals(serviceInfo.getKey(), UtilAndComs.ALL_IPS) || StringUtils</span><br><span class="line">                        .equals(serviceInfo.getName(), UtilAndComs.ENV_LIST_KEY) || StringUtils</span><br><span class="line">                        .equals(serviceInfo.getName(), <span class="string">&quot;00-00---000-ENV_CONFIGS-000---00-00&quot;</span>) || StringUtils</span><br><span class="line">                        .equals(serviceInfo.getName(), <span class="string">&quot;vipclient.properties&quot;</span>) || StringUtils</span><br><span class="line">                        .equals(serviceInfo.getName(), <span class="string">&quot;00-00---000-ALL_HOSTS-000---00-00&quot;</span>)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                DiskCache.write(serviceInfo, failoverDir);</span><br><span class="line">       	 &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将缓存内容写入磁盘文件</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ServiceInfo dom, String dir)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            makeSureCacheDirExists(dir);</span><br><span class="line"></span><br><span class="line">            File file = <span class="keyword">new</span> File(dir, dom.getKeyEncoded());</span><br><span class="line">            <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">                <span class="comment">// add another !file.exists() to avoid conflicted creating-new-file from multi-instances</span></span><br><span class="line">                <span class="keyword">if</span> (!file.createNewFile() &amp;&amp; !file.exists()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;failed to create cache file&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            StringBuilder keyContentBuffer = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">            String json = dom.getJsonFromServer();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isEmpty(json)) &#123;</span><br><span class="line">                json = JacksonUtils.toJson(dom);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            keyContentBuffer.append(json);</span><br><span class="line">					 </span><br><span class="line">            ConcurrentDiskUtil.writeFileContent(file, keyContentBuffer.toString(), Charset.defaultCharset().toString());</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            NAMING_LOGGER.error(<span class="string">&quot;[NA] failed to write cache for dom:&quot;</span> + dom.getName(), e);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><u><strong>小结：</strong> 在ServiceInfoHolder初始化初始化时，会生成本地缓存目录 ${user.home}/nacos/naming；每10秒钟将ServiceInfo备份到缓存文件中；故障转移开启生效实例化延迟5秒钟会从本地文件将ServiceInfo读入缓存serviceMap；如果配置参数「namingLoadCacheAtStart」设置为true启动时会从本地缓存文件读取ServiceInfo信息，默认为false。</u></p>
<p><strong>注解@7</strong> 注册客户端委派代理类初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NamingClientProxyDelegate</span><span class="params">(String namespace, ServiceInfoHolder serviceInfoHolder, Properties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">            InstancesChangeNotifier changeNotifier)</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">  		  <span class="comment">// @注解7.1</span></span><br><span class="line">        <span class="keyword">this</span>.serviceInfoUpdateService = <span class="keyword">new</span> ServiceInfoUpdateService(properties, serviceInfoHolder, <span class="keyword">this</span>,</span><br><span class="line">                changeNotifier);</span><br><span class="line">  			<span class="comment">// @注解7.2</span></span><br><span class="line">        <span class="keyword">this</span>.serverListManager = <span class="keyword">new</span> ServerListManager(properties);</span><br><span class="line">  		  <span class="keyword">this</span>.serviceInfoHolder = serviceInfoHolder;</span><br><span class="line">        <span class="keyword">this</span>.securityProxy = <span class="keyword">new</span> SecurityProxy(properties, NamingHttpClientManager.getInstance().getNacosRestTemplate());</span><br><span class="line">        initSecurityProxy();</span><br><span class="line">        <span class="keyword">this</span>.httpClientProxy = <span class="keyword">new</span> NamingHttpClientProxy(namespace, securityProxy, serverListManager, properties,serviceInfoHolder);</span><br><span class="line">        <span class="keyword">this</span>.grpcClientProxy = <span class="keyword">new</span> NamingGrpcClientProxy(namespace, securityProxy, serverListManager, properties,serviceInfoHolder);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@7.1</strong> ServiceInfoUpdateService初始化，另起一章分析</p>
<h1 id="ServiceInfoUpdateService初始化源码分析"><a href="#ServiceInfoUpdateService初始化源码分析" class="headerlink" title="ServiceInfoUpdateService初始化源码分析"></a>ServiceInfoUpdateService初始化源码分析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ServiceInfoUpdateService</span><span class="params">(Properties properties, ServiceInfoHolder serviceInfoHolder,</span></span></span><br><span class="line"><span class="function"><span class="params">            NamingClientProxy namingClientProxy, InstancesChangeNotifier changeNotifier)</span> </span>&#123;</span><br><span class="line">  			<span class="comment">// @注解7.1.1</span></span><br><span class="line">  			<span class="keyword">this</span>.executor = <span class="keyword">new</span> ScheduledThreadPoolExecutor(initPollingThreadCount(properties),</span><br><span class="line">                <span class="keyword">new</span> NameThreadFactory(<span class="string">&quot;com.alibaba.nacos.client.naming.updater&quot;</span>));</span><br><span class="line">        <span class="keyword">this</span>.serviceInfoHolder = serviceInfoHolder;</span><br><span class="line">        <span class="keyword">this</span>.namingClientProxy = namingClientProxy;</span><br><span class="line">        <span class="keyword">this</span>.changeNotifier = changeNotifier;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@7.1.1</strong>  定时任务调度执行器，线程池大小为处理器核数的一半，可以通过参数”namingPollingThreadCount”指定</p>
<p>职责：调度器用于执行UpdateTask，延迟1秒执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">synchronized</span> ScheduledFuture&lt;?&gt; addTask(UpdateTask task) &#123;</span><br><span class="line">        <span class="keyword">return</span> executor.schedule(task, DEFAULT_DELAY, TimeUnit.MILLISECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UpdateTask执行逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> delayTime = DEFAULT_DELAY;   </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 判断该注册的Service是否被订阅，如果没有订阅则不再执行</span></span><br><span class="line">      <span class="keyword">if</span> (!changeNotifier.isSubscribed(groupName, serviceName, clusters) &amp;&amp; !futureMap.containsKey(serviceKey)) 			&#123;</span><br><span class="line">        NAMING_LOGGER.info(<span class="string">&quot;update task is stopped, service:&quot;</span> + groupedServiceName + <span class="string">&quot;, clusters:&quot;</span> + clusters);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 获取缓存的service信息          </span></span><br><span class="line">      ServiceInfo serviceObj = serviceInfoHolder.getServiceInfoMap().get(serviceKey);</span><br><span class="line">      <span class="keyword">if</span> (serviceObj == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 根据serviceName从注册中心服务端获取Service信息</span></span><br><span class="line">        serviceObj = namingClientProxy.queryInstancesOfService(serviceName, groupName, clusters, <span class="number">0</span>, <span class="keyword">false</span>);</span><br><span class="line">        serviceInfoHolder.processServiceInfo(serviceObj);</span><br><span class="line">        lastRefTime = serviceObj.getLastRefTime();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">			<span class="comment">// 过期服务（服务的最新更新时间小于等于缓存刷新时间），从注册中心重新查询</span></span><br><span class="line">      <span class="keyword">if</span> (serviceObj.getLastRefTime() &lt;= lastRefTime) &#123;</span><br><span class="line">        serviceObj = namingClientProxy.queryInstancesOfService(serviceName, groupName, clusters, <span class="number">0</span>, <span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 处理Service消息</span></span><br><span class="line">        serviceInfoHolder.processServiceInfo(serviceObj);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 刷新更新时间</span></span><br><span class="line">      lastRefTime = serviceObj.getLastRefTime();</span><br><span class="line">      <span class="keyword">if</span> (CollectionUtils.isEmpty(serviceObj.getHosts())) &#123;</span><br><span class="line">        incFailCount();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 下次更新缓存时间设置，默认为6秒</span></span><br><span class="line">      delayTime = serviceObj.getCacheMillis() * DEFAULT_UPDATE_CACHE_TIME_MULTIPLE;</span><br><span class="line">      <span class="comment">// 重置失败数量为0</span></span><br><span class="line">      resetFailCount();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">      incFailCount();</span><br><span class="line">      NAMING_LOGGER.warn(<span class="string">&quot;[NA] failed to update serviceName: &quot;</span> + groupedServiceName, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// 下次调度刷新时间，下次执行的时间与failCount有关</span></span><br><span class="line">      <span class="comment">// failCount=0，则下次调度时间为6秒，最长为1分钟</span></span><br><span class="line">      <span class="comment">// 即当无异常情况下缓存实例的刷新时间是6秒</span></span><br><span class="line">      executor.schedule(<span class="keyword">this</span>, Math.min(delayTime &lt;&lt; failCount, DEFAULT_DELAY * <span class="number">60</span>), TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>备注：</strong> UpdateTask主要逻辑为如果服务缓存刷新时间过期，则会从注册中心查询最新服务信息，同时刷新缓存更新时间。并定时调度去更新服务注册信息，更新的频率最小为6秒，最长为1分钟。当更新无异常时更新频率为6秒，当发生异常时最长频率为1分钟。</p>
<p>另外如果过期还会调用serviceInfoHolder#processServiceInfo处理服务信息，下面看下其执行逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ServiceInfo <span class="title">processServiceInfo</span><span class="params">(ServiceInfo serviceInfo)</span> </span>&#123;</span><br><span class="line">        String serviceKey = serviceInfo.getKey();</span><br><span class="line">        <span class="keyword">if</span> (serviceKey == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ServiceInfo oldService = serviceInfoMap.get(serviceInfo.getKey());</span><br><span class="line">        <span class="keyword">if</span> (isEmptyOrErrorPush(serviceInfo)) &#123;</span><br><span class="line">            <span class="comment">//empty or error push, just ignore</span></span><br><span class="line">            <span class="keyword">return</span> oldService;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 缓存服务信息</span></span><br><span class="line">        serviceInfoMap.put(serviceInfo.getKey(), serviceInfo);</span><br><span class="line">        <span class="comment">// 判断注册的实例信息是否已变更</span></span><br><span class="line">        <span class="keyword">boolean</span> changed = isChangedServiceInfo(oldService, serviceInfo);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(serviceInfo.getJsonFromServer())) &#123;</span><br><span class="line">            serviceInfo.setJsonFromServer(JacksonUtils.toJson(serviceInfo));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 通过prometheus-simpleclient监控服务缓存Map的大小</span></span><br><span class="line">        MetricsMonitor.getServiceInfoMapSizeMonitor().set(serviceInfoMap.size());</span><br><span class="line">        <span class="comment">// 服务实例已变更</span></span><br><span class="line">        <span class="keyword">if</span> (changed) &#123;</span><br><span class="line">            NAMING_LOGGER.info(<span class="string">&quot;current ips:(&quot;</span> + serviceInfo.ipCount() + <span class="string">&quot;) service: &quot;</span> + serviceInfo.getKey() + <span class="string">&quot; -&gt; &quot;</span></span><br><span class="line">                    + JacksonUtils.toJson(serviceInfo.getHosts()));</span><br><span class="line">            <span class="comment">// 添加实例变更事件，会被推动到订阅者执行</span></span><br><span class="line">            NotifyCenter.publishEvent(<span class="keyword">new</span> InstancesChangeEvent(serviceInfo.getName(), serviceInfo.getGroupName(),</span><br><span class="line">                    serviceInfo.getClusters(), serviceInfo.getHosts()));</span><br><span class="line">            <span class="comment">// 记录Service本地文件</span></span><br><span class="line">            DiskCache.write(serviceInfo, cacheDir);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> serviceInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>备注：</strong> 服务实例信息会被缓存在serviceInfoMap中，key为「goupName@@ServiceName」例如：DEFAULT_GROUP@@nacos.test.3；serviceInfoMap的大小会通过prometheus simpleclient统计监控；如果服务信息有更新，会通过 NotifyCenter.publishEvent发布实例变更事件，订阅该服务的的订阅者Subscribes将会处理该事件；将缓存服务信息保存到本地文件容灾。</p>
<p>下面看下如何判断服务实例信息变更的：实例信息修改、删除、新增均属于实例变更。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isChangedServiceInfo</span><span class="params">(ServiceInfo oldService, ServiceInfo newService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == oldService) &#123;</span><br><span class="line">            NAMING_LOGGER.info(<span class="string">&quot;init new ips(&quot;</span> + newService.ipCount() + <span class="string">&quot;) service: &quot;</span> + newService.getKey() + <span class="string">&quot; -&gt; &quot;</span></span><br><span class="line">                    + JacksonUtils.toJson(newService.getHosts()));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (oldService.getLastRefTime() &gt; newService.getLastRefTime()) &#123;</span><br><span class="line">            NAMING_LOGGER</span><br><span class="line">                    .warn(<span class="string">&quot;out of date data received, old-t: &quot;</span> + oldService.getLastRefTime() + <span class="string">&quot;, new-t: &quot;</span> + newService</span><br><span class="line">                            .getLastRefTime());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> changed = <span class="keyword">false</span>;</span><br><span class="line">        Map&lt;String, Instance&gt; oldHostMap = <span class="keyword">new</span> HashMap&lt;String, Instance&gt;(oldService.getHosts().size());</span><br><span class="line">        <span class="keyword">for</span> (Instance host : oldService.getHosts()) &#123;</span><br><span class="line">            oldHostMap.put(host.toInetAddr(), host);</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;String, Instance&gt; newHostMap = <span class="keyword">new</span> HashMap&lt;String, Instance&gt;(newService.getHosts().size());</span><br><span class="line">        <span class="keyword">for</span> (Instance host : newService.getHosts()) &#123;</span><br><span class="line">            newHostMap.put(host.toInetAddr(), host);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 变更的实例集合</span></span><br><span class="line">        Set&lt;Instance&gt; modHosts = <span class="keyword">new</span> HashSet&lt;Instance&gt;();</span><br><span class="line">        <span class="comment">// 新增的实例集合</span></span><br><span class="line">        Set&lt;Instance&gt; newHosts = <span class="keyword">new</span> HashSet&lt;Instance&gt;();</span><br><span class="line">        <span class="comment">// 删除的实例集合</span></span><br><span class="line">        Set&lt;Instance&gt; remvHosts = <span class="keyword">new</span> HashSet&lt;Instance&gt;();</span><br><span class="line"></span><br><span class="line">        List&lt;Map.Entry&lt;String, Instance&gt;&gt; newServiceHosts = <span class="keyword">new</span> ArrayList&lt;Map.Entry&lt;String, Instance&gt;&gt;(</span><br><span class="line">                newHostMap.entrySet());</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Instance&gt; entry : newServiceHosts) &#123;</span><br><span class="line">            Instance host = entry.getValue();</span><br><span class="line">            String key = entry.getKey();</span><br><span class="line">            <span class="keyword">if</span> (oldHostMap.containsKey(key) &amp;&amp; !StringUtils.equals(host.toString(), oldHostMap.get(key).toString())) &#123;</span><br><span class="line">                modHosts.add(host);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!oldHostMap.containsKey(key)) &#123;</span><br><span class="line">                newHosts.add(host);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Instance&gt; entry : oldHostMap.entrySet()) &#123;</span><br><span class="line">            Instance host = entry.getValue();</span><br><span class="line">            String key = entry.getKey();</span><br><span class="line">            <span class="keyword">if</span> (newHostMap.containsKey(key)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!newHostMap.containsKey(key)) &#123;</span><br><span class="line">                remvHosts.add(host);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (newHosts.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            changed = <span class="keyword">true</span>;</span><br><span class="line">            NAMING_LOGGER</span><br><span class="line">                    .info(<span class="string">&quot;new ips(&quot;</span> + newHosts.size() + <span class="string">&quot;) service: &quot;</span> + newService.getKey() + <span class="string">&quot; -&gt; &quot;</span> + JacksonUtils</span><br><span class="line">                            .toJson(newHosts));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (remvHosts.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            changed = <span class="keyword">true</span>;</span><br><span class="line">            NAMING_LOGGER.info(<span class="string">&quot;removed ips(&quot;</span> + remvHosts.size() + <span class="string">&quot;) service: &quot;</span> + newService.getKey() + <span class="string">&quot; -&gt; &quot;</span></span><br><span class="line">                    + JacksonUtils.toJson(remvHosts));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (modHosts.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            changed = <span class="keyword">true</span>;</span><br><span class="line">            NAMING_LOGGER.info(<span class="string">&quot;modified ips(&quot;</span> + modHosts.size() + <span class="string">&quot;) service: &quot;</span> + newService.getKey() + <span class="string">&quot; -&gt; &quot;</span></span><br><span class="line">                    + JacksonUtils.toJson(modHosts));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> changed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>接着看下UpdateTask是什么时候被加入的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleUpdateIfAbsent</span><span class="params">(String serviceName, String groupName, String clusters)</span> </span>&#123;</span><br><span class="line">        String serviceKey = ServiceInfo.getKey(NamingUtils.getGroupedName(serviceName, groupName), clusters);</span><br><span class="line">        <span class="keyword">if</span> (futureMap.get(serviceKey) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (futureMap) &#123;</span><br><span class="line">            <span class="keyword">if</span> (futureMap.get(serviceKey) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">						<span class="comment">// 构建UpdateTask</span></span><br><span class="line">            ScheduledFuture&lt;?&gt; future = addTask(<span class="keyword">new</span> UpdateTask(serviceName, groupName, clusters));</span><br><span class="line">            futureMap.put(serviceKey, future);</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServiceInfo <span class="title">subscribe</span><span class="params">(String serviceName, String groupName, String clusters)</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">    String serviceNameWithGroup = NamingUtils.getGroupedName(serviceName, groupName);</span><br><span class="line">    String serviceKey = ServiceInfo.getKey(serviceNameWithGroup, clusters);</span><br><span class="line">    ServiceInfo result = serviceInfoHolder.getServiceInfoMap().get(serviceKey);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == result) &#123;</span><br><span class="line">    	result = grpcClientProxy.subscribe(serviceName, groupName, clusters);</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">// 定时调度UpdateTask</span></span><br><span class="line">    serviceInfoUpdateService.scheduleUpdateIfAbsent(serviceName, groupName, clusters);</span><br><span class="line">    serviceInfoHolder.processServiceInfo(result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>备注：</strong> 也就是在我们开启订阅subscribe时就会生成一个UpdateTask被调度。</p>
<p>实例列表变更时会生成实例变更事件并通知订阅者执行，下面看下Subscribe是如何执行该事件的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">naming.subscribe(<span class="string">&quot;nacos.test.3&quot;</span>, <span class="keyword">new</span> AbstractEventListener() &#123;</span><br><span class="line">				 <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> Executor <span class="title">getExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               <span class="keyword">return</span> executor;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(Event event)</span> </span>&#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;订阅到的1：&quot;</span> + ((NamingEvent) event).getServiceName());</span><br><span class="line">               System.out.println(<span class="string">&quot;订阅到的2：&quot;</span> + ((NamingEvent) event).getInstances());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerListener</span><span class="params">(String groupName, String serviceName, String clusters, EventListener listener)</span> </span>&#123;</span><br><span class="line">        String key = ServiceInfo.getKey(NamingUtils.getGroupedName(serviceName, groupName), clusters);</span><br><span class="line">        ConcurrentHashSet&lt;EventListener&gt; eventListeners = listenerMap.get(key);</span><br><span class="line">        <span class="keyword">if</span> (eventListeners == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                eventListeners = listenerMap.get(key);</span><br><span class="line">                <span class="keyword">if</span> (eventListeners == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    eventListeners = <span class="keyword">new</span> ConcurrentHashSet&lt;EventListener&gt;();</span><br><span class="line">                    listenerMap.put(key, eventListeners); <span class="comment">// 将EventListener缓存到listenerMap</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        eventListeners.add(listener);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>备注：</strong> 示例中传入了AbstractEventListener，同时将该EventListener缓存到listenerMap，key为「goupName@@ServiceName」例如：DEFAULT_GROUP@@nacos.test.3。</p>
<p>变更事件会通知到Subcribes，具体由InstancesChangeNotifier#onEvent执行，具体为使用示例中的getExecutor()执行Event。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(InstancesChangeEvent event)</span> </span>&#123;</span><br><span class="line">        String key = ServiceInfo</span><br><span class="line">                .getKey(NamingUtils.getGroupedName(event.getServiceName(), event.getGroupName()), event.getClusters());</span><br><span class="line">        ConcurrentHashSet&lt;EventListener&gt; eventListeners = listenerMap.get(key);</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(eventListeners)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">final</span> EventListener listener : eventListeners) &#123;</span><br><span class="line">            <span class="keyword">final</span> com.alibaba.nacos.api.naming.listener.Event namingEvent = transferToNamingEvent(event);</span><br><span class="line">            <span class="keyword">if</span> (listener <span class="keyword">instanceof</span> AbstractEventListener &amp;&amp; ((AbstractEventListener) listener).getExecutor() != <span class="keyword">null</span>) &#123;</span><br><span class="line">              	<span class="comment">// 调用AbstractEventListener的线程执行该Evnet</span></span><br><span class="line">                ((AbstractEventListener) listener).getExecutor().execute(() -&gt; listener.onEvent(namingEvent));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                listener.onEvent(namingEvent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><u><strong>小结：</strong> 当我们开启订阅时subscribe时，会通过调度器生成一个UpdateTask；UpdateTask每个6秒钟（最长为1分钟）会从注册中心获取实例Instance列表，如果有变更会通过NotifyCenter.publishEvent发布实例变更事件，相关订阅者Subscribe执行该事件，也就是回调到了我们自己的onEvent方法中；另外serviceInfoMap大小通过prometheus simpleclient暴露监控指标</u></p>
<h1 id="ServerListManager-初始化"><a href="#ServerListManager-初始化" class="headerlink" title="ServerListManager 初始化"></a>ServerListManager 初始化</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NamingClientProxyDelegate</span><span class="params">(String namespace, ServiceInfoHolder serviceInfoHolder, Properties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">            InstancesChangeNotifier changeNotifier)</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">  		  <span class="comment">// @注解7.1</span></span><br><span class="line">        <span class="keyword">this</span>.serviceInfoUpdateService = <span class="keyword">new</span> ServiceInfoUpdateService(properties, serviceInfoHolder, <span class="keyword">this</span>,</span><br><span class="line">                changeNotifier);</span><br><span class="line">  			<span class="comment">// @注解7.2</span></span><br><span class="line">        <span class="keyword">this</span>.serverListManager = <span class="keyword">new</span> ServerListManager(properties);</span><br><span class="line">  		  <span class="keyword">this</span>.serviceInfoHolder = serviceInfoHolder;</span><br><span class="line">  			<span class="comment">// @注解7.3</span></span><br><span class="line">        <span class="keyword">this</span>.securityProxy = <span class="keyword">new</span> SecurityProxy(properties, NamingHttpClientManager.getInstance().getNacosRestTemplate());</span><br><span class="line">        initSecurityProxy();</span><br><span class="line">        <span class="keyword">this</span>.httpClientProxy = <span class="keyword">new</span> NamingHttpClientProxy(namespace, securityProxy, serverListManager, properties,serviceInfoHolder);</span><br><span class="line">        <span class="keyword">this</span>.grpcClientProxy = <span class="keyword">new</span> NamingGrpcClientProxy(namespace, securityProxy, serverListManager, properties,serviceInfoHolder);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>@注解7.2:</strong> 东西有点多，接着来ServerListManager初始化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ServerListManager</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line">        initServerAddr(properties); <span class="comment">// 获取Nocas Server地址</span></span><br><span class="line">        <span class="keyword">if</span> (!serverList.isEmpty()) &#123;</span><br><span class="line">            currentIndex.set(<span class="keyword">new</span> Random().nextInt(serverList.size())); <span class="comment">// @注解7.2.2</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initServerAddr</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line">  		  <span class="comment">// 注解@7.2.1</span></span><br><span class="line">        <span class="keyword">this</span>.endpoint = InitUtils.initEndpoint(properties);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotEmpty(endpoint)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.serversFromEndpoint = getServerListFromEndpoint();</span><br><span class="line">          	<span class="comment">// 每30秒刷新server地址</span></span><br><span class="line">            refreshServerListExecutor = <span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">1</span>,</span><br><span class="line">                    <span class="keyword">new</span> NameThreadFactory(<span class="string">&quot;com.alibaba.nacos.client.naming.server.list.refresher&quot;</span>));</span><br><span class="line">            refreshServerListExecutor</span><br><span class="line">                    .scheduleWithFixedDelay(<span class="keyword">this</span>::refreshServerListIfNeed, <span class="number">0</span>, refreshServerListInternal,</span><br><span class="line">                            TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          	<span class="comment">// 直接将Nacos Server地址传入</span></span><br><span class="line">            String serverListFromProps = properties.getProperty(PropertyKeyConst.SERVER_ADDR);</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isNotEmpty(serverListFromProps)) &#123;</span><br><span class="line">                <span class="keyword">this</span>.serverList.addAll(Arrays.asList(serverListFromProps.split(<span class="string">&quot;,&quot;</span>)));</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.serverList.size() == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.nacosDomain = serverListFromProps;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@7.2.1</strong>  可配置固定Endpoint的方式获取Nacos Server地址，可以通过properties.setProperty(PropertyKeyConst.ENDPOINT,””)来设置。Endpoint可以是一个服务的域名，client每隔30秒会向「http://“ + endpoint + “/nacos/serverlist」发送请求获取server list并更新列表。除了配置Endpoint外，可以通过properties.setProperty(PropertyKeyConst.SERVER_ADD,””)将nacos server地址传入到客户端。</p>
<p><strong>@注解7.2.2</strong> 客户端会随机选择nacos server的一个地址</p>
<p><u><strong>小结：</strong> 在获取Nacos Server地址列表时，支持直接传入properties.setProperty(PropertyKeyConst.SERVER_ADD,””)和通过动态刷新EndPoint来更新，刷新频率为30秒。</u></p>
<p><strong>@注解7.3</strong> 安全代理SecurityProxy初始化，解析用户名和密码，并登陆每台server获取token；这块先不做深入分析</p>
<p>得，本文有点长了，剩下两个初始化，NamingHttpClientProxy和NamingGrpcClientProxy下篇接着撸。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>Nacos</category>
      </categories>
      <tags>
        <tag>Nacos</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/posts/0/</url>
    <content><![CDATA[<div id="vip-container"><hr>
<p>title:Q1# 问题整理20210529<br>categories:Questions<br>tags:Questions<br>date:2021-05-29 11:55:01</p>
<hr>
<p>业务要发展，功能要增强，基础设施要完善，变更就无法避免，带来新功能的同时也带来了风险。整理下近期碰到的和被问的几个问题。</p>
<h1 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h1><p>​        Zookeeper几乎每年都能听到有公司踩到坑，故事往往是这样：@1 多个业务线共用zk集群，某个新上的功能把zk当缓存用，大量创建zk路径，造成zk不堪重负瘫痪；@2 某个新上的功能往zk集群中写入过大消息，单条消息好几兆，造成zk集群性能下降，甚至带宽、磁盘被打满。</p>
<p>​        知道可能的坑咱肯定不能再去踩了，重要中间件的独立zk集群彻底隔离，上面的问题基本可以避免。今天的故事却发生在watch的数量上。</p>
<p><strong>现象</strong> </p>
<p>​        从4月中旬左右发现zk的watch水位在翻倍增长，从200多万到400多万一直翻到800多万，一直到五一之后的12000万。watch水位的升高会影响与zk通信的延迟。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210529114757.png"></p>
<p><strong>原因</strong> </p>
<p>​    SDK中有使用一个公共主题用于客户端行为收集，该主题下会被注册临时节点，临时节点会被watch用于一个特定功能。在卡点升级过程中随着服务应用的接入，注册的节点越来越多。例如：3000个临时节点每个节点都会有3000个watch数量，就会有3000的平方个watch数量，就是900万个watch数量</p>
<p><strong>解决</strong> </p>
<p>​    止血方案： 删除公共主题下的临时节点，watch数量水位恢复正常</p>
<p>​    根除方案：剔除SDK中对注册节点的watch，例如：curator中用NodeCacheListener替代TreeCacheListener，同时移除关联节点的wath功能，或者对公共主题进行过滤，不再注册节点</p>
<a id="more"></a>



<h1 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h1><p><strong>问：</strong> Sentinel的集群限流有预热功能吗？</p>
<p><strong>答：</strong> 预热适用于单机限流。</p>
<p><strong>源码</strong> </p>
<p>这个问题先从源码角度看看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPassCheck</span><span class="params">(<span class="comment">/*@NonNull*/</span> FlowRule rule, Context context, DefaultNode node, <span class="keyword">int</span> acquireCount,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                    <span class="keyword">boolean</span> prioritized)</span> </span>&#123;</span><br><span class="line">        String limitApp = rule.getLimitApp();</span><br><span class="line">        <span class="keyword">if</span> (limitApp == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rule.isClusterMode()) &#123; <span class="comment">// 注解@1 集群限流逻辑</span></span><br><span class="line">            <span class="keyword">return</span> passClusterCheck(rule, context, node, acquireCount, prioritized);</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">				<span class="comment">// 注解@2 单机限流逻辑</span></span><br><span class="line">        <span class="keyword">return</span> passLocalCheck(rule, context, node, acquireCount, prioritized);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>备注：集群限流逻辑：会向token server请求token，如果获取token则放行否则拒绝，没有预热相关逻辑。</p>
<p>下面接着看单机限流：单机限流会有不同类型限流效果的选择，因此预热只有单机限流才存在。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210529181440.png"></p>
<h1 id="问题三"><a href="#问题三" class="headerlink" title="问题三"></a>问题三</h1><p><strong>问：</strong> RocketMQ默认消费重试多少次？可以自定义设置吗？</p>
<p><strong>答：</strong> 默认消费16次，可以自定义设置消费次数，通过DefaultMQPullConsumer#setMaxReconsumeTimes设置</p>
<p><strong>源码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> maxReconsumeTimes = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注解@1 DefaultMQPullConsumer#setMaxReconsumeTimes</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMaxReconsumeTimes</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> maxReconsumeTimes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxReconsumeTimes = maxReconsumeTimes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="问题四"><a href="#问题四" class="headerlink" title="问题四"></a>问题四</h1><p><strong>问：</strong>RocketMQ发送重试次数可以设置吗？</p>
<p><strong>答：</strong> 可以的，默认2次重试算上第1次共3次。可以自定义设置重试次数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认次数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> retryTimesWhenSendFailed = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 同步发送重试次数</span></span><br><span class="line">producer.setRetryTimesWhenSendFailed();</span><br><span class="line"><span class="comment">// 异步发送重试次数</span></span><br><span class="line">producer.setRetryTimesWhenSendAsyncFailed();</span><br></pre></td></tr></table></figure>













































</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
  </entry>
</search>
