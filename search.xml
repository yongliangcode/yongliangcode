<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>FA1# 微服务流控防护场景与应对措施</title>
    <url>/posts/9bf5e4df/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>微服务成了互联网架构的标配模式，对微服务之间的调用的流量治理和管控就尤为重要。哪些场景需要流量防控，针对这些场景又有哪些应对措施。有没有一个通用的措施来降低风险呢？这篇文章咱就聊聊这个。</p>
<a id="more"></a>





<h1 id="服务被过载调用"><a href="#服务被过载调用" class="headerlink" title="服务被过载调用"></a>服务被过载调用</h1><p>当服务D的某个接口服务被上游服务过载调用时，如果不对服务D加入保护，可能整体将服务D整体拖垮。在这种场景中，我们需要对服务D配置限流，以保护服务D不被整体冲跨。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%99%90%E6%B5%81.png"></p>
<p><strong>应对措施：</strong> 针对服务提供方D配置流量防护规则，对进入服务D的流量进行控制，从而对服务D提供保护。触发流控时可以有多重策略，例如：快速失败、预热模式、排队等待、预热模式+排队等待。</p>
<p><strong>快速失败：</strong> 发生流控时直接抛出异常。</p>
<p><strong>预热模式：</strong> 发生流控时，流量缓慢增加的一种模式，效果如下图所示，流量QPS从200缓慢增加到600。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210109141101.png"></p>
<p><strong>排队等待：</strong> 请求匀速通过，过多请求需要排队，此时排队有超时时间，超过排队时间抛出流控异常。效果如下图所示：请求QPS保持1000的匀速通过。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210109141720.png"></p>
<p><strong>预热模式+排队等待：</strong> 这种模式是预热和排队等待的叠加模式，请求以匀速的方式缓慢增加。如下图：请求从0缓慢增加到500，匀速通过一段时间后，再增加到1000。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210109142131.png"></p>
<h1 id="服务慢调用或故障"><a href="#服务慢调用或故障" class="headerlink" title="服务慢调用或故障"></a>服务慢调用或故障</h1><p>下面的场景A调用B、A调用C、A调用D，当服务B服务不稳定时，服务A调用服务B发生了慢调用或者大量异常错误。这种场景，如果不干预，可能影响到A调用C和A调用D的状况。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/%E7%86%94%E6%96%AD%E9%99%8D%E7%BA%A7.png"></p>
<p><strong>应对措施：</strong> A调用B配置熔断降级规则，当服务B不稳定发生慢调用或者异常时，如果触发阈值，将服务B的调用熔断；从而保护了服务A调用C、服务A调用D的正常情况。</p>
<p><strong>熔断效果：</strong> 熔断的实现通常通过断路器实现，具体过程为：</p>
<ul>
<li>当满足慢调用比例、异常比例、异常数量阈值后，触发熔断（OPEN），在熔断时长内拒绝所有请求</li>
<li>当熔断过了定义的熔断时长，状态由熔断（OPEN）变为探测（HALF_OPEN）</li>
<li>接下来的一个请求不发生慢调用或者异常，熔断结束由探测状态（HALF_OPEN）变为（CLOSED）</li>
<li>接下来的一个请求发生慢调用或者异常，继续熔断，由探测状态（HALF_OPEN）变为（OPEN）</li>
</ul>
<h1 id="服务资源被挤占"><a href="#服务资源被挤占" class="headerlink" title="服务资源被挤占"></a>服务资源被挤占</h1><p>分布式链路中，如果某一条链路产生慢调用，对其他链路造成挤压。除了上面提到配置熔断降级外，可以通过线程并发控制来隔离。</p>
<p>下图中有3条链路，其中链路1由于服务E的不稳定，产生了慢调用。</p>
<table>
<thead>
<tr>
<th>链路标号</th>
<th>调用链</th>
</tr>
</thead>
<tbody><tr>
<td>链路1</td>
<td>服务A–&gt;服务D#Method1–&gt;服务E</td>
</tr>
<tr>
<td>链路2</td>
<td>服务B–&gt;服务D#Method2–&gt;服务F</td>
</tr>
<tr>
<td>链路3</td>
<td>服务C–&gt;服务D#Method2–&gt;服务G</td>
</tr>
</tbody></table>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E9%87%8D%E7%94%BB%20(1).png"></p>
<p>链路1慢调用可能导致如下情况：</p>
<ul>
<li>链路1线程数增多对服务D资源造成挤压</li>
<li>对服务D资源的过度挤压，链路2和链路3造成不稳定</li>
<li>极端情况导致整个服务D不可用，严重时引发雪崩</li>
</ul>
<p><strong>应对措施：</strong> 通过对服务D的MethodA1、MethodA2的线程数并发设置规则，超过阈值时将会触发阻断，不再向下游调用，避免不可用引发雪崩。</p>
<p><strong>并发控制效果</strong> 下图中设置了调用方的并发线程数为10，通过每分钟的查询可以看出，线程数一直保持在10。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210109150939.png"></p>
<h1 id="数据过热挤占资源"><a href="#数据过热挤占资源" class="headerlink" title="数据过热挤占资源"></a>数据过热挤占资源</h1><p>热点数据，比如：大促时的热销产品、秒杀类产品等。如下图所示，如果不对热点商品下单流量进行管控，可能对其他商品造成挤压；影响整个商品下单体验。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/%E7%83%AD%E7%82%B9%E5%8F%82%E6%95%B0.png"></p>
<p><strong>应对措施：</strong> 通过对热点参数测速，配置流控规则，超过阈值时触发流控。例如：通过对入参产品ID进行测速，超过设置的阈值时，触发流控，避免对其过度挤占资源。</p>
<h1 id="通用防护分组措施"><a href="#通用防护分组措施" class="headerlink" title="通用防护分组措施"></a>通用防护分组措施</h1><p>上面的现象中，无论是服务不稳定、还是被挤占、或者被过载调用。除了通过上述的防护措施外，可以对服务进行等级划分并分组。</p>
<p>如下图所示：服务A和服务D为核心服务、服务B和服务C为非核心服务。通过将服务D进行分组，分成了1组和2组。分组1只允许核心服务调用，分组2只允许非核心服务调用。</p>
<p>这样做的好处：将流量进行物理隔离，避免由于非核心业务流量对核心业务流量造成挤压、保护核心链路稳定性。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/%E5%88%86%E7%BB%84%E6%8E%AA%E6%96%BD.png"></p>
<p><strong>分组措施@1</strong>  通常可以更换注册中心路径实现，服务A和服务D（分组1）放在同一个注册中心路径（例如：soa-group1）；服务B、服务C、服务D（分组2）放在另一个不同的注册中心路径（例如：soa-group2）。</p>
<p><strong>分组措施@2</strong> 通过对分组的服务节点打标实现，例如：服务D（分组1）节点被打标为group1，服务D（分组2）节点被打标为group2。在服务消费方订阅节点时根据不同的分组筛选节点调用。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>方案设计</category>
      </categories>
      <tags>
        <tag>方案设计</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ1# RocketMQ Connection命令</title>
    <url>/posts/6957c801/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="消费端连接信息"><a href="#消费端连接信息" class="headerlink" title="消费端连接信息"></a>消费端连接信息</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin consumerConnection -g T_SCANRECORD_NEW_GROUP -n 192.168.1.x:9876</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option PermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">001 127.0.0.1@60190 192.168.2.x:50104 JAVA V3_2_6_SNAPSHOT</span><br><span class="line"></span><br><span class="line">002 127.0.0.1@7454 192.168.7.x:27692 JAVA V3_2_6_SNAPSHOT</span><br><span class="line"></span><br><span class="line">003 127.0.0.1@31600 192.168.21.x:40243 JAVA V3_2_6_SNAPSHOT</span><br><span class="line"></span><br><span class="line">004 127.0.0.1@21322 192.168.21.x:31416 JAVA V3_2_6_SNAPSHOT</span><br><span class="line"></span><br><span class="line">005 127.0.0.1@39557 192.168.2.x:45959 JAVA V3_2_6_SNAPSHOT</span><br><span class="line"></span><br><span class="line">006 127.0.0.1@24765 192.168.7.x:15166 JAVA V3_2_6_SNAPSHOT</span><br><span class="line"></span><br><span class="line">007 127.0.0.1@26993 192.168.7.x:57864 JAVA V3_2_6_SNAPSHOT</span><br><span class="line"></span><br><span class="line">008 127.0.0.1@652 192.168.21.x:59261 JAVA V3_2_6_SNAPSHOT</span><br><span class="line"></span><br><span class="line">009 127.0.0.1@10388 192.168.21.x:1671 JAVA V3_2_6_SNAPSHOT</span><br><span class="line"></span><br><span class="line">Below is subscription:001 Topic: %RETRY%T_SCANRECORD_NEW_GROUP SubExpression: *</span><br><span class="line"></span><br><span class="line">002 Topic: T_SCANRECORD_NEW SubExpression: 1||2||3||4 || 5 || -5||7 || 45</span><br><span class="line"></span><br><span class="line">ConsumeType: CONSUME_PASSIVELY</span><br><span class="line"></span><br><span class="line">MessageModel: CLUSTERING</span><br><span class="line"></span><br><span class="line">ConsumeFromWhere: CONSUME_FROM_FIRST_OFFSET</span><br></pre></td></tr></table></figure>



<a id="more"></a>



<h1 id="生产连接信息"><a href="#生产连接信息" class="headerlink" title="生产连接信息"></a>生产连接信息</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin producerConnection -t T_SCANRECORD_NEW -g producetGroup -n 192.168.1.x:9876</span><br></pre></td></tr></table></figure>







</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ10# RocketMQ查询死信队列中的消息内容</title>
    <url>/posts/cad2b239/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>RocketMQ中当重试消息超过最大重试次数（默认16次），会被发送到%DLQ%开头的死信队列，默认死信队列为只写权限。在有些情况下，想看看死信队列里的内容。</p>
<h1 id="更改死信队列权限"><a href="#更改死信队列权限" class="headerlink" title="更改死信队列权限"></a>更改死信队列权限</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin updateTopicPerm -c ClusterB -t %DLQ%online-tst -p 6 -n 192.168.1.x:9876</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option PermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">update topic perm from 2 to 6 in 192.168.1.x:10911 success.</span><br><span class="line"></span><br><span class="line">update topic perm from 2 to 6 in 192.168.1.x:10911 success.</span><br><span class="line"></span><br><span class="line">update topic perm from 2 to 6 in 192.168.1.x:10911 success.</span><br><span class="line"></span><br><span class="line">update topic perm from 2 to 6 in 192.168.1.x:10911 success.</span><br><span class="line"></span><br><span class="line">注：将死信队列只写权限更改为读写权限</span><br></pre></td></tr></table></figure>



<a id="more"></a>



<h1 id="查询死信队列状态"><a href="#查询死信队列状态" class="headerlink" title="查询死信队列状态"></a>查询死信队列状态</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin topicStatus -n 192.168.1.x:9876 -t %DLQ%online-tst</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option PermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">Broker Name QID Min Offset Max Offset Last Updated</span><br><span class="line"></span><br><span class="line">broker-a 0 0 109 2018-12-10 18:03:08,732</span><br><span class="line"></span><br><span class="line">broker-a 1 0 109 2018-12-10 18:03:08,740</span><br><span class="line"></span><br><span class="line">broker-a 2 0 110 2018-12-10 18:03:08,750</span><br><span class="line"></span><br><span class="line">broker-a 3 0 109 2018-12-10 18:03:08,728</span><br></pre></td></tr></table></figure>



<h1 id="根据offset查询消息内容"><a href="#根据offset查询消息内容" class="headerlink" title="根据offset查询消息内容"></a>根据offset查询消息内容</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin queryMsgByOffset -n localhost:9876 -t %DLQ%online-tst -b broker-a -i 0 -o 108</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option PermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">OffsetID: 0A090F2800002A9F000000D70519DD35</span><br><span class="line"></span><br><span class="line">OffsetID: 0A090F2800002A9F000000D70519DD35</span><br><span class="line"></span><br><span class="line">Topic: %DLQ%online-tst</span><br><span class="line"></span><br><span class="line">Tags: [null]</span><br><span class="line"></span><br><span class="line">Keys: [null]</span><br><span class="line"></span><br><span class="line">Queue ID: 0</span><br><span class="line"></span><br><span class="line">Queue Offset: 108</span><br><span class="line"></span><br><span class="line">CommitLog Offset: 923503549749</span><br><span class="line"></span><br><span class="line">Reconsume Times: 0</span><br><span class="line"></span><br><span class="line">Born Timestamp: 2018-12-10 17:59:24,731</span><br><span class="line"></span><br><span class="line">Store Timestamp: 2018-12-10 18:03:08,732</span><br><span class="line"></span><br><span class="line">Born Host: 10.10.128.183:51889</span><br><span class="line"></span><br><span class="line">Store Host: 10.9.15.40:10911</span><br><span class="line"></span><br><span class="line">System Flag: 0</span><br><span class="line"></span><br><span class="line">Properties: &#123;MIN_OFFSET&#x3D;0, MAX_OFFSET&#x3D;109, UNIQ_KEY&#x3D;0A0A80B78DE818B4AAC22FA2493B01B2, WAIT&#x3D;true&#125;</span><br><span class="line"></span><br><span class="line">Message Body Path: &#x2F;tmp&#x2F;rocketmq&#x2F;msgbodys&#x2F;0A0A80B78DE818B4AAC22FA2493B01B2</span><br><span class="line"></span><br><span class="line">注：使用打印命令消息临时存储在&#x2F;tmp&#x2F;rocketmq&#x2F;msgbodys</span><br></pre></td></tr></table></figure>

<h1 id="查看消息内容"><a href="#查看消息内容" class="headerlink" title="查看消息内容"></a>查看消息内容</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &#x2F;tmp&#x2F;rocketmq&#x2F;msgbodys&#x2F;0A0A80B78DE818B4AAC22FA2490F01AE</span><br><span class="line"></span><br><span class="line">Hello RocketMQ430</span><br></pre></td></tr></table></figure>

</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ11# RocketMQ集群生产环境节点下线操作</title>
    <url>/posts/6887b617/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="现状描述"><a href="#现状描述" class="headerlink" title="现状描述"></a>现状描述</h1><p>集群其中一台物理机未知原因导致单用户无法登陆机器，该物理机需要重启修改密码或者重装系统。该台为master节点，运行正常。</p>
<p>配置策略为：异步刷盘 &amp; 主从异步复制</p>
<p>如果直接下线该master，由于主从异步复制，可能导致部分消息来不及复制到slave造成消息丢失。所以该方案不可行。</p>
<p>另一种方案选择：关闭该broker的写入权限，待该broker不再有写入和消费时，再下线该节点。</p>
<h1 id="关闭broker写权限"><a href="#关闭broker写权限" class="headerlink" title="关闭broker写权限"></a>关闭broker写权限</h1><p>2表示只写权限，4表示只读权限，6表示读写权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin updateBrokerConfig -b 192.168.x.x:10911 -n 192.168.x.x:9876 -k brokerPermission -v 4</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option PermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">update broker config success, 192.168.x.x:10911</span><br></pre></td></tr></table></figure>



<a id="more"></a>



<h1 id="观察节点流量"><a href="#观察节点流量" class="headerlink" title="观察节点流量"></a>观察节点流量</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin clusterList -n 192.168.x.x:9876</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option PermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">\#Cluster Name #Broker Name #BID #Addr #Version #InTPS(LOAD) #OutTPS(LOAD) #PCWait(ms) #Hour #SPACE</span><br><span class="line"></span><br><span class="line">ZmsClusterA broker-a 0 192.168.x.x:10911 V4_1_0_SNAPSHOT 2492.95(0,0ms) 2269.27(1,0ms) 0 137.57 0.1861</span><br><span class="line"></span><br><span class="line">ZmsClusterA broker-a 1 192.168.x.x:10911 V4_1_0_SNAPSHOT 2485.45(0,0ms) 0.00(0,0ms) 0 125.26 0.3055</span><br><span class="line"></span><br><span class="line">ZmsClusterA broker-b 0 192.168.x.x:10911 V4_1_0_SNAPSHOT 26.47(0,0ms) 26.08(0,0ms) 0 137.24 0.1610</span><br><span class="line"></span><br><span class="line">ZmsClusterA broker-b 1 192.168.x.x:10915 V4_1_0_SNAPSHOT 20.47(0,0ms) 0.00(0,0ms) 0 125.22 0.3055</span><br><span class="line"></span><br><span class="line">ZmsClusterA broker-c 0 192.168.x.x:10911 V4_1_0_SNAPSHOT 2061.09(0,0ms) 1967.30(0,0ms) 0 125.28 0.2031</span><br><span class="line"></span><br><span class="line">ZmsClusterA broker-c 1 192.168.x.x:10911 V4_1_0_SNAPSHOT 2048.20(0,0ms) 0.00(0,0ms) 0 137.51 0.2789</span><br><span class="line"></span><br><span class="line">ZmsClusterA broker-d 0 192.168.x.x:10911 V4_1_0_SNAPSHOT 2017.40(0,0ms) 1788.32(0,0ms) 0 125.22 0.1261</span><br><span class="line"></span><br><span class="line">ZmsClusterA broker-d 1 192.168.x.x:10915 V4_1_0_SNAPSHOT 2026.50(0,0ms) 0.00(0,0ms) 0 137.61 0.2789</span><br></pre></td></tr></table></figure>



<p>观察InTPS和OutTPS，理想情况都为零时，并不再变化时，则该节点可下线了。</p>
<p>然而，在实际过程中并没有出现为零的情况，InTPS和OutTPS总是有值，有时个位数字有时是两位数字，大部分时间在20多的值。此刻要分析下broker目前的消费状态。</p>
<h1 id="观察broker消费状态"><a href="#观察broker消费状态" class="headerlink" title="观察broker消费状态"></a>观察broker消费状态</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh bin&#x2F;mqadmin brokerConsumeStats -b 192.168.x.x:10911 -n 192.168.x.x:9876 &gt;&gt; brokerConsumeStats.tmp</span><br></pre></td></tr></table></figure>



<p>查看brokerConsumeStats.tmp，主要查看#LastTime和#Diff。 发现%RETRY%重试类队列#Diff有很微小（1或者3）的数据，而其他topic均为0. LastTime时间最新也是发生在%RETRY%队列中。此时可以让该节点下线操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#Topic #Group #Broker Name #QID #Broker Offset #Consumer Offset #Diff #LastTime</span><br><span class="line"></span><br><span class="line">SV_Multi_Message ZTO_SV_EmchatWebConsumerGroup broker-b 0 2171742 2171742 0 2019-04-24 23:38:09</span><br><span class="line"></span><br><span class="line">SV_Multi_Message ZTO_SV_EmchatWebConsumerGroup broker-b 1 2171756 2171756 0 2019-04-24 23:38:50</span><br><span class="line"></span><br><span class="line">SV_Multi_Message ZTO_SV_EmchatWebConsumerGroup broker-b 2 2171740 2171740 0 2019-04-24 23:42:58</span><br><span class="line"></span><br><span class="line">SV_Multi_Message ZTO_SV_EmchatWebConsumerGroup broker-b 3 2171759 2171759 0 2019-04-24 23:40:44</span><br><span class="line"></span><br><span class="line">SV_Multi_Message ZTO_SV_EmchatWebConsumerGroup broker-b 4 2171743 2171743 0 2019-04-24 23:32:48</span><br><span class="line"></span><br><span class="line">SV_Multi_Message ZTO_SV_EmchatWebConsumerGroup broker-b 5 2171740 2171740 0 2019-04-24 23:35:58</span><br><span class="line"></span><br><span class="line">SV_Multi_Message ZTO_SV_EmchatWebConsumerGroup broker-b 6 2171758 2171758 0 2019-04-24 23:36:23</span><br><span class="line"></span><br><span class="line">SV_Multi_Message ZTO_SV_EmchatWebConsumerGroup broker-b 7 2171740 2171740 0 2019-04-24 23:37:50</span><br><span class="line"></span><br><span class="line">%RETRY%ZTO_SV_EmchatWebConsumerG ZTO_SV_EmchatWebConsumerGroup broker-b 0 61876 61876 0 2019-04-24 10:09:04</span><br><span class="line"></span><br><span class="line">%RETRY%SVC_TRACK_CONSUMER SVC_TRACK_CONSUMER broker-b 0 497968 497968 0 2019-04-19 12:51:24</span><br><span class="line"></span><br><span class="line">SVC_TRACK_TOPIC SVC_TRACK_CONSUMER broker-b 0 191710 191710 0 2019-04-24 23:44:22</span><br><span class="line"></span><br><span class="line">SVC_TRACK_TOPIC SVC_TRACK_CONSUMER broker-b 1 191706 191706 0 2019-04-24 23:44:25</span><br><span class="line"></span><br><span class="line">SVC_TRACK_TOPIC SVC_TRACK_CONSUMER broker-b 2 191697 191697 0 2019-04-24 23:44:44</span><br><span class="line"></span><br><span class="line">SVC_TRACK_TOPIC SVC_TRACK_CONSUMER broker-b 3 191695 191695 0 2019-04-24 23:44:47</span><br><span class="line"></span><br><span class="line">SVC_TRACK_TOPIC SVC_TRACK_CONSUMER broker-b 4 191688 191688 0 2019-04-24 23:44:47</span><br><span class="line"></span><br><span class="line">SVC_TRACK_TOPIC SVC_TRACK_CONSUMER broker-b 5 191683 191683 0 2019-04-24 23:44:48</span><br><span class="line"></span><br><span class="line">SVC_TRACK_TOPIC SVC_TRACK_CONSUMER broker-b 6 191676 191676 0 2019-04-24 23:44:49</span><br><span class="line"></span><br><span class="line">SVC_TRACK_TOPIC SVC_TRACK_CONSUMER broker-b 7 191672 191672 0 2019-04-24 23:44:49</span><br></pre></td></tr></table></figure>



<h1 id="borker读写权限恢复"><a href="#borker读写权限恢复" class="headerlink" title="borker读写权限恢复"></a>borker读写权限恢复</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin updateBrokerConfig -b 192.168.x.x:10911 -n 192.168.x.x:9876 -k brokerPermission -v 6</span><br></pre></td></tr></table></figure>



<h1 id="观察各节点流量是否正常"><a href="#观察各节点流量是否正常" class="headerlink" title="观察各节点流量是否正常"></a>观察各节点流量是否正常</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin clusterList -n 192.168.x.x:9876</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option PermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">\#Cluster Name #Broker Name #BID #Addr #Version #InTPS(LOAD) #OutTPS(LOAD) #PCWait(ms) #Hour #SPACE</span><br><span class="line"></span><br><span class="line">ZmsClusterA broker-a 0 192.168.x.x:10911 V4_1_0_SNAPSHOT 2492.95(0,0ms) 2269.27(1,0ms) 0 137.57 0.1861</span><br><span class="line"></span><br><span class="line">ZmsClusterA broker-a 1 192.168.x.x:10911 V4_1_0_SNAPSHOT 2485.45(0,0ms) 0.00(0,0ms) 0 125.26 0.3055</span><br><span class="line"></span><br><span class="line">ZmsClusterA broker-b 0 192.168.x.x:10911 V4_1_0_SNAPSHOT 2299.47(0,0ms) 2226.08(0,0ms) 0 137.24 0.1610</span><br><span class="line"></span><br><span class="line">ZmsClusterA broker-b 1 192.168.x.x:10915 V4_1_0_SNAPSHOT 2280.47(0,0ms) 0.00(0,0ms) 0 125.22 0.3055</span><br><span class="line"></span><br><span class="line">ZmsClusterA broker-c 0 192.168.x.x:10911 V4_1_0_SNAPSHOT 2061.09(0,0ms) 1967.30(0,0ms) 0 125.28 0.2031</span><br><span class="line"></span><br><span class="line">ZmsClusterA broker-c 1 192.168.x.x:10911 V4_1_0_SNAPSHOT 2048.20(0,0ms) 0.00(0,0ms) 0 137.51 0.2789</span><br><span class="line"></span><br><span class="line">ZmsClusterA broker-d 0 192.168.x.x:10911 V4_1_0_SNAPSHOT 2017.40(0,0ms) 1788.32(0,0ms) 0 125.22 0.1261</span><br><span class="line"></span><br><span class="line">ZmsClusterA broker-d 1 192.168.x.x:10915 V4_1_0_SNAPSHOT 2026.50(0,0ms) 0.00(0,0ms) 0 137.61 0.2789</span><br></pre></td></tr></table></figure>

</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ12# RocketMQ性能优化</title>
    <url>/posts/eb676532/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一、系统优化</span><br><span class="line"></span><br><span class="line">1.最大文件数</span><br><span class="line"></span><br><span class="line">2.系统参数调整</span><br><span class="line"></span><br><span class="line">二、RocketMQ性能调优</span><br><span class="line"></span><br><span class="line">1.开启异步刷盘</span><br><span class="line"></span><br><span class="line">2.开启堆外内存设置</span><br><span class="line"></span><br><span class="line">3.开启文件预热</span><br><span class="line"></span><br><span class="line">4.开启Slave读权限</span><br><span class="line"></span><br><span class="line">5.关闭堆内存据传输</span><br></pre></td></tr></table></figure>



<h1 id="系统优化"><a href="#系统优化" class="headerlink" title="系统优化"></a>系统优化</h1><h2 id="最大文件数"><a href="#最大文件数" class="headerlink" title="最大文件数"></a>最大文件数</h2><p>limits.conf 设置用户能打开的最大文件数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;security&#x2F;limits.conf</span><br><span class="line"></span><br><span class="line">\# End of file</span><br><span class="line"></span><br><span class="line">baseuser soft nofile 655360</span><br><span class="line"></span><br><span class="line">baseuser hard nofile 655360</span><br><span class="line"></span><br><span class="line">\* soft nofile 655360</span><br><span class="line"></span><br><span class="line">\* hard nofile 655360</span><br></pre></td></tr></table></figure>



<a id="more"></a>



<h2 id="系统参数调整"><a href="#系统参数调整" class="headerlink" title="系统参数调整"></a>系统参数调整</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo vim &#x2F;etc&#x2F;sysctl.conf</span><br><span class="line"></span><br><span class="line">vm.overcommit_memory&#x3D;1</span><br><span class="line"></span><br><span class="line">vm.drop_caches&#x3D;1</span><br><span class="line"></span><br><span class="line">vm.zone_reclaim_mode&#x3D;0</span><br><span class="line"></span><br><span class="line">vm.max_map_count&#x3D;655360</span><br><span class="line"></span><br><span class="line">vm.dirty_background_ratio&#x3D;50</span><br><span class="line"></span><br><span class="line">vm.dirty_ratio&#x3D;50</span><br><span class="line"></span><br><span class="line">vm.dirty_writeback_centisecs&#x3D;360000</span><br><span class="line"></span><br><span class="line">vm.page-cluster&#x3D;3</span><br><span class="line"></span><br><span class="line">vm.swappiness&#x3D;1</span><br><span class="line"></span><br><span class="line">vm.zone_reclaim_mode&#x3D;1 &#x2F;&#x2F; 主节点</span><br><span class="line"></span><br><span class="line">vm.min_free_kbytes&#x3D;512000</span><br><span class="line"></span><br><span class="line">sudo sysctl -p</span><br></pre></td></tr></table></figure>



<h2 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h2><h3 id="overcommit-memory"><a href="#overcommit-memory" class="headerlink" title="overcommit_memory"></a>overcommit_memory</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">是否允许内存的过量分配</span><br><span class="line"></span><br><span class="line">当为0的时候，当用户申请内存的时候，内核会去检查是否有这么大的内存空间</span><br><span class="line"></span><br><span class="line">当为1的时候，内核始终认为，有足够大的内存空间，直到它用完了为止</span><br><span class="line"></span><br><span class="line">当为2的时候，内核禁止任何形式的过量分配内存</span><br></pre></td></tr></table></figure>

<h3 id="drop-caches"><a href="#drop-caches" class="headerlink" title="drop_caches"></a>drop_caches</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">写入的时候，内核会清空缓存，腾出内存来，相当于sync</span><br><span class="line"></span><br><span class="line">写1的时候，会清空页缓存，就是文件</span><br><span class="line"></span><br><span class="line">写2的时候，会清空inode和目录树</span><br><span class="line"></span><br><span class="line">写3的时候，都清空</span><br><span class="line"></span><br><span class="line">This is a non-destructive operation and will only free things that are completely unused.</span><br><span class="line"></span><br><span class="line">Dirty objects will continue to be in use until written out to disk and are not freeable.</span><br><span class="line"></span><br><span class="line">If you run &quot;sync&quot; first to flush them out to disk, these drop operations will tend to free more memory.</span><br></pre></td></tr></table></figure>

<h3 id="zone-reclaim-mode"><a href="#zone-reclaim-mode" class="headerlink" title="zone_reclaim_mode"></a>zone_reclaim_mode</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果为0的话，那么系统会倾向于从其他节点分配内存</span><br><span class="line"></span><br><span class="line">如果为1的话，那么系统会倾向于从本地节点回收Cache内存多数时候</span><br></pre></td></tr></table></figure>

<h3 id="max-map-count"><a href="#max-map-count" class="headerlink" title="max_map_count"></a>max_map_count</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">定义了一个进程能拥有的最多的内存区域，默认为65536</span><br></pre></td></tr></table></figure>



<h3 id="dirty-background-bytes-dirty-background-ratio"><a href="#dirty-background-bytes-dirty-background-ratio" class="headerlink" title="dirty_background_bytes/dirty_background_ratio"></a>dirty_background_bytes/dirty_background_ratio</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当dirty cache到了多少的时候，就启动pdflush进程，将dirty cache写回磁盘</span><br><span class="line"></span><br><span class="line">当有dirty_background_bytes存在的时候，dirty_background_ratio是被自动计算的</span><br></pre></td></tr></table></figure>



<h3 id="dirty-bytes-dirty-ratio"><a href="#dirty-bytes-dirty-ratio" class="headerlink" title="dirty_bytes/dirty_ratio"></a>dirty_bytes/dirty_ratio</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当一个进程的dirty cache到了多少的时候，启动pdflush进程，将dirty cache写回磁盘</span><br><span class="line"></span><br><span class="line">当dirty_bytes存在的时候，dirty_ratio是被自动计算的</span><br></pre></td></tr></table></figure>



<h3 id="dirty-writeback-centisecs"><a href="#dirty-writeback-centisecs" class="headerlink" title="dirty_writeback_centisecs"></a>dirty_writeback_centisecs</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pdflush每隔多久，自动运行一次（单位是百分之一秒）</span><br></pre></td></tr></table></figure>



<h3 id="page-cluster"><a href="#page-cluster" class="headerlink" title="page-cluster"></a>page-cluster</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">每次swap in或者swap out操作多少内存页为2的指数。</span><br><span class="line"></span><br><span class="line">等于0的时候，为1页；等于1的时候，为2页；等于2的时候，为4页</span><br></pre></td></tr></table></figure>



<h3 id="swappiness"><a href="#swappiness" class="headerlink" title="swappiness"></a>swappiness</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">swappiness&#x3D;0 仅在内存不足的情况下，当剩余空闲内存低于vm.min_free_kbytes limit时，使用交换空间</span><br><span class="line"></span><br><span class="line">swappiness&#x3D;1 内核版本3.5及以上、Red Hat内核版本2.6.32-303及以上，进行最少量的交换，而不禁用交换</span><br><span class="line"></span><br><span class="line">swappiness&#x3D;10 当系统存在足够内存时，推荐设置为该值以提高性能</span><br><span class="line"></span><br><span class="line">swappiness&#x3D;60 默认值</span><br><span class="line"></span><br><span class="line">swappiness&#x3D;100 内核将积极的使用交换空间</span><br></pre></td></tr></table></figure>





<h1 id="RocketMQ性能调优"><a href="#RocketMQ性能调优" class="headerlink" title="RocketMQ性能调优"></a>RocketMQ性能调优</h1><p>线上RocketMQ的JVM未做调优，堆内存使用8G；主要从RocketMQ配置参数方面梳理下。</p>
<h2 id="开启异步刷盘"><a href="#开启异步刷盘" class="headerlink" title="开启异步刷盘"></a>开启异步刷盘</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flushDiskType&#x3D;ASYNC_FLUSH</span><br><span class="line"></span><br><span class="line">同步刷盘TPS过低，较难满足业务发展需求</span><br></pre></td></tr></table></figure>



<h2 id="开启堆外内存设置"><a href="#开启堆外内存设置" class="headerlink" title="开启堆外内存设置"></a>开启堆外内存设置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">transientStorePoolEnable&#x3D;true</span><br><span class="line"></span><br><span class="line">消息写入到堆外内存，消费时从pageCache消费，读写分离，提升集群性能</span><br></pre></td></tr></table></figure>



<h2 id="开启文件预热"><a href="#开启文件预热" class="headerlink" title="开启文件预热"></a>开启文件预热</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">warmMapedFileEnable&#x3D;true</span><br><span class="line"></span><br><span class="line">开启文件预热，避免日志文件在分配内存时缺页中断</span><br></pre></td></tr></table></figure>



<h2 id="开启Slave读权限"><a href="#开启Slave读权限" class="headerlink" title="开启Slave读权限"></a>开启Slave读权限</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">slaveReadEnable&#x3D;true</span><br><span class="line"></span><br><span class="line">消息占用物理内存的大小通过accessMessageInMemoryMaxRatio来配置默认为40%；</span><br><span class="line"></span><br><span class="line">如果消费的消息不在内存中，开启slaveReadEnable时会从slave节点读取；提高Master内存利用率</span><br></pre></td></tr></table></figure>



<h2 id="关闭堆内存据传输"><a href="#关闭堆内存据传输" class="headerlink" title="关闭堆内存据传输"></a>关闭堆内存据传输</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">transferMsgByHeap默认true设置为false</span><br><span class="line"></span><br><span class="line">Broker响应消费请求时，不必将数据重新读到堆内存再发送给客户端；</span><br><span class="line"></span><br><span class="line">直接从PageCache将数据发送给客户端</span><br></pre></td></tr></table></figure>



<h2 id="延长发送队列等待时间"><a href="#延长发送队列等待时间" class="headerlink" title="延长发送队列等待时间"></a>延长发送队列等待时间</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">waitTimeMillsInSendQueue默认200ms；适当延长到1000ms</span><br><span class="line"></span><br><span class="line">降低由于等待超时客户端快速失败抛出[TIMEOUT_CLEAN_QUEUE]broker busy频率</span><br></pre></td></tr></table></figure>

</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ15# RocketMQ生产环境配置</title>
    <url>/posts/50d4ff7d/</url>
    <content><![CDATA[<div id="vip-container"><p>一份RocketMQ生产环境的配置文件，供参考，集群架构为异步刷盘异步复制。另外有补充的欢迎后台留言给我。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#请修改</span><br><span class="line"></span><br><span class="line">brokerClusterName&#x3D;XXXCluster</span><br><span class="line"></span><br><span class="line">brokerName&#x3D;broker-a</span><br><span class="line"></span><br><span class="line">brokerId&#x3D;0</span><br><span class="line"></span><br><span class="line">listenPort&#x3D;10911</span><br><span class="line"></span><br><span class="line">#请修改</span><br><span class="line"></span><br><span class="line">namesrvAddr&#x3D;x.x.x.x:9876;x.x.x.x::9876</span><br><span class="line"></span><br><span class="line">defaultTopicQueueNums&#x3D;4</span><br><span class="line"></span><br><span class="line">autoCreateTopicEnable&#x3D;false</span><br><span class="line"></span><br><span class="line">autoCreateSubscriptionGroup&#x3D;false</span><br><span class="line"></span><br><span class="line">deleteWhen&#x3D;04</span><br><span class="line"></span><br><span class="line">fileReservedTime&#x3D;48</span><br><span class="line"></span><br><span class="line">mapedFileSizeCommitLog&#x3D;1073741824</span><br><span class="line"></span><br><span class="line">mapedFileSizeConsumeQueue&#x3D;50000000</span><br><span class="line"></span><br><span class="line">destroyMapedFileIntervalForcibly&#x3D;120000</span><br><span class="line"></span><br><span class="line">redeleteHangedFileInterval&#x3D;120000</span><br><span class="line"></span><br><span class="line">diskMaxUsedSpaceRatio&#x3D;88</span><br><span class="line"></span><br><span class="line">#存储路径</span><br><span class="line"></span><br><span class="line">storePathRootDir&#x3D;&#x2F;data&#x2F;rocketmq&#x2F;store</span><br><span class="line"></span><br><span class="line">#commitLog存储路径</span><br><span class="line"></span><br><span class="line">storePathCommitLog&#x3D;&#x2F;data&#x2F;rocketmq&#x2F;store&#x2F;commitlog</span><br><span class="line"></span><br><span class="line">#消费队列存储路径</span><br><span class="line"></span><br><span class="line">storePathConsumeQueue&#x3D;&#x2F;data&#x2F;rocketmq&#x2F;store&#x2F;consumequeue</span><br><span class="line"></span><br><span class="line"># 消息索引存储路径</span><br><span class="line"></span><br><span class="line">storePathIndex&#x3D;&#x2F;data&#x2F;rocketmq&#x2F;store&#x2F;index</span><br><span class="line"></span><br><span class="line"># checkpoint 文件存储路径</span><br><span class="line"></span><br><span class="line">storeCheckpoint&#x3D;&#x2F;data&#x2F;rocketmq&#x2F;store&#x2F;checkpoint</span><br><span class="line"></span><br><span class="line">#abort 文件存储路径</span><br><span class="line"></span><br><span class="line">abortFile&#x3D;&#x2F;data&#x2F;rocketmq&#x2F;store&#x2F;abort</span><br><span class="line"></span><br><span class="line">maxMessageSize&#x3D;65536</span><br><span class="line"></span><br><span class="line">flushCommitLogLeastPages&#x3D;4</span><br><span class="line"></span><br><span class="line">flushConsumeQueueLeastPages&#x3D;2</span><br><span class="line"></span><br><span class="line">flushCommitLogThoroughInterval&#x3D;10000</span><br><span class="line"></span><br><span class="line">flushConsumeQueueThoroughInterval&#x3D;60000</span><br><span class="line"></span><br><span class="line">brokerRole&#x3D;SYNC_MASTER</span><br><span class="line"></span><br><span class="line">flushDiskType&#x3D;ASYNC_FLUSH</span><br><span class="line"></span><br><span class="line">checkTransactionMessageEnable&#x3D;false</span><br><span class="line"></span><br><span class="line">maxTransferCountOnMessageInMemory&#x3D;1000</span><br><span class="line"></span><br><span class="line">transientStorePoolEnable&#x3D;true</span><br><span class="line"></span><br><span class="line">warmMapedFileEnable&#x3D;true</span><br><span class="line"></span><br><span class="line">pullMessageThreadPoolNums&#x3D;128</span><br><span class="line"></span><br><span class="line">slaveReadEnable&#x3D;true</span><br><span class="line"></span><br><span class="line">transferMsgByHeap&#x3D;false</span><br><span class="line"></span><br><span class="line">waitTimeMillsInSendQueue&#x3D;1000</span><br></pre></td></tr></table></figure>

</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ14# RocketMQ同步复制性能优化</title>
    <url>/posts/d1c4e530/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>早些时候写过性能测试和性能优化文章，主要基于异步刷盘/异步复制；由于业务需要需要搭建异步刷盘/同步复制集群；同时对性能进行压测。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">压测结果显示集群几乎无法使用，TPS居然是个位数，客户端也在报错。</span><br></pre></td></tr></table></figure>



<a id="more"></a>



<h2 id="压测日志"><a href="#压测日志" class="headerlink" title="压测日志"></a>压测日志</h2><p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201218231410.png"></p>
<h2 id="客户端日志"><a href="#客户端日志" class="headerlink" title="客户端日志"></a>客户端日志</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2019-09-19 19:22:38,038 ERROR RocketmqClient - [BENCHMARK_PRODUCER] Send Exception</span><br><span class="line"></span><br><span class="line">org.apache.rocketmq.client.exception.MQBrokerException: CODE: 2 DESC: [TIMEOUT_CLEAN_QUEUE]broker busy, start flow control for a while, period in queue: 209ms, size of queue: 9</span><br><span class="line"></span><br><span class="line">For more information, please visit the url, http:&#x2F;&#x2F;rocketmq.apache.org&#x2F;docs&#x2F;faq&#x2F;</span><br><span class="line"></span><br><span class="line">at org.apache.rocketmq.client.impl.MQClientAPIImpl.processSendResponse(MQClientAPIImpl.java:671)</span><br><span class="line"></span><br><span class="line">at org.apache.rocketmq.client.impl.MQClientAPIImpl.sendMessageSync(MQClientAPIImpl.java:467)</span><br><span class="line"></span><br><span class="line">at org.apache.rocketmq.client.impl.MQClientAPIImpl.sendMessage(MQClientAPIImpl.java:449)</span><br><span class="line"></span><br><span class="line">at</span><br></pre></td></tr></table></figure>



<h1 id="解决发送失败情况"><a href="#解决发送失败情况" class="headerlink" title="解决发送失败情况"></a>解决发送失败情况</h1><p>经排查，将transientStorePoolEnable关闭(默认为false)；压测显示最高TPS有1.9万。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brokerRole&#x3D;SYNC_MASTER</span><br><span class="line"></span><br><span class="line">\#transientStorePoolEnable&#x3D;true</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201218231653.png"></p>
<h1 id="解决发送TPS过低情况"><a href="#解决发送TPS过低情况" class="headerlink" title="解决发送TPS过低情况"></a>解决发送TPS过低情况</h1><p>最高TPS只有1.9万，依然过低，与预期相差甚远，我们预期压测应该可以到7到8万这样可以满足业务发展需要。再次检查broker端参数配置，没有发现有参数导致性能如此过低。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">回顾性能调优的几个方面：系统调优、集群调优、JVM调优。</span><br></pre></td></tr></table></figure>

<p>系统调优与集群调优都已经做过了，唯一没有优化的JVM调优，堆内存设置默认的8G。</p>
<p>JAVA_OPT=”${JAVA_OPT} -server -Xms8g -Xmx8g -Xmn4g”</p>
<p>将JVM堆内存提高4倍后，压测效果明显提升，基本可以达到预期7万多的TPS。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201218231833.png"></p>
<h1 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h1><p>1.为什么在异步刷盘/同步复制时开启堆外内存池transientStorePoolEnable后，集群压测几乎无法进行？</p>
<p>2.为什么在异步刷盘/同步复制时调大JVM堆内存后，性能明显提升呢？提升了的倍数几乎是堆内存增大的倍数。</p>
<h2 id="刷盘流程回顾"><a href="#刷盘流程回顾" class="headerlink" title="刷盘流程回顾"></a>刷盘流程回顾</h2><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMzY2MDYzMA==&mid=2247483827&idx=1&sn=d7204473069dbad47b0cc7e05ad83acc&chksm=9b9e790aace9f01c84d0e9d686309875064a22704d843cdb941fbebe46728dfb338dc4cfa4bd&scene=21#wechat_redirect">RocketMQ存储–消息追加【源码笔记】</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMzY2MDYzMA==&mid=2247483855&idx=1&sn=710f8b2eb72ec28ff10eb7dbaf44dc7f&chksm=9b9e7976ace9f0608b5da4d4cf9676580aa599e7ce239b6aba9736cc6c60ff8efafb7910f7b1&scene=21#wechat_redirect">RocketMQ存储–同步刷盘和异步刷盘【源码笔记】</a></p>
<p><strong>异步刷盘未开启堆外缓存示意图</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201218232152.png"></p>
<p><strong>异步刷盘开启堆外缓存示意图</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201218232214.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：异步刷盘未开启transientStorePoolEnable时，消息追加到mappedByteBuffer中，异步线程刷调用mappedByteBuffer.force落盘；异步刷盘开启transientStorePoolEnable时，消息写入wrtieBuffer中，异步线程将消息提交到fileChannel，然后异步线程调用fileChannel.force落盘。</span><br></pre></td></tr></table></figure>



<h2 id="主从复制回顾"><a href="#主从复制回顾" class="headerlink" title="主从复制回顾"></a>主从复制回顾</h2><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMzY2MDYzMA==&mid=2247483701&idx=1&sn=9760e50c69285aad2d868a13d810394e&chksm=9b9e798cace9f09aa5d31b5c4b972e627b3fe1afcb892d40fbf57c561b18175bd12119e8c08c&scene=21#wechat_redirect">RocketMQ存储–主从同步【源码笔记】</a></p>
<p>HAConnection#WriteSocketService负责向Slave发送数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;查找待拉取偏移量之后所有的可读消息</span><br><span class="line"></span><br><span class="line">SelectMappedBufferResult selectResult &#x3D; HAConnection.this.haService.getDefaultMessageStore().getCommitLogData(this.nextTransferFromWhere);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line"></span><br><span class="line">SelectMappedBufferResult result &#x3D; mappedFile.selectMappedBuffer(pos);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line"></span><br><span class="line">ByteBuffer byteBuffer &#x3D; this.mappedByteBuffer.slice();</span><br><span class="line"></span><br><span class="line">byteBuffer.position(pos);</span><br><span class="line"></span><br><span class="line">int size &#x3D; readPosition - pos; &#x2F;&#x2F;计算距离最大可读位置的大小</span><br><span class="line"></span><br><span class="line">ByteBuffer byteBufferNew &#x3D; byteBuffer.slice();</span><br><span class="line"></span><br><span class="line">byteBufferNew.limit(size);</span><br><span class="line"></span><br><span class="line">return new SelectMappedBufferResult()</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：主从复制使用mappedByteBuffer向Slave同步数据。</span><br></pre></td></tr></table></figure>

<h2 id="流程模拟"><a href="#流程模拟" class="headerlink" title="流程模拟"></a>流程模拟</h2><h3 id="开启堆外内存池流程"><a href="#开启堆外内存池流程" class="headerlink" title="开启堆外内存池流程"></a>开启堆外内存池流程</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line"></span><br><span class="line">public void test01()&#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 堆外内存池transientStorePoolEnable开启后，消息追加操作</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">File file &#x3D; new File(&quot;&#x2F;Users&#x2F;yongliang&#x2F;logs&#x2F;temp.log&quot;);</span><br><span class="line"></span><br><span class="line">FileChannel fileChannel &#x3D; new RandomAccessFile(file, &quot;rw&quot;).getChannel();</span><br><span class="line"></span><br><span class="line">String data &#x3D; &quot;beautiful girl!&quot;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; mmap 文件映射操作</span><br><span class="line"></span><br><span class="line">MappedByteBuffer mappedByteBuffer &#x3D; fileChannel.map(FileChannel.MapMode.READ_WRITE, 0, data.length());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 堆外内存transientStorePoolEnable开启</span><br><span class="line"></span><br><span class="line">ByteBuffer byteBuffer &#x3D; ByteBuffer.allocateDirect(data.length());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ----------------消息追加开始-----------------------</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 注意此时使用堆内内存分配</span><br><span class="line"></span><br><span class="line">ByteBuffer msgStoreItemMemory &#x3D; ByteBuffer.allocate(data.length());</span><br><span class="line"></span><br><span class="line">msgStoreItemMemory.put(data.getBytes());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 开启transientStorePoolEnable消息写入了ByteBuffer</span><br><span class="line"></span><br><span class="line">byteBuffer.put(msgStoreItemMemory.array(),0,data.length());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ----------------消息追加结束-----------------------</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ----------------消息提交开始-----------------------</span><br><span class="line"></span><br><span class="line">byteBuffer.position(0);</span><br><span class="line"></span><br><span class="line">byteBuffer.limit(data.length());</span><br><span class="line"></span><br><span class="line">fileChannel.write(byteBuffer);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ----------------消息提交结束-----------------------</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; --------主从复制从mappedByteBuffer获取消息开始----------</span><br><span class="line"></span><br><span class="line">mappedByteBuffer.position(0);</span><br><span class="line"></span><br><span class="line">mappedByteBuffer.limit(data.length());</span><br><span class="line"></span><br><span class="line">Charset charset &#x3D; Charset.forName(&quot;UTF-8&quot;);</span><br><span class="line"></span><br><span class="line">CharsetDecoder decoder &#x3D; charset.newDecoder();</span><br><span class="line"></span><br><span class="line">CharBuffer charBuffer &#x3D; decoder.decode(mappedByteBuffer.asReadOnlyBuffer());</span><br><span class="line"></span><br><span class="line">System.out.println(charBuffer.toString());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; --------主从复制从mappedByteBuffer获取消息结束----------</span><br><span class="line"></span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">e.printStackTrace();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：模拟开启堆外内存池transientStorePoolEnable的消息追加及主从复制流程。</span><br></pre></td></tr></table></figure>

<h3 id="未开启堆外内存池流程"><a href="#未开启堆外内存池流程" class="headerlink" title="未开启堆外内存池流程"></a>未开启堆外内存池流程</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line"></span><br><span class="line">public void test02()&#123;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">File file &#x3D; new File(&quot;&#x2F;Users&#x2F;yongliang&#x2F;logs&#x2F;temp1.log&quot;);</span><br><span class="line"></span><br><span class="line">FileChannel fileChannel &#x3D; new RandomAccessFile(file, &quot;rw&quot;).getChannel();</span><br><span class="line"></span><br><span class="line">String data &#x3D; &quot;beautiful girl!&quot;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; mmap 文件映射操作</span><br><span class="line"></span><br><span class="line">MappedByteBuffer mappedByteBuffer &#x3D; fileChannel.map(FileChannel.MapMode.READ_WRITE, 0, data.length());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ----------------消息追加开始-----------------------</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 注意消息组装使用堆内内存分配</span><br><span class="line"></span><br><span class="line">ByteBuffer msgStoreItemMemory &#x3D; ByteBuffer.allocate(data.length());</span><br><span class="line"></span><br><span class="line">msgStoreItemMemory.put(data.getBytes());</span><br><span class="line"></span><br><span class="line">mappedByteBuffer.put(msgStoreItemMemory.array(),0,data.length());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ----------------消息追加结束-----------------------</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; --------主从复制从mappedByteBuffer获取消息开始----------</span><br><span class="line"></span><br><span class="line">mappedByteBuffer.position(0);</span><br><span class="line"></span><br><span class="line">mappedByteBuffer.limit(data.length());</span><br><span class="line"></span><br><span class="line">Charset charset &#x3D; Charset.forName(&quot;UTF-8&quot;);</span><br><span class="line"></span><br><span class="line">CharsetDecoder decoder &#x3D; charset.newDecoder();</span><br><span class="line"></span><br><span class="line">CharBuffer charBuffer &#x3D; decoder.decode(mappedByteBuffer.asReadOnlyBuffer());</span><br><span class="line"></span><br><span class="line">System.out.println(charBuffer.toString());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; --------主从复制从mappedByteBuffer获取消息结束----------</span><br><span class="line"></span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">e.printStackTrace();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：模拟未开启堆外内存池transientStorePoolEnable的消息追加及主从复制流程。</span><br></pre></td></tr></table></figure>

<h1 id="原因总结"><a href="#原因总结" class="headerlink" title="原因总结"></a>原因总结</h1><p>1.为什么在异步刷盘/同步复制时开启堆外内存transientStorePoolEnable后，集群压测几乎无法进行？</p>
<p>解释：</p>
<p>1&gt;主从同步复制使用mappedByteBuffer；</p>
<p>2&gt;开启堆外内存池transientStorePoolEnable后数据先落到WriteBuffer，再通过异步提交线程提交到FileChannel，再通过mmap将数据映射到mappedByteBuffer；</p>
<p>3&gt;未开启堆外内存池transientStorePoolEnable数据直接写入到mappedByteBuffe；</p>
<p>由于开启堆外内存数据映射到mappedByteBuffer比直接写入mappedByteBuffer多了很多步骤，再加上发送队列处理事件默认只有200毫秒（waitTimeMillsInSendQueue=200），造成集群不能正常压测的原因。</p>
<p>2.为什么在异步刷盘/同步复制时调大JVM堆内存后，性能明显提升呢？提升了的倍数几乎是对内存增大的倍数。</p>
<p>解释：</p>
<p>从模拟流程中可以看出，在组装消息时使用堆内存，提高堆内存显著提高写入Tps的原因所在。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 注意消息组装使用堆内内存分配</span><br><span class="line"></span><br><span class="line">ByteBuffer msgStoreItemMemory &#x3D; ByteBuffer.allocate(data.length());</span><br></pre></td></tr></table></figure>

</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ16# RocketMQ一次延迟消息故障排查</title>
    <url>/posts/258cdfc5/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>RocketMQ社区版本支持18个延迟级别，每个级别在设定的时间都被会消费者准确消费到。为此也专门测试过消费的间隔是不是准确，测试结果显示很准确。</p>
<p>然而，如此准确的特性居然出问题了，接到业务同学报告线上某个集群延迟消息消费不到，开发环境、测试环境都没问题。各个环境的版本都是统一的RocketMQ 4.5.2。诡异！</p>
<a id="more"></a>

<h1 id="临时方案"><a href="#临时方案" class="headerlink" title="临时方案"></a>临时方案</h1><p>将该业务的topic和consumer转移到线上其他集群，延迟消息消费正常。</p>
<h1 id="问题定位"><a href="#问题定位" class="headerlink" title="问题定位"></a>问题定位</h1><h2 id="搜查日志"><a href="#搜查日志" class="headerlink" title="搜查日志"></a>搜查日志</h2><p>发现storeerror.log一直刷下面的日志，观察发现offset远远超过了存储的大小！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2020-03-18 16:38:06 WARN ScheduleMessageTimerThread - Offset not matched. Request offset: 509548460, firstOffset: 0, lastOffset: 6000000, mappedFileSize: 6000000, mappedFiles count: 1</span><br><span class="line"></span><br><span class="line">2020-03-18 16:38:06 WARN ScheduleMessageTimerThread - Offset not matched. Request offset: 665682360, firstOffset: 0, lastOffset: 6000000, mappedFileSize: 6000000, mappedFiles count: 1</span><br><span class="line"></span><br><span class="line">2020-03-18 16:38:07 WARN ScheduleMessageTimerThread - Offset not matched. Request offset: 509548460, firstOffset: 0, lastOffset: 6000000, mappedFileSize: 6000000, mappedFiles count: 1</span><br><span class="line"></span><br><span class="line">2020-03-18 16:38:07 WARN ScheduleMessageTimerThread - Offset not matched. Request offset: 665682360, firstOffset: 0, lastOffset: 6000000, mappedFileSize: 6000000, mappedFiles count: 1</span><br><span class="line"></span><br><span class="line">2020-03-18 16:38:07 WARN ScheduleMessageTimerThread - Offset not matched. Request offset: 509548460, firstOffset: 0, lastOffset: 6000000, mappedFileSize: 6000000, mappedFiles count: 1</span><br><span class="line"></span><br><span class="line">2020-03-18 16:38:07 WARN ScheduleMessageTimerThread - Offset not matched. Request offset: 665682360, firstOffset: 0, lastOffset: 6000000, mappedFileSize: 6000000, mappedFiles count: 1</span><br><span class="line"></span><br><span class="line">2020-03-18 16:38:07 WARN ScheduleMessageTimerThread - Offset not matched. Request offset: 509548460, firstOffset: 0, lastOffset: 6000000, mappedFileSize: 6000000, mappedFiles count: 1</span><br></pre></td></tr></table></figure>



<h2 id="消息查询"><a href="#消息查询" class="headerlink" title="消息查询"></a>消息查询</h2><p>通过查询发送延迟的消息，发现该消息存储成功；已经存储在了“SCHEDULE_TOPIC_XXXX”中了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin queryMsgById -n x.x.x.x:9876 -i 0A6F160300002A9F000000BACA44720C</span><br><span class="line"></span><br><span class="line">RocketMQLog:WARN No appenders could be found for logger (io.netty.util.internal.PlatformDependent0).</span><br><span class="line"></span><br><span class="line">RocketMQLog:WARN Please initialize the logger system properly.</span><br><span class="line"></span><br><span class="line">OffsetID: 0A6F160300002A9F000000BACA44720C</span><br><span class="line"></span><br><span class="line">OffsetID: 0A6F160300002A9F000000BACA44720C</span><br><span class="line"></span><br><span class="line">Topic: SCHEDULE_TOPIC_XXXX</span><br><span class="line"></span><br><span class="line">Tags: [null]</span><br><span class="line"></span><br><span class="line">Keys: [rocketmq.key.-1351724170]</span><br><span class="line"></span><br><span class="line">Queue ID: 3</span><br><span class="line"></span><br><span class="line">Queue Offset: 142</span><br><span class="line"></span><br><span class="line">CommitLog Offset: 802257400332</span><br><span class="line"></span><br><span class="line">Reconsume Times: 0</span><br><span class="line"></span><br><span class="line">Born Timestamp: 2020-03-18 15:27:37,512</span><br><span class="line"></span><br><span class="line">Store Timestamp: 2020-03-18 15:27:37,513</span><br><span class="line"></span><br><span class="line">Born Host: 10.x.x.x:56650</span><br><span class="line"></span><br><span class="line">Store Host: 10.x.x.x:10911</span><br><span class="line"></span><br><span class="line">System Flag: 0</span><br><span class="line"></span><br><span class="line">Properties: &#123;REAL_TOPIC&#x3D;melon_online_test, KEYS&#x3D;rocketmq.key.-1351724170, UNIQ_KEY&#x3D;0A6F15AB6305070DEA4E5ADD60280023, WAIT&#x3D;true, DELAY&#x3D;4, REAL_QID&#x3D;1&#125;</span><br><span class="line"></span><br><span class="line">Message Body Path: &#x2F;tmp&#x2F;rocketmq&#x2F;msgbodys&#x2F;0A6F15AB6305070DEA4E5ADD60280023</span><br><span class="line"></span><br><span class="line">org.apache.rocketmq.client.exception.MQClientException: CODE: 17 DESC: No topic route info in name server for the topic: SCHEDULE_TOPIC_XXXX</span><br><span class="line"></span><br><span class="line">See http:&#x2F;&#x2F;rocketmq.apache.org&#x2F;docs&#x2F;faq&#x2F; for further details.</span><br><span class="line"></span><br><span class="line">at org.apache.rocketmq.client.impl.MQClientAPIImpl.getTopicRouteInfoFromNameServer(MQClientAPIImpl.java:1351)</span><br><span class="line"></span><br><span class="line">at org.apache.rocketmq.client.impl.MQClientAPIImpl.getTopicRouteInfoFromNameServer(MQClientAPIImpl.java:1321)</span><br><span class="line"></span><br><span class="line">at org.apache.rocketmq.tools.admin.DefaultMQAdminExtImpl.examineTopicRouteInfo(DefaultMQAdminExtImpl.java:305)</span><br><span class="line"></span><br><span class="line">at org.apache.rocketmq.tools.admin.DefaultMQAdminExtImpl.queryTopicConsumeByWho(DefaultMQAdminExtImpl.java:619)</span><br><span class="line"></span><br><span class="line">at org.apache.rocketmq.tools.admin.DefaultMQAdminExtImpl.messageTrackDetail(DefaultMQAdminExtImpl.java:776)</span><br><span class="line"></span><br><span class="line">at org.apache.rocketmq.tools.admin.DefaultMQAdminExt.messageTrackDetail(DefaultMQAdminExt.java:435)</span><br><span class="line"></span><br><span class="line">at org.apache.rocketmq.tools.command.message.QueryMsgByIdSubCommand.printMsg(QueryMsgByIdSubCommand.java:145)</span><br><span class="line"></span><br><span class="line">at org.apache.rocketmq.tools.command.message.QueryMsgByIdSubCommand.queryById(QueryMsgByIdSubCommand.java:49)</span><br><span class="line"></span><br><span class="line">at org.apache.rocketmq.tools.command.message.QueryMsgByIdSubCommand.execute(QueryMsgByIdSubCommand.java:252)</span><br><span class="line"></span><br><span class="line">at org.apache.rocketmq.tools.command.MQAdminStartup.main0(MQAdminStartup.java:138)</span><br><span class="line"></span><br><span class="line">at org.apache.rocketmq.tools.command.MQAdminStartup.main(MQAdminStartup.java:89)</span><br></pre></td></tr></table></figure>



<h2 id="原理回顾"><a href="#原理回顾" class="headerlink" title="原理回顾"></a>原理回顾</h2><p>延迟消息存储时被替换为“SCHEDULE_TOPIC_XXXX”主题，broker会为每个等级的建立定时任务进行调度，将各个等级到时间的消息替换为原来的主题，从而消费者可以消费到该消息。</p>
<p>以上日志加上消息查询结果已存储在“SCHEDULE_TOPIC_XXXX”，可以断定调度环节出问题了，由于offset远远超过最大offset而报错；没能将目标主题成功替换。</p>
<h2 id="报错源码"><a href="#报错源码" class="headerlink" title="报错源码"></a>报错源码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public MappedFile findMappedFileByOffset(final long offset, final boolean returnFirstOnNotFound) &#123;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">MappedFile firstMappedFile &#x3D; this.getFirstMappedFile();</span><br><span class="line"></span><br><span class="line">MappedFile lastMappedFile &#x3D; this.getLastMappedFile();</span><br><span class="line"></span><br><span class="line">if (firstMappedFile !&#x3D; null &amp;&amp; lastMappedFile !&#x3D; null) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这里报错了，每次用offset&#x3D;509548460来查，可是总大小才6000000</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 每次来查报错返回null</span><br><span class="line"></span><br><span class="line">if (offset &lt; firstMappedFile.getFileFromOffset() || offset &gt;&#x3D; lastMappedFile.getFileFromOffset() + this.mappedFileSize) &#123;</span><br><span class="line"></span><br><span class="line">LOG_ERROR.warn(&quot;Offset not matched. Request offset: &#123;&#125;, firstOffset: &#123;&#125;, lastOffset: &#123;&#125;, mappedFileSize: &#123;&#125;, mappedFiles count: &#123;&#125;&quot;,</span><br><span class="line"></span><br><span class="line">offset,</span><br><span class="line"></span><br><span class="line">firstMappedFile.getFileFromOffset(),</span><br><span class="line"></span><br><span class="line">lastMappedFile.getFileFromOffset() + this.mappedFileSize,</span><br><span class="line"></span><br><span class="line">this.mappedFileSize,</span><br><span class="line"></span><br><span class="line">this.mappedFiles.size());</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">log.error(&quot;findMappedFileByOffset Exception&quot;, e);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return null;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>调用位置：ScheduleMessageService#executeOnTimeup</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 根据offset捞取消息内容</span><br><span class="line"></span><br><span class="line">MessageExt msgExt &#x3D; ScheduleMessageService.this.defaultMessageStore.lookMessageByOffset(</span><br><span class="line">offsetPy, sizePy);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 处理结束后处理位点自增</span><br><span class="line"></span><br><span class="line">nextOffset &#x3D; offset + (i &#x2F; ConsumeQueue.CQ_STORE_UNIT_SIZE);</span><br><span class="line">ScheduleMessageService.this.updateOffset(this.delayLevel, nextOffset);</span><br></pre></td></tr></table></figure>



<p>其中offsetPy来自ConsumeQueue；另外delayOffset.json存储延迟消息的处理进度。</p>
<h1 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h1><p>将”delayOffset.json”和”consumequeue/SCHEDULE_TOPIC_XXXX”移到其他目录，相当于删除；逐台重启broker节点。重启结束后，经过验证，延迟消息功能正常发送和消费。</p>
<h1 id="结束了吗？"><a href="#结束了吗？" class="headerlink" title="结束了吗？"></a>结束了吗？</h1><p>看到这里你可能还有疑问，offset如何能增长到665682360这么大的？而且offset完全由broker自身去调度后自增的，并非由客户端上报的。记得前年RocketMQ也出现过类似问题，那时候RocketMQ版本是4.1，在测试环境延迟消息失效。此问题很罕见，一年未必碰到一会，后面会提交给社区讨论下。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ18# RocketMQ关于Broker闪断故障排查</title>
    <url>/posts/89ef1054/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>在2020-03-16 18:00左右收到告警，业务出现发送RocketMQ失败，在约1分钟左右后自动恢复。RocketMQ运行向来稳定，为何也抖动了？</p>
<a id="more"></a>



<h1 id="Broker日志分析"><a href="#Broker日志分析" class="headerlink" title="Broker日志分析"></a>Broker日志分析</h1><h2 id="查看GC日志"><a href="#查看GC日志" class="headerlink" title="查看GC日志"></a>查看GC日志</h2><p>通过查看发时间问题时间附近GC日志并无发现异常。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2020-03-16T17:49:13.785+0800: 13484510.599: Total time for which application threads were stopped: 0.0072354 seconds, Stopping threads took: 0.0001536 seconds</span><br><span class="line"></span><br><span class="line">2020-03-16T18:01:23.149+0800: 13485239.963: [GC pause (G1 Evacuation Pause) (young) 13485239.965: [G1Ergonomics (CSet Construction) start choosing CSet, _pending_cards: 7738, predicted base time: 5.74 ms, remaining time: 194.26 ms, target pause time: 200.00 ms]</span><br><span class="line"></span><br><span class="line">13485239.965: [G1Ergonomics (CSet Construction) add young regions to CSet, eden: 255 regions, survivors: 1 regions, predicted young region time: 0.52 ms]</span><br><span class="line"></span><br><span class="line">13485239.965: [G1Ergonomics (CSet Construction) finish choosing CSet, eden: 255 regions, survivors: 1 regions, old: 0 regions, predicted pause time: 6.26 ms, target pause time: 200.00 ms]</span><br><span class="line"></span><br><span class="line">, 0.0090963 secs]</span><br><span class="line"></span><br><span class="line">[Parallel Time: 2.3 ms, GC Workers: 23]</span><br><span class="line"></span><br><span class="line">[GC Worker Start (ms): Min: 13485239965.1, Avg: 13485239965.4, Max: 13485239965.7, Diff: 0.6]</span><br><span class="line"></span><br><span class="line">[Ext Root Scanning (ms): Min: 0.0, Avg: 0.3, Max: 0.6, Diff: 0.6, Sum: 8.0]</span><br><span class="line"></span><br><span class="line">[Update RS (ms): Min: 0.1, Avg: 0.3, Max: 0.6, Diff: 0.5, Sum: 7.8]</span><br><span class="line"></span><br><span class="line">[Processed Buffers: Min: 2, Avg: 5.7, Max: 11, Diff: 9, Sum: 131]</span><br><span class="line"></span><br><span class="line">[Scan RS (ms): Min: 0.0, Avg: 0.0, Max: 0.1, Diff: 0.1, Sum: 0.8]</span><br><span class="line"></span><br><span class="line">[Code Root Scanning (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.3]</span><br><span class="line"></span><br><span class="line">[Object Copy (ms): Min: 0.2, Avg: 0.5, Max: 0.7, Diff: 0.4, Sum: 11.7]</span><br><span class="line"></span><br><span class="line">[Termination (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.3]</span><br><span class="line"></span><br><span class="line">[Termination Attempts: Min: 1, Avg: 1.0, Max: 1, Diff: 0, Sum: 23]</span><br><span class="line"></span><br><span class="line">[GC Worker Other (ms): Min: 0.0, Avg: 0.2, Max: 0.3, Diff: 0.3, Sum: 3.6]</span><br><span class="line"></span><br><span class="line">[GC Worker Total (ms): Min: 1.0, Avg: 1.4, Max: 1.9, Diff: 0.8, Sum: 32.6]</span><br><span class="line"></span><br><span class="line">[GC Worker End (ms): Min: 13485239966.7, Avg: 13485239966.9, Max: 13485239967.0, Diff: 0.3]</span><br><span class="line"></span><br><span class="line">[Code Root Fixup: 0.0 ms]</span><br><span class="line"></span><br><span class="line">[Code Root Purge: 0.0 ms]</span><br><span class="line"></span><br><span class="line">[Clear CT: 0.9 ms]</span><br><span class="line"></span><br><span class="line">[Other: 5.9 ms]</span><br><span class="line"></span><br><span class="line">[Choose CSet: 0.0 ms]</span><br><span class="line"></span><br><span class="line">[Ref Proc: 1.9 ms]</span><br><span class="line"></span><br><span class="line">[Ref Enq: 0.0 ms]</span><br><span class="line"></span><br><span class="line">[Redirty Cards: 1.0 ms]</span><br><span class="line"></span><br><span class="line">[Humongous Register: 0.0 ms]</span><br><span class="line"></span><br><span class="line">[Humongous Reclaim: 0.0 ms]</span><br><span class="line"></span><br><span class="line">[Free CSet: 0.2 ms]</span><br><span class="line"></span><br><span class="line">[Eden: 4080.0M(4080.0M)-&gt;0.0B(4080.0M) Survivors: 16.0M-&gt;16.0M Heap: 4176.5M(8192.0M)-&gt;96.5M(8192.0M)]</span><br><span class="line"></span><br><span class="line">[Times: user&#x3D;0.05 sys&#x3D;0.00, real&#x3D;0.01 secs]</span><br></pre></td></tr></table></figure>



<h2 id="查看Broker日志"><a href="#查看Broker日志" class="headerlink" title="查看Broker日志"></a>查看Broker日志</h2><p>由日志可以看出：slave与问题节点broker同步信息异常。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2020-03-16 17:55:15 ERROR BrokerControllerScheduledThread1 - SyncTopicConfig Exception, x.x.x.x:10911</span><br><span class="line"></span><br><span class="line">org.apache.rocketmq.remoting.exception.RemotingTimeoutException: wait response on the channel &lt;x.x.x.x:10909&gt; timeout, 3000(ms)</span><br><span class="line"></span><br><span class="line">at org.apache.rocketmq.remoting.netty.NettyRemotingAbstract.invokeSyncImpl(NettyRemotingAbstract.java:427) ~[rocketmq-remoting-4.5.2.jar:4.5.2]</span><br><span class="line"></span><br><span class="line">at org.apache.rocketmq.remoting.netty.NettyRemotingClient.invokeSync(NettyRemotingClient.java:375) ~[rocketmq-remoting-4.5.2.jar:4.5.2]</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">备注：通过查看RocketMQ的集群和GC日志，只能说明但是网络不可用，造成主从同步问题；并未发现Broker自身出问题了。</span><br></pre></td></tr></table></figure>



<!--more-->



<h2 id="系统监控分析"><a href="#系统监控分析" class="headerlink" title="系统监控分析"></a>系统监控分析</h2><h2 id="网络监控"><a href="#网络监控" class="headerlink" title="网络监控"></a>网络监控</h2><p>网络ping在问题时间段发送中断，网络没有流量。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219074012.png"></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219074030.png"></p>
<h2 id="磁盘IO监控"><a href="#磁盘IO监控" class="headerlink" title="磁盘IO监控"></a>磁盘IO监控</h2><p>在问题时间段磁盘IO有陡增</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219074123.png"></p>
<h2 id="CPU监控"><a href="#CPU监控" class="headerlink" title="CPU监控"></a>CPU监控</h2><p>CPU在问题时间段有飙高后回落</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219074154.png"></p>
<h2 id="内存信息"><a href="#内存信息" class="headerlink" title="内存信息"></a>内存信息</h2><p>内存信息没有采集到，由于当时网络中断了。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219074213.png"></p>
<h2 id="集群流量"><a href="#集群流量" class="headerlink" title="集群流量"></a>集群流量</h2><p>除了网络终端未采集到数据外，问题时间断之前只有6000左右的TPS；网络恢复后有个脉冲到11301，然而总体负载很低。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2020-03-16T17:54:05.037+08:00 bike_mq totalTps 6576</span><br><span class="line"></span><br><span class="line">2020-03-16T17:54:15.037+08:00 bike_mq totalTps 6375</span><br><span class="line"></span><br><span class="line">2020-03-16T17:54:25.037+08:00 bike_mq totalTps 6334</span><br><span class="line"></span><br><span class="line">2020-03-16T17:54:35.037+08:00 bike_mq totalTps 6048</span><br><span class="line"></span><br><span class="line">2020-03-16T17:54:45.037+08:00 bike_mq totalTps 6162</span><br><span class="line"></span><br><span class="line">2020-03-16T17:54:55.037+08:00 bike_mq totalTps 6123</span><br><span class="line"></span><br><span class="line">2020-03-16T17:56:50.208+08:00 bike_mq totalTps 5128</span><br><span class="line"></span><br><span class="line">2020-03-16T17:57:19.177+08:00 bike_mq totalTps 6240</span><br><span class="line"></span><br><span class="line">2020-03-16T17:57:24.44+08:00 bike_mq totalTps 11301</span><br><span class="line"></span><br><span class="line">2020-03-16T17:57:30.072+08:00 bike_mq totalTps 9577</span><br><span class="line"></span><br><span class="line">2020-03-16T17:57:31.334+08:00 bike_mq totalTps 9485</span><br><span class="line"></span><br><span class="line">2020-03-16T17:57:32.564+08:00 bike_mq totalTps 9190</span><br><span class="line"></span><br><span class="line">2020-03-16T17:57:33.79+08:00 bike_mq totalTps 7742</span><br><span class="line"></span><br><span class="line">2020-03-16T17:57:35.043+08:00 bike_mq totalTps 7323</span><br><span class="line"></span><br><span class="line">2020-03-16T17:57:36.269+08:00 bike_mq totalTps 7058</span><br><span class="line"></span><br><span class="line">2020-03-16T17:57:37.502+08:00 bike_mq totalTps 6697</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">备注：通过监控看到在问题时间段网络、CPU、磁盘IO都出现了问题；到底是磁盘IO引起CPU飙高的？进而影响网络的；还是CPU先飙高引起网络中断和磁盘IO的。机器上只有一个RocketMQ进程，而且当时流量负载并不高；所以由应用进程导致CPU、网络、磁盘IO等问题是解释不通的。那会不会阿里云抖动呢？但是如果阿里云抖动为何只影响RocketMQ集群的3个节点呢？其他RocketMQ集群没有问题；业务机器也没有发现网络等问题。</span><br></pre></td></tr></table></figure>



<h1 id="Linux系统日志分析"><a href="#Linux系统日志分析" class="headerlink" title="Linux系统日志分析"></a>Linux系统日志分析</h1><p>通过查看问题时间段日志，发现页分配失败“page allocation failure. order:0, mode:0x20”，也就Page不够了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2020-03-16T17:56:07.505715+08:00 VECS0xxxx kernel: &lt;IRQ&gt; [&lt;ffffffff81143c31&gt;] ? __alloc_pages_nodemask+0x7e1&#x2F;0x960</span><br><span class="line"></span><br><span class="line">2020-03-16T17:56:07.505717+08:00 VECS0xxxx kernel: java: page allocation failure. order:0, mode:0x20</span><br><span class="line"></span><br><span class="line">2020-03-16T17:56:07.505719+08:00 VECS0xxxx kernel: Pid: 12845, comm: java Not tainted 2.6.32-754.17.1.el6.x86_64 #1</span><br><span class="line"></span><br><span class="line">2020-03-16T17:56:07.505721+08:00 VECS0xxxx kernel: Call Trace:</span><br><span class="line"></span><br><span class="line">2020-03-16T17:56:07.505724+08:00 VECS0xxxx kernel: &lt;IRQ&gt; [&lt;ffffffff81143c31&gt;] ? __alloc_pages_nodemask+0x7e1&#x2F;0x960</span><br><span class="line"></span><br><span class="line">2020-03-16T17:56:07.505726+08:00 VECS0xxxx kernel: [&lt;ffffffff8148e700&gt;] ? dev_queue_xmit+0xd0&#x2F;0x360</span><br><span class="line"></span><br><span class="line">2020-03-16T17:56:07.505729+08:00 VECS0xxxx kernel: [&lt;ffffffff814cb3e2&gt;] ? ip_finish_output+0x192&#x2F;0x380</span><br><span class="line"></span><br><span class="line">2020-03-16T17:56:07.505732+08:00 VECS0xxxx kernel: [&lt;ffffffff811862e2&gt;] ?</span><br></pre></td></tr></table></figure>



<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="调整内核参数"><a href="#调整内核参数" class="headerlink" title="调整内核参数"></a>调整内核参数</h2><p>系统版本：CentOS 6.10 内核版本：Linux version 2.6.32-754.17.1.el6.x86_64</p>
<p>在sysctl.conf修改参数vm.zone_reclaim_mode和vm.min_free_kbytes。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;sysctl.conf</span><br><span class="line"></span><br><span class="line">vm.zone_reclaim_mode &#x3D; 1</span><br><span class="line"></span><br><span class="line">vm.min_free_kbytes &#x3D; 512000</span><br><span class="line"></span><br><span class="line">sysctl -p &#x2F;etc&#x2F;sysctl.conf</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">备注：修改以上系统参数后，通过两天的观察，内核没有再抛“page allocation failure. order:0, mode:0x20”。</span><br></pre></td></tr></table></figure>

<p>参考文章</p>
<p><a href="https://access.redhat.com/solutions/90883">https://access.redhat.com/solutions/90883</a></p>
<p><a href="https://billtian.github.io/digoal.blog/2017/10/24/03.html">https://billtian.github.io/digoal.blog/2017/10/24/03.html</a></p>
<h2 id="参数含义说明"><a href="#参数含义说明" class="headerlink" title="参数含义说明"></a>参数含义说明</h2><p><strong>min_free_kbytes</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">This is used to force the Linux VM to keep a minimum number</span><br><span class="line"></span><br><span class="line">of kilobytes free. The VM uses this number to compute a</span><br><span class="line"></span><br><span class="line">watermark[WMARK_MIN] value for each lowmem zone in the system.</span><br><span class="line"></span><br><span class="line">Each lowmem zone gets a number of reserved free pages based</span><br><span class="line"></span><br><span class="line">proportionally on its size.</span><br><span class="line"></span><br><span class="line">Some minimal amount of memory is needed to satisfy PF_MEMALLOC</span><br><span class="line"></span><br><span class="line">allocations; if you set this to lower than 1024KB, your system will</span><br><span class="line"></span><br><span class="line">become subtly broken, and prone to deadlock under high loads.</span><br><span class="line"></span><br><span class="line">Setting this too high will OOM your machine instantly.</span><br></pre></td></tr></table></figure>



<p><strong>zone_reclaim_mode</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Zone_reclaim_mode allows someone to set more or less aggressive approaches to</span><br><span class="line"></span><br><span class="line">reclaim memory when a zone runs out of memory. If it is set to zero then no</span><br><span class="line"></span><br><span class="line">zone reclaim occurs. Allocations will be satisfied from other zones &#x2F; nodes</span><br><span class="line"></span><br><span class="line">in the system.</span><br><span class="line"></span><br><span class="line">This is value ORed together of</span><br><span class="line"></span><br><span class="line">1 &#x3D; Zone reclaim on</span><br><span class="line"></span><br><span class="line">2 &#x3D; Zone reclaim writes dirty pages out</span><br><span class="line"></span><br><span class="line">4 &#x3D; Zone reclaim swaps pages</span><br><span class="line"></span><br><span class="line">zone_reclaim_mode is disabled by default. For file servers or workloads</span><br><span class="line"></span><br><span class="line">that benefit from having their data cached, zone_reclaim_mode should be</span><br><span class="line"></span><br><span class="line">left disabled as the caching effect is likely to be more important than</span><br><span class="line"></span><br><span class="line">data locality.</span><br><span class="line"></span><br><span class="line">zone_reclaim may be enabled if it&#39;s known that the workload is partitioned</span><br><span class="line"></span><br><span class="line">such that each partition fits within a NUMA node and that accessing remote</span><br><span class="line"></span><br><span class="line">memory would cause a measurable performance reduction. The page allocator</span><br><span class="line"></span><br><span class="line">will then reclaim easily reusable pages (those page cache pages that are</span><br><span class="line"></span><br><span class="line">currently not used) before allocating off node pages.</span><br><span class="line"></span><br><span class="line">Allowing zone reclaim to write out pages stops processes that are</span><br><span class="line"></span><br><span class="line">writing large amounts of data from dirtying pages on other nodes. Zone</span><br><span class="line"></span><br><span class="line">reclaim will write out dirty pages if a zone fills up and so effectively</span><br><span class="line"></span><br><span class="line">throttle the process. This may decrease the performance of a single process</span><br><span class="line"></span><br><span class="line">since it cannot use all of system memory to buffer the outgoing writes</span><br><span class="line"></span><br><span class="line">anymore but it preserve the memory on other nodes so that the performance</span><br><span class="line"></span><br><span class="line">of other processes running on other nodes will not be affected.</span><br><span class="line"></span><br><span class="line">Allowing regular swap effectively restricts allocations to the local</span><br><span class="line"></span><br><span class="line">node unless explicitly overridden by memory policies or cpuset</span><br><span class="line"></span><br><span class="line">configurations.</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">备注：zone_reclaim_mode默认为0即不启用zone_reclaim模式，1为打开zone_reclaim模式从本地节点回收内存；min_free_kbytesy允许内核使用的最小内存。</span><br></pre></td></tr></table></figure>

<h1 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h1><p>在系统空闲内存低于 watermark[low]时，开始启动内核线程kswapd进行内存回收，直到该zone的空闲内存数量达到watermark[high]后停止回收。如果上层申请内存的速度太快，导致空闲内存降至watermark[min]后，内核就会进行direct reclaim（直接回收），即直接在应用程序的进程上下文中进行回收，再用回收上来的空闲页满足内存申请，因此实际会阻塞应用程序，带来一定的响应延迟，而且可能会触发系统OOM。这是因为watermark[min]以下的内存属于系统的自留内存，用以满足特殊使用，所以不会给用户态的普通申请来用。</p>
<p><strong>min_free_kbytes大小的影响</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">min_free_kbytes设的越大，watermark的线越高，同时三个线之间的buffer量也相应会增加。这意味着会较早的启动kswapd进行回收，且会回收上来较多的内存（直至watermark[high]才会停止），这会使得系统预留过多的空闲内存，从而在一定程度上降低了应用程序可使用的内存量。极端情况下设置min_free_kbytes接近内存大小时，留给应用程序的内存就会太少而可能会频繁地导致OOM的发生。</span><br><span class="line"></span><br><span class="line">min_free_kbytes设的过小，则会导致系统预留内存过小。kswapd回收的过程中也会有少量的内存分配行为（会设上PF_MEMALLOC）标志，这个标志会允许kswapd使用预留内存；另外一种情况是被OOM选中杀死的进程在退出过程中，如果需要申请内存也可以使用预留部分。这两种情况下让他们使用预留内存可以避免系统进入deadlock状态。</span><br></pre></td></tr></table></figure>



<p><strong>三个watermark的计算方法</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">watermark[min] &#x3D; min_free_kbytes换算为page单位即可，假设为min_free_pages。（因为是每个zone各有一套watermark参数，实际计算效果是根据各个zone大小所占内存总大小的比例，而算出来的per zone min_free_pages） watermark[low] &#x3D; watermark[min] * 5 &#x2F; 4 watermark[high] &#x3D; watermark[min] * 3 &#x2F; 2</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">备注：摘自“内存管理参数min_free_kbytes分析”，链接：https:&#x2F;&#x2F;www.dazhuanlan.com</span><br></pre></td></tr></table></figure></div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ17# RocketMQ/Kafka监控项整理</title>
    <url>/posts/7cbb1243/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="系统监控项"><a href="#系统监控项" class="headerlink" title="系统监控项"></a>系统监控项</h1><h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><p>CPU使用率、CPU Load、</p>
<h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>内存使用率</p>
<h2 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h2><p>磁盘使用率、磁盘IO、磁盘IOWAIT</p>
<h2 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h2><p>带宽检测</p>
<a id="more"></a>



<h2 id="实例存活"><a href="#实例存活" class="headerlink" title="实例存活"></a>实例存活</h2><p>集群实例是否存活、实例端口是否可达</p>
<h2 id="JVM监控"><a href="#JVM监控" class="headerlink" title="JVM监控"></a>JVM监控</h2><p>堆内存、Full GC时间等</p>
<h1 id="集群监控项"><a href="#集群监控项" class="headerlink" title="集群监控项"></a>集群监控项</h1><h2 id="集群节点数量"><a href="#集群节点数量" class="headerlink" title="集群节点数量"></a>集群节点数量</h2><p>注：比如RocketMQ集群中有4主4从；当Master节点数量小于4时</p>
<h2 id="集群节点可用性"><a href="#集群节点可用性" class="headerlink" title="集群节点可用性"></a>集群节点可用性</h2><p>注：检测集群节点是否可达以及RT Time</p>
<h2 id="集群写入TPS"><a href="#集群写入TPS" class="headerlink" title="集群写入TPS"></a>集群写入TPS</h2><p>注：例如集群写入TPS压测值的40%</p>
<h2 id="集群消费TPS"><a href="#集群消费TPS" class="headerlink" title="集群消费TPS"></a>集群消费TPS</h2><p>注：集群消费TPS需关注带宽及CPU</p>
<h2 id="集群写入TPS变化率"><a href="#集群写入TPS变化率" class="headerlink" title="集群写入TPS变化率"></a>集群写入TPS变化率</h2><p>注：例如5分钟内集群TPS陡增30%</p>
<h2 id="集群消费TPS变化率"><a href="#集群消费TPS变化率" class="headerlink" title="集群消费TPS变化率"></a>集群消费TPS变化率</h2><p>注：例如5分钟内集群TPS陡增30%</p>
<h2 id="集群日消息总量的变化"><a href="#集群日消息总量的变化" class="headerlink" title="集群日消息总量的变化"></a>集群日消息总量的变化</h2><p>注：例如集群中每日的消息总量监控</p>
<h2 id="Broker写入-消费TPS"><a href="#Broker写入-消费TPS" class="headerlink" title="Broker写入/消费TPS"></a>Broker写入/消费TPS</h2><p>注：单节点的写入/消费TPS</p>
<!--more-->



<h1 id="主题监控项"><a href="#主题监控项" class="headerlink" title="主题监控项"></a>主题监控项</h1><h2 id="主题写入TPS"><a href="#主题写入TPS" class="headerlink" title="主题写入TPS"></a>主题写入TPS</h2><p>注：单一主题的写入速率</p>
<h2 id="主题写入TPS的变化率"><a href="#主题写入TPS的变化率" class="headerlink" title="主题写入TPS的变化率"></a>主题写入TPS的变化率</h2><p>注：例如某一主题5分钟内速率陡增30%</p>
<h2 id="主题日消息量"><a href="#主题日消息量" class="headerlink" title="主题日消息量"></a>主题日消息量</h2><p>注：例如单一主题每日消息量</p>
<h2 id="死信队列监控"><a href="#死信队列监控" class="headerlink" title="死信队列监控"></a>死信队列监控</h2><p>注：被丢入死信队列的消息监控</p>
<h1 id="消费组监控项"><a href="#消费组监控项" class="headerlink" title="消费组监控项"></a>消费组监控项</h1><h2 id="消费积压"><a href="#消费积压" class="headerlink" title="消费积压"></a>消费积压</h2><p>注：积压量的监控</p>
<h2 id="消费TPS"><a href="#消费TPS" class="headerlink" title="消费TPS"></a>消费TPS</h2><p>注：消费速率监控</p>
<h2 id="消费阻塞"><a href="#消费阻塞" class="headerlink" title="消费阻塞"></a>消费阻塞</h2><p>注：消费者隔特定时间未消费数据</p>
<h2 id="消费速率变化"><a href="#消费速率变化" class="headerlink" title="消费速率变化"></a>消费速率变化</h2><p>注：例如5分钟之内消费速率陡降了30%</p>
<h1 id="发送客户端监控项"><a href="#发送客户端监控项" class="headerlink" title="发送客户端监控项"></a>发送客户端监控项</h1><h2 id="发送消息体大小变化"><a href="#发送消息体大小变化" class="headerlink" title="发送消息体大小变化"></a>发送消息体大小变化</h2><p>注：发送消息的大小在小于1K、1～2K、大于5K等的分布</p>
<h2 id="发送耗时变化"><a href="#发送耗时变化" class="headerlink" title="发送耗时变化"></a>发送耗时变化</h2><p>注：单节点消息发送在不通时间范围内的分布</p>
<h2 id="发送速率变化"><a href="#发送速率变化" class="headerlink" title="发送速率变化"></a>发送速率变化</h2><p>注：单个发送节点速率变化</p>
<h2 id="发送成功失败分布"><a href="#发送成功失败分布" class="headerlink" title="发送成功失败分布"></a>发送成功失败分布</h2><p>注：消息发送成功/失败分布情况</p>
<h1 id="消费客户端监控项"><a href="#消费客户端监控项" class="headerlink" title="消费客户端监控项"></a>消费客户端监控项</h1><h2 id="消费速率变化-1"><a href="#消费速率变化-1" class="headerlink" title="消费速率变化"></a>消费速率变化</h2><p>注：单节点速率变化</p>
<h2 id="消费耗时变化"><a href="#消费耗时变化" class="headerlink" title="消费耗时变化"></a>消费耗时变化</h2><p>注：单节点发送耗时分布情况</p>
<h2 id="消费成功失败分布"><a href="#消费成功失败分布" class="headerlink" title="消费成功失败分布"></a>消费成功失败分布</h2><p>注：单节点消费成功失败的分布情况</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ19# RocketMQ集群CPU毛刺问题复盘</title>
    <url>/posts/649ec9da/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>RocketMQ从节点、主节点频繁CPU飙高，很明显的毛刺，很多次从节点直接挂掉了。</p>
<p>详情截图如下：</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219075750.png"></p>
<a id="more"></a>



<h1 id="集群情况"><a href="#集群情况" class="headerlink" title="集群情况"></a>集群情况</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RocketMQ版本使用4.5.2，4主4从模式</span><br><span class="line"></span><br><span class="line">集群tps在8000左右</span><br><span class="line"></span><br><span class="line">单节点配置32C&#x2F;128G&#x2F;1.7T</span><br><span class="line"></span><br><span class="line">其中2从部署在阿里云ECS上，即一个集群6台ECS</span><br><span class="line"></span><br><span class="line">内核版本：Linux version 2.6.32-754.18.2.el6.x86_64 (mockbuild@x86-01.bsys.centos.org) (gcc version 4.4.7 20120313 (Red Hat 4.4.7-23) (GCC) ) #1 SMP Wed Aug 14 16:26:59 UTC 2019</span><br></pre></td></tr></table></figure>



<h1 id="内核参数"><a href="#内核参数" class="headerlink" title="内核参数"></a>内核参数</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vm.overcommit_memory&#x3D;1</span><br><span class="line"></span><br><span class="line">vm.drop_caches&#x3D;1</span><br><span class="line"></span><br><span class="line">vm.zone_reclaim_mode&#x3D;0</span><br><span class="line"></span><br><span class="line">vm.max_map_count&#x3D;655360</span><br><span class="line"></span><br><span class="line">vm.dirty_background_ratio&#x3D;50</span><br><span class="line"></span><br><span class="line">vm.dirty_ratio&#x3D;50</span><br><span class="line"></span><br><span class="line">vm.dirty_writeback_centisecs&#x3D;360000</span><br><span class="line"></span><br><span class="line">vm.page-cluster&#x3D;3</span><br><span class="line"></span><br><span class="line">vm.swappiness&#x3D;1</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">备注：搭建时的内核参数主从一致的，内容如上，之前使用该参数配置在RocketMQ集群4.1版本中，未发生任何异常情况。</span><br></pre></td></tr></table></figure>

<h1 id="从节点JVM参数"><a href="#从节点JVM参数" class="headerlink" title="从节点JVM参数"></a>从节点JVM参数</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;java&#x2F;jdk1.8.0_66&#x2F;bin&#x2F;java -server -Xms8g -Xmx8g -Xmn4g -XX:+UseG1GC -XX:G1HeapRegionSize&#x3D;16m -XX:G1ReservePercent&#x3D;25 -XX:InitiatingHeapOccupancyPercent&#x3D;30 -XX:SoftRefLRUPolicyMSPerMB&#x3D;0 -verbose:gc -Xloggc:&#x2F;dev&#x2F;shm&#x2F;rmq_broker_gc_%p_%t.log -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCApplicationStoppedTime -XX:+PrintAdaptiveSizePolicy -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles&#x3D;5 -XX:GCLogFileSize&#x3D;30m -XX:-OmitStackTraceInFastThrow -XX:+AlwaysPreTouch -XX:MaxDirectMemorySize&#x3D;15g -XX:-UseLargePages -XX:-UseBiasedLocking -Djava.ext.dirs&#x3D;&#x2F;usr&#x2F;java&#x2F;jdk1.8.0_66&#x2F;jre&#x2F;lib&#x2F;ext:&#x2F;workspace&#x2F;rocketmq-all-4.5.2-bin-release&#x2F;bin&#x2F;..&#x2F;lib -cp .:&#x2F;workspace&#x2F;rocketmq-all-4.5.2-bin-release&#x2F;bin&#x2F;..&#x2F;conf:.:&#x2F;usr&#x2F;java&#x2F;jdk1.8.0_66&#x2F;lib&#x2F;tools.jar:&#x2F;usr&#x2F;java&#x2F;jdk1.8.0_66&#x2F;lib&#x2F;dt.jar org.apache.rocketmq.broker.BrokerStartup -c &#x2F;workspace&#x2F;rocketmq-all-4.5.2-bin-release&#x2F;conf&#x2F;2m-2s-async&#x2F;broker-d-s.properties</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">备注：堆内存分配为8G</span><br></pre></td></tr></table></figure>

<h1 id="问题详情"><a href="#问题详情" class="headerlink" title="问题详情"></a>问题详情</h1><h2 id="主节点出现闪断"><a href="#主节点出现闪断" class="headerlink" title="主节点出现闪断"></a>主节点出现闪断</h2><p>在3月16日出现了CPU sys飙高导致broker约有1分钟的不可用，具体系统日志错误为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2020-03-16T17:56:07.505715+08:00 VECS0xxxx kernel: &lt;IRQ&gt; [&lt;ffffffff81143c31&gt;] ? __alloc_pages_nodemask+0x7e1&#x2F;0x960</span><br><span class="line"></span><br><span class="line">2020-03-16T17:56:07.505717+08:00 VECS0xxxx kernel: java: page allocation failure. order:0, mode:0x20</span><br><span class="line"></span><br><span class="line">2020-03-16T17:56:07.505719+08:00 VECS0xxxx kernel: Pid: 12845, comm: java Not tainted 2.6.32-754.17.1.el6.x86_64 #1</span><br><span class="line"></span><br><span class="line">2020-03-16T17:56:07.505721+08:00 VECS0xxxx kernel: Call Trace:</span><br><span class="line"></span><br><span class="line">2020-03-16T17:56:07.505724+08:00 VECS0xxxx kernel: &lt;IRQ&gt; [&lt;ffffffff81143c31&gt;] ? __alloc_pages_nodemask+0x7e1&#x2F;0x960</span><br><span class="line"></span><br><span class="line">2020-03-16T17:56:07.505726+08:00 VECS0xxxx kernel: [&lt;ffffffff8148e700&gt;] ? dev_queue_xmit+0xd0&#x2F;0x360</span><br><span class="line"></span><br><span class="line">2020-03-16T17:56:07.505729+08:00 VECS0xxxx kernel: [&lt;ffffffff814cb3e2&gt;] ? ip_finish_output+0x192&#x2F;0x380</span><br><span class="line"></span><br><span class="line">2020-03-16T17:56:07.505732+08:00 VECS0xxxx kernel: [&lt;ffffffff811862e2&gt;] ?</span><br></pre></td></tr></table></figure>



<p>截图如下：</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219080000.png"></p>
<p>解决方式调整了主节点的内核参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vm.zone_reclaim_mode &#x3D; 1</span><br><span class="line"></span><br><span class="line">vm.min_free_kbytes &#x3D; 512000</span><br></pre></td></tr></table></figure>



<p>当前主节点的内核参数配置为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vm.overcommit_memory&#x3D;1</span><br><span class="line"></span><br><span class="line">vm.drop_caches&#x3D;1</span><br><span class="line"></span><br><span class="line">vm.zone_reclaim_mode&#x3D;0</span><br><span class="line"></span><br><span class="line">vm.max_map_count&#x3D;655360</span><br><span class="line"></span><br><span class="line">vm.dirty_background_ratio&#x3D;25</span><br><span class="line"></span><br><span class="line">vm.dirty_ratio&#x3D;25</span><br><span class="line"></span><br><span class="line">vm.dirty_writeback_centisecs&#x3D;360000</span><br><span class="line"></span><br><span class="line">vm.page-cluster&#x3D;3</span><br><span class="line"></span><br><span class="line">vm.swappiness&#x3D;1</span><br><span class="line"></span><br><span class="line">vm.zone_reclaim_mode &#x3D; 1</span><br><span class="line"></span><br><span class="line">vm.min_free_kbytes &#x3D; 512000</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">备注：主节点详细过程参见下文：</span><br></pre></td></tr></table></figure>

<p>RocketMQ关于Broker闪断故障排查【实战笔记】</p>
<p><a href="https://mp.weixin.qq.com/s/8EE7_MqV-oZBYqtrdrlUIw">https://mp.weixin.qq.com/s/8EE7_MqV-oZBYqtrdrlUIw</a></p>
<h2 id="从节点挂掉情况"><a href="#从节点挂掉情况" class="headerlink" title="从节点挂掉情况"></a>从节点挂掉情况</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">调整主节点时把从节点也统一调整了，从节点也调整成了zone_reclaim_mode和min_free_kbytes参数</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vm.overcommit_memory&#x3D;0</span><br><span class="line"></span><br><span class="line">vm.drop_caches&#x3D;1</span><br><span class="line"></span><br><span class="line">vm.zone_reclaim_mode&#x3D;0</span><br><span class="line"></span><br><span class="line">vm.max_map_count&#x3D;655360</span><br><span class="line"></span><br><span class="line">vm.dirty_background_ratio&#x3D;10</span><br><span class="line"></span><br><span class="line">vm.dirty_ratio&#x3D;10</span><br><span class="line"></span><br><span class="line">vm.dirty_writeback_centisecs&#x3D;360000</span><br><span class="line"></span><br><span class="line">vm.page-cluster&#x3D;3</span><br><span class="line"></span><br><span class="line">vm.swappiness&#x3D;1</span><br><span class="line"></span><br><span class="line">vm.zone_reclaim_mode &#x3D; 1</span><br><span class="line"></span><br><span class="line">vm.min_free_kbytes &#x3D; 512000</span><br></pre></td></tr></table></figure>



<p>此后从节点频繁出现了CPU飙高导致节点挂掉的情况，都是CPU sys在飙高，系统日志如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">30 2020-03-27T10:35:28.769900+08:00 VECSxxxx kernel: INFO: task AliYunDunUpdate:29054 blocked for more than 120 seconds.</span><br><span class="line"></span><br><span class="line">31 2020-03-27T10:35:28.769932+08:00 VECSxxxx kernel: Not tainted 2.6.32-754.17.1.el6.x86_64 #1</span><br><span class="line"></span><br><span class="line">32 2020-03-27T10:35:28.771650+08:00 VECS0xxxx kernel: &quot;echo 0 &gt; &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;hung_task_timeout_secs&quot; disables this message.</span><br><span class="line"></span><br><span class="line">33 2020-03-27T10:35:28.774631+08:00 VECS0xxxx kernel: AliYunDunUpda D ffffffff815592fb 0 29054 1 0x10000080</span><br><span class="line"></span><br><span class="line">34 2020-03-27T10:35:28.777500+08:00 VECS0xxxx kernel: ffff8803ef75baa0 0000000000000082 ffff8803ef75ba68 ffff8803ef75ba64</span><br><span class="line"></span><br><span class="line">35 2020-03-27T10:35:28.780557+08:00 VECS0xxxx kernel: ffff8803ef75bae8 00000000000014a6 002d61b26118849c ffff880099b18c00</span><br><span class="line"></span><br><span class="line">36 2020-03-27T10:35:28.782853+08:00 VECS0xxxx kernel: 00000003f95c0502 0000000000000a2a ffff880488c665f8 ffff8803ef75bfd8</span><br></pre></td></tr></table></figure>



<p>为解决“blocked for more than 120 seconds”问题两次调整从节点dirty参数，从50%调整到25%后还是出现飙高情况，然后调整到10%，最终还是出现CPU飙高，截图如下：</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219080121.png"></p>
<p>系统message日志</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1656 2020-04-01T17:19:52.462310+08:00 VECS0xxxx kernel: INFO: task netstat:30311 blocked for more than 120 seconds.</span><br><span class="line"></span><br><span class="line">1657 2020-04-01T17:19:52.464266+08:00 VECS0xxx kernel: Not tainted 2.6.32-754.18.2.el6.x86_64 #1</span><br><span class="line"></span><br><span class="line">1658 2020-04-01T17:19:52.466011+08:00 VECS0xxxx kernel: &quot;echo 0 &gt; &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;hung_task_timeout_secs&quot; disables this messa ge.</span><br><span class="line"></span><br><span class="line">1659 2020-04-01T17:19:52.468971+08:00 VECS0xxxx kernel: netstat D ffffffff8160d9e0 0 30311 1 0x10000084</span><br><span class="line"></span><br><span class="line">1660 2020-04-01T17:19:52.471907+08:00 VECS0xxx kernel: ffff8801b0443d10 0000000000000082 0000000000000000 ffff88011ffc6ab0</span><br><span class="line"></span><br><span class="line">1661 2020-04-01T17:19:52.474211+08:00 VECS0xxxx kernel: ffff88000005b5c0 ffff88011ffc6ab0 0000275feaea8627 0000000000000002</span><br><span class="line"></span><br><span class="line">1662 2020-04-01T17:19:52.477311+08:00 VECS0xxxx kernel: 00000001029004e5 000000000000030f ffff88011ffc7068 ffff8801b0443fd8</span><br><span class="line"></span><br><span class="line">1663 2020-04-01T17:19:52.477323+08:00 VECS0xxxx kernel: Call Trace:</span><br><span class="line"></span><br><span class="line">1664 2020-04-01T17:19:52.478328+08:00 VECS0xxxx kernel: [&lt;ffffffff811c4b60&gt;] ? mntput_no_expire+0x30&#x2F;0x110</span><br><span class="line"></span><br><span class="line">1665 2020-04-01T17:19:52.482136+08:00 VECS0xxxx kernel: [&lt;ffffffff8155c6d5&gt;] rwsem_down_failed_common+0x95&#x2F;0x1d0</span><br><span class="line"></span><br><span class="line">1666 2020-04-01T17:19:52.482149+08:00 VECS0xxxx kernel: [&lt;ffffffff81244db5&gt;] ? security_inode_permission+0x25&#x2F;0x30</span><br></pre></td></tr></table></figure>



<h1 id="继续调整内核参数"><a href="#继续调整内核参数" class="headerlink" title="继续调整内核参数"></a>继续调整内核参数</h1><p>问题首先发生在主节点，调整min_free_kbytes和zone_reclaim_mode参数后，主节点问题没有再发生。是否由于把从节点的也调整了，导致了从节点CPU sys飙高挂掉？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">将min_free_kbytes调低来看下从节点的运行情况，将min_free_kbytes调低到128000</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：但是很遗憾，不管内核参数如何调整。CPU毛刺现象只能缓解，却不能有效根除。</span><br></pre></td></tr></table></figure>

<p>CPU spike on slave node: <a href="https://github.com/apache/rocketmq/issues/1910">https://github.com/apache/rocketmq/issues/1910</a></p>
<!--more-->



<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>为此特在社区提了个问题，也得到了RocketMQ创始人冯嘉和RocketMQ Committer杜恒两位大佬的关注和指点。杜恒大佬有提Linux内核2.6的操作系统有bug会导致类似情况。回想一下原东家的RocketMQ集群运行以来从未出现过如此诡异现象，虽让好友将内核版本发与我，内核版本为3.10。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219080227.png"></p>
<p>问题必须解决，这里是生产环境。所以对线上所有集群主从节点全部从centos6升级到centos7，内核版本也从从2.6升级到3.10。升级后通过半个月左右的观察，未出现CPU毛刺问题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Linux version 3.10.0-1062.4.1.el7.x86_64 (mockbuild@kbuilder.bsys.centos.org) (gcc version 4.8.5 20150623 (Red Hat 4.8.5-39) (GCC) ) #1 SMP Fri Oct 18 17:15:30 UTC 2019</span><br></pre></td></tr></table></figure>



</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ2# RocketMQ Consumer命令</title>
    <url>/posts/e790de00/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="创建订阅组"><a href="#创建订阅组" class="headerlink" title="创建订阅组"></a>创建订阅组</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin updateSubGroup -n localhost:9876 -c DefaultCluster -g zto-tst-consumer</span><br></pre></td></tr></table></figure>



<h1 id="删除订阅组"><a href="#删除订阅组" class="headerlink" title="删除订阅组"></a>删除订阅组</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin deleteSubGroup -n 192.168.1.x:9876 -c AdpMqCluster -g CODCANCELSIGN</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option PermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">delete subscription group [CODCANCELSIGN] from broker [192.168.1.x:10911] in cluster [AdpMqCluster] success.</span><br><span class="line"></span><br><span class="line">delete subscription group [CODCANCELSIGN] from broker [192.168.1.x:10911] in cluster [AdpMqCluster] success.</span><br><span class="line"></span><br><span class="line">delete subscription group [CODCANCELSIGN] from broker [192.168.1.x:10919] in cluster [AdpMqCluster] success.</span><br><span class="line"></span><br><span class="line">delete subscription group [CODCANCELSIGN] from broker [192.168.1.x:10915] in cluster [AdpMqCluster] success.</span><br><span class="line"></span><br><span class="line">delete subscription group [CODCANCELSIGN] from broker [192.168.1.x:10915] in cluster [AdpMqCluster] success.</span><br><span class="line"></span><br><span class="line">delete subscription group [CODCANCELSIGN] from broker [192.168.1.x:10919] in cluster [AdpMqCluster] success.</span><br><span class="line"></span><br><span class="line">delete topic [%RETRY%CODCANCELSIGN] from cluster [xMqCluster] success.</span><br><span class="line"></span><br><span class="line">delete topic [%RETRY%CODCANCELSIGN] from NameServer success.</span><br><span class="line"></span><br><span class="line">delete topic [%DLQ%CODCANCELSIGN] from cluster [xMqCluster] success.</span><br><span class="line"></span><br><span class="line">delete topic [%DLQ%CODCANCELSIGN] from NameServer success.</span><br></pre></td></tr></table></figure>



<a id="more"></a>



<h1 id="查看消费组情况及IP地址"><a href="#查看消费组情况及IP地址" class="headerlink" title="查看消费组情况及IP地址"></a>查看消费组情况及IP地址</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin consumerStatus -g TraceToCaiNiao -n 192.168.1.x:9876</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option PermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">001 192.168.12.122@25063 V3_5_8 1539756615406&#x2F;192.168.x.x@25063</span><br><span class="line"></span><br><span class="line">002 192.168.13.96@3351 V3_5_8 1539756615406&#x2F;192.168.x.x@3351</span><br><span class="line"></span><br><span class="line">003 192.168.x.x@13385 V3_5_8 1539756615406&#x2F;192.168.x.x@13385</span><br><span class="line"></span><br><span class="line">004 192.168.x.x@6691 V3_5_8 1539756615406&#x2F;192.168.x.x@6691</span><br></pre></td></tr></table></figure>



<h1 id="查看消费组情况"><a href="#查看消费组情况" class="headerlink" title="查看消费组情况"></a>查看消费组情况</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin consumerProgress -n 192.168.1.x:9876 -g SortComplementConsumer</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option PermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">Topic Broker Name QID Broker Offset Consumer Offset Diff LastTime</span><br><span class="line"></span><br><span class="line">%RETRY%SortComplementConsumer broker-a 0 1 1 0 2018-10-22 12:43:13</span><br><span class="line"></span><br><span class="line">%RETRY%SortComplementConsumer broker-b 0 2 2 0 2018-10-22 12:43:13</span><br><span class="line"></span><br><span class="line">%RETRY%SortComplementConsumer broker-c 0 2 2 0 2018-10-22 12:43:28</span><br><span class="line"></span><br><span class="line">%RETRY%SortComplementConsumer broker-d 0 2 2 0 2018-10-22 12:44:33</span><br><span class="line"></span><br><span class="line">SCANRECORD broker-a 0 39717505 39717502 3 2018-10-22 13:53:21</span><br><span class="line"></span><br><span class="line">SCANRECORD broker-a 1 39721504 39721502 2 2018-10-22 13:53:21</span><br><span class="line"></span><br><span class="line">SCANRECORD broker-a 2 39733704 39733703 1 2018-10-22 13:53:21</span><br></pre></td></tr></table></figure>





</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ20# RocketMQ集群实现平滑扩缩容</title>
    <url>/posts/69ff2739/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="运维需求"><a href="#运维需求" class="headerlink" title="运维需求"></a>运维需求</h1><p>在RocketMQ集群的实践中，对集群扩容、缩容、节点下线等运维做到平滑、业务无感知、数据无丢失，这个对于集群运维的同学来说非常重要。</p>
<p>比如前些日子出现的问题，由于线上集群频繁出现CPU毛刺甚至直接挂掉并伴随着集群抖动，对内核参数的调整只能减缓毛刺却不能消除抖动。集群抖动业务使用会伴随着发送延迟告警，始终是个必须处理的隐患。最终决定更换操作系统即更换内核。</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">集群信息: RocketMQ版本4.5.2</span><br><span class="line"></span><br><span class="line">主从信息：4主4从 broker-a, broker-b, broker-c, broker-d,</span><br><span class="line"></span><br><span class="line">broker-a(slave), broker-b(slave), broker-c(slave), broker-d(slave)</span><br></pre></td></tr></table></figure>

<p>操作系统: centos6</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Linux version 2.6.32-754.18.2.el6.x86_64 (mockbuild@x86-01.bsys.centos.org) (gcc version 4.4.7 20120313 (Red Hat 4.4.7-23) (GCC) ) #1 SMP Wed Aug 14 16:26:59 UTC 2019</span><br></pre></td></tr></table></figure>

<p>目标系统：centos7</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Linux version 3.10.0-1062.4.1.el7.x86_64 (mockbuild@kbuilder.bsys.centos.org) (gcc version 4.8.5 20150623 (Red Hat 4.8.5-39) (GCC) ) #1 SMP Fri Oct 18 17:15:30 UTC 2019</span><br></pre></td></tr></table></figure>



<p>集群的部署如下下图所示：</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219080526.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">其需要简单概括如下，就是要将上述集群的操作系统内核从 Centos6 升级到 Centos7,但业务不能停。</span><br></pre></td></tr></table></figure>



<h1 id="平滑扩容"><a href="#平滑扩容" class="headerlink" title="平滑扩容"></a>平滑扩容</h1><h2 id="下线从节点"><a href="#下线从节点" class="headerlink" title="下线从节点"></a>下线从节点</h2><p>从节点正常关闭rocketmq，从节点下线对业务不会造成影响，如果配置，slaveReadEnable=true，从节点的通常在消息回溯延迟超过内存消息的40%时使用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh bin&#x2F;mqshutdown broker</span><br><span class="line"></span><br><span class="line">or</span><br><span class="line"></span><br><span class="line">kill pid</span><br></pre></td></tr></table></figure>



<p>从节点下线之后，集群的部署情况如下图所示：</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219080558.png"></p>
<p>直接停掉从节点，并不影响当前业务的使用，因为写，读都可以通过主节点，对业务无影响。</p>
<h2 id="重组主从模式"><a href="#重组主从模式" class="headerlink" title="重组主从模式"></a>重组主从模式</h2><p>新申请4台机器与原从节点重新组合成主从关系。</p>
<p>具体操作为将新申请的4台机器的内核全部升级为Centos7内核，并部署为 broker-a1,broker-b1,broker-c1,broker-d1，这里如果使用 broker-e,f,f,h 命名，会造成流量切斜，导致消费不均衡，原因在文末会给出，大家不妨思考一下。</p>
<p>然后将上一步下掉的从节点，其内核全部升级为 centos7的内核。并将这些节点设置为新增4个主节点的从，其部署结构如下图所示：</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219080619.png"></p>
<p>此时集群中变成8主，其中新增集群有从节点，即装有centor7内核的新机器构成了4主4从，接下来就只需要将内核为centos6的主节点的数据消费完成，并下线即可。</p>
<!--more-->



<h1 id="平滑缩容"><a href="#平滑缩容" class="headerlink" title="平滑缩容"></a>平滑缩容</h1><p>接下来主要是将装有centos6内核的旧机器从集群中移除，具体操作如下。</p>
<h2 id="关闭broker写权限"><a href="#关闭broker写权限" class="headerlink" title="关闭broker写权限"></a>关闭broker写权限</h2><p>逐台关闭 broker-a, broker-b, broker-c, broker-d 的写入权限，其中4表示只读权限，6表示读写权限。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin updateBrokerConfig -b x.x.x.x:10911 -n x.x.x.x:9876 -k brokerPermission -v 4</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option PermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">update broker config success, x.x.x.x:10911</span><br></pre></td></tr></table></figure>



<h2 id="验证broker流量情况"><a href="#验证broker流量情况" class="headerlink" title="验证broker流量情况"></a>验证broker流量情况</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin clusterList -n x.x.x.x:9876</span><br></pre></td></tr></table></figure>

<p>等待broker出入流量均归零</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219080712.png"></p>
<p>验证broker积压情况</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin brokerConsumeStats -b x.x.x.x:10911 -n x.x.x.x:9876</span><br></pre></td></tr></table></figure>



<p>观察最后一行Diff Total等于0时表示该节点已经没有积压，即全部消费完毕。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219080746.png"></p>
<h2 id="节点下线"><a href="#节点下线" class="headerlink" title="节点下线"></a>节点下线</h2><p>当节点流量和积压都为0时，节点可以下线了。如果broker一直有流量或者积压一直存在呢？通常线上集群的存储时间为2～3天；可以在过了存储时间后再安排下线。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh bin&#x2F;mqshutdown broker</span><br><span class="line"></span><br><span class="line">or</span><br><span class="line"></span><br><span class="line">kill pid</span><br></pre></td></tr></table></figure>



<h1 id="问题答疑"><a href="#问题答疑" class="headerlink" title="问题答疑"></a>问题答疑</h1><p>上文中有提到过扩容新增节点时命名时不要使用 broker-e, broker-f, broker-g, broker-h；而采用broker-a1, broker-b1, broker-c1, broker-d1。</p>
<p>按照默认平均分配消费算法，如果采用第一种命名，当关闭broker-a, broker-b, broker-c, broker-d的写入权限时，数据会全部集中在broker-e, broker-f, broker-g, broker-h节点，假如线上部署了四台消费机器，会有两台机器分到broker-a, broker-b, broker-c, broker-d的分区，而另外两台机器分到broker-e, broker-f, broker-g, broker-h的分区。</p>
<p>而broker-a, broker-b, broker-c, broker-d节点的写权限被关闭后，会造成其中两台节点无数据，数据全部分配到另外的消费机器上。</p>
<p>因为只是关闭了broker-a,b,c,d的写权限，读权限未关闭，但如果使用broker-a,a1，b,b1这种命名方式，就能平衡其流量，不至于连续出现大部分队列上无数据的情况，使消费者负载趋于均衡。</p>
<p>在不影响业务的情况下，把集群内所有的节点全部重新更新内核就是这么溜，欢迎留言与作者互动，共同交流。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ21# 为何建议关闭RocketMQ预热配置</title>
    <url>/posts/a46a67ee/</url>
    <content><![CDATA[<div id="vip-container"><p>RocketMQ提供了一个预热配置项warmMapedFileEnable默认为关闭状态。曾在文章RocketMQ存储–映射文件预热【源码笔记】分析过文件预热流程。在预热文件时会填充1个G的假值0作为占位符，提前分配物理内存，防止消息写入时发生缺页异常。如此特性正如文章标题所说，为何建议关闭RocketMQ预热配置呢？</p>
<a id="more"></a>



<h1 id="服务端监控"><a href="#服务端监控" class="headerlink" title="服务端监控"></a>服务端监控</h1><h2 id="日志监控"><a href="#日志监控" class="headerlink" title="日志监控"></a>日志监控</h2><p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219081057.png"></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219081114.png"></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219081131.png"></p>
<h2 id="CPU情况"><a href="#CPU情况" class="headerlink" title="CPU情况"></a>CPU情况</h2><p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219081205.png"></p>
<p>由服务端日志可以看出，在预热时broker会发生较长的耗时，10～30秒不等，CPU也会有小幅抖动，这会造成什么影响呢？接着看下文</p>
<!--more-->



<h1 id="客户端发送监控"><a href="#客户端发送监控" class="headerlink" title="客户端发送监控"></a>客户端发送监控</h1><p>在broker预热时，客户端耗时长达5秒。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219081226.png"></p>
<p>在broker预热时，客户端耗时长达6秒</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219081243.png"></p>
<p>在此时间段，业务应用伴随着大量超时报警。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>在broker预热时，往往伴随着磁盘写入耗时过长、CPU小幅抖动、业务具体表现为发送耗时过长，超时错误增多。关闭预热配置从集群TPS摸高情况来看并未有明显的差异，但是从稳定性角度关闭却很有必要。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ22# RocketMQ内存传输及4.7消费线程参数设置</title>
    <url>/posts/fe0b8776/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>RocketMQ配置中有一个设置项为transferMsgByHeap，即是否通过堆内存传输数据。在文章“RocketMQ存储–同步刷盘和异步刷盘”中对其进行过梳理。那transferMsgByHeap是开启好呢？还是关闭好！第二个问题是可以设置消费的线程数，由于无界队列所以只需要设置最小线程数consumeThreadMin即可，那在rocket-client4.7版本中还能这么用吗？</p>
<a id="more"></a>

<h1 id="transferMsgByHeap误解"><a href="#transferMsgByHeap误解" class="headerlink" title="transferMsgByHeap误解"></a>transferMsgByHeap误解</h1><p>transferMsgByHeap设置为false时，通过堆外内存传输数据，相比堆内存传输减少了数据拷贝、零字节拷贝、效率更高，所以关闭transferMsgByHeap应该成为我们的优先选择，但是实践来看，你或许会改变想法，下面是transferMsgByHeap=false，客户端大量超时错误时的日志截图。</p>
<h2 id="Broker日志截图"><a href="#Broker日志截图" class="headerlink" title="Broker日志截图"></a>Broker日志截图</h2><p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219081609.png"></p>
<h2 id="CPU日志截图"><a href="#CPU日志截图" class="headerlink" title="CPU日志截图"></a>CPU日志截图</h2><p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219081632.png"></p>
<h2 id="系统日志截图"><a href="#系统日志截图" class="headerlink" title="系统日志截图"></a>系统日志截图</h2><p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219081704.png"></p>
<h2 id="源码报错截图"><a href="#源码报错截图" class="headerlink" title="源码报错截图"></a>源码报错截图</h2><p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219082807.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：你看到这里会发现，在关闭transferMsgByHeap时，可能造成堆外内存分配不够，触发系统内存回收和落盘操作。此时CPU会有一个陡坡，具体客户端表现为发送大量超时。解决方式开启transferMsgByHeap即可，让运行更加平稳。</span><br></pre></td></tr></table></figure>



<!--more-->



<h1 id="消费的最小线程数"><a href="#消费的最小线程数" class="headerlink" title="消费的最小线程数"></a>消费的最小线程数</h1><p>我们在使用rocketmq消费时，有两个参数consumeThreadMin和consumeThreadMax。在以往的版本中，我们只需要设置consumeThreadMin即可，例如consumeThreadMin=64。在rocket-client4.7版本中，如果设置consumeThreadMin=64会导致消费失败，下面看下原因。</p>
<h2 id="错误提示"><a href="#错误提示" class="headerlink" title="错误提示"></a>错误提示</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">org.apache.rocketmq.client.exception.MQClientException: consumeThreadMin (64) is larger than consumeThreadMax (20)</span><br></pre></td></tr></table></figure>



<h2 id="源码原因"><a href="#源码原因" class="headerlink" title="源码原因"></a>源码原因</h2><p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219082853.png"></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219082913.png"></p>
<p>小结：在rocketmq-client新版本中，增加了consumeThreadMax的判断。当consumeThreadMin大于20时需要同时设置consumeThreadMax，所以单独设置consumeThreadMin=64会抛出错误导致消费失败。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ23# RocketMQ消息存储概览</title>
    <url>/posts/96e2eb1a/</url>
    <content><![CDATA[<div id="vip-container"><p>先梳理消息存储主干流程。本分切分为两部分，第一部分消息存储流程概览，主要为校验流程；第二部分CommitLog存储概览，即消息存储流程。</p>
<h1 id="消息存储流程概览"><a href="#消息存储流程概览" class="headerlink" title="消息存储流程概览"></a>消息存储流程概览</h1><p>调用链</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">@1 SendMessageProcessor#sendMessage</span><br><span class="line"></span><br><span class="line"><span class="comment">//消息存储</span></span><br><span class="line"></span><br><span class="line">PutMessageResult putMessageResult = <span class="keyword">this</span>.brokerController.getMessageStore().putMessage(msgInner);</span><br><span class="line"></span><br><span class="line">@2 DefaultMessageStore#putMessage</span><br></pre></td></tr></table></figure>



<a id="more"></a>



<p>流程图</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219132807.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">备注：PageCache是否繁忙，内存锁定时间为1秒，在集群流量负载很高时可能出现system busy，broker buys等异常信息。</span><br></pre></td></tr></table></figure>

<p>源代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PutMessageResult <span class="title">putMessage</span><span class="params">(MessageExtBrokerInner msg)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果消息存储服务已关闭，则消息写入被拒绝</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.shutdown) &#123;</span><br><span class="line"></span><br><span class="line">log.warn(<span class="string">&quot;message store has shutdown, so putMessage is forbidden&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.SERVICE_NOT_AVAILABLE, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Slave不处理消息存储</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (BrokerRole.SLAVE == <span class="keyword">this</span>.messageStoreConfig.getBrokerRole()) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> value = <span class="keyword">this</span>.printTimes.getAndIncrement();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((value % <span class="number">50000</span>) == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">log.warn(<span class="string">&quot;message store is slave mode, so putMessage is forbidden &quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.SERVICE_NOT_AVAILABLE, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果消息存储服务不可写，则消息写入会被拒绝</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//出现该错误可能磁盘已满</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.runningFlags.isWriteable()) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> value = <span class="keyword">this</span>.printTimes.getAndIncrement();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((value % <span class="number">50000</span>) == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">log.warn(<span class="string">&quot;message store is not writeable, so putMessage is forbidden &quot;</span> + <span class="keyword">this</span>.runningFlags.getFlagBits());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.SERVICE_NOT_AVAILABLE, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.printTimes.set(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Topic长度的限制不能超过127个字节</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (msg.getTopic().length() &gt; Byte.MAX_VALUE) &#123;</span><br><span class="line"></span><br><span class="line">log.warn(<span class="string">&quot;putMessage message topic length too long &quot;</span> + msg.getTopic().length());</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消息属性长度检查不能超过32K</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (msg.getPropertiesString() != <span class="keyword">null</span> &amp;&amp; msg.getPropertiesString().length() &gt; Short.MAX_VALUE) &#123;</span><br><span class="line"></span><br><span class="line">log.warn(<span class="string">&quot;putMessage message properties length too long &quot;</span> + msg.getPropertiesString().length());</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.PROPERTIES_SIZE_EXCEEDED, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断PageCache是否繁忙：阀值[osPageCacheBusyTimeOutMills = 1000 ] 比较时间为当前时间与Commit Lock时间之差</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果返回true，意味着此时有消息在写入CommitLog，且那条消息的写入耗时较长（超过1s），则本条消息不再写入</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回内存页写入繁忙</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.isOSPageCacheBusy()) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.OS_PAGECACHE_BUSY, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> beginTime = <span class="keyword">this</span>.getSystemClock().now();</span><br><span class="line"></span><br><span class="line"><span class="comment">//将消息写入CommitLog</span></span><br><span class="line"></span><br><span class="line">PutMessageResult result = <span class="keyword">this</span>.commitLog.putMessage(msg);</span><br><span class="line"></span><br><span class="line"><span class="comment">//消息写入时间过长，发出警告</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> eclipseTime = <span class="keyword">this</span>.getSystemClock().now() - beginTime;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (eclipseTime &gt; <span class="number">500</span>) &#123;</span><br><span class="line"></span><br><span class="line">log.warn(<span class="string">&quot;putMessage not in lock eclipse time(ms)=&#123;&#125;, bodyLength=&#123;&#125;&quot;</span>, eclipseTime, msg.getBody().length);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对消息的存储耗时进行分级记录，并记录当前所有消息存储时的最大耗时</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.storeStatsService.setPutMessageEntireTimeMax(eclipseTime);</span><br><span class="line"></span><br><span class="line"><span class="comment">//记录存粗失败次数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> == result || !result.isOk()) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.storeStatsService.getPutMessageFailedTimes().incrementAndGet();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<!--more-->



<h1 id="CommitLog存储流程"><a href="#CommitLog存储流程" class="headerlink" title="CommitLog存储流程"></a>CommitLog存储流程</h1><p>调用链</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">@1 DefaultMessageStore#putMessage</span><br><span class="line"></span><br><span class="line"><span class="comment">//将消息写入CommitLog</span></span><br><span class="line"></span><br><span class="line">PutMessageResult result = <span class="keyword">this</span>.commitLog.putMessage(msg);</span><br><span class="line"></span><br><span class="line">@2 CommitLog#putMessage</span><br></pre></td></tr></table></figure>



<p>流程图</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219132948.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">备注：此时写入消息并没有写入磁盘，而是写入了writeBuffer或者mappedByteBuffer（PageCache或堆外内存）</span><br></pre></td></tr></table></figure>

<p>源代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public PutMessageResult putMessage(final MessageExtBrokerInner msg) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Set the storage time</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设置消息存储时间（存储到Broker的时间）</span><br><span class="line"></span><br><span class="line">msg.setStoreTimestamp(System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Set the message body BODY CRC (consider the most appropriate setting</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; on the client)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Message Body的循环冗余校验码，防止消息体内容被篡改</span><br><span class="line"></span><br><span class="line">msg.setBodyCRC(UtilAll.crc32(msg.getBody()));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Back to Results</span><br><span class="line"></span><br><span class="line">AppendMessageResult result &#x3D; null;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;统计存储耗时相关的Metric</span><br><span class="line"></span><br><span class="line">StoreStatsService storeStatsService &#x3D; this.defaultMessageStore.getStoreStatsService();</span><br><span class="line"></span><br><span class="line">String topic &#x3D; msg.getTopic();</span><br><span class="line"></span><br><span class="line">int queueId &#x3D; msg.getQueueId();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取消息类型</span><br><span class="line"></span><br><span class="line">final int tranType &#x3D; MessageSysFlag.getTransactionValue(msg.getSysFlag());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;不处理事务消息</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;重试(延时)消息发到SCHEDULE_TOPIC中</span><br><span class="line"></span><br><span class="line">if (tranType &#x3D;&#x3D; MessageSysFlag.TRANSACTION_NOT_TYPE&#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">|| tranType &#x3D;&#x3D; MessageSysFlag.TRANSACTION_COMMIT_TYPE) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Delay Delivery</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;延时投递时间级别</span><br><span class="line"></span><br><span class="line">if (msg.getDelayTimeLevel() &gt; 0) &#123;</span><br><span class="line"></span><br><span class="line">if (msg.getDelayTimeLevel() &gt; this.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel()) &#123;</span><br><span class="line"></span><br><span class="line">msg.setDelayTimeLevel(this.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将Topic更改为 SCHEDULE_TOPIC_XXXX</span><br><span class="line"></span><br><span class="line">topic &#x3D; ScheduleMessageService.SCHEDULE_TOPIC;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;根据延时级别获取延时消息新队列ID（queueId等于延时级别-1）</span><br><span class="line"></span><br><span class="line">queueId &#x3D; ScheduleMessageService.delayLevel2QueueId(msg.getDelayTimeLevel());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Backup real topic, queueId</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将消息中原topic和queueId存入到消息属性中</span><br><span class="line"></span><br><span class="line">MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_TOPIC, msg.getTopic());</span><br><span class="line"></span><br><span class="line">MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_QUEUE_ID, String.valueOf(msg.getQueueId()));</span><br><span class="line"></span><br><span class="line">msg.setPropertiesString(MessageDecoder.messageProperties2String(msg.getProperties()));</span><br><span class="line"></span><br><span class="line">msg.setTopic(topic);</span><br><span class="line"></span><br><span class="line">msg.setQueueId(queueId);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">long eclipseTimeInLock &#x3D; 0;</span><br><span class="line"></span><br><span class="line">MappedFile unlockMappedFile &#x3D; null;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取最新的日志文件CommitLog 内存映射文件 零拷贝</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;mappedFileQueue 管理这些连续的CommitLog文件</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;MappedFile 和 MappedFileQueue高性能的磁盘接口</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;mappedFileQueue可以理解为commitLog文件夹，而MappedFile对应文件夹下的文件</span><br><span class="line"></span><br><span class="line">MappedFile mappedFile &#x3D; this.mappedFileQueue.getLastMappedFile();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;加锁，默认使用自旋锁。</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;依赖于messageStoreConfig#useReentrantLockWhenPutMessage配置</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;putMessage会有多个工作线程并行处理，所以需要加锁。串行写入commitLog</span><br><span class="line"></span><br><span class="line">putMessageLock.lock(); &#x2F;&#x2F;spin or ReentrantLock ,depending on store config</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">long beginLockTimestamp &#x3D; this.defaultMessageStore.getSystemClock().now();</span><br><span class="line"></span><br><span class="line">this.beginTimeInLock &#x3D; beginLockTimestamp;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Here settings are stored timestamp, in order to ensure an orderly</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; global</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;再次设置时间戳全局有序</span><br><span class="line"></span><br><span class="line">msg.setStoreTimestamp(beginLockTimestamp);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;文件已满或者没有映射文件重新创建一个文件</span><br><span class="line"></span><br><span class="line">if (null &#x3D;&#x3D; mappedFile || mappedFile.isFull()) &#123;</span><br><span class="line"></span><br><span class="line">mappedFile &#x3D; this.mappedFileQueue.getLastMappedFile(0); &#x2F;&#x2F; Mark: NewFile may be cause noise</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建映射文件失败（可能磁盘已满）</span><br><span class="line"></span><br><span class="line">if (null &#x3D;&#x3D; mappedFile) &#123;</span><br><span class="line"></span><br><span class="line">log.error(&quot;create maped file1 error, topic: &quot; + msg.getTopic() + &quot; clientAddr: &quot; + msg.getBornHostString());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;消息写入完成后，先将beginTimeInLock设置为0，然后释放锁</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;该值用来计算消息写入耗时。写入新消息前，会根据该值来检查操作系统内存页写入是否繁忙</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;如果上一条消息在1s内没有成功写入，则本次消息不再写入</span><br><span class="line"></span><br><span class="line">beginTimeInLock &#x3D; 0;</span><br><span class="line"></span><br><span class="line">return new PutMessageResult(PutMessageStatus.CREATE_MAPEDFILE_FAILED, null);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;向映射文件中写入消息</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;注意：只是将消息写入映射文件中的writeBuffer&#x2F;mappedByteBuffer，没有刷盘</span><br><span class="line"></span><br><span class="line">result &#x3D; mappedFile.appendMessage(msg, this.appendMessageCallback);</span><br><span class="line"></span><br><span class="line">switch (result.getStatus()) &#123;</span><br><span class="line"></span><br><span class="line">case PUT_OK: &#x2F;&#x2F;消息成功写入</span><br><span class="line"></span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;文件已经到结尾了，重新建一个新的mappedFile.</span><br><span class="line"></span><br><span class="line">case END_OF_FILE: &#x2F;&#x2F;当前CommitLog可用空间不足</span><br><span class="line"></span><br><span class="line">unlockMappedFile &#x3D; mappedFile;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Create a new file, re-write the message</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建新的CommitLog，并重新写入消息</span><br><span class="line"></span><br><span class="line">mappedFile &#x3D; this.mappedFileQueue.getLastMappedFile(0);</span><br><span class="line"></span><br><span class="line">if (null &#x3D;&#x3D; mappedFile) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; XXX: warn and notify me</span><br><span class="line"></span><br><span class="line">log.error(&quot;create maped file2 error, topic: &quot; + msg.getTopic() + &quot; clientAddr: &quot; + msg.getBornHostString());</span><br><span class="line"></span><br><span class="line">beginTimeInLock &#x3D; 0;</span><br><span class="line"></span><br><span class="line">return new PutMessageResult(PutMessageStatus.CREATE_MAPEDFILE_FAILED, result);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result &#x3D; mappedFile.appendMessage(msg, this.appendMessageCallback);</span><br><span class="line"></span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">case MESSAGE_SIZE_EXCEEDED: &#x2F;&#x2F;消息长度超过了最大阀值</span><br><span class="line"></span><br><span class="line">case PROPERTIES_SIZE_EXCEEDED: &#x2F;&#x2F;消息属性超过了最大阀值</span><br><span class="line"></span><br><span class="line">beginTimeInLock &#x3D; 0;</span><br><span class="line"></span><br><span class="line">return new PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, result);</span><br><span class="line"></span><br><span class="line">case UNKNOWN_ERROR: &#x2F;&#x2F;未知错误</span><br><span class="line"></span><br><span class="line">beginTimeInLock &#x3D; 0;</span><br><span class="line"></span><br><span class="line">return new PutMessageResult(PutMessageStatus.UNKNOWN_ERROR, result);</span><br><span class="line"></span><br><span class="line">default:</span><br><span class="line"></span><br><span class="line">beginTimeInLock &#x3D; 0;</span><br><span class="line"></span><br><span class="line">return new PutMessageResult(PutMessageStatus.UNKNOWN_ERROR, result);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">eclipseTimeInLock &#x3D; this.defaultMessageStore.getSystemClock().now() - beginLockTimestamp;</span><br><span class="line"></span><br><span class="line">beginTimeInLock &#x3D; 0;</span><br><span class="line"></span><br><span class="line">&#125; finally &#123;</span><br><span class="line"></span><br><span class="line">putMessageLock.unlock(); &#x2F;&#x2F;释放锁</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (eclipseTimeInLock &gt; 500) &#123;</span><br><span class="line"></span><br><span class="line">log.warn(&quot;[NOTIFYME]putMessage in lock cost time(ms)&#x3D;&#123;&#125;, bodyLength&#x3D;&#123;&#125; AppendMessageResult&#x3D;&#123;&#125;&quot;, eclipseTimeInLock, msg.getBody().length, result);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (null !&#x3D; unlockMappedFile &amp;&amp; this.defaultMessageStore.getMessageStoreConfig().isWarmMapedFileEnable()) &#123;</span><br><span class="line"></span><br><span class="line">this.defaultMessageStore.unlockMappedFile(unlockMappedFile);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PutMessageResult putMessageResult &#x3D; new PutMessageResult(PutMessageStatus.PUT_OK, result);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Statistics Metrics指标</span><br><span class="line"></span><br><span class="line">storeStatsService.getSinglePutMessageTopicTimesTotal(msg.getTopic()).incrementAndGet();</span><br><span class="line"></span><br><span class="line">storeStatsService.getSinglePutMessageTopicSizeTotal(topic).addAndGet(result.getWroteBytes());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;同步刷盘或者异步刷盘</span><br><span class="line"></span><br><span class="line">handleDiskFlush(result, putMessageResult, msg);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;主从同步</span><br><span class="line"></span><br><span class="line">handleHA(result, putMessageResult, msg);</span><br><span class="line"></span><br><span class="line">return putMessageResult;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ24# RocketMQ存储--日志文件创建与映射流程</title>
    <url>/posts/9adc03fa/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>日志目录(可配置)/data/rocketmq/store/commitlog会有20位长度的日志文件。</p>
<p>1.日志文件什么时候创建的？</p>
<p>2.日志文件创建流程是什么？</p>
<p>3.日志文件和内存映射是怎么样的？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-rw-rw-r-- 1 baseuser baseuser 1073741824 Jun 27 22:50 00000117290188144640</span><br><span class="line"></span><br><span class="line">-rw-rw-r-- 1 baseuser baseuser 1073741824 Jun 27 22:52 00000117291261886464</span><br><span class="line"></span><br><span class="line">-rw-rw-r-- 1 baseuser baseuser 1073741824 Jun 27 22:54 00000117292335628288</span><br><span class="line"></span><br><span class="line">-rw-rw-r-- 1 baseuser baseuser 1073741824 Jun 27 22:56 00000117293409370112</span><br><span class="line"></span><br><span class="line">-rw-rw-r-- 1 baseuser baseuser 1073741824 Jun 27 22:57 00000117294483111936</span><br><span class="line"></span><br><span class="line">-rw-rw-r-- 1 baseuser baseuser 1073741824 Jun 27 22:56 00000117295556853760</span><br></pre></td></tr></table></figure>



<a id="more"></a>



<h1 id="日志映射相关类初始化"><a href="#日志映射相关类初始化" class="headerlink" title="日志映射相关类初始化"></a>日志映射相关类初始化</h1><p>在Broker启动时实例化了两个类DefaultMessageStore和AllocateMappedFileService。</p>
<p>AllocateMappedFileService是线程类继承了Runnable接口，该线程类持有DefaultMessageStore的引用（即：可操作管理DefaultMessageStore），并启动该线程类。</p>
<p>调用链</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;Broker启动时调用</span><br><span class="line"></span><br><span class="line">@1 BrokerStartup#main#createBrokerController()</span><br><span class="line"></span><br><span class="line">boolean initResult &#x3D; controller.initialize();</span><br><span class="line"></span><br><span class="line">@2 Controller#initialize()</span><br><span class="line"></span><br><span class="line">this.messageStore &#x3D; new DefaultMessageStore(this.messageStoreConfig, this.brokerStatsManager, this.messageArrivingListener, this.brokerConfig);</span><br><span class="line"></span><br><span class="line">@3 DefaultMessageStore#DefaultMessageStore()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将DefaultMessageStore自身引用传给AllocateMappedFileService</span><br><span class="line"></span><br><span class="line">this.allocateMappedFileService &#x3D; new AllocateMappedFileService(this);</span><br><span class="line"></span><br><span class="line">this.allocateMappedFileService.start();&#x2F;&#x2F;启动该线程类</span><br><span class="line"></span><br><span class="line">@4 class AllocateMappedFileService extends ServiceThread</span><br><span class="line"></span><br><span class="line">public AllocateMappedFileService(DefaultMessageStore messageStore) &#123;</span><br><span class="line"></span><br><span class="line">this.messageStore &#x3D; messageStore;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>线程类一直运行在干啥</strong></p>
<p>既然在Broker启动时该线程类AllocateMappedFileService就启动了，那么在做什么呢？run方法为while循环，即：<strong>只要服务不停止并且mmapOperation()返回true则一直运行</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;异步处理，调用mmapOperation完成请求的处理</span><br><span class="line"></span><br><span class="line">public void run() &#123;</span><br><span class="line"></span><br><span class="line">log.info(this.getServiceName() + &quot; service started&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;while循环，只要服务部停止即调用 mmapOperation方法</span><br><span class="line"></span><br><span class="line">while (!this.isStopped() &amp;&amp; this.mmapOperation()) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.info(this.getServiceName() + &quot; service end&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>mmapOperation方法流程图</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219133504.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：mmapOperation方法主要做了两件事：初始化MappedFile和预热MappedFile。只要服务不停止和线程不被中断，这个过程一直重复运行。</span><br></pre></td></tr></table></figure>



<h1 id="提交映射文件请求（AllocateRequest）"><a href="#提交映射文件请求（AllocateRequest）" class="headerlink" title="提交映射文件请求（AllocateRequest）"></a>提交映射文件请求（AllocateRequest）</h1><p>既然AllocateMappedFileService一直从容器（优先级队列和ConcurrentHashMap）中获取AllocateRequest。AllocateRequest是什么时候产生并放到容器中的呢？</p>
<p>RocketMQ消息存储概览【源码笔记】中写入commitLog流程，获取最新的日志文件。</p>
<p><strong>调用链</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@1 CommitLog#putMessage</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;文件已满或者没有映射文件重新创建一个文件</span><br><span class="line"></span><br><span class="line">if (null &#x3D;&#x3D; mappedFile || mappedFile.isFull()) &#123;</span><br><span class="line"></span><br><span class="line">mappedFile &#x3D; this.mappedFileQueue.getLastMappedFile(0);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Mark: NewFile may be cause noise</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@2 MappedFileQueue#getLastMappedFile</span><br></pre></td></tr></table></figure>



<p><strong>流程图</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219133550.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：MappedFileQueue#getLastMappedFile会向线程类AllocateMappedFileServic提交两个映射文件创建请求：分别为nextFilePath和nextNextFilePath；如果线程类AllocateMappedFileServic为null，则直接new一个MappedFile，此时只会创建一个文件</span><br></pre></td></tr></table></figure>

<p><strong>下面为AllocateMappedFileServic#putRequestAndReturnMappedFile提交两个映射文件请求流程</strong></p>
<p><strong>调用链</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@1 MappedFileQueue#getLastMappedFile</span><br><span class="line"></span><br><span class="line">if (this.allocateMappedFileService !&#x3D; null) &#123;</span><br><span class="line"></span><br><span class="line">mappedFile &#x3D; this.allocateMappedFileService.putRequestAndReturnMappedFile(nextFilePath,</span><br><span class="line"></span><br><span class="line">nextNextFilePath, this.mappedFileSize);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@2 AllocateMappedFileService#putRequestAndReturnMappedFile</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>流程图</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219133629.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：处理提交的映射文件请求指的是实例化两个AllocateRequest并把他们提交到requestTable（ConcurrentHashMap）和requestQueue（PriorityBlockingQueue）中，等待5秒，此段时间线程会从这两个容器中获取请求并创建MappedFile，并将结果返回。</span><br></pre></td></tr></table></figure>



<!--more-->



<h1 id="MappedFile初始化"><a href="#MappedFile初始化" class="headerlink" title="MappedFile初始化"></a>MappedFile初始化</h1><p>本段梳理下上文中mmapOperation方法流程图第5步初始化MappedFile的流程</p>
<p><strong>调用链</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@1 AllocateMappedFileService#mmapOperation</span><br><span class="line"></span><br><span class="line">mappedFile &#x3D; new MappedFile(req.getFilePath(), req.getFileSize());</span><br><span class="line"></span><br><span class="line">@2 MappedFile#init(fileName, fileSize);</span><br></pre></td></tr></table></figure>

<p><strong>流程图</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219133707.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：MappedFile主要干了两件事：1.创建日志文件。2.并将文件映射到内存中</span><br></pre></td></tr></table></figure>



<h1 id="6-总结"><a href="#6-总结" class="headerlink" title="6.总结"></a>6.总结</h1><p><strong>1.日志文件什么时候创建的？</strong></p>
<p>备注：在写入消息时，需要获取最新的日志文件（MappedFile），如果文件不存在或者已经写满，此时需要创建MappedFile。具体在MappedFile#init方法this.file = new File(fileName)进行创建。</p>
<p><strong>2.日志文件创建流程是什么？</strong></p>
<p>备注：将两个映射创建请求（nextReq和nextNextReq）提交到requestTable（ConcurrentHashMap）和requestQueue(PriorityBlockingQueue)容器中;由线程不断检查并从容器中取出创建日志文件（MappedFile）。</p>
<p><strong>3.日志文件和内存映射是怎么样的？</strong></p>
<p>备注：具体的映射时在MappedFile#init方法中通过this.mappedByteBuffer = this.fileChannel.map(MapMode.READ_WRITE, 0, fileSize);将日志文件映射到内存中的。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ25# RocketMQ存储--映射文件预热</title>
    <url>/posts/708c22d7/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>1.为什么创建文件（commitLog）时要预热？</p>
<p>2.为什么要写入1G大小的假值（0）呢？</p>
<p>3.为什么要锁定内存？</p>
<p>4.预热流程是怎么样的？</p>
<a id="more"></a>

<h1 id="调用链"><a href="#调用链" class="headerlink" title="调用链"></a>调用链</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@1 AllocateMappedFileService#mmapOperation</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; pre write mappedFile</span><br><span class="line"></span><br><span class="line">if (mappedFile.getFileSize() &gt;&#x3D; this.messageStore.getMessageStoreConfig()</span><br><span class="line"></span><br><span class="line">.getMapedFileSizeCommitLog() &amp;&amp; this.messageStore.getMessageStoreConfig().isWarmMapedFileEnable()) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;预热</span><br><span class="line"></span><br><span class="line">mappedFile.warmMappedFile(</span><br><span class="line"></span><br><span class="line">this.messageStore.getMessageStoreConfig().getFlushDiskType(),</span><br><span class="line"></span><br><span class="line">this.messageStore.getMessageStoreConfig()</span><br><span class="line"></span><br><span class="line">.getFlushLeastPagesWhenWarmMapedFile()</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@2 MappedFilewarmMappedFile</span><br></pre></td></tr></table></figure>



<h1 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h1><p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219133918.png"></p>
<!--more-->



<h1 id="代码验证"><a href="#代码验证" class="headerlink" title="代码验证"></a>代码验证</h1><p>在文件预热时为什么将1G假值（0）写入文件呢？不写这些值会怎么样呢？</p>
<p>将预热代码改造下做个测试：分别映射空文件和将文件写入1G假值0，观察内存映射变化。</p>
<p><strong>1.文件映射测试代码</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String [] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">File file &#x3D; new File(args[0]);</span><br><span class="line"></span><br><span class="line">FileChannel fileChannel &#x3D; new RandomAccessFile(file, &quot;rw&quot;).getChannel();</span><br><span class="line"></span><br><span class="line">MappedByteBuffer mappedByteBuffer &#x3D; fileChannel.map(FileChannel.MapMode.READ_WRITE, 0, 1024 * 1024 * 1024);</span><br><span class="line"></span><br><span class="line">if(args.length &gt;1 &amp;&amp; args[1]!&#x3D;null &amp;&amp; Boolean.parseBoolean(args[1]))&#123;</span><br><span class="line"></span><br><span class="line">for (int i &#x3D; 0, j &#x3D; 0; i &lt; 1024 * 1024 * 1024; i +&#x3D; 1024 * 4, j++) &#123;</span><br><span class="line"></span><br><span class="line">mappedByteBuffer.put(i, (byte) 0);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final long address &#x3D; ((DirectBuffer) (mappedByteBuffer)).address();</span><br><span class="line"></span><br><span class="line">Pointer pointer &#x3D; new Pointer(address);</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">int ret &#x3D; LibC.INSTANCE.mlock(pointer, new NativeLong(1024 * 1024 * 102));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">int ret &#x3D; LibC.INSTANCE.madvise(pointer, new NativeLong(1024 * 1024 * 102), LibC.MADV_WILLNEED);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Thread.sleep(1000000000);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.映射空文件</strong></p>
<p>新建文件x.tmp，此文件为空，映射到内存会发生什么呢？</p>
<p>运行例子程序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -jar melontst2.jar x.tmp</span><br></pre></td></tr></table></figure>



<p>查看虚拟内存映射</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &#x2F;proc&#x2F;xxx-pid&#x2F;maps</span><br><span class="line"></span><br><span class="line">7f4c48000000-7f4c88000000 rw-s 00000000 fd:00 395167 &#x2F;home&#x2F;baseuser&#x2F;x.tmp</span><br></pre></td></tr></table></figure>



<p><u>小结：7f4c88000000-7f4c48000000 = 139966675943424 - 139965602201600</u></p>
<p><u>= 1024 * 1024 * 1024 = 1G。即：虽然是空文件，内存映射大小依然是1G大小</u></p>
<p><strong>3.映射1G文件</strong></p>
<p>新建文件y.tmp, 写入大小为1G字节0的数据，映射到内存会发生什么呢？</p>
<p>运行例子程序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -jar melontst2.jar y.tmp true</span><br></pre></td></tr></table></figure>



<p>查看虚拟内存映射</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &#x2F;proc&#x2F;xxx-pid&#x2F;maps</span><br><span class="line"></span><br><span class="line">7f36e4000000-7f3724000000 rw-s 00000000 fd:00 395900 &#x2F;home&#x2F;baseuser&#x2F;y.tmp</span><br></pre></td></tr></table></figure>



<p><u>小结：内存映射大小计算</u></p>
<p><u>7f3724000000-7f36e4000000=139874803908608-139873730166784=1073741824</u></p>
<p><u>= 1024 * 1024 * 1024 = 1G</u></p>
<p><u>内存分配了1G大小。</u></p>
<p><strong>4.思考</strong></p>
<p>既然空文件和写入1G字节虚拟内存映射都是1G大小，写入1G大小的意义呢？</p>
<p><strong>使用mmap()内存分配时，只是建立了进程虚拟地址空间，并没有分配虚拟内存对应的物理内存。当进程访问这些没有建立映射关系的虚拟内存时，处理器自动触发一个缺页异常，进而进入内核空间分配物理内存、更新进程缓存表，最后返回用户空间，回复进程运行</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：写入这些假值的意义在于实际分配物理内存，在消息写入时防止缺页异常</span><br></pre></td></tr></table></figure>

<p><strong>5.内存映射简图</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219134135.png"></p>
<p><strong>虚拟内存</strong></p>
<p>计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换</p>
<p>虚拟地址空间的内部又被分为内核空间和用户空间两部分，进程在用户态时，只能访问用户空间内存；只有进入内核态后，才可以访问内核空间内存</p>
<p><strong>MMU</strong></p>
<p>MMU是Memory Management Unit的缩写，中文名是内存管理单元，它是中央处理器（CPU）中用来管理虚拟存储器、物理存储器的控制线路，同时也负责虚拟地址映射为物理地址</p>
<p><strong>页表</strong></p>
<p>是虚拟内存系统用来存储逻辑地址和物理地址之间映射的数据结构</p>
<p><strong>内存映射mmap</strong></p>
<p>将虚拟地址映射到物理地址</p>
<h1 id="Native-API解释"><a href="#Native-API解释" class="headerlink" title="Native API解释"></a>Native API解释</h1><p><strong>mmap</strong></p>
<p>映射文件或设备到内存</p>
<p>void mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset);</p>
<p>The mmap() function asks to map length bytes starting at offset offset from the file (or other object) specified by the file descriptor fd into memory, preferably at address start. This latter address is a hint only, and is usually specified as 0. The actual place where the object is mapped is returned by mmap().</p>
<p><strong>mlock</strong></p>
<p>锁定内存</p>
<p>int mlock(const void *addr, size_t len);</p>
<p>mlock() locks pages in the address range starting at addr and continuing for len bytes. All pages that contain a part of the specified address range are guaranteed to be resident in RAM when the call returns successfully; the pages are guaranteed to stay in RAM until later unlocked.</p>
<p><strong>madvise</strong></p>
<p>提出建议关于使用内存</p>
<p>int madvise(void *start, size_t length, int advice);</p>
<p>The madvise() system call advises the kernel about how to handle paging input/output in the address range beginning at address start and with size length bytes. It allows an application to tell the kernel how it expects to use some mapped or shared memory areas, so that the kernel can choose appropriate read-ahead and caching techniques. This call does not influence the semantics of the application (except in the case ofMADV_DONTNEED), but may influence its performance. The kernel is free to ignore the advice。</p>
<p>MADV_WILLNEED模式（MappedFile预热使用该模式）</p>
<p>MADV_WILLNEED：Expect access in the near future. (Hence, it might be a good idea to read some pages ahead.)</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>1.Broker配置warmMapedFileEnable为false，开启预热需要设置true。</p>
<p>2.写入1G字节假值0是为了让系统分配物理内存空间，如果没有这些假值，系统不会实际分配物理内存，防止在写入消息时发生缺页异常。</p>
<p>3.mlock锁定内存，防止其被交换到swap空间。</p>
<p>4.madvise建议操作系统如何使用内存，MADV_WILLNEED提前预热，预读一些页面，提高性能。</p>
<p>5.文件预热使得内存提前分配，并锁定在内存中，在写入消息时不必再进行内存分配。</p>
<h1 id="附录源代码"><a href="#附录源代码" class="headerlink" title="附录源代码"></a>附录源代码</h1><p><strong>1.文件初始化源代码</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void init(final String fileName, final int fileSize) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">this.fileName &#x3D; fileName;</span><br><span class="line"></span><br><span class="line">this.fileSize &#x3D; fileSize;</span><br><span class="line"></span><br><span class="line">this.file &#x3D; new File(fileName);</span><br><span class="line"></span><br><span class="line">this.fileFromOffset &#x3D; Long.parseLong(this.file.getName());&#x2F;&#x2F;文件名代表该文件的起始偏移量</span><br><span class="line"></span><br><span class="line">boolean ok &#x3D; false;</span><br><span class="line"></span><br><span class="line">ensureDirOK(this.file.getParent());</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;通过RandomAccessFile创读写文件通道</span><br><span class="line"></span><br><span class="line">this.fileChannel &#x3D; new RandomAccessFile(this.file, &quot;rw&quot;).getChannel();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将文件内容通过NIO的内存映射Buffer,将文件映射到内存</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将磁盘文件读到内存中，每个文件大小为1G</span><br><span class="line"></span><br><span class="line">this.mappedByteBuffer &#x3D; this.fileChannel.map(MapMode.READ_WRITE, 0, fileSize);</span><br><span class="line"></span><br><span class="line">TOTAL_MAPPED_VIRTUAL_MEMORY.addAndGet(fileSize);</span><br><span class="line"></span><br><span class="line">TOTAL_MAPPED_FILES.incrementAndGet();</span><br><span class="line"></span><br><span class="line">ok &#x3D; true;</span><br><span class="line"></span><br><span class="line">&#125; catch (FileNotFoundException e) &#123;</span><br><span class="line"></span><br><span class="line">log.error(&quot;create file channel &quot; + this.fileName + &quot; Failed. &quot;, e);</span><br><span class="line"></span><br><span class="line">throw e;</span><br><span class="line"></span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line"></span><br><span class="line">log.error(&quot;map file &quot; + this.fileName + &quot; Failed. &quot;, e);</span><br><span class="line"></span><br><span class="line">throw e;</span><br><span class="line"></span><br><span class="line">&#125; finally &#123;</span><br><span class="line"></span><br><span class="line">if (!ok &amp;&amp; this.fileChannel !&#x3D; null) &#123;</span><br><span class="line"></span><br><span class="line">this.fileChannel.close();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>2.预热源代码</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void warmMappedFile(FlushDiskType type, int pages) &#123;</span><br><span class="line"></span><br><span class="line">long beginTime &#x3D; System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">ByteBuffer byteBuffer &#x3D; this.mappedByteBuffer.slice();</span><br><span class="line"></span><br><span class="line">int flush &#x3D; 0; &#x2F;&#x2F;记录上一次刷盘的字节数</span><br><span class="line"></span><br><span class="line">long time &#x3D; System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">for (int i &#x3D; 0, j &#x3D; 0; i &lt; this.fileSize; i +&#x3D; MappedFile.OS_PAGE_SIZE, j++) &#123;</span><br><span class="line"></span><br><span class="line">byteBuffer.put(i, (byte) 0);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; force flush when flush disk type is sync</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;当刷盘策略为同步刷盘时，执行强制刷盘</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;每修改pages个分页刷一次盘 内存页的大小为4K</span><br><span class="line"></span><br><span class="line">if (type &#x3D;&#x3D; FlushDiskType.SYNC_FLUSH) &#123;</span><br><span class="line"></span><br><span class="line">if ((i &#x2F; OS_PAGE_SIZE) - (flush &#x2F; OS_PAGE_SIZE) &gt;&#x3D; pages) &#123;</span><br><span class="line"></span><br><span class="line">flush &#x3D; i;</span><br><span class="line"></span><br><span class="line">mappedByteBuffer.force();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; prevent gc</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Linux CPU调度策略基于时间片 Thread.sleep 当前线程主动放弃CPU资源，立即进入就绪状态</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;防止一直抢占CPU资源不释放</span><br><span class="line"></span><br><span class="line">if (j % 1000 &#x3D;&#x3D; 0) &#123;</span><br><span class="line"></span><br><span class="line">log.info(&quot;j&#x3D;&#123;&#125;, costTime&#x3D;&#123;&#125;&quot;, j, System.currentTimeMillis() - time);</span><br><span class="line"></span><br><span class="line">time &#x3D; System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">Thread.sleep(0);</span><br><span class="line"></span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">e.printStackTrace();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; force flush when prepare load finished</span><br><span class="line"></span><br><span class="line">if (type &#x3D;&#x3D; FlushDiskType.SYNC_FLUSH) &#123;</span><br><span class="line"></span><br><span class="line">log.info(&quot;mapped file warm-up done, force to disk, mappedFile&#x3D;&#123;&#125;, costTime&#x3D;&#123;&#125;&quot;,</span><br><span class="line"></span><br><span class="line">this.getFileName(), System.currentTimeMillis() - beginTime);</span><br><span class="line"></span><br><span class="line">mappedByteBuffer.force();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.info(&quot;mapped file warm-up done. mappedFile&#x3D;&#123;&#125;, costTime&#x3D;&#123;&#125;&quot;, this.getFileName(),</span><br><span class="line"></span><br><span class="line">System.currentTimeMillis() - beginTime);</span><br><span class="line"></span><br><span class="line">this.mlock();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>3.内存锁定代码</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void mlock() &#123;</span><br><span class="line"></span><br><span class="line">final long beginTime &#x3D; System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">final long address &#x3D; ((DirectBuffer) (this.mappedByteBuffer)).address();</span><br><span class="line"></span><br><span class="line">Pointer pointer &#x3D; new Pointer(address);</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;锁死</span><br><span class="line"></span><br><span class="line">int ret &#x3D; LibC.INSTANCE.mlock(pointer, new NativeLong(this.fileSize));</span><br><span class="line"></span><br><span class="line">log.info(&quot;mlock &#123;&#125; &#123;&#125; &#123;&#125; ret &#x3D; &#123;&#125; time consuming &#x3D; &#123;&#125;&quot;, address, this.fileName, this.fileSize, ret, System.currentTimeMillis() - beginTime);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">int ret &#x3D; LibC.INSTANCE.madvise(pointer, new NativeLong(this.fileSize), LibC.MADV_WILLNEED);</span><br><span class="line"></span><br><span class="line">log.info(&quot;madvise &#123;&#125; &#123;&#125; &#123;&#125; ret &#x3D; &#123;&#125; time consuming &#x3D; &#123;&#125;&quot;, address, this.fileName, this.fileSize, ret, System.currentTimeMillis() - beginTime);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ26# RocketMQ存储--消息追加</title>
    <url>/posts/52ef32ad/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>1.消息追加到何处了呢？</p>
<p>2.消息格式是怎么样的？</p>
<a id="more"></a>



<h1 id="调用链"><a href="#调用链" class="headerlink" title="调用链"></a>调用链</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@1 CommitLog#putMessage</span><br><span class="line"></span><br><span class="line">result &#x3D; mappedFile.appendMessage(msg, this.appendMessageCallback);</span><br><span class="line"></span><br><span class="line">@2 MaapedFile#appendMessagesInner</span><br><span class="line"></span><br><span class="line">result &#x3D; cb.doAppend</span><br><span class="line"></span><br><span class="line">@3 CommitLog#DefaultAppendMessageCallback#doAppend</span><br></pre></td></tr></table></figure>



<h1 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h1><p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219134505.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：在消息写入Buffer的过程中有3个坐标</span><br></pre></td></tr></table></figure>


<p><strong>1. wrotePosition</strong></p>
<p>* commitLog内存（ByteBuffer）写入位点，标记消息写到哪了，下次从该位置开始写。在消息写完后递增，递增大小为消息的长度</p>
<p><strong>2. wroteOffset</strong></p>
<p>* 物理偏移量，标记在commitlog物理文件中消息的位置</p>
<p>* 物理偏移量=文件名称（fileFromOffset）+ 内存相对位置byteBuffer.position(wrotePosition)</p>
<p><strong>3. queueOffset</strong></p>
<p>* topicQueue逻辑偏移量，标记消息在topic的分区中的消息的位置，在消息写入后递增，递增长度为1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">疑问？</span><br><span class="line">写入Buffer有两类，堆外内存Buffer(writeBuffer)和mmap映射Buffer(mappedByteBuffer)。mappedByteBuffer为commitLog日志文件的直接映射，而堆外内存writeBuffer是怎么落盘的呢？</span><br></pre></td></tr></table></figure>

<p>此处先记录疑问，分析刷盘时回头再看。</p>
<p>###### 四、消息格式</p>
<p>在追加单条消息时，第4步组织消息，格式如下表格：</p>
<p>| 序号 | 内容 | 所占空间 |</p>
<p>| — | — | — |</p>
<p>| 1 | msgLen消息长度 | 4个字节 |</p>
<p>| 2 | MAGIC_CODE 魔数 | 4个字节 |</p>
<p>| 3 | BodyCRC 校验码 | 4个字节 |</p>
<p>| 4 | QueueId 消息所在的分区|4个字节 |</p>
<p>| 5 | 消息Flag | 4个字节 |</p>
<p>| 6 | queueOffset 分区偏移量| 8个字节 |</p>
<p>| 7 | fileFromOffset + byteBuffer.position() 物理偏移量 | 8个字节 |</p>
<p>| 8 | SysFlag 系统标记压缩等| 4个字节 |</p>
<p>| 9 | BornTimestamp 发送时间| 8个字节 |</p>
<p>| 10 |BornHost 发送的机器IP| 8个字节 |</p>
<p>| 11 | StoreTimestamp 存储时间| 8个字节 |</p>
<p>| 12 | StoreHost 存储的broker|8个字节 |</p>
<p>| 13 | ReconsumeTimes 消费重试次数|4个字节 |</p>
<p>| 14 | PreparedTransactionOffset 事物消息偏移量| 8字节 |</p>
<p>| 15 | bodyLength 消息体长度 | |</p>
<p>| 16 | body 消息体内容 | |</p>
<p>| 17 | topicLength 主题长度| |</p>
<p>| 18 | topicData主题内容 | |</p>
<p>| 19 | propertiesLength 属性长度| |</p>
<p>| 20 | propertiesData 属性内容 | |</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">**小结：1到14项是每条消息都有的，所占空间为84个字节**</span><br></pre></td></tr></table></figure>



<!--more-->



<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>1.消息追加到何处了呢？</strong></p>
<p>注：消息追加内存Buffer中，分两类。堆外内存Buffer(writeBuffer)和mmap映射Buffer(mappedByteBuffer)</p>
<p><strong>2.消息格式是怎么样的？</strong></p>
<p>消息格式顺序见第四部分。</p>
<h1 id="附录源代码"><a href="#附录源代码" class="headerlink" title="附录源代码"></a>附录源代码</h1><p><strong>消息追加源代码</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public AppendMessageResult appendMessagesInner(final MessageExt messageExt, final AppendMessageCallback cb) &#123;</span><br><span class="line"></span><br><span class="line">assert messageExt !&#x3D; null;</span><br><span class="line"></span><br><span class="line">assert cb !&#x3D; null;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;当前MappedFile的写入位置</span><br><span class="line"></span><br><span class="line">int currentPos &#x3D; this.wrotePosition.get();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;文件还有剩余空间（小于1G继续写入）</span><br><span class="line"></span><br><span class="line">if (currentPos &lt; this.fileSize) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;仅当transientStorePoolEnable 为true，刷盘策略为异步刷盘（FlushDiskType为ASYNC_FLUSH）,并且broker为主节点时，才启用堆外分配内存。此时：writeBuffer不为null</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Buffer与同步和异步刷盘相关</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;writeBuffer&#x2F;mappedByteBuffer的position始终为0，而limit则始终等于capacity</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;slice创建一个新的buffer, 是根据position和limit来生成byteBuffer</span><br><span class="line"></span><br><span class="line">ByteBuffer byteBuffer &#x3D; writeBuffer !&#x3D; null ? writeBuffer.slice() : this.mappedByteBuffer.slice();</span><br><span class="line"></span><br><span class="line">byteBuffer.position(currentPos); &#x2F;&#x2F;设置写的起始位置</span><br><span class="line"></span><br><span class="line">AppendMessageResult result &#x3D; null;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;处理单个消息</span><br><span class="line"></span><br><span class="line">if (messageExt instanceof MessageExtBrokerInner) &#123;</span><br><span class="line"></span><br><span class="line">result &#x3D; cb.doAppend(this.getFileFromOffset(), byteBuffer, this.fileSize - currentPos, (MessageExtBrokerInner) messageExt);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;处理批量消息</span><br><span class="line"></span><br><span class="line">&#125; else if (messageExt instanceof MessageExtBatch) &#123;</span><br><span class="line"></span><br><span class="line">result &#x3D; cb.doAppend(this.getFileFromOffset(), byteBuffer, this.fileSize - currentPos, (MessageExtBatch)messageExt);</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line"></span><br><span class="line">return new AppendMessageResult(AppendMessageStatus.UNKNOWN_ERROR);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">this.wrotePosition.addAndGet(result.getWroteBytes());&#x2F;&#x2F;修改写的位置</span><br><span class="line"></span><br><span class="line">this.storeTimestamp &#x3D; result.getStoreTimestamp();</span><br><span class="line"></span><br><span class="line">return result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;写满会报错，正常不会进入该代码，调用该方法前有判断</span><br><span class="line"></span><br><span class="line">log.error(&quot;MappedFile.appendMessage return null, wrotePosition: &#123;&#125; fileSize: &#123;&#125;&quot;, currentPos, this.fileSize);</span><br><span class="line"></span><br><span class="line">return new AppendMessageResult(AppendMessageStatus.UNKNOWN_ERROR);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>消息格式源代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AppendMessageResult <span class="title">doAppend</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> fileFromOffset, <span class="keyword">final</span> ByteBuffer byteBuffer, <span class="keyword">final</span> <span class="keyword">int</span> maxBlank,</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">final</span> MessageExtBrokerInner msgInner)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// STORETIMESTAMP + STOREHOSTADDRESS + OFFSET &lt;br&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//fileFromOffset(起始位置): 一个commitLog文件（对应一个MappedFile）对应的偏移量（文件名就代表这个偏移量）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//byteBuffer.position()(相对位置):当前MappedFile(对应一个commitLog)的写位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//wroteOffset：绝对位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// PHY OFFSET</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> wroteOffset = fileFromOffset + byteBuffer.position();</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.resetByteBuffer(hostHolder, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据broker存储的地址和消息的物理绝对位置生成唯一的MessageId</span></span><br><span class="line"></span><br><span class="line">String msgId = MessageDecoder.createMessageId(<span class="keyword">this</span>.msgIdMemory, msgInner.getStoreHostBytes(hostHolder), wroteOffset);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Record ConsumeQueue information</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//消息队列（ConsumeQueue）逻辑偏移量</span></span><br><span class="line"></span><br><span class="line">keyBuilder.setLength(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">keyBuilder.append(msgInner.getTopic());</span><br><span class="line"></span><br><span class="line">keyBuilder.append(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line"></span><br><span class="line">keyBuilder.append(msgInner.getQueueId());</span><br><span class="line"></span><br><span class="line">String key = keyBuilder.toString();</span><br><span class="line"></span><br><span class="line">Long queueOffset = CommitLog.<span class="keyword">this</span>.topicQueueTable.get(key);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> == queueOffset) &#123;</span><br><span class="line"></span><br><span class="line">queueOffset = <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line">CommitLog.<span class="keyword">this</span>.topicQueueTable.put(key, queueOffset);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Transaction messages that require special handling</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> tranType = MessageSysFlag.getTransactionValue(msgInner.getSysFlag());</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (tranType) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prepared and Rollback message is not consumed, will not enter the</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// consumer queuec</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> MessageSysFlag.TRANSACTION_PREPARED_TYPE:</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> MessageSysFlag.TRANSACTION_ROLLBACK_TYPE:</span><br><span class="line"></span><br><span class="line">queueOffset = <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> MessageSysFlag.TRANSACTION_NOT_TYPE:</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> MessageSysFlag.TRANSACTION_COMMIT_TYPE:</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">byte</span>[] propertiesData =</span><br><span class="line"></span><br><span class="line">msgInner.getPropertiesString() == <span class="keyword">null</span> ? <span class="keyword">null</span> : msgInner.getPropertiesString().getBytes(MessageDecoder.CHARSET_UTF8);</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> propertiesLength = propertiesData == <span class="keyword">null</span> ? <span class="number">0</span> : propertiesData.length;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (propertiesLength &gt; Short.MAX_VALUE) &#123;</span><br><span class="line"></span><br><span class="line">log.warn(<span class="string">&quot;putMessage message properties length too long. length=&#123;&#125;&quot;</span>, propertiesData.length);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> AppendMessageResult(AppendMessageStatus.PROPERTIES_SIZE_EXCEEDED);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">byte</span>[] topicData = msgInner.getTopic().getBytes(MessageDecoder.CHARSET_UTF8);</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> topicLength = topicData.length;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> bodyLength = msgInner.getBody() == <span class="keyword">null</span> ? <span class="number">0</span> : msgInner.getBody().length;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算message大小</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> msgLen = calMsgLength(bodyLength, topicLength, propertiesLength);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Exceeds the maximum message</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (msgLen &gt; <span class="keyword">this</span>.maxMessageSize) &#123;</span><br><span class="line"></span><br><span class="line">CommitLog.log.warn(<span class="string">&quot;message size exceeded, msg total size: &quot;</span> + msgLen + <span class="string">&quot;, msg body size: &quot;</span> + bodyLength</span><br><span class="line"></span><br><span class="line">\+ <span class="string">&quot;, maxMessageSize: &quot;</span> + <span class="keyword">this</span>.maxMessageSize);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> AppendMessageResult(AppendMessageStatus.MESSAGE_SIZE_EXCEEDED);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//确定当前这个Commietlog文件是否有足够的可用空间存储</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//maxBlank:当前这个Commitlog文件（对应的MappedFile）的剩余空间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//一个Message不能跨越两个Commitlog</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//每个CommitLog文件都要确保预留8个字节来表示这个CommitLog文件结尾</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Determines whether there is sufficient free space</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((msgLen + END_FILE_MIN_BLANK_LENGTH) &gt; maxBlank) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.resetByteBuffer(<span class="keyword">this</span>.msgStoreItemMemory, maxBlank);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1 TOTALSIZE</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.msgStoreItemMemory.putInt(maxBlank);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 MAGICCODE</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//表示一个CommitLog文件结尾魔数，当读到这个魔数表示文件已结束</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.msgStoreItemMemory.putInt(CommitLog.BLANK_MAGIC_CODE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3 The remaining space may be any value</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Here the length of the specially set maxBlank</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">long</span> beginTimeMills = CommitLog.<span class="keyword">this</span>.defaultMessageStore.now();</span><br><span class="line"></span><br><span class="line"><span class="comment">//将消息内容存储在ByteBuffer中，此处存储在MappedFile对应的内存映射Buffer中，并没有写入到磁盘</span></span><br><span class="line"></span><br><span class="line">byteBuffer.put(<span class="keyword">this</span>.msgStoreItemMemory.array(), <span class="number">0</span>, maxBlank);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> AppendMessageResult(AppendMessageStatus.END_OF_FILE, wroteOffset, maxBlank, msgId, msgInner.getStoreTimestamp(),</span><br><span class="line"></span><br><span class="line">queueOffset, CommitLog.<span class="keyword">this</span>.defaultMessageStore.now() - beginTimeMills);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialization of storage space</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.resetByteBuffer(msgStoreItemMemory, msgLen);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1 TOTALSIZE 该消息条目长度，4个字节</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.msgStoreItemMemory.putInt(msgLen);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 MAGICCODE 魔数，4字节。固定值0xdaa320a7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.msgStoreItemMemory.putInt(CommitLog.MESSAGE_MAGIC_CODE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3 BODYCRC 消息体CRC校验码，4个字节</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.msgStoreItemMemory.putInt(msgInner.getBodyCRC());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4 QUEUEID 消息消费队列ID 4个字节</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.msgStoreItemMemory.putInt(msgInner.getQueueId());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5 FLAG 消息FLAG，RocketMQ不做处理，供应用程序使用，默认4个字节</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.msgStoreItemMemory.putInt(msgInner.getFlag());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6 QUEUEOFFSET 消息在消息消费队列的偏移量，8个字节</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.msgStoreItemMemory.putLong(queueOffset);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 7 PHYSICALOFFSET 消息在CommitLog文件中的偏移量，8字节</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.msgStoreItemMemory.putLong(fileFromOffset + byteBuffer.position());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 8 SYSFLAG 消息系统Flag，例如是否压缩、是否事务消息 4字节</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.msgStoreItemMemory.putInt(msgInner.getSysFlag());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 9 BORNTIMESTAMP 消息生产者调用消息发送API的时间戳，8个字节</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.msgStoreItemMemory.putLong(msgInner.getBornTimestamp());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 10 BORNHOST 消息发送者IP、端口号、8字节</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.resetByteBuffer(hostHolder, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.msgStoreItemMemory.put(msgInner.getBornHostBytes(hostHolder));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 11 STORETIMESTAMP 消息存储的时间戳，8字节</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.msgStoreItemMemory.putLong(msgInner.getStoreTimestamp());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 12 STOREHOSTADDRESS Broker服务器IP+端口号，8字节</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.resetByteBuffer(hostHolder, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.msgStoreItemMemory.put(msgInner.getStoreHostBytes(hostHolder));</span><br><span class="line"></span><br><span class="line"><span class="comment">//this.msgBatchMemory.put(msgInner.getStoreHostBytes());</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 13 RECONSUMETIMES 消息重试次数，4字节</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.msgStoreItemMemory.putInt(msgInner.getReconsumeTimes());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 14 Prepared Transaction Offset 事务消息物理偏移量，8字节</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.msgStoreItemMemory.putLong(msgInner.getPreparedTransactionOffset());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 15 BODY 消息体内容，长度为bodyLenth中存储的值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.msgStoreItemMemory.putInt(bodyLength);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (bodyLength &gt; <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.msgStoreItemMemory.put(msgInner.getBody());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 16 TOPIC 主题，长度为TopicLength中存储的值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.msgStoreItemMemory.put((<span class="keyword">byte</span>) topicLength);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.msgStoreItemMemory.put(topicData);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 17 PROPERTIES 消息属性长度，属性长度不能超过32767（short的最大值）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.msgStoreItemMemory.putShort((<span class="keyword">short</span>) propertiesLength);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (propertiesLength &gt; <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.msgStoreItemMemory.put(propertiesData);</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">long</span> beginTimeMills = CommitLog.<span class="keyword">this</span>.defaultMessageStore.now();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Write messages to the queue buffer</span></span><br><span class="line"></span><br><span class="line">byteBuffer.put(<span class="keyword">this</span>.msgStoreItemMemory.array(), <span class="number">0</span>, msgLen);</span><br><span class="line"></span><br><span class="line">AppendMessageResult result = <span class="keyword">new</span> AppendMessageResult(AppendMessageStatus.PUT_OK, wroteOffset, msgLen, msgId,</span><br><span class="line"></span><br><span class="line">msgInner.getStoreTimestamp(), queueOffset, CommitLog.<span class="keyword">this</span>.defaultMessageStore.now() - beginTimeMills);</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (tranType) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> MessageSysFlag.TRANSACTION_PREPARED_TYPE:</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> MessageSysFlag.TRANSACTION_ROLLBACK_TYPE:</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> MessageSysFlag.TRANSACTION_NOT_TYPE:</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> MessageSysFlag.TRANSACTION_COMMIT_TYPE:</span><br><span class="line"></span><br><span class="line"><span class="comment">// The next update ConsumeQueue information</span></span><br><span class="line"></span><br><span class="line">CommitLog.<span class="keyword">this</span>.topicQueueTable.put(key, ++queueOffset);</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ27# RocketMQ存储--同步刷盘和异步刷盘</title>
    <url>/posts/b973d41f/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="问题思考"><a href="#问题思考" class="headerlink" title="问题思考"></a>问题思考</h1><p>1.同步刷盘是怎么工作的？</p>
<p>2.异步刷盘是怎么工作的？</p>
<p>3.上篇文章的疑问，写入堆外内存的消息如何落盘的？</p>
<a id="more"></a>



<h1 id="Broker启动刷盘有关调用链"><a href="#Broker启动刷盘有关调用链" class="headerlink" title="Broker启动刷盘有关调用链"></a>Broker启动刷盘有关调用链</h1><p><strong>调用链</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;初始化链条</span><br><span class="line"></span><br><span class="line">@1 BrokerStartup#main</span><br><span class="line"></span><br><span class="line">start(createBrokerController(args));</span><br><span class="line"></span><br><span class="line">@2 BrokerStartup#createBrokerController</span><br><span class="line"></span><br><span class="line">final BrokerController controller &#x3D; new BrokerController(...)</span><br><span class="line"></span><br><span class="line">boolean initResult &#x3D; controller.initialize();</span><br><span class="line"></span><br><span class="line">@3 BrokerController#initialize</span><br><span class="line"></span><br><span class="line">this.messageStore &#x3D; new DefaultMessageStore(...);</span><br><span class="line"></span><br><span class="line">@4 DefaultMessageStore#DefaultMessageStore()</span><br><span class="line"></span><br><span class="line">this.commitLog &#x3D; new CommitLog(this);</span><br><span class="line"></span><br><span class="line">@5 CommitLog#CommitLog()</span><br><span class="line"></span><br><span class="line">if (FlushDiskType.SYNC_FLUSH &#x3D;&#x3D; defaultMessageStore.getMessageStoreConfig()</span><br><span class="line"></span><br><span class="line">.getFlushDiskType()) &#123;</span><br><span class="line"></span><br><span class="line">this.flushCommitLogService &#x3D; new GroupCommitService();</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line"></span><br><span class="line">this.flushCommitLogService &#x3D; new FlushRealTimeService();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">this.commitLogService &#x3D; new CommitRealTimeService();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;启动链条</span><br><span class="line"></span><br><span class="line">@6 BrokerStartup#start</span><br><span class="line"></span><br><span class="line">controller.start();</span><br><span class="line"></span><br><span class="line">@7 BrokerController#start()</span><br><span class="line"></span><br><span class="line">this.messageStore.start();</span><br><span class="line"></span><br><span class="line">@8 DefaultMessageStore#start()</span><br><span class="line"></span><br><span class="line">this.commitLog.start();</span><br><span class="line"></span><br><span class="line">@9 CommitLog#start()</span><br><span class="line"></span><br><span class="line">this.flushCommitLogService.start();</span><br><span class="line"></span><br><span class="line">if (defaultMessageStore.getMessageStoreConfig()</span><br><span class="line"></span><br><span class="line">.isTransientStorePoolEnable()) &#123;</span><br><span class="line"></span><br><span class="line">this.commitLogService.start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><u>小结：由调用链可以看出，初始化并启动了以下线程类</u></p>
<p>* 同步刷盘 GroupCommitService</p>
<p>* 异步刷盘 FlushRealTimeService</p>
<p>* 如果开启堆外内存并且为异步刷盘 CommitRealTimeService</p>
<p><strong>线程类关系图</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219134925.png"></p>
<h1 id="线程类工作流程"><a href="#线程类工作流程" class="headerlink" title="线程类工作流程"></a>线程类工作流程</h1><p>既然线程类在Broker启动时就启动了，他们在做啥呢？</p>
<p><strong>堆外内存线程类</strong>CommitRealTimeService工作流程</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219134952.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：</span><br><span class="line">1.CommitRealTimeService主要工作是将写入堆外内存(writeBuffer)的消息，写入到fileChannel中，fileChannel为commitLog文件通道</span><br><span class="line">2.committedPosition用于记录将writeBuffer数据写入到fileChannel中的内存位点（相对偏移量offset）</span><br><span class="line">3.committedWhere用于记录写入fileChannel中的物理偏移量（文件名称+相对偏移量offset）</span><br></pre></td></tr></table></figure>



<p><strong>同步刷盘线程类GroupCommitService工作流程</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219135027.png"></p>
<p><strong>注1：</strong></p>
<p>* 执行onWaitEnd时交换读写容器，该线程类提供两个容器来装GroupCommitRequest</p>
<p>* requestsWrite和requestsRead，每次执行提交(刷盘)前都会进行容器交换</p>
<p>* 好处：读写请求容器分离，避免潜在的锁竞争</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void swapRequests() &#123;</span><br><span class="line"></span><br><span class="line">List&lt;GroupCommitRequest&gt; tmp &#x3D; this.requestsWrite;</span><br><span class="line"></span><br><span class="line">this.requestsWrite &#x3D; this.requestsRead;</span><br><span class="line"></span><br><span class="line">this.requestsRead &#x3D; tmp;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>注2:</strong></p>
<p>* flushedPosition 标记已经刷盘内存的位点。即刷盘相对偏移量，刷盘到什么位置了，下次从此处刷盘即可</p>
<p>* flushedWhere 标记已经刷盘的物理偏移量，根据此位置可精确查找到文件中消息的存储位置</p>
<p>flushedWhere = 当前刷盘文件名称（该日志文件的起始物理偏移量） + flushedPosition</p>
<p><strong>注3</strong></p>
<p>* 流程图中标记红色部分，将刷盘结果通知给等待线程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：同步刷盘线程类GroupCommitService主要工作</span><br><span class="line">1.将请求从读容器中取出并通过mappedByteBuffer.force()将数据落盘。</span><br></pre></td></tr></table></figure>



<p><strong>异步刷盘线程类FlushRealTimeService工作流程</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219135125.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：FlushRealTimeService主要工作</span><br><span class="line">1.不开启堆外外内存刷盘方式为mappedByteBuffer.force()</span><br><span class="line">2.开启堆外内存刷盘方式为fileChannel.force</span><br></pre></td></tr></table></figure>

<p><u><strong>疑问：同步刷盘线程类GroupCommitService每执行一次都会交换读写容器，那刷盘请求什么时候放到写容器（requestsWrite）呢？</strong></u></p>
<h1 id="消息追加与线程类的交互"><a href="#消息追加与线程类的交互" class="headerlink" title="消息追加与线程类的交互"></a>消息追加与线程类的交互</h1><p>分析完线程类后，把镜头切换到消息追加，看看消息进来后是如何跟线程类交互的？</p>
<p><strong>调用链</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@1 CommitLog#putMessage</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;同步刷盘或者异步刷盘</span><br><span class="line"></span><br><span class="line">handleDiskFlush(result, putMessageResult, msg);</span><br><span class="line"></span><br><span class="line">@2 CommitLog#handleDiskFlush</span><br></pre></td></tr></table></figure>



<p><strong>同步刷盘主要代码</strong></p>
<p>同步刷盘时构造刷盘请求，将请求提交给线程类GroupCommitService，service.putRequest(request)，并获取刷盘结果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (FlushDiskType.SYNC_FLUSH &#x3D;&#x3D; this.defaultMessageStore.getMessageStoreConfig().getFlushDiskType()) &#123;</span><br><span class="line"></span><br><span class="line">final GroupCommitService service &#x3D; (GroupCommitService) this.flushCommitLogService;</span><br><span class="line"></span><br><span class="line">GroupCommitRequest request &#x3D; new GroupCommitRequest(result.getWroteOffset() + result.getWroteBytes());</span><br><span class="line"></span><br><span class="line">service.putRequest(request);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;等待MappedFile刷盘成功状态通过countDownLatch来控制</span><br><span class="line"></span><br><span class="line">boolean flushOK &#x3D; request.waitForFlush(this.defaultMessageStore.getMessageStoreConfig().getSyncFlushTimeout());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>异步刷盘主要代码</strong></p>
<p>未开启堆外内存唤醒FlushRealTimeServicee，开启堆外内存唤醒CommitRealTimeService。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (!this.defaultMessageStore.getMessageStoreConfig()</span><br><span class="line"></span><br><span class="line">.isTransientStorePoolEnable()) &#123;</span><br><span class="line"></span><br><span class="line">flushCommitLogService.wakeup();</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line"></span><br><span class="line">commitLogService.wakeup();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<!--more-->



<h1 id="刷盘方式示意图"><a href="#刷盘方式示意图" class="headerlink" title="刷盘方式示意图"></a>刷盘方式示意图</h1><p><strong>同步刷盘示意图</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219135252.png"></p>
<p><strong>异步刷盘未开启堆外缓存示意图</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219135312.png"></p>
<p><strong>异步刷盘开启堆外缓存示意图</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219135332.png"></p>
<h1 id="文章总结"><a href="#文章总结" class="headerlink" title="文章总结"></a>文章总结</h1><p>1.同异步刷盘通过Broker属性flushDiskType来设置，默认为ASYNC_FLUSH，同步刷盘配置为SYNC_FLUSH</p>
<p>2.同步刷盘是怎么工作的？</p>
<p>注：见GroupCommitService工作流程及与消息追加交互</p>
<p>3.异步刷盘是怎么工作的？</p>
<p>注：见FlushRealTimeService和CommitRealTimeService工作流程及与消息追加交互</p>
<p>4.上篇文章的疑问，写入堆外内存的消息如何落盘的？</p>
<p>注：见异步刷盘开启堆外缓存示意图</p>
<h1 id="主要源码类清单"><a href="#主要源码类清单" class="headerlink" title="主要源码类清单"></a>主要源码类清单</h1><p>* CommitLog.java</p>
<p>* CommitLog#putMessage</p>
<p>* CommitLog#GroupCommitService</p>
<p>* CommitLog#FlushRealTimeService</p>
<p>* CommitLog#CommitRealTimeService</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ28# RocketMQ存储--主从同步</title>
    <url>/posts/72491306/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="问题思考"><a href="#问题思考" class="headerlink" title="问题思考"></a>问题思考</h1><p>1.消息存储在Master上了，如何同步到Slave上了呢？</p>
<p>2.同步复制和异步复制流程是怎么样的？</p>
<a id="more"></a>



<h1 id="Broker启动HA调用链"><a href="#Broker启动HA调用链" class="headerlink" title="Broker启动HA调用链"></a>Broker启动HA调用链</h1><p><strong>HA初始化调用链</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@1 BrokerStartup#main</span><br><span class="line"></span><br><span class="line">start(createBrokerController(args));</span><br><span class="line"></span><br><span class="line">@2 BrokerStartup#createBrokerController</span><br><span class="line"></span><br><span class="line">boolean initResult &#x3D; controller.initialize();</span><br><span class="line"></span><br><span class="line">@3 BrokerController#initialize</span><br><span class="line"></span><br><span class="line">this.messageStore &#x3D; new DefaultMessageStore</span><br><span class="line"></span><br><span class="line">@4 DefaultMessageStore#DefaultMessageStore()</span><br><span class="line"></span><br><span class="line">this.haService &#x3D; new HAService(this);</span><br><span class="line"></span><br><span class="line">this.defaultMessageStore &#x3D; defaultMessageStore;</span><br><span class="line"></span><br><span class="line">this.acceptSocketService &#x3D;</span><br><span class="line"></span><br><span class="line">new AcceptSocketService(defaultMessageStore.getMessageStoreConfig()</span><br><span class="line"></span><br><span class="line">.getHaListenPort());</span><br><span class="line"></span><br><span class="line">this.groupTransferService &#x3D; new GroupTransferService();</span><br><span class="line"></span><br><span class="line">this.haClient &#x3D; new HAClient();</span><br></pre></td></tr></table></figure>



<p><strong>启动调用链</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@1 BrokerStartup#start</span><br><span class="line"></span><br><span class="line">controller.start();</span><br><span class="line"></span><br><span class="line">@2 BrokerController#start</span><br><span class="line"></span><br><span class="line">this.messageStore.start();</span><br><span class="line"></span><br><span class="line">@3 DefaultMessageStore#start</span><br><span class="line"></span><br><span class="line">@4 this.haService.start();</span><br><span class="line"></span><br><span class="line">this.acceptSocketService.beginAccept();</span><br><span class="line"></span><br><span class="line">this.acceptSocketService.start();</span><br><span class="line"></span><br><span class="line">this.groupTransferService.start();</span><br><span class="line"></span><br><span class="line">this.haClient.start();</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：从初始化和启动调用链中可以看到，在Broker启动时，初始化并启动了三个线程类，分别为AcceptSocketService、GroupTransferService、HAClient。</span><br></pre></td></tr></table></figure>

<p><strong>问题：这三个线程类在干啥？</strong></p>
<!--more-->



<h1 id="线程类职责"><a href="#线程类职责" class="headerlink" title="线程类职责"></a>线程类职责</h1><p><strong>AcceptSocketService职责</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219135638.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：AcceptSocketService职责初始化TCP通道，监听新的连接并创建HAConnection。</span><br></pre></td></tr></table></figure>

<p><u>问题：HAConnection在做什么？</u></p>
<p><strong>HAConnection职责</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;构造方法</span><br><span class="line"></span><br><span class="line">public HAConnection(final HAService haService, final SocketChannel socketChannel) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">this.haService &#x3D; haService;</span><br><span class="line"></span><br><span class="line">this.socketChannel &#x3D; socketChannel;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取客户端请求地址</span><br><span class="line"></span><br><span class="line">this.clientAddr &#x3D; this.socketChannel.socket().getRemoteSocketAddress().toString();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将通道调整为非阻塞</span><br><span class="line"></span><br><span class="line">this.socketChannel.configureBlocking(false);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;关闭连接前将数据发送完毕</span><br><span class="line"></span><br><span class="line">this.socketChannel.socket().setSoLinger(false, -1);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将Nagle算法关闭，客户端每发送一次数据无论大小，都会将其发送出去</span><br><span class="line"></span><br><span class="line">this.socketChannel.socket().setTcpNoDelay(true);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设置接受缓存区为64K</span><br><span class="line"></span><br><span class="line">this.socketChannel.socket().setReceiveBufferSize(1024 * 64);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设置发包缓存区为64K</span><br><span class="line"></span><br><span class="line">this.socketChannel.socket().setSendBufferSize(1024 * 64);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;写数据线程类</span><br><span class="line"></span><br><span class="line">this.writeSocketService &#x3D; new WriteSocketService(this.socketChannel);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;读数据线程类</span><br><span class="line"></span><br><span class="line">this.readSocketService &#x3D; new ReadSocketService(this.socketChannel);</span><br><span class="line"></span><br><span class="line">this.haService.getConnectionCount().incrementAndGet();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;启动</span><br><span class="line"></span><br><span class="line">public void start() &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;启动读数据线程</span><br><span class="line"></span><br><span class="line">this.readSocketService.start();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;启动写数据线程</span><br><span class="line"></span><br><span class="line">this.writeSocketService.start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><u>疑问：HAConnection除了对通道做了一些设置外，启动了两个线程服务类，分别为readSocketService和writeSocketService，他们职责是什么呢？</u></p>
<p><strong>writeSocketService职责</strong></p>
<p>流程图</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219135721.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：writeSocketService主要职责，将数据不断写入socketChannel通道；写入数据的大小为nextTransferFromWhere与最大可读位置getReadPosition之间数据；每次写完传输指针自增this.nextTransferFromWhere +&#x3D; size；每隔5秒发送心跳包到socketChannel通道。</span><br></pre></td></tr></table></figure>

<p><strong>readSocketService职责</strong></p>
<p>流程图</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219135746.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：readSocketService主要职责解析slave发来的请求位点，并更新push2SlaveMaxOffset为该请求位点；唤醒groupTransferService线程。</span><br></pre></td></tr></table></figure>



<p><strong>GroupTransferService职责</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219135816.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：GroupTransferService职责判断主从同步是否完成，完成后唤醒消息发送线程</span><br></pre></td></tr></table></figure>



<p><strong>HAClient职责</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219135843.png"></p>
<p><u>小结：HAClient职责Slave封装实现类，负责与Master建立连接通道，并从通道中获取数据存储；</u></p>
<p><u>并向Master上报Slave存储的最大物理偏移量。</u></p>
<h1 id="主从同步示意图"><a href="#主从同步示意图" class="headerlink" title="主从同步示意图"></a>主从同步示意图</h1><p><strong>主从同步交互消息格式</strong></p>
<p>1.1 Slave上报物理偏移量reportOffset量格式</p>
<p>| 格式 | 说明 |</p>
<p>| — | — |</p>
<p>| 00000018516677754880 | 长度为8位的20位数字 |</p>
<p>1.2 Master写入Slave的信息由Header与Body构成</p>
<p>| 格式 | 说明 |</p>
<p>| — | — |</p>
<p>| 00000018516677754880+size | Header部分由8位物理偏移量+消息体大小构成</p>
<p>| 消息具体内容 | Slave请求的位点与Master可读位置之间的数据</p>
<p><strong>主从同步示意图</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219135921.png"></p>
<h1 id="源代码清单"><a href="#源代码清单" class="headerlink" title="源代码清单"></a>源代码清单</h1><p>* HAService.java</p>
<p>* HAService#AcceptSocketService</p>
<p>* HAService#GroupTransferService</p>
<p>* HAService#HAClient</p>
<p>* HAConnection.java</p>
<p>* HAConnection#ReadSocketService</p>
<p>* HAConnection#WriteSocketService</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ3# RocketMQ Cluster命令</title>
    <url>/posts/a3779249/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="查看集群信息"><a href="#查看集群信息" class="headerlink" title="查看集群信息"></a>查看集群信息</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin clusterList -n localhost:9876</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option PermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">Cluster Name Broker Name BID Addr Version InTPS OutTPS</span><br><span class="line"></span><br><span class="line">AdpMqCluster broker-a 0 192.168.1.x:10911 V3_4_6 2819.22 1077.39</span><br><span class="line"></span><br><span class="line">AdpMqCluster broker-b 0 192.168.1.x:10911 V3_4_6 2839.42 1070.89</span><br><span class="line"></span><br><span class="line">AdpMqCluster broker-c 0 192.168.1.x:10919 V3_4_6 2800.12 1058.39</span><br><span class="line"></span><br><span class="line">AdpMqCluster broker-d 0 192.168.1.x:10915 V3_4_6 2897.04 1126.04</span><br><span class="line"></span><br><span class="line">AdpMqCluster broker-e 0 192.168.1.x:10919 V3_4_6 2987.20 1181.88</span><br><span class="line"></span><br><span class="line">AdpMqCluster broker-f 0 192.168.1.x:10915 V3_4_6 3010.40 1187.08</span><br></pre></td></tr></table></figure>



<a id="more"></a>



<h1 id="创建Topic"><a href="#创建Topic" class="headerlink" title="创建Topic"></a>创建Topic</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin updateTopic -n localhost:9876 -c DefaultCluster -t zto-example</span><br></pre></td></tr></table></figure>



<h1 id="删除Topic"><a href="#删除Topic" class="headerlink" title="删除Topic"></a>删除Topic</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin deleteTopic -n localhost:9876 -c DefaultCluster -t zto-example</span><br></pre></td></tr></table></figure></div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ29# RocketMQ客户端PUSH消费概览</title>
    <url>/posts/3b8a1c43/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>PUSH消费整体流程是怎么样的？</p>
<a id="more"></a>



<h1 id="PUSH消费流程概览"><a href="#PUSH消费流程概览" class="headerlink" title="PUSH消费流程概览"></a>PUSH消费流程概览</h1><p><strong>从客户端示例开始</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DefaultMQPushConsumer consumer &#x3D; new DefaultMQPushConsumer(&quot;CID_JODIE_1&quot;);</span><br><span class="line"></span><br><span class="line">consumer.subscribe(&quot;Jodie_topic_1023&quot;, &quot;*&quot;); consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;wrong time format 2017_0422_221800</span><br><span class="line"></span><br><span class="line">consumer.setConsumeTimestamp(&quot;20170422221800&quot;);</span><br><span class="line"></span><br><span class="line">consumer.registerMessageListener(new MessageListenerConcurrently() &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line"></span><br><span class="line">public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context) &#123;</span><br><span class="line"></span><br><span class="line">System.out.printf(Thread.currentThread().getName() + &quot; Receive New Messages: &quot; + msgs + &quot;%n&quot;);</span><br><span class="line"></span><br><span class="line">return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">consumer.start();</span><br><span class="line"></span><br><span class="line">System.out.printf(&quot;Consumer Started.%n&quot;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>客户端PUSH消费流程概览</strong></p>
<p><strong>概览流程1</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219140443.png"></p>
<!--more-->



<p><strong>概览流程2</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219140501.png"></p>
<p><u>小结：PUSH消费的主要内容实例化DefaultMQPushConsumer，注册MessageQueue分配策略；</u></p>
<p><u>初始化订阅数据并存入缓存；注册消费监听用于回调处理消息；创建并启动MQClientInstance实例；向Broker发送心跳等工作。</u></p>
<p><strong>参数校验哪些内容？</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219140542.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：参数校验中MessageListener只能为顺序消费或者并发消费两种模式；消费最小线程consumeThreadMin取值需要小于1000即最多1000个消费线程；由于为无界队consumeThreadMax设置无效。</span><br></pre></td></tr></table></figure>



<p><strong>MQClientInstance初始化与启动</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219140622.png"></p>
<p><u>小结：MQClientInstance初始化启动连带一系列线程类的启动。例如：PullMessageService、RebalanceService等以及通过Netty建立TCP通道。</u></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本篇文章主要对PUSH消费启动有个整体的印象，在分析消息拉取/并发消费/顺序消费/负载均衡时再来看各个类的具体职责。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ30# RocketMQ客户端PUSH消费--并发消费与顺序消费</title>
    <url>/posts/55c56ee4/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="消息拉取与处理"><a href="#消息拉取与处理" class="headerlink" title="消息拉取与处理"></a>消息拉取与处理</h1><p><strong>消息拉取</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219140825.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：PullMessageService处理拉取消息请求。通过组织RequetHeader需要包含从哪里开始拉取（ConsumerGroup、Topic，Queue，queueOffset）等信息，向Broker发起请求，取回消息后对消息进行处理。当该Queue的消息数量超过1000，或者最小与最大偏移量之间的差距超过默认2000也会触发限流，即：延迟50毫秒放入请求队列。也可以通过挂起消费线程来延迟（1秒）消息拉取，从而达到消费限流作用。</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p><strong>消息处理</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219140851.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：PullMessageService处理消息部分流程：将消息提交给了processQueue红黑树缓存；同时将消息提交给consumeMessageService来处理具体的消息内容。</span><br></pre></td></tr></table></figure>



<!--more-->



<h1 id="并发消费流程"><a href="#并发消费流程" class="headerlink" title="并发消费流程"></a>并发消费流程</h1><p><strong>ConsumeMessageConcurrentlyService职责</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219140921.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：ConsumeMessageService并发消费（ConsumeMessageConcurrentlyService）主要工作交给Listener（客户端传入）进行处理，并对处理结果进行统计和处理；对于失败消息，广播消费会丢弃，集群消费会发回Broker重新消费；清理ProcessQueue并更新缓存（offsetTable）消费进度。</span><br></pre></td></tr></table></figure>



<h1 id="顺序消费流程"><a href="#顺序消费流程" class="headerlink" title="顺序消费流程"></a>顺序消费流程</h1><p><strong>ConsumeMessageOrderlyService职责</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219140952.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：顺序消费流程跟并发消费最大的区别在于，对要处理的队列加锁，确保同一队列，同一时间，只允许一个消费线程处理。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">疑问：</span><br><span class="line"></span><br><span class="line">1.为什么顺序消费时需要对Broker发请求对要处理的队列加锁？</span><br><span class="line"></span><br><span class="line">2.对Broker端队列加锁流程是怎么样的？</span><br><span class="line"></span><br><span class="line">3.既然加锁了需要解锁吗？</span><br><span class="line"></span><br><span class="line">4.会存在Broker加锁过期了客户端还在处理该队列的情况吗？</span><br></pre></td></tr></table></figure>



<p><strong>Broker端队列加锁流程</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219141026.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：顺序消费时对Broker端队列加锁防止该队列在特定时间内（一次默认60秒）被分配给其他clientId处理；Broker端加锁了不需要解锁，一次加锁失效时长为60秒；不存在Broker加锁过期了客户端还在处理该队列的情况，Broker加锁时长为60秒，而客户端加锁时长为30秒，当客户端加锁时长失效时会重新请求Broker加锁并更新时间戳，从而可以持续延长加锁时间。</span><br></pre></td></tr></table></figure>



<h1 id="交互示意图"><a href="#交互示意图" class="headerlink" title="交互示意图"></a>交互示意图</h1><p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219141054.png"></p>
<h1 id="源码清单"><a href="#源码清单" class="headerlink" title="源码清单"></a>源码清单</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.PullMessageService.java</span><br><span class="line"></span><br><span class="line">2.ConsumeMessageConcurrentlyService.java</span><br><span class="line"></span><br><span class="line">3.ConsumeMessageOrderlyService.java</span><br><span class="line"></span><br><span class="line">4.RebalanceLockManager.java</span><br><span class="line"></span><br></pre></td></tr></table></figure>



</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ31# RocketMQ客户端PUSH消费--负载均衡</title>
    <url>/posts/dd191b8b/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="问题思考"><a href="#问题思考" class="headerlink" title="问题思考"></a>问题思考</h1><p>1.主题队列是如何分配的？</p>
<p>2.什么时候会进行负载均衡？</p>
<p>3.负载均衡后是否会导致消息重复消费？</p>
<a id="more"></a>

<h1 id="调用链条"><a href="#调用链条" class="headerlink" title="调用链条"></a>调用链条</h1><p><strong>初始化链条</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@1 DefaultMQPushConsumerImpl#start</span><br><span class="line"></span><br><span class="line">this.mQClientFactory</span><br><span class="line"></span><br><span class="line">&#x3D; MQClientManager.getInstance().getAndCreateMQClientInstance</span><br><span class="line"></span><br><span class="line">@2 MQClientManager#getAndCreateMQClientInstance</span><br><span class="line"></span><br><span class="line">instance &#x3D; new MQClientInstance</span><br><span class="line"></span><br><span class="line">@3 MQClientInstance#MQClientInstance</span><br><span class="line"></span><br><span class="line">this.rebalanceService &#x3D; new RebalanceService</span><br></pre></td></tr></table></figure>



<p><strong>启动链条</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@1 DefaultMQPushConsumerImpl#start</span><br><span class="line"></span><br><span class="line">mQClientFactory.start()</span><br><span class="line"></span><br><span class="line">@2 MQClientInstance#start</span><br><span class="line"></span><br><span class="line">this.rebalanceService.start</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：从初始化链和调用链可以看出RebalanceService为线程类，随着消费启动时而启动，消费不退出则一直运行着。</span><br></pre></td></tr></table></figure>



<h1 id="负载均衡流程"><a href="#负载均衡流程" class="headerlink" title="负载均衡流程"></a>负载均衡流程</h1><p><strong>负载均衡链条</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@1 RebalanceService#run</span><br><span class="line"></span><br><span class="line">mqClientFactory.doRebalance()</span><br><span class="line"></span><br><span class="line">@2 MQClientInstance#doRebalance</span><br><span class="line"></span><br><span class="line">impl.doRebalance()</span><br><span class="line"></span><br><span class="line">@3 DefaultMQPushConsumerImpl#doRebalance</span><br><span class="line"></span><br><span class="line">this.rebalanceImpl.doRebalance</span><br><span class="line"></span><br><span class="line">@4 RebalanceImpl#doRebalance</span><br><span class="line"></span><br><span class="line">rebalanceByTopic</span><br></pre></td></tr></table></figure>



<p><strong>负载均衡流程</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219141402.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：在负载均衡时，会循环该消费组订阅的所有Topic都会执行负载均衡。</span><br></pre></td></tr></table></figure>



<p><strong>更新缓存processQueue流程</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219141423.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：</span><br><span class="line">1. 更新缓存时如果消费组订阅的队列不在新分配的队列集合中或者队列拉取时间超时失效，则将快照ProcessQueue设置为丢弃。</span><br><span class="line">2. 消费拉取时判断ProcessQueue为丢弃，则不再对该队列拉取。</span><br><span class="line">3. 顺序消费时如果获取消费锁成功，表明此队列空闲没有被消费，此时向Broker发起解锁请求，解锁成功后将该队列从缓存（processQueueTable）移除。</span><br><span class="line">4. 顺序消费时获取锁失败，表明正在消费则不从processQueueTable移除，由于ProcessQueue设置为丢弃，在顺序消费下次拉取时会退出该队列的拉取请求。</span><br></pre></td></tr></table></figure>



<!--more-->



<p><strong>向Broker发送心跳流程</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219141446.png"></p>
<p><strong>队列分配算法</strong></p>
<p>负载均衡流程图中对clientId和分区队列的分配提交给分区算法执行，那该算法是如何运作的呢？</p>
<p>接口AllocateMessageQueueStrategy队列分配策略提供五种分配算法实现：</p>
<p>* 1.平均分配策略AllocateMessageQueueAveragely</p>
<p>* 2.环形分配策略AllocateMessageQueueAveragelyByCircle</p>
<p>* 3.机房分配策略AllocateMessageQueueByMachineRoom</p>
<p>* 4.一致性Hash分配策略AllocateMessageQueueConsistentHash</p>
<p>* 5.配置文件分配策略AllocateMessageQueueByConfig</p>
<p>除此之外可以自定义分配算法，实现接口接口即可，默认使用平均分配算法，也是最常用的，下面以该算法看看如何工作的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public List&lt;MessageQueue&gt; allocate</span><br><span class="line"></span><br><span class="line">(String consumerGroup, String currentCID, List&lt;MessageQueue&gt; mqAll,</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; cidAll) &#123;</span><br><span class="line"></span><br><span class="line">List&lt;MessageQueue&gt; result &#x3D; new ArrayList&lt;MessageQueue&gt;();</span><br><span class="line"></span><br><span class="line">int index &#x3D; cidAll.indexOf(currentCID);</span><br><span class="line"></span><br><span class="line">int mod &#x3D; mqAll.size() % cidAll.size();</span><br><span class="line"></span><br><span class="line">int averageSize &#x3D; mqAll.size() &lt;&#x3D; cidAll.size() ?</span><br><span class="line"></span><br><span class="line">1 : (mod &gt; 0 &amp;&amp; index &lt; mod ?</span><br><span class="line"></span><br><span class="line">mqAll.size() &#x2F; cidAll.size() + 1 : mqAll.size() &#x2F; cidAll.size());</span><br><span class="line"></span><br><span class="line">int startIndex &#x3D; (mod &gt; 0 &amp;&amp; index &lt; mod) ? index * averageSize : index * averageSize + mod;</span><br><span class="line"></span><br><span class="line">int range &#x3D; Math.min(averageSize, mqAll.size() - startIndex);</span><br><span class="line"></span><br><span class="line">for (int i &#x3D; 0; i &lt; range; i++) &#123;</span><br><span class="line"></span><br><span class="line">result.add(mqAll.get((startIndex + i) % mqAll.size()));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>代码不是很好阅读，看下面验证结果即可。</p>
<p><strong>平均分配算法验证</strong></p>
<p>* 只有一个clientId时分配情况</p>
<p>会把1个Broker的16个分区全部分配给该客户端，每隔20秒触发一次负载均衡。</p>
<p>currentCID=2.0.1.138@consumer01分到的队列为0～15</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">----------2019-08-04 22:10:15-----------</span><br><span class="line"></span><br><span class="line">currentCID&#x3D;2.0.1.138@consumer01</span><br><span class="line"></span><br><span class="line">index&#x3D;0</span><br><span class="line"></span><br><span class="line">mod&#x3D;0</span><br><span class="line"></span><br><span class="line">averageSize&#x3D;16</span><br><span class="line"></span><br><span class="line">startIndex&#x3D;0</span><br><span class="line"></span><br><span class="line">range&#x3D;16</span><br><span class="line"></span><br><span class="line">result&#x3D;[MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;0], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;1], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;2], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;3], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;4], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;5], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;6], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;7], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;8], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;9], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;10], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;11], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;12], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;13], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;14], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;15]]</span><br><span class="line"></span><br><span class="line">----------2019-08-04 22:10:35-----------</span><br><span class="line"></span><br><span class="line">currentCID&#x3D;2.0.1.138@consumer01</span><br><span class="line"></span><br><span class="line">index&#x3D;0</span><br><span class="line"></span><br><span class="line">mod&#x3D;0</span><br><span class="line"></span><br><span class="line">averageSize&#x3D;16</span><br><span class="line"></span><br><span class="line">startIndex&#x3D;0</span><br><span class="line"></span><br><span class="line">range&#x3D;16</span><br><span class="line"></span><br><span class="line">result&#x3D;[MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;0], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;1], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;2], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;3], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;4], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;5], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;6], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;7], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;8], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;9], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;10], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;11], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;12], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;13], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;14], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;15]]</span><br></pre></td></tr></table></figure>



<p>* 新加入第二个client时</p>
<p>此时有两个clinetId分别为2.0.1.138@consumer01和2.0.1.138@consumer02，1个 Broker16个分区的分配情况。</p>
<p>currentCID=2.0.1.138@consumer01分到的分区为0～7</p>
<p>currentCID=2.0.1.138@consumer02分到的分区为8～16</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">----------2019-08-04 22:12:25-----------</span><br><span class="line"></span><br><span class="line">currentCID&#x3D;2.0.1.138@consumer01</span><br><span class="line"></span><br><span class="line">index&#x3D;0</span><br><span class="line"></span><br><span class="line">mod&#x3D;0</span><br><span class="line"></span><br><span class="line">averageSize&#x3D;8</span><br><span class="line"></span><br><span class="line">startIndex&#x3D;0</span><br><span class="line"></span><br><span class="line">range&#x3D;8</span><br><span class="line"></span><br><span class="line">result&#x3D;[MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;0], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;1], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;2], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;3], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;4], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;5], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;6], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;7]]</span><br><span class="line"></span><br><span class="line">----------2019-08-04 22:12:45-----------</span><br><span class="line"></span><br><span class="line">currentCID&#x3D;2.0.1.138@consumer02</span><br><span class="line"></span><br><span class="line">index&#x3D;1</span><br><span class="line"></span><br><span class="line">mod&#x3D;0</span><br><span class="line"></span><br><span class="line">averageSize&#x3D;8</span><br><span class="line"></span><br><span class="line">startIndex&#x3D;8</span><br><span class="line"></span><br><span class="line">range&#x3D;8</span><br><span class="line"></span><br><span class="line">result&#x3D;[MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;8], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;9], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;10], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;11], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;12], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;13], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;14], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;15]]</span><br></pre></td></tr></table></figure>



<p>* 新加入第三个client时</p>
<p>此时有三个客户端2.0.1.138@consumer01、2.0.1.138@consumer02、2.0.1.138@consumer03，1个Broker的16个队列的分配情况。</p>
<p>currentCID=2.0.1.138@consumer01分到的队列0～5</p>
<p>currentCID=2.0.1.138@consumer02分到的队列6～10</p>
<p>currentCID=2.0.1.138@consumer03分到的队列11～15</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">----------2019-08-04 22:13:58-----------</span><br><span class="line"></span><br><span class="line">currentCID&#x3D;2.0.1.138@consumer01</span><br><span class="line"></span><br><span class="line">index&#x3D;0</span><br><span class="line"></span><br><span class="line">mod&#x3D;1</span><br><span class="line"></span><br><span class="line">averageSize&#x3D;6</span><br><span class="line"></span><br><span class="line">startIndex&#x3D;0</span><br><span class="line"></span><br><span class="line">range&#x3D;6</span><br><span class="line"></span><br><span class="line">result&#x3D;[MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;0], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;1], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;2], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;3], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;4], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;5]]</span><br><span class="line"></span><br><span class="line">----------2019-08-04 22:14:18-----------</span><br><span class="line"></span><br><span class="line">currentCID&#x3D;2.0.1.138@consumer02</span><br><span class="line"></span><br><span class="line">index&#x3D;1</span><br><span class="line"></span><br><span class="line">mod&#x3D;1</span><br><span class="line"></span><br><span class="line">averageSize&#x3D;5</span><br><span class="line"></span><br><span class="line">startIndex&#x3D;6</span><br><span class="line"></span><br><span class="line">range&#x3D;5</span><br><span class="line"></span><br><span class="line">result&#x3D;[MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;6], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;7], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;8], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;9], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;10]]</span><br><span class="line"></span><br><span class="line">----------2019-08-04 22:14:39-----------</span><br><span class="line"></span><br><span class="line">currentCID&#x3D;2.0.1.138@consumer03</span><br><span class="line"></span><br><span class="line">index&#x3D;2</span><br><span class="line"></span><br><span class="line">mod&#x3D;1</span><br><span class="line"></span><br><span class="line">averageSize&#x3D;5</span><br><span class="line"></span><br><span class="line">startIndex&#x3D;11</span><br><span class="line"></span><br><span class="line">range&#x3D;5</span><br><span class="line"></span><br><span class="line">result&#x3D;[MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;11], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;12], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;13], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;14], MessageQueue [topic&#x3D;topic_test, brokerName&#x3D;liangyongdeMacBook-Pro.local, queueId&#x3D;15]]</span><br></pre></td></tr></table></figure>



<h1 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h1><p>1.主题队列是如何分配的？</p>
<p>备注：见队列分配算法，通常使用平均分配算法。</p>
<p>2.什么时候会进行负载均衡？</p>
<p>备注：负载均衡线程每隔20秒执行一次，当有新客户端退出或者加入或者新的Broker加入或掉线都会触发重新负载均衡。</p>
<p>3.负载均衡后是否会导致消息重复消费？</p>
<p>备注：</p>
<p>并发消费可能导致消息被重复消费，看以下代码。如果负载均衡前已分配的队列不在负载均衡后的新队列集合中，会丢弃该队列即：processQueue.isDropped()。而该队列可能已经被消费完了，在处理结果时被丢弃了，消费进度没有更新。别的消费客户端重新拉取该队列时造成重复消费。</p>
<p>顺序消费不会导致消息被重复消费。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;并发消费对结果的处理</span><br><span class="line"></span><br><span class="line">ConsumeMessageConcurrentlyService#ConsumeRequest</span><br><span class="line"></span><br><span class="line">if (!processQueue.isDropped()) &#123; ConsumeMessageConcurrentlyService.this.processConsumeResult(status, context, this);</span><br><span class="line"></span><br><span class="line">&#125; else &#123; &#x2F;&#x2F;被丢弃，消费进度不会更新</span><br><span class="line"></span><br><span class="line">log.warn(&quot;processQueue is dropped without process consume result. messageQueue&#x3D;&#123;&#125;, msgs&#x3D;&#123;&#125;&quot;, messageQueue, msgs);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ32# RocketMQ客户端消费--ProcessQueue处理队列</title>
    <url>/posts/87a2ceec/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="问题思考"><a href="#问题思考" class="headerlink" title="问题思考"></a>问题思考</h1><p>在消费消息时处处能看到处理队列ProcessQueue的身影，既然随处可见也一定很重要，那有必要分析下为何重要了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.ProcessQueue提供哪些方法？</span><br><span class="line"></span><br><span class="line">2.这些方法的作用是什么？</span><br><span class="line"></span><br><span class="line">3.哪里调用了这些方法？</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h1 id="ProcessQueue方法梳理"><a href="#ProcessQueue方法梳理" class="headerlink" title="ProcessQueue方法梳理"></a>ProcessQueue方法梳理</h1><h2 id="isLockExpired方法"><a href="#isLockExpired方法" class="headerlink" title="isLockExpired方法"></a>isLockExpired方法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean isLockExpired() &#123;</span><br><span class="line"></span><br><span class="line">	return (System.currentTimeMillis() - this.lastLockTimestamp) &gt; REBALANCE_LOCK_MAX_LIVE_TIME;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>lastLockTimestamp(最新加锁时间戳)</strong></p>
<p>lastLockTimestamp属性调用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@1 RebalanceImpl#lock</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;请求broker对该消费队列进行加锁</span><br><span class="line"></span><br><span class="line">Set&lt;MessageQueue&gt; lockedMq &#x3D; this.mQClientFactory.getMQClientAPIImpl().lockBatchMQ</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">processQueue.setLocked(true);&#x2F;&#x2F;加锁</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设置加锁时间戳</span><br><span class="line"></span><br><span class="line">processQueue.setLastLockTimestamp(System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@2 RebalanceImpl#lockAll</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;向broker发送该clientId所对应的messageQueue锁定请求</span><br><span class="line"></span><br><span class="line">Set&lt;MessageQueue&gt; lockOKMQSet &#x3D;</span><br><span class="line"></span><br><span class="line">this.mQClientFactory.getMQClientAPIImpl().lockBatchMQ</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">processQueue.setLocked(true);</span><br><span class="line"></span><br><span class="line">processQueue.setLastLockTimestamp(System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>isLockExpired方法调用</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@1 ConsumeMessageOrderlyService#ConsumeRequest</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;集群顺序消费时需要判断processQueue加锁是否过期</span><br><span class="line"></span><br><span class="line">if (MessageModel.BROADCASTING.equals(ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.messageModel())</span><br><span class="line"></span><br><span class="line">|| (this.processQueue.isLocked() &amp;&amp; !this.processQueue.isLockExpired()))</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：@1&amp;@2中可以看出lastLockTimestamp在顺序消费时向Broker请求对队列加锁成功后设置的时间戳；REBALANCE_LOCK_MAX_LIVE_TIME由参数rocketmq.client.rebalance.lockMaxLiveTime设置默认为30秒；lastLockTimestamp的含义为加锁的有效时间为30秒，超过该时间则失效；顺序消费在判断过期时延迟拉取。</span><br></pre></td></tr></table></figure>



<h2 id="isPullExpired方法"><a href="#isPullExpired方法" class="headerlink" title="isPullExpired方法"></a>isPullExpired方法</h2><p><strong>isPullExpired方法代码</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean isPullExpired() &#123;</span><br><span class="line"></span><br><span class="line">return (System.currentTimeMillis() - this.lastPullTimestamp) &gt; PULL_MAX_IDLE_TIME;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<!--more-->



<p><strong>lastPullTimestamp属性调用</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@1 DefaultMQPushConsumerImpl#pullMessage</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;每次消息拉取后更新最后一次拉取时间戳</span><br><span class="line"></span><br><span class="line">pullRequest.getProcessQueue()</span><br><span class="line"></span><br><span class="line">.setLastPullTimestamp(System.currentTimeMillis());</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@1 RebalanceImpl#updateProcessQueueTableInRebalance</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;在负载均衡时如果拉取时间失效会将ProceeQueue丢弃</span><br><span class="line"></span><br><span class="line">else if (pq.isPullExpired()) &#123;</span><br><span class="line"></span><br><span class="line">case CONSUME_ACTIVELY:</span><br><span class="line"></span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">case CONSUME_PASSIVELY:</span><br><span class="line"></span><br><span class="line">pq.setDropped(true);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：lastPullTimestamp每次拉取消息都会更新时间戳；PULL_MAX_IDLE_TIME由rocketmq.client.pull.pullMaxIdleTime设置默认为120秒；方法在负载均衡更新ProcessQueueTable时调用如果拉取失效ProcessQueue将被丢弃。</span><br></pre></td></tr></table></figure>



<h2 id="putMessage方法"><a href="#putMessage方法" class="headerlink" title="putMessage方法"></a>putMessage方法</h2><p>putMessage方法代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"></span><br><span class="line">\* 消息丢入红黑树</span><br><span class="line"></span><br><span class="line">\* @param msgs</span><br><span class="line"></span><br><span class="line">\* @return</span><br><span class="line"></span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">public boolean putMessage(final List&lt;MessageExt&gt; msgs) &#123;</span><br><span class="line"></span><br><span class="line">boolean dispatchToConsume &#x3D; false;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">this.lockTreeMap.writeLock().lockInterruptibly();</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">int validMsgCnt &#x3D; 0;</span><br><span class="line"></span><br><span class="line">for (MessageExt msg : msgs) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;消息存入红黑树key为queueOffset,value为消息</span><br><span class="line"></span><br><span class="line">MessageExt old &#x3D; msgTreeMap.put(msg.getQueueOffset(), msg);</span><br><span class="line"></span><br><span class="line">if (null &#x3D;&#x3D; old) &#123;</span><br><span class="line"></span><br><span class="line">validMsgCnt++;&#x2F;&#x2F;递增消息数量</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;记录最大queueOffset</span><br><span class="line"></span><br><span class="line">this.queueOffsetMax &#x3D; msg.getQueueOffset();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;统计消息数量</span><br><span class="line"></span><br><span class="line">msgCount.addAndGet(validMsgCnt);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;消息集合有数据可继续消费</span><br><span class="line"></span><br><span class="line">if (!msgTreeMap.isEmpty() &amp;&amp; !this.consuming) &#123;</span><br><span class="line"></span><br><span class="line">dispatchToConsume &#x3D; true;</span><br><span class="line"></span><br><span class="line">this.consuming &#x3D; true;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (!msgs.isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;取出这批消息集合中的最后一条消息</span><br><span class="line"></span><br><span class="line">MessageExt messageExt &#x3D; msgs.get(msgs.size() - 1);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取分区最大的消息offet</span><br><span class="line"></span><br><span class="line">String property &#x3D; messageExt.getProperty(MessageConst.PROPERTY_MAX_OFFSET);</span><br><span class="line"></span><br><span class="line">if (property !&#x3D; null) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;计算还有多少消息未被消费</span><br><span class="line"></span><br><span class="line">long accTotal &#x3D; Long.parseLong(property) - messageExt.getQueueOffset();</span><br><span class="line"></span><br><span class="line">if (accTotal &gt; 0) &#123;</span><br><span class="line"></span><br><span class="line">this.msgAccCnt &#x3D; accTotal;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; finally &#123;</span><br><span class="line"></span><br><span class="line">this.lockTreeMap.writeLock().unlock();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">log.error(&quot;putMessage exception&quot;, e);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return dispatchToConsume;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>putMessage方法调用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@1 DefaultMQPushConsumerImpl#pullMessage</span><br><span class="line"></span><br><span class="line">boolean dispathToConsume &#x3D; processQueue.putMessage(pullResult.getMsgFoundList())</span><br><span class="line"></span><br><span class="line">@2 ConsumeMessageOrderlyService#submitConsumeRequest</span><br><span class="line"></span><br><span class="line">if (dispathToConsume) &#123; &#x2F;&#x2F;dispathToConsume顺序消费返回结果为true</span><br><span class="line"></span><br><span class="line">ConsumeRequest consumeRequest &#x3D;</span><br><span class="line"></span><br><span class="line">new ConsumeRequest(processQueue, messageQueue);</span><br><span class="line"></span><br><span class="line">this.consumeExecutor.submit(consumeRequest);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@3 PullConsumerImpl#registerPullTaskCallback</span><br><span class="line"></span><br><span class="line">pq.putMessage(pullResult.getMsgFoundList());</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：在拉取消息后处理消息时，提交给ProcessQueue#putMessage中红黑树msgTreeMap存储一份数据，并统计消息的数量以及还有多少消息未被拉取；返回结果dispatchToConsume如果true表明消费集合有数据，顺序消息会据此构造消费请求继续处理。</span><br></pre></td></tr></table></figure>



<h2 id="getMaxSpan方法"><a href="#getMaxSpan方法" class="headerlink" title="getMaxSpan方法"></a>getMaxSpan方法</h2><p>getMaxSpan方法代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"></span><br><span class="line">\* 获取当前消息最大间隔</span><br><span class="line"></span><br><span class="line">\* 消息队列第一条消息与最后一条消息的偏移量差值</span><br><span class="line"></span><br><span class="line">\* @return</span><br><span class="line"></span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">public long getMaxSpan() &#123;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">this.lockTreeMap.readLock().lockInterruptibly();</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">if (!this.msgTreeMap.isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line">return this.msgTreeMap.lastKey() - this.msgTreeMap.firstKey();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; finally &#123;</span><br><span class="line"></span><br><span class="line">this.lockTreeMap.readLock().unlock();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">log.error(&quot;getMaxSpan exception&quot;, e);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>getMaxSpan方法调用</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@1 DefaultMQPushConsumerImpl#pullMessage</span><br><span class="line"></span><br><span class="line">f (!this.consumeOrderly) &#123;&#x2F;&#x2F;非顺序消费</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;并发处理的消息跨度不能超过2000，超过2000，延迟50秒进行拉去</span><br><span class="line"></span><br><span class="line">if (processQueue.getMaxSpan() &gt; this.defaultMQPushConsumer.getConsumeConcurrentlyMaxSpan()) &#123;</span><br><span class="line"></span><br><span class="line">this.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL);</span><br><span class="line"></span><br><span class="line">if ((flowControlTimes2++ % 1000) &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F;每出发1000次打印流控日志</span><br><span class="line"></span><br><span class="line">log.warn(</span><br><span class="line"></span><br><span class="line">&quot;the queue&#39;s messages, span too long, so do flow control, minOffset&#x3D;&#123;&#125;, maxOffset&#x3D;&#123;&#125;, maxSpan&#x3D;&#123;&#125;, pullRequest&#x3D;&#123;&#125;, flowControlTimes&#x3D;&#123;&#125;&quot;,</span><br><span class="line"></span><br><span class="line">processQueue.getMsgTreeMap().firstKey(), processQueue.getMsgTreeMap().lastKey(), processQueue.getMaxSpan(),</span><br><span class="line"></span><br><span class="line">pullRequest, flowControlTimes2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：getMaxSpan方法计算已拉取消息队列第一条消息与最后一条消息的偏移量差值，即拉取消息的数量跨度，在并发消息时调用，如果该跨度大于2000则延迟50秒再拉取数据。</span><br></pre></td></tr></table></figure>



<h2 id="removeMessage方法"><a href="#removeMessage方法" class="headerlink" title="removeMessage方法"></a>removeMessage方法</h2><p>removeMessage方法代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"></span><br><span class="line">\* 将消息从红黑树msgTreeMap中移除</span><br><span class="line"></span><br><span class="line">\* @param msgs</span><br><span class="line"></span><br><span class="line">\* @return</span><br><span class="line"></span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">public long removeMessage(final List&lt;MessageExt&gt; msgs) &#123;</span><br><span class="line"></span><br><span class="line">long result &#x3D; -1;</span><br><span class="line"></span><br><span class="line">final long now &#x3D; System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">this.lockTreeMap.writeLock().lockInterruptibly();</span><br><span class="line"></span><br><span class="line">this.lastConsumeTimestamp &#x3D; now;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">if (!msgTreeMap.isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line">result &#x3D; this.queueOffsetMax + 1;</span><br><span class="line"></span><br><span class="line">int removedCnt &#x3D; 0;</span><br><span class="line"></span><br><span class="line">for (MessageExt msg : msgs) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;移除消息</span><br><span class="line"></span><br><span class="line">MessageExt prev &#x3D; msgTreeMap.remove(msg.getQueueOffset());</span><br><span class="line"></span><br><span class="line">if (prev !&#x3D; null) &#123;</span><br><span class="line"></span><br><span class="line">removedCnt--;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">msgCount.addAndGet(removedCnt);&#x2F;&#x2F;消息总数扣除</span><br><span class="line"></span><br><span class="line">if (!msgTreeMap.isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line">result &#x3D; msgTreeMap.firstKey(); &#x2F;&#x2F;第一条消息的偏移量</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; finally &#123;</span><br><span class="line"></span><br><span class="line">this.lockTreeMap.writeLock().unlock();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; catch (Throwable t) &#123;</span><br><span class="line"></span><br><span class="line">log.error(&quot;removeMessage exception&quot;, t);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>removeMessage方法调用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@1 ConsumeMessageConcurrentlyService#processConsumeResult</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;消费完毕后从ProcessQueue中清除这批消息</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;offset为清除这批偏移量后processQueue.msgTreeMap中最小的偏移量</span><br><span class="line"></span><br><span class="line">long offset &#x3D; consumeRequest.getProcessQueue().removeMessage(consumeRequest.getMsgs());</span><br></pre></td></tr></table></figure>



<p>```</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：removeMessage方法在并发消费后进行调用，消息处理完了将ProcessQueue中红黑树这批消息移除。</span><br></pre></td></tr></table></figure>

<h2 id="cleanExpiredMsg方法"><a href="#cleanExpiredMsg方法" class="headerlink" title="cleanExpiredMsg方法"></a>cleanExpiredMsg方法</h2><p>cleanExpiredMsg方法代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"></span><br><span class="line">\* @param pushConsumer</span><br><span class="line"></span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">public void cleanExpiredMsg(DefaultMQPushConsumer pushConsumer) &#123;</span><br><span class="line"></span><br><span class="line">if (pushConsumer.getDefaultMQPushConsumerImpl().isConsumeOrderly()) &#123;</span><br><span class="line"></span><br><span class="line">return;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;每次调用最多清理16条</span><br><span class="line"></span><br><span class="line">int loop &#x3D; msgTreeMap.size() &lt; 16 ? msgTreeMap.size() : 16;</span><br><span class="line"></span><br><span class="line">for (int i &#x3D; 0; i &lt; loop; i++) &#123;</span><br><span class="line"></span><br><span class="line">MessageExt msg &#x3D; null;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">this.lockTreeMap.readLock().lockInterruptibly();</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;默认超过15分钟未消费的消息将延迟3个延迟级别再消费</span><br><span class="line"></span><br><span class="line">if (!msgTreeMap.isEmpty() &amp;&amp; System.currentTimeMillis() - Long.parseLong(MessageAccessor.getConsumeStartTimeStamp(msgTreeMap.firstEntry().getValue())) &gt; pushConsumer.getConsumeTimeout() * 60 * 1000) &#123;</span><br><span class="line"></span><br><span class="line">msg &#x3D; msgTreeMap.firstEntry().getValue();</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line"></span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; finally &#123;</span><br><span class="line"></span><br><span class="line">this.lockTreeMap.readLock().unlock();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">log.error(&quot;getExpiredMsg exception&quot;, e);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;返回broker，延迟3个级别消费</span><br><span class="line"></span><br><span class="line">pushConsumer.sendMessageBack(msg, 3);</span><br><span class="line"></span><br><span class="line">log.info(&quot;send expire msg back. topic&#x3D;&#123;&#125;, msgId&#x3D;&#123;&#125;, storeHost&#x3D;&#123;&#125;, queueId&#x3D;&#123;&#125;, queueOffset&#x3D;&#123;&#125;&quot;, msg.getTopic(), msg.getMsgId(), msg.getStoreHost(), msg.getQueueId(), msg.getQueueOffset());</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">this.lockTreeMap.writeLock().lockInterruptibly();</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">if (!msgTreeMap.isEmpty() &amp;&amp; msg.getQueueOffset() &#x3D;&#x3D; msgTreeMap.firstKey()) &#123;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将消息移出</span><br><span class="line"></span><br><span class="line">msgTreeMap.remove(msgTreeMap.firstKey());</span><br><span class="line"></span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">log.error(&quot;send expired msg exception&quot;, e);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; finally &#123;</span><br><span class="line"></span><br><span class="line">this.lockTreeMap.writeLock().unlock();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">log.error(&quot;getExpiredMsg exception&quot;, e);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">log.error(&quot;send expired msg exception&quot;, e);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>cleanExpiredMsg方法调用</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@1 ConsumeMessageConcurrentlyService#start()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;定时任务15分钟运行一次</span><br><span class="line"></span><br><span class="line">public void start() &#123;</span><br><span class="line"></span><br><span class="line">this.cleanExpireMsgExecutors.scheduleAtFixedRate(new Runnable() &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line"></span><br><span class="line">public void run() &#123;</span><br><span class="line"></span><br><span class="line">cleanExpireMsg();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;, this.defaultMQPushConsumer.getConsumeTimeout(), this.defaultMQPushConsumer.getConsumeTimeout(), TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void cleanExpireMsg() &#123;</span><br><span class="line"></span><br><span class="line">Iterator&lt;Map.Entry&lt;MessageQueue, ProcessQueue&gt;&gt; it &#x3D; this.defaultMQPushConsumerImpl.getRebalanceImpl().getProcessQueueTable().entrySet().iterator();</span><br><span class="line"></span><br><span class="line">while (it.hasNext()) &#123;</span><br><span class="line"></span><br><span class="line">Map.Entry&lt;MessageQueue, ProcessQueue&gt; next &#x3D; it.next();</span><br><span class="line"></span><br><span class="line">ProcessQueue pq &#x3D; next.getValue();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;清理过期消息</span><br><span class="line"></span><br><span class="line">pq.cleanExpiredMsg(this.defaultMQPushConsumer);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：cleanExpiredMsg方法在并发消费中调用，每个15分钟执行一次；该方法会对超过15分钟未被消费的数据进行清理，每次最多清理16条。</span><br></pre></td></tr></table></figure>



<h2 id="takeMessags方法"><a href="#takeMessags方法" class="headerlink" title="takeMessags方法"></a>takeMessags方法</h2><p>takeMessags方法代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"></span><br><span class="line">\* 从ProcessQueue中取出batchSize条消息</span><br><span class="line"></span><br><span class="line">\* @param batchSize</span><br><span class="line"></span><br><span class="line">\* @return</span><br><span class="line"></span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">public List&lt;MessageExt&gt; takeMessags(final int batchSize) &#123;</span><br><span class="line"></span><br><span class="line">List&lt;MessageExt&gt; result &#x3D; new ArrayList&lt;MessageExt&gt;(batchSize);</span><br><span class="line"></span><br><span class="line">final long now &#x3D; System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">this.lockTreeMap.writeLock().lockInterruptibly();</span><br><span class="line"></span><br><span class="line">this.lastConsumeTimestamp &#x3D; now;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">if (!this.msgTreeMap.isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line">for (int i &#x3D; 0; i &lt; batchSize; i++) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;消息从红黑树中取出</span><br><span class="line"></span><br><span class="line">Map.Entry&lt;Long, MessageExt&gt; entry &#x3D; this.msgTreeMap.pollFirstEntry();</span><br><span class="line"></span><br><span class="line">if (entry !&#x3D; null) &#123;</span><br><span class="line"></span><br><span class="line">result.add(entry.getValue());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;取出的消息在msgTreeMapTemp中存储一份</span><br><span class="line"></span><br><span class="line">msgTreeMapTemp.put(entry.getKey(), entry.getValue());</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line"></span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (result.isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line">consuming &#x3D; false;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; finally &#123;</span><br><span class="line"></span><br><span class="line">this.lockTreeMap.writeLock().unlock();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">log.error(&quot;take Messages exception&quot;, e);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>takeMessags方法调用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@1 ConsumeMessageOrderlyService#ConsumeRequest</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;取出消息</span><br><span class="line"></span><br><span class="line">List&lt;MessageExt&gt; msgs &#x3D; this.processQueue.takeMessags(consumeBatchSize);</span><br><span class="line"></span><br><span class="line">if (!msgs.isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;客户端消费消息</span><br><span class="line"></span><br><span class="line">status &#x3D; messageListener.consumeMessage(Collections.unmodifiableList(msgs), context);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：顺序消费时通过ProcessQueue#takeMessags获取特定数量的消息（默认1条）并传给客户端Listener进行处理。</span><br></pre></td></tr></table></figure>



<h2 id="rollback方法"><a href="#rollback方法" class="headerlink" title="rollback方法"></a>rollback方法</h2><p>rollback方法代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"></span><br><span class="line">\* 将msgTreeMapTmp中所有消息重新放入到msgTreeMap并清除msgTreeMapTmp</span><br><span class="line"></span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">public void rollback() &#123;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">this.lockTreeMap.writeLock().lockInterruptibly();</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">this.msgTreeMap.putAll(this.msgTreeMapTemp);</span><br><span class="line"></span><br><span class="line">this.msgTreeMapTemp.clear();</span><br><span class="line"></span><br><span class="line">&#125; finally &#123;</span><br><span class="line"></span><br><span class="line">this.lockTreeMap.writeLock().unlock();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">log.error(&quot;rollback exception&quot;, e);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>rollback方法调用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@1 ConsumeMessageOrderlyService#processConsumeResult</span><br><span class="line"></span><br><span class="line">case ROLLBACK:</span><br><span class="line"></span><br><span class="line">consumeRequest.getProcessQueue().rollback();</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：在顺序消费客户端处理消息后，如果消息处理结果的状态为ROLLBACK，此时调用ProcessQueue#rollback方法；将msgTreeMapTmp中的消息重新写回红黑树msgTreeMap中；ROLLBACK此状态在顺序消费时已不建议使用。</span><br></pre></td></tr></table></figure>



<h2 id="commit方法"><a href="#commit方法" class="headerlink" title="commit方法"></a>commit方法</h2><p>commit方法代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"></span><br><span class="line">\* 将msgTreeMapTmp中的消息清除，表示成功处理了该批消息</span><br><span class="line"></span><br><span class="line">\* @return</span><br><span class="line"></span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">public long commit() &#123;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">this.lockTreeMap.writeLock().lockInterruptibly();</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">Long offset &#x3D; this.msgTreeMapTemp.lastKey();</span><br><span class="line"></span><br><span class="line">msgCount.addAndGet(this.msgTreeMapTemp.size() * (-1));</span><br><span class="line"></span><br><span class="line">this.msgTreeMapTemp.clear();</span><br><span class="line"></span><br><span class="line">if (offset !&#x3D; null) &#123;</span><br><span class="line"></span><br><span class="line">return offset + 1; &#x2F;&#x2F;返回下一条消息offset</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; finally &#123;</span><br><span class="line"></span><br><span class="line">this.lockTreeMap.writeLock().unlock();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">log.error(&quot;commit exception&quot;, e);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return -1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>commit方法调用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@1 ConsumeMessageOrderlyService#processConsumeResult</span><br><span class="line"></span><br><span class="line">case SUCCESS:</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;清空msgTreeMapTemp</span><br><span class="line"></span><br><span class="line">commitOffset &#x3D; consumeRequest.getProcessQueue().commit();</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：在顺序消费客户端处理消息状态为成功时，内存中消费偏移量提交即ProcessQueue#commit清空msgTreeMapTemp临时红黑树中的数据。</span><br></pre></td></tr></table></figure>



<h2 id="makeMessageToCosumeAgain方法"><a href="#makeMessageToCosumeAgain方法" class="headerlink" title="makeMessageToCosumeAgain方法"></a>makeMessageToCosumeAgain方法</h2><p>makeMessageToCosumeAgain方法代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"></span><br><span class="line">\* 重新消费该批消息</span><br><span class="line"></span><br><span class="line">\* @param msgs</span><br><span class="line"></span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">public void makeMessageToCosumeAgain(List&lt;MessageExt&gt; msgs) &#123;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">this.lockTreeMap.writeLock().lockInterruptibly();</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">for (MessageExt msg : msgs) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将消息从msgTreeMapTemp移除</span><br><span class="line"></span><br><span class="line">this.msgTreeMapTemp.remove(msg.getQueueOffset());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将该批消息重新放入msgTreeMap</span><br><span class="line"></span><br><span class="line">this.msgTreeMap.put(msg.getQueueOffset(), msg);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; finally &#123;</span><br><span class="line"></span><br><span class="line">this.lockTreeMap.writeLock().unlock();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">log.error(&quot;makeMessageToCosumeAgain exception&quot;, e);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>makeMessageToCosumeAgain方法调用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">case SUSPEND_CURRENT_QUEUE_A_MOMENT:</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;重新消费该批信息</span><br><span class="line"></span><br><span class="line">onsumeRequest.getProcessQueue().makeMessageToCosumeAgain(msgs);</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：akeMessageToCosumeAgain在顺序消费客户端返回消息状态为SUSPEND_CURRENT_QUEUE_A_MOMENT时调用；将消息从msgTreeMapTemp移除，并将该批消息重新放入msgTreeMap。</span><br></pre></td></tr></table></figure>



<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>ProcessQueue作为MessageQueue在消费端的镜像，从负载均衡、消息拉取、消费状态处理、offset提交，控制着整个消费的脉搏，尤其在顺序消费中参与更多。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ33# RocketMQ消费--Broker端处理逻辑</title>
    <url>/posts/9c431d59/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="问题思考"><a href="#问题思考" class="headerlink" title="问题思考"></a>问题思考</h1><p>1.Broker是如何处理消费流程的？</p>
<p>2.消费进度是如何流转的？</p>
<p>说明：本文分析均为PUSH消费模式</p>
<a id="more"></a>



<h1 id="Broker处理消费流程"><a href="#Broker处理消费流程" class="headerlink" title="Broker处理消费流程"></a>Broker处理消费流程</h1><p>本部分将消费的切分成三块梳理：Broker消费处理流程概览、查找消息流程、以及消息查询结果处理流程。</p>
<h2 id="Broker消费处理流程概览"><a href="#Broker消费处理流程概览" class="headerlink" title="Broker消费处理流程概览"></a>Broker消费处理流程概览</h2><p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219143006.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：在拉取消息时会进行Broker和主题读权限的判断，实战中若有必要可以封锁Broker的拉取权限从而禁止从该broker进行消费；或者封锁某主题的读权限禁止消费组从该主题消费消息。</span><br></pre></td></tr></table></figure>



<h2 id="查找消息流程"><a href="#查找消息流程" class="headerlink" title="查找消息流程"></a>查找消息流程</h2><p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219143030.png"></p>
<p><u>小结：如果需要从磁盘拉取消息则一次默认最多拉取8条，一次消息的消息大小最大为64K。</u></p>
<p><u>如果从缓存中拉取默认最多32条，一次拉取的消息大小最大256K。使用tagcode会在查找消息前进行过滤，使用SQL92过滤再消息查找出来后进行过滤。</u></p>
<!--more-->



<h2 id="消息查询结果处理流程"><a href="#消息查询结果处理流程" class="headerlink" title="消息查询结果处理流程"></a>消息查询结果处理流程</h2><p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219143112.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：建议开启slaveReadEnable&#x3D;true，当拉取的消息超过Broker内存40%时会从Slave节点消费，Master不必从磁盘重新读取数据；transferMsgByHeap默认为true即消息先拉取到堆空间再返回到客户端；如果设置为false则使用Netty#FileRegion，可用零字节拷贝不必再拷贝到堆内存提高性能。</span><br></pre></td></tr></table></figure>



<h1 id="消费进度流转"><a href="#消费进度流转" class="headerlink" title="消费进度流转"></a>消费进度流转</h1><h2 id="客户端上报消费进度"><a href="#客户端上报消费进度" class="headerlink" title="客户端上报消费进度"></a>客户端上报消费进度</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;@1 顺序消费&#x2F;并发消费流程相同</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;ConsumeMessageOrderlyService#processConsumeResult</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;ConsumeMessageConcurrentlyService#processConsumeResult</span><br><span class="line"></span><br><span class="line">if (offset &gt;&#x3D; 0 &amp;&amp; !consumeRequest.getProcessQueue().isDropped()) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;更新消费进度偏移量</span><br><span class="line"></span><br><span class="line">this.defaultMQPushConsumerImpl.getOffsetStore().updateOffset(consumeRequest.getMessageQueue(), offset, true);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@2 RemoteBrokerOffsetStore#updateOffset</span><br><span class="line"></span><br><span class="line">AtomicLong offsetOld &#x3D; this.offsetTable.get(mq);</span><br><span class="line"></span><br><span class="line">MixAll.compareAndIncreaseOnly(offsetOld, offset);</span><br><span class="line"></span><br><span class="line">@3 offsetTable存储结构：key为MessageQueue value为消费的偏移量进度</span><br><span class="line"></span><br><span class="line">ConcurrentMap&lt;MessageQueue, AtomicLong&gt; offsetTable &#x3D;</span><br><span class="line"></span><br><span class="line">new ConcurrentHashMap&lt;MessageQueue, AtomicLong&gt;()</span><br><span class="line"></span><br><span class="line">@4 定时同步消费进度</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;持久化消息消费进度，默认5秒保存一次</span><br><span class="line"></span><br><span class="line">this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line"></span><br><span class="line">public void run() &#123;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">MQClientInstance.this.persistAllConsumerOffset();</span><br><span class="line"></span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">log.error(&quot;ScheduledTask persistAllConsumerOffset exception&quot;, e);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;, 1000 * 10, this.clientConfig.getPersistConsumerOffsetInterval(), TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">@5 RemoteBrokerOffsetStore#persistAll</span><br><span class="line"></span><br><span class="line">for (Map.Entry&lt;MessageQueue, AtomicLong&gt; entry : this.offsetTable.entrySet())</span><br><span class="line"></span><br><span class="line">this.updateConsumeOffsetToBroker(mq, offset.get());</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：PUSH消费中消费进度存储在offsetTable中，定时任务每5秒钟上报Broker一次。</span><br></pre></td></tr></table></figure>



<h2 id="Broker端处理消费进度"><a href="#Broker端处理消费进度" class="headerlink" title="Broker端处理消费进度"></a>Broker端处理消费进度</h2><p><strong>处理客户端定时上报消费进度</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;@1 ConsumerManageProcessor#processRequest#updateConsumerOffset</span><br><span class="line"></span><br><span class="line">this.brokerController.getConsumerOffsetManager().commitOffset</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@2 ConsumerOffsetManager#commitOffset</span><br><span class="line"></span><br><span class="line">String key &#x3D; topic + TOPIC_GROUP_SEPARATOR + group;</span><br><span class="line"></span><br><span class="line">this.commitOffset(clientHost, key, queueId, offset);</span><br><span class="line"></span><br><span class="line">Long storeOffset &#x3D; map.put(queueId, offset);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@3 消费进度缓存结构</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;key&#x3D;topic@group</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;value&#x3D;ConcurrentMap&lt;Integer&#x2F;* queueId*&#x2F;, Long&#x2F;*offset*&#x2F;&gt;&gt;</span><br><span class="line"></span><br><span class="line">offsetTable &#x3D; new ConcurrentHashMap&lt;String, ConcurrentMap&lt;Integer, Long&gt;&gt;(512);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@4 5秒钟一次存储消费进度</span><br><span class="line"></span><br><span class="line">this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line"></span><br><span class="line">public void run() &#123;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">BrokerController.this.consumerOffsetManager.persist();</span><br><span class="line"></span><br><span class="line">&#125; catch (Throwable e) &#123;</span><br><span class="line"></span><br><span class="line">log.error(&quot;schedule persist consumerOffset error.&quot;, e);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;, 1000 * 10, this.brokerConfig.getFlushConsumerOffsetInterval(), TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@5 consumerOffset.json文件格式</span><br><span class="line"></span><br><span class="line">&quot;zeus-package-mismatch-topic@autosort-packagelog&quot;:&#123;0:9055300,1:9055157,2:9055304,3:9055232&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：Broker接到客户端消费进度上报后更新缓存offsetTable，每隔5秒中定时任务将offsetTable消费进度存储在磁盘文件consumerOffset.json中。</span><br></pre></td></tr></table></figure>

<p><strong>消息拉取后实时更新消费进度</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;@1 PullMessageProcessor#processRequest</span><br><span class="line"></span><br><span class="line">if (storeOffsetEnable) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;更新消费进度</span><br><span class="line"></span><br><span class="line">this.brokerController.getConsumerOffsetManager().commitOffset(RemotingHelper.parseChannelRemoteAddr(channel),</span><br><span class="line"></span><br><span class="line">requestHeader.getConsumerGroup(), requestHeader.getTopic(), requestHeader.getQueueId(), requestHeader.getCommitOffset());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：PUSH消费客户端拉取消息后会实时更新消费的进度。</span><br></pre></td></tr></table></figure>



<h2 id="消费进度流转示意图"><a href="#消费进度流转示意图" class="headerlink" title="消费进度流转示意图"></a>消费进度流转示意图</h2><p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219143256.png"></p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ34# RocketMQ--ConsumeQueue文件与Index文件</title>
    <url>/posts/c4a1b302/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="问题思考"><a href="#问题思考" class="headerlink" title="问题思考"></a>问题思考</h1><p>消息消费时先从ConsumeQueue中获取物理偏移量，再根据物理偏移量从commitLog中获取具体消息；消息检索时会用到索引文件，其中值得思考的问题：</p>
<p>1.ConsumeQueue构建流程是怎样的？</p>
<p>2.ConsumeQueue数据结构是怎样的？</p>
<p>3.Index索引文件构建流程怎样的？</p>
<p>4.Index数据结构时怎么样的？</p>
<a id="more"></a>

<h1 id="ConsumeQueue-Index构建概览"><a href="#ConsumeQueue-Index构建概览" class="headerlink" title="ConsumeQueue/Index构建概览"></a>ConsumeQueue/Index构建概览</h1><h2 id="调用链条"><a href="#调用链条" class="headerlink" title="调用链条"></a>调用链条</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;Broker启动初始化</span><br><span class="line"></span><br><span class="line">@1 BrokerStartup#main</span><br><span class="line"></span><br><span class="line">start(createBrokerController(args))</span><br><span class="line"></span><br><span class="line">boolean initResult &#x3D; controller.initialize()</span><br><span class="line"></span><br><span class="line">@2 BrokerController#initialize</span><br><span class="line"></span><br><span class="line">this.messageStore &#x3D; new DefaultMessageStore</span><br><span class="line"></span><br><span class="line">@3 DefaultMessageStore#DefaultMessageStore()</span><br><span class="line"></span><br><span class="line">this.reputMessageService &#x3D; new ReputMessageService();</span><br><span class="line"></span><br><span class="line">this.dispatcherList &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">this.dispatcherList.addLast(new CommitLogDispatcherBuildConsumeQueue());</span><br><span class="line"></span><br><span class="line">this.dispatcherList.addLast(new CommitLogDispatcherBuildIndex());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;存储服务启动</span><br><span class="line"></span><br><span class="line">@4 DefaultMessageStore#start()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;允许重复转发reputFromOffset设置为CommitLog的提交指针</span><br><span class="line"></span><br><span class="line">if (this.getMessageStoreConfig().isDuplicationEnable()) &#123;this.reputMessageService.setReputFromOffset(this.commitLog.getConfirmOffset());</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;不允许重复转发reputFromOffset设置为CommitLog内存中最大偏移量 this.reputMessageService.setReputFromOffset(this.commitLog.getMaxOffset();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">this.reputMessageService.start();</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：@1中分别为dispatcherList添加了CommitLogDispatcherBuildConsumeQueue和CommitLogDispatcherBuildIndex；@4中duplicationEnable默认为false即不允许重复，从CommitLog中的最大偏移量开始转发，reputMessageService线程类在Broker启动时启动，主要负责构建consumeQueue与index文件。</span><br></pre></td></tr></table></figure>

<h2 id="ReputMessageService线程类职责"><a href="#ReputMessageService线程类职责" class="headerlink" title="ReputMessageService线程类职责"></a>ReputMessageService线程类职责</h2><p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219143536.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：ReputMessageServicee根据构建进度reputFromOffset查找可构建的消息数据，然后逐条解析组成构建请求，并构建consumeQueue和index文件构建；如果当前Broker为Master并且长轮询模式上通过消息到达监听器通知客户端。</span><br></pre></td></tr></table></figure>



<h1 id="ConsumeQueue构建流程及数据结构"><a href="#ConsumeQueue构建流程及数据结构" class="headerlink" title="ConsumeQueue构建流程及数据结构"></a>ConsumeQueue构建流程及数据结构</h1><p>在Broker启动时初始化了dispatcherList, 添加了分别负责ConsumeQueue文件和Index文件构建类；这部分关注ConsumeQueue构建。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.dispatcherList &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;构建ConsumeQueue</span><br><span class="line"></span><br><span class="line">this.dispatcherList.addLast(new CommitLogDispatcherBuildConsumeQueue());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;构建Index</span><br><span class="line"></span><br><span class="line">this.dispatcherList.addLast(new CommitLogDispatcherBuildIndex());</span><br><span class="line"></span><br><span class="line">public void doDispatch(DispatchRequest req) &#123;</span><br><span class="line"></span><br><span class="line">for (CommitLogDispatcher dispatcher : this.dispatcherList) &#123;</span><br><span class="line"></span><br><span class="line">dispatcher.dispatch(req);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<!--more-->



<h2 id="ConsumeQueue文件构建流程"><a href="#ConsumeQueue文件构建流程" class="headerlink" title="ConsumeQueue文件构建流程"></a>ConsumeQueue文件构建流程</h2><p><strong>调用链</strong></p>
<p>```</p>
<p>@1 DefaultMessageStore#putMessagePositionInfo</p>
<p>@2 ConsumeQueue#putMessagePositionInfoWrapper</p>
<p>```</p>
<p><strong>流程图</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219143645.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：ConsumeQueue构建主要流程为构建ConsumeQueue数据结构并将其写入fileChannel落盘；第一次创建ConsumeQueue文件时进行补位，用0填充，可促使系统实际分配内存起到预热作用。</span><br></pre></td></tr></table></figure>

<p><strong>补位代码</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void fillPreBlank(final MappedFile mappedFile, final long untilWhere) &#123;</span><br><span class="line"></span><br><span class="line">ByteBuffer byteBuffer &#x3D; ByteBuffer.allocate(CQ_STORE_UNIT_SIZE);</span><br><span class="line"></span><br><span class="line">byteBuffer.putLong(0L);</span><br><span class="line"></span><br><span class="line">byteBuffer.putInt(Integer.MAX_VALUE);</span><br><span class="line"></span><br><span class="line">byteBuffer.putLong(0L);</span><br><span class="line"></span><br><span class="line">int until &#x3D; (int) (untilWhere % this.mappedFileQueue.getMappedFileSize());</span><br><span class="line"></span><br><span class="line">for (int i &#x3D; 0; i &lt; until; i +&#x3D; CQ_STORE_UNIT_SIZE) &#123;</span><br><span class="line"></span><br><span class="line">mappedFile.appendMessage(byteBuffer.array());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="ConsumeQueue数据结构"><a href="#ConsumeQueue数据结构" class="headerlink" title="ConsumeQueue数据结构"></a>ConsumeQueue数据结构</h2><p><strong>数据结构代码</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.byteBufferIndex.flip();</span><br><span class="line"></span><br><span class="line">this.byteBufferIndex.limit(CQ_STORE_UNIT_SIZE); &#x2F;&#x2F;限定每个条目大小</span><br><span class="line"></span><br><span class="line">this.byteBufferIndex.putLong(offset); &#x2F;&#x2F;写入消息偏移量</span><br><span class="line"></span><br><span class="line">this.byteBufferIndex.putInt(size); &#x2F;&#x2F;写入消息长度</span><br><span class="line"></span><br><span class="line">this.byteBufferIndex.putLong(tagsCode); &#x2F;&#x2F;写入tag hashcode</span><br></pre></td></tr></table></figure>



<p><strong>数据结构图示</strong></p>
<p>ConsumeQueue文件中每个条目占20位。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219143751.png"></p>
<h1 id="Index构建流程及数据结构"><a href="#Index构建流程及数据结构" class="headerlink" title="Index构建流程及数据结构"></a>Index构建流程及数据结构</h1><p>在Broker启动时初始化了dispatcherList, 添加了分别负责ConsumeQueue文件和Index文件构建类；这部分关注Index构建。</p>
<p>IndexService初始化时初始化两个参数Hash槽数量hashSlotNum=5000000，索引的最大数量maxIndexNum=5000000 * 4=20000000。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.dispatcherList &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;构建ConsumeQueue</span><br><span class="line"></span><br><span class="line">this.dispatcherList.addLast(new CommitLogDispatcherBuildConsumeQueue());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;构建Index</span><br><span class="line"></span><br><span class="line">this.dispatcherList.addLast(new CommitLogDispatcherBuildIndex());</span><br><span class="line"></span><br><span class="line">public void doDispatch(DispatchRequest req) &#123;</span><br><span class="line"></span><br><span class="line">for (CommitLogDispatcher dispatcher : this.dispatcherList) &#123;</span><br><span class="line"></span><br><span class="line">dispatcher.dispatch(req);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;IndexService初始化</span><br><span class="line"></span><br><span class="line">public IndexService(final DefaultMessageStore store) &#123;</span><br><span class="line"></span><br><span class="line">this.defaultMessageStore &#x3D; store;</span><br><span class="line"></span><br><span class="line">this.hashSlotNum &#x3D; store.getMessageStoreConfig().getMaxHashSlotNum();</span><br><span class="line"></span><br><span class="line">this.indexNum &#x3D; store.getMessageStoreConfig().getMaxIndexNum();</span><br><span class="line"></span><br><span class="line">this.storePath &#x3D;</span><br><span class="line"></span><br><span class="line">StorePathConfigHelper.getStorePathIndex(store.getMessageStoreConfig().getStorePathRootDir());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Index文件构建流程"><a href="#Index文件构建流程" class="headerlink" title="Index文件构建流程"></a>Index文件构建流程</h2><p><strong>调用链条</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@1 DefaultMessageStore#CommitLogDispatcherBuildIndex#dispatch</span><br><span class="line"></span><br><span class="line">@2 IdexService#buildIndex</span><br></pre></td></tr></table></figure>



<p><strong>流程图</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219143915.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：Index文件写入流程概要：先获取索引文件并将未写入文件的内存数据通过守护线程写入磁盘；计算要写入索引所在hash槽的位置取出原来的值；构建索引条目填充数据；最后更新索引文件头部信息。</span><br></pre></td></tr></table></figure>



<h2 id="Index数据结构"><a href="#Index数据结构" class="headerlink" title="Index数据结构"></a>Index数据结构</h2><p><strong>写入索引数据到mappedByteBuffer代码</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;计算索引数据需要放在哪个位置</span><br><span class="line"></span><br><span class="line">int absIndexPos &#x3D;</span><br><span class="line"></span><br><span class="line">IndexHeader.INDEX_HEADER_SIZE + this.hashSlotNum * hashSlotSize</span><br><span class="line"></span><br><span class="line">\+ this.indexHeader.getIndexCount() * indexSize;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将hashcode存储在MappedByteBuffer中</span><br><span class="line"></span><br><span class="line">this.mappedByteBuffer.putInt(absIndexPos, keyHash);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将物理偏移量存储在MappedByteBuffer中</span><br><span class="line"></span><br><span class="line">this.mappedByteBuffer.putLong(absIndexPos + 4, phyOffset);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;落地时间-当前索引的起始时间差值写入MappedByteBuffer</span><br><span class="line"></span><br><span class="line">this.mappedByteBuffer.putInt(absIndexPos + 4 + 8, (int) timeDiff);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;记录前一条hash桶对应的值（Index条目下标）；注意此处用于解决Hash冲突</span><br><span class="line"></span><br><span class="line">this.mappedByteBuffer.putInt(absIndexPos + 4 + 8 + 4, slotValue);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将当前index中包含的条目数量存入到Hash槽中，将覆盖原先的值</span><br><span class="line"></span><br><span class="line">this.mappedByteBuffer.putInt(absSlotPos,this.indexHeader.getIndexCount());</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：上述代码描述索引条目的构建流程及数据结构，通过记录上一条冲突的槽值形成链表结构。</span><br></pre></td></tr></table></figure>



<h2 id="Index数据结构图示"><a href="#Index数据结构图示" class="headerlink" title="Index数据结构图示"></a>Index数据结构图示</h2><p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219144023.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：Index索引有三部分组成IndexHeader、Hash槽位、索引条目；每块内容和所占大小如图所示；如果有Hash冲突，在每个索引条目最后记录了原来Hash槽里的值，从而形成链表结构。</span><br></pre></td></tr></table></figure></div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ35# RocketMQ NameServe</title>
    <url>/posts/a0b01b06/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="NameServer启动"><a href="#NameServer启动" class="headerlink" title="NameServer启动"></a>NameServer启动</h1><p>* 从生产环境实践来看，NameServer启动使用默认配置即可，运行良好。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">启动命令：nohup sh bin&#x2F;mqnamesrv &amp;</span><br></pre></td></tr></table></figure>

<p>* NamesrvStartup.java 启动入口类，NameServer 启动默认端口9876</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nettyServerConfig.setListenPort(9876)</span><br></pre></td></tr></table></figure>

<p>* 每10秒钟扫描一次，移除失效的broker，同时移除缓存元数据</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;初始化NameServer</span><br><span class="line"></span><br><span class="line">boolean initResult &#x3D; controller.initialize();</span><br><span class="line"></span><br><span class="line">public boolean initialize() &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;加载KV配置</span><br><span class="line"></span><br><span class="line">this.kvConfigManager.load();</span><br><span class="line"></span><br><span class="line">this.remotingServer &#x3D; new NettyRemotingServer(this.nettyServerConfig, this.brokerHousekeepingService);</span><br><span class="line"></span><br><span class="line">this.remotingExecutor &#x3D;</span><br><span class="line"></span><br><span class="line">Executors.newFixedThreadPool(nettyServerConfig.getServerWorkerThreads(), new ThreadFactoryImpl(&quot;RemotingExecutorThread_&quot;));</span><br><span class="line"></span><br><span class="line">this.registerProcessor();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;每10秒钟扫描一次，移除失效的broker</span><br><span class="line"></span><br><span class="line">this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line"></span><br><span class="line">public void run() &#123;</span><br><span class="line"></span><br><span class="line">NamesrvController.this.routeInfoManager.scanNotActiveBroker();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;, 5, 10, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;每隔10秒钟打印一次KV配置信息</span><br><span class="line"></span><br><span class="line">this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line"></span><br><span class="line">public void run() &#123;</span><br><span class="line"></span><br><span class="line">NamesrvController.this.kvConfigManager.printAllPeriodically();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;, 1, 10, TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">return true;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>* 失效时间为2分钟，即：Broker在2分钟内未上报心跳会被移除</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;失效时间为2分钟，即：Broker在2分钟内未上报心跳会被移除</span><br><span class="line"></span><br><span class="line">public void scanNotActiveBroker() &#123;</span><br><span class="line"></span><br><span class="line">Iterator&lt;Entry&lt;String, BrokerLiveInfo&gt;&gt; it &#x3D; this.brokerLiveTable.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">while (it.hasNext()) &#123;</span><br><span class="line"></span><br><span class="line">Entry&lt;String, BrokerLiveInfo&gt; next &#x3D; it.next();</span><br><span class="line"></span><br><span class="line">long last &#x3D; next.getValue().getLastUpdateTimestamp();</span><br><span class="line"></span><br><span class="line">if ((last + BROKER_CHANNEL_EXPIRED_TIME) &lt; System.currentTimeMillis()) &#123;</span><br><span class="line"></span><br><span class="line">RemotingUtil.closeChannel(next.getValue().getChannel());</span><br><span class="line"></span><br><span class="line">it.remove();</span><br><span class="line"></span><br><span class="line">log.warn(&quot;The broker channel expired, &#123;&#125; &#123;&#125;ms&quot;, next.getKey(), BROKER_CHANNEL_EXPIRED_TIME);</span><br><span class="line"></span><br><span class="line">this.onChannelDestroy(next.getKey(), next.getValue().getChannel());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private final static long BROKER_CHANNEL_EXPIRED_TIME &#x3D; 1000 * 60 * 2;</span><br></pre></td></tr></table></figure>



<h1 id="DefaultRequestProcessor"><a href="#DefaultRequestProcessor" class="headerlink" title="DefaultRequestProcessor"></a>DefaultRequestProcessor</h1><p>* 用于响应客户端、Broker的请求。主要向NameServer发送心跳包、获取Cluster、Broker、Topic元数据信息。</p>
<p>* 调用链：在NameServer启动时注册，NamesrvController.initialize()-&gt;registerProcessor()。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public RemotingCommand processRequest(ChannelHandlerContext ctx, RemotingCommand request) throws RemotingCommandException &#123;</span><br><span class="line"></span><br><span class="line">if (log.isDebugEnabled()) &#123;</span><br><span class="line"></span><br><span class="line">log.debug(&quot;receive request, &#123;&#125; &#123;&#125; &#123;&#125;&quot;,</span><br><span class="line"></span><br><span class="line">request.getCode(),</span><br><span class="line"></span><br><span class="line">RemotingHelper.parseChannelRemoteAddr(ctx.channel()),</span><br><span class="line"></span><br><span class="line">request);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">switch (request.getCode()) &#123;</span><br><span class="line"></span><br><span class="line">case RequestCode.PUT_KV_CONFIG:&#x2F;&#x2F;增加NameServer配置信息；由DefaultMQAdminExt使用</span><br><span class="line"></span><br><span class="line">return this.putKVConfig(ctx, request);</span><br><span class="line"></span><br><span class="line">case RequestCode.GET_KV_CONFIG:&#x2F;&#x2F;根据NameSpace和key获取NameServer配置信息；由DefaultMQAdminExt使用</span><br><span class="line"></span><br><span class="line">return this.getKVConfig(ctx, request);</span><br><span class="line"></span><br><span class="line">case RequestCode.DELETE_KV_CONFIG: &#x2F;&#x2F;据NameSapce和Key删除NameServerr配置信息</span><br><span class="line"></span><br><span class="line">return this.deleteKVConfig(ctx, request);</span><br><span class="line"></span><br><span class="line">case RequestCode.REGISTER_BROKER: &#x2F;&#x2F;注册Broker信息；由BrokerOuterAPI.registerBroker使用，在BrokerController启动时调用</span><br><span class="line"></span><br><span class="line">Version brokerVersion &#x3D; MQVersion.value2Version(request.getVersion());</span><br><span class="line"></span><br><span class="line">if (brokerVersion.ordinal() &gt;&#x3D; MQVersion.Version.V3_0_11.ordinal()) &#123;</span><br><span class="line"></span><br><span class="line">return this.registerBrokerWithFilterServer(ctx, request);</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line"></span><br><span class="line">return this.registerBroker(ctx, request);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">case RequestCode.UNREGISTER_BROKER:&#x2F;&#x2F;移除注销broker信息；由BrokerOuterAPI.unregisterBroker使用，在BrokerController.shutdown时调用</span><br><span class="line"></span><br><span class="line">return this.unregisterBroker(ctx, request);</span><br><span class="line"></span><br><span class="line">case RequestCode.GET_ROUTEINTO_BY_TOPIC: &#x2F;&#x2F;获取Topic路由信息 TopicRouteData</span><br><span class="line"></span><br><span class="line">return this.getRouteInfoByTopic(ctx, request);</span><br><span class="line"></span><br><span class="line">case RequestCode.GET_BROKER_CLUSTER_INFO:&#x2F;&#x2F;获取Cluster及Broker信息</span><br><span class="line"></span><br><span class="line">return this.getBrokerClusterInfo(ctx, request);</span><br><span class="line"></span><br><span class="line">case RequestCode.WIPE_WRITE_PERM_OF_BROKER: &#x2F;&#x2F;去除该broker上所有topic的写权限</span><br><span class="line"></span><br><span class="line">return this.wipeWritePermOfBroker(ctx, request);</span><br><span class="line"></span><br><span class="line">case RequestCode.GET_ALL_TOPIC_LIST_FROM_NAMESERVER: &#x2F;&#x2F;获取所有的Topic列表</span><br><span class="line"></span><br><span class="line">return getAllTopicListFromNameserver(ctx, request);</span><br><span class="line"></span><br><span class="line">case RequestCode.DELETE_TOPIC_IN_NAMESRV: &#x2F;&#x2F;从nameServer中删除topic</span><br><span class="line"></span><br><span class="line">return deleteTopicInNamesrv(ctx, request);</span><br><span class="line"></span><br><span class="line">case RequestCode.GET_KVLIST_BY_NAMESPACE: &#x2F;&#x2F;获取配置信息 configTable</span><br><span class="line"></span><br><span class="line">return this.getKVListByNamespace(ctx, request);</span><br><span class="line"></span><br><span class="line">case RequestCode.GET_TOPICS_BY_CLUSTER: &#x2F;&#x2F;获取该集群下的所有topic list</span><br><span class="line"></span><br><span class="line">return this.getTopicsByCluster(ctx, request);</span><br><span class="line"></span><br><span class="line">case RequestCode.GET_SYSTEM_TOPIC_LIST_FROM_NS: &#x2F;&#x2F; 此处意思为：系统会将集群名称、broker名称作为默认topic创建。现在获取这类topic</span><br><span class="line"></span><br><span class="line">return this.getSystemTopicListFromNs(ctx, request);</span><br><span class="line"></span><br><span class="line">case RequestCode.GET_UNIT_TOPIC_LIST: &#x2F;&#x2F;暂无使用</span><br><span class="line"></span><br><span class="line">return this.getUnitTopicList(ctx, request);</span><br><span class="line"></span><br><span class="line">case RequestCode.GET_HAS_UNIT_SUB_TOPIC_LIST: &#x2F;&#x2F;暂无使用</span><br><span class="line"></span><br><span class="line">return this.getHasUnitSubTopicList(ctx, request);</span><br><span class="line"></span><br><span class="line">case RequestCode.GET_HAS_UNIT_SUB_UNUNIT_TOPIC_LIST:&#x2F;&#x2F;暂无使用</span><br><span class="line"></span><br><span class="line">return this.getHasUnitSubUnUnitTopicList(ctx, request);</span><br><span class="line"></span><br><span class="line">case RequestCode.UPDATE_NAMESRV_CONFIG: &#x2F;&#x2F;更新properties请求</span><br><span class="line"></span><br><span class="line">return this.updateConfig(ctx, request);</span><br><span class="line"></span><br><span class="line">case RequestCode.GET_NAMESRV_CONFIG: &#x2F;&#x2F;获取properties内容</span><br><span class="line"></span><br><span class="line">return this.getConfig(ctx, request);</span><br><span class="line"></span><br><span class="line">default:</span><br><span class="line"></span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return null;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<!--more-->



<h1 id="注册broker信息"><a href="#注册broker信息" class="headerlink" title="注册broker信息"></a><strong>注册broker信息</strong></h1><p>* Broker每隔30秒向所有的NameServer上报Topic注册信息</p>
<p>* Broker调用链：BrokerController.start()-&gt;this.registerBrokerAll()-&gt;this.brokerOuterAPI.registerBrokerAll()</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;每隔30秒向所有的NameServer上报Topic注册信息</span><br><span class="line"></span><br><span class="line">this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line"></span><br><span class="line">public void run() &#123;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">BrokerController.this.registerBrokerAll(true, false);</span><br><span class="line"></span><br><span class="line">&#125; catch (Throwable e) &#123;</span><br><span class="line"></span><br><span class="line">log.error(&quot;registerBrokerAll Exception&quot;, e);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;, 1000 * 10, 1000 * 30, TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure>



<p>* 服务端处理主要包括：注册集群信息clusterAddrTable、注册broker信息brokerAddrTable、注册topic信息topicQueueTable、</p>
<p>broker心跳包brokerLiveTable</p>
<p>* NameServer处理链：DefaultRequestProcessor-&gt;processRequest-&gt;RequestCode.REGISTER_BROKER-&gt;this.registerBroker-&gt;</p>
<p>RouteInfoManager.registerBroker()</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public RegisterBrokerResult registerBroker(</span><br><span class="line"></span><br><span class="line">final String clusterName,</span><br><span class="line"></span><br><span class="line">final String brokerAddr,</span><br><span class="line"></span><br><span class="line">final String brokerName,</span><br><span class="line"></span><br><span class="line">final long brokerId,</span><br><span class="line"></span><br><span class="line">final String haServerAddr,</span><br><span class="line"></span><br><span class="line">final TopicConfigSerializeWrapper topicConfigWrapper,</span><br><span class="line"></span><br><span class="line">final List&lt;String&gt; filterServerList,</span><br><span class="line"></span><br><span class="line">final Channel channel) &#123;</span><br><span class="line"></span><br><span class="line">RegisterBrokerResult result &#x3D; new RegisterBrokerResult();</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;加写锁，防止并发修改</span><br><span class="line"></span><br><span class="line">this.lock.writeLock().lockInterruptibly();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;注册集群信息</span><br><span class="line"></span><br><span class="line">Set&lt;String&gt; brokerNames &#x3D; this.clusterAddrTable.get(clusterName);</span><br><span class="line"></span><br><span class="line">if (null &#x3D;&#x3D; brokerNames) &#123;</span><br><span class="line"></span><br><span class="line">brokerNames &#x3D; new HashSet&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">this.clusterAddrTable.put(clusterName, brokerNames);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">brokerNames.add(brokerName);</span><br><span class="line"></span><br><span class="line">boolean registerFirst &#x3D; false;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;注册broker信息</span><br><span class="line"></span><br><span class="line">BrokerData brokerData &#x3D; this.brokerAddrTable.get(brokerName);</span><br><span class="line"></span><br><span class="line">if (null &#x3D;&#x3D; brokerData) &#123;</span><br><span class="line"></span><br><span class="line">registerFirst &#x3D; true;</span><br><span class="line"></span><br><span class="line">brokerData &#x3D; new BrokerData(clusterName, brokerName, new HashMap&lt;Long, String&gt;());</span><br><span class="line"></span><br><span class="line">this.brokerAddrTable.put(brokerName, brokerData);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String oldAddr &#x3D; brokerData.getBrokerAddrs().put(brokerId, brokerAddr);</span><br><span class="line"></span><br><span class="line">registerFirst &#x3D; registerFirst || (null &#x3D;&#x3D; oldAddr);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Topic配置变化了；Master Broker第一次注册或者Topic dataVersion不相同时更新路由信息</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;有Topic新增时dataVersion会递增</span><br><span class="line"></span><br><span class="line">if (null !&#x3D; topicConfigWrapper &#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">&amp;&amp; MixAll.MASTER_ID &#x3D;&#x3D; brokerId) &#123;</span><br><span class="line"></span><br><span class="line">if (this.isBrokerTopicConfigChanged(brokerAddr, topicConfigWrapper.getDataVersion())&#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">|| registerFirst) &#123;</span><br><span class="line"></span><br><span class="line">ConcurrentMap&lt;String, TopicConfig&gt; tcTable &#x3D;</span><br><span class="line"></span><br><span class="line">topicConfigWrapper.getTopicConfigTable();</span><br><span class="line"></span><br><span class="line">if (tcTable !&#x3D; null) &#123;</span><br><span class="line"></span><br><span class="line">for (Map.Entry&lt;String, TopicConfig&gt; entry : tcTable.entrySet()) &#123;</span><br><span class="line"></span><br><span class="line">this.createAndUpdateQueueData(brokerName, entry.getValue()); &#x2F;&#x2F;更新topicQueueTable</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;更新broker心跳信息</span><br><span class="line"></span><br><span class="line">BrokerLiveInfo prevBrokerLiveInfo &#x3D; this.brokerLiveTable.put(brokerAddr,</span><br><span class="line"></span><br><span class="line">new BrokerLiveInfo(</span><br><span class="line"></span><br><span class="line">System.currentTimeMillis(),</span><br><span class="line"></span><br><span class="line">topicConfigWrapper.getDataVersion(),</span><br><span class="line"></span><br><span class="line">channel,</span><br><span class="line"></span><br><span class="line">haServerAddr));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;新broker注册时会有日志输出</span><br><span class="line"></span><br><span class="line">if (null &#x3D;&#x3D; prevBrokerLiveInfo) &#123;</span><br><span class="line"></span><br><span class="line">log.info(&quot;new broker registerd, &#123;&#125; HAServer: &#123;&#125;&quot;, brokerAddr, haServerAddr);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;更新filterServer信息</span><br><span class="line"></span><br><span class="line">if (filterServerList !&#x3D; null) &#123;</span><br><span class="line"></span><br><span class="line">if (filterServerList.isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line">this.filterServerTable.remove(brokerAddr);</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line"></span><br><span class="line">this.filterServerTable.put(brokerAddr, filterServerList);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Slave设置MasterAddr和HaServerAddr</span><br><span class="line"></span><br><span class="line">if (MixAll.MASTER_ID !&#x3D; brokerId) &#123;</span><br><span class="line"></span><br><span class="line">String masterAddr &#x3D; brokerData.getBrokerAddrs().get(MixAll.MASTER_ID);</span><br><span class="line"></span><br><span class="line">if (masterAddr !&#x3D; null) &#123;</span><br><span class="line"></span><br><span class="line">BrokerLiveInfo brokerLiveInfo &#x3D; this.brokerLiveTable.get(masterAddr);</span><br><span class="line"></span><br><span class="line">if (brokerLiveInfo !&#x3D; null) &#123;</span><br><span class="line"></span><br><span class="line">result.setHaServerAddr(brokerLiveInfo.getHaServerAddr());</span><br><span class="line"></span><br><span class="line">result.setMasterAddr(masterAddr);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; finally &#123;</span><br><span class="line"></span><br><span class="line">this.lock.writeLock().unlock();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">log.error(&quot;registerBroker Exception&quot;, e);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h1 id="NameServer缓存元数据结构"><a href="#NameServer缓存元数据结构" class="headerlink" title="NameServer缓存元数据结构"></a>NameServer缓存元数据结构</h1><p>* 注册集群信息clusterAddrTable</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Broker集群信息; key为集群名称，value为所有的broker名称集合</span><br><span class="line"></span><br><span class="line">private final HashMap&lt;String&#x2F;* clusterName *&#x2F;, Set&lt;String&#x2F;* brokerName *&#x2F;&gt;&gt; clusterAddrTable;</span><br></pre></td></tr></table></figure>

<p>* 注册broker信息brokerAddrTable</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"></span><br><span class="line">\* Broker信息；key为brokerName，value为BrokerData</span><br><span class="line"></span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">private final HashMap&lt;String&#x2F;* brokerName *&#x2F;, BrokerData&gt; brokerAddrTable;</span><br><span class="line"></span><br><span class="line">public class BrokerData implements Comparable&lt;BrokerData&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"></span><br><span class="line">\* Cluster名称</span><br><span class="line"></span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">private String cluster;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"></span><br><span class="line">\* broker名称</span><br><span class="line"></span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">private String brokerName;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"></span><br><span class="line">\* 0-&gt;ip:port</span><br><span class="line"></span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">private HashMap&lt;Long&#x2F;* brokerId *&#x2F;, String&#x2F;* broker address *&#x2F;&gt; brokerAddrs;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>* 注册topic信息topicQueueTable</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;消息队列路由信息；key为topic，value为QueueData</span><br><span class="line"></span><br><span class="line">private final HashMap&lt;String&#x2F;* topic *&#x2F;, List&lt;QueueData&gt;&gt; topicQueueTable;</span><br><span class="line"></span><br><span class="line">public class QueueData implements Comparable&lt;QueueData&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Broker名称</span><br><span class="line"></span><br><span class="line">private String brokerName;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;读队列个数，默认4个</span><br><span class="line"></span><br><span class="line">private int readQueueNums;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;写队列个数，默认4个</span><br><span class="line"></span><br><span class="line">private int writeQueueNums;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 队列权限</span><br><span class="line"></span><br><span class="line">private int perm;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;配置的,同步复制还是异步复制标记,对应TopicConfig.topicSysFlag</span><br><span class="line"></span><br><span class="line">private int topicSynFlag;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>* Broker心跳包brokerLiveTable</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;Broker状态信息，NameServer每次收到心跳包会替换该信息，每隔30秒更新一次</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;brokerAddr: ip:port-&gt;&#123;&#125;</span><br><span class="line"></span><br><span class="line">private final HashMap&lt;String&#x2F;* brokerAddr *&#x2F;, BrokerLiveInfo&gt; brokerLiveTable;</span><br><span class="line"></span><br><span class="line">class BrokerLiveInfo &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 存储上次收到心跳包的时间,每隔30秒更新一次</span><br><span class="line"></span><br><span class="line">private long lastUpdateTimestamp;</span><br><span class="line"></span><br><span class="line">private DataVersion dataVersion;</span><br><span class="line"></span><br><span class="line">private Channel channel;</span><br><span class="line"></span><br><span class="line">private String haServerAddr;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ36# RocketMQ Topic创建</title>
    <url>/posts/ee41af7f/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="Topic创建的方式"><a href="#Topic创建的方式" class="headerlink" title="Topic创建的方式"></a>Topic创建的方式</h1><p>Topic的创建分为自动创建和通过命令行创建两种。通过broker配置参数autoCreateTopicEnable设置。 通常可以在非生产环境开启自动创建，生产环境待审批后再进行创建。</p>
<p>* 命令行创建</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh bin&#x2F;mqadmin updateTopic -c DefaultCluster -n localhost:9876 -t threezto-test -r 12 -w 12</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h1 id="客户端发起Topic创建请求"><a href="#客户端发起Topic创建请求" class="headerlink" title="客户端发起Topic创建请求"></a>客户端发起Topic创建请求</h1><p>* 客户端工作：向集群中各个broker主节点通知topic配置变更</p>
<p>* 参数设定：通过参数指定读队列数量、写队列数量、权限、当指定-c时，在该集群的所有broker都会创建</p>
<p>* 调用链</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UpdateTopicSubCommand.execute()-&gt;defaultMQAdminExtImpl.createAndUpdateTopicConfig-&gt;MQClientAPIImpl.createTopic</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;-c指定，集群中每个broker主节点都会创建</span><br><span class="line"></span><br><span class="line">Set&lt;String&gt; masterSet &#x3D;</span><br><span class="line"></span><br><span class="line">CommandUtil.fetchMasterAddrByClusterName(defaultMQAdminExt, clusterName);</span><br><span class="line"></span><br><span class="line">for (String addr : masterSet) &#123;</span><br><span class="line"></span><br><span class="line">defaultMQAdminExt.createAndUpdateTopicConfig(addr, topicConfig);</span><br><span class="line"></span><br><span class="line">System.out.printf(&quot;create topic to %s success.%n&quot;, addr);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<!--more-->



<h1 id="Broker处理Topic创建"><a href="#Broker处理Topic创建" class="headerlink" title="Broker处理Topic创建"></a>Broker处理Topic创建</h1><p>* Broker处理请求</p>
<p>1.更改本地topic配置缓存topicConfigTable</p>
<p>2.将缓存topicConfigTable配置信息写入磁盘</p>
<p>3.向NameServer上报变更信息</p>
<p>4.主从同步变更信息</p>
<p>* 调用链</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AdminBrokerProcessor.processRequest()-&gt;RequestCode.UPDATE_AND_CREATE_TOPIC-&gt;updateAndCreateTopic</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private RemotingCommand updateAndCreateTopic(ChannelHandlerContext ctx, RemotingCommand request) throws RemotingCommandException &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;省略代码</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;更改broker缓存topicConfigTable信息并落盘存储</span><br><span class="line"></span><br><span class="line">this.brokerController.getTopicConfigManager().updateTopicConfig(topicConfig);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;向nameSrv上报变更信息，主从同步</span><br><span class="line"></span><br><span class="line">this.brokerController.registerBrokerAll(false, true);</span><br><span class="line"></span><br><span class="line">return null;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>* 更改本地topic配置缓存topicConfigTable以及持久化磁盘</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void updateTopicConfig(final TopicConfig topicConfig) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;更新Topic缓存配置</span><br><span class="line"></span><br><span class="line">TopicConfig old &#x3D; this.topicConfigTable.put(topicConfig.getTopicName(), topicConfig);</span><br><span class="line"></span><br><span class="line">if (old !&#x3D; null) &#123;</span><br><span class="line"></span><br><span class="line">LOG.info(&quot;update topic config, old:[&#123;&#125;] new:[&#123;&#125;]&quot;, old, topicConfig);</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line"></span><br><span class="line">LOG.info(&quot;create new topic [&#123;&#125;]&quot;, topicConfig);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;递增版本</span><br><span class="line"></span><br><span class="line">this.dataVersion.nextVersion();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;存储本地磁盘</span><br><span class="line"></span><br><span class="line">this.persist();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"></span><br><span class="line">\* 持久化磁盘</span><br><span class="line"></span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">public synchronized void persist() &#123;</span><br><span class="line"></span><br><span class="line">String jsonString &#x3D; this.encode(true);</span><br><span class="line"></span><br><span class="line">if (jsonString !&#x3D; null) &#123;</span><br><span class="line"></span><br><span class="line">String fileName &#x3D; this.configFilePath();</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">MixAll.string2File(jsonString, fileName);</span><br><span class="line"></span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line"></span><br><span class="line">PLOG.error(&quot;persist file Exception, &quot; + fileName, e);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>* Topic配置存储的磁盘格式config/topics.json</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;topic_online_test&quot;:&#123;</span><br><span class="line"></span><br><span class="line">&quot;order&quot;:false,</span><br><span class="line"></span><br><span class="line">&quot;perm&quot;:6,</span><br><span class="line"></span><br><span class="line">&quot;readQueueNums&quot;:4,</span><br><span class="line"></span><br><span class="line">&quot;topicFilterType&quot;:&quot;SINGLE_TAG&quot;,</span><br><span class="line"></span><br><span class="line">&quot;topicName&quot;:&quot;topic_online_test&quot;,</span><br><span class="line"></span><br><span class="line">&quot;topicSysFlag&quot;:0,</span><br><span class="line"></span><br><span class="line">&quot;writeQueueNums&quot;:4</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>* 向NameServer上报变更信息，主从同步.</p>
<p>NameServer收到请求处理见：<a href="https://www.jianshu.com/p/db5ed97fd19d">RocketMQ NameServer源码梳理笔记</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public synchronized void registerBrokerAll(final boolean checkOrderConfig, boolean oneway) &#123;</span><br><span class="line"></span><br><span class="line">TopicConfigSerializeWrapper topicConfigWrapper &#x3D; this.getTopicConfigManager().buildTopicConfigSerializeWrapper();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Broker只有读或者写权限时, Topic设置为与broker相同的权限</span><br><span class="line"></span><br><span class="line">if (!PermName.isWriteable(this.getBrokerConfig().getBrokerPermission())</span><br><span class="line"></span><br><span class="line">|| !PermName.isReadable(this.getBrokerConfig().getBrokerPermission())) &#123;</span><br><span class="line"></span><br><span class="line">ConcurrentHashMap&lt;String, TopicConfig&gt; topicConfigTable &#x3D; new ConcurrentHashMap&lt;String, TopicConfig&gt;();</span><br><span class="line"></span><br><span class="line">for (TopicConfig topicConfig : topicConfigWrapper.getTopicConfigTable().values()) &#123;</span><br><span class="line"></span><br><span class="line">TopicConfig tmp &#x3D;</span><br><span class="line"></span><br><span class="line">new TopicConfig(topicConfig.getTopicName(), topicConfig.getReadQueueNums(), topicConfig.getWriteQueueNums(),</span><br><span class="line"></span><br><span class="line">this.brokerConfig.getBrokerPermission());</span><br><span class="line"></span><br><span class="line">topicConfigTable.put(topicConfig.getTopicName(), tmp);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">topicConfigWrapper.setTopicConfigTable(topicConfigTable);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;向所有NameServer节点注册Topic信息</span><br><span class="line"></span><br><span class="line">RegisterBrokerResult registerBrokerResult &#x3D; this.brokerOuterAPI.registerBrokerAll(</span><br><span class="line"></span><br><span class="line">this.brokerConfig.getBrokerClusterName(),</span><br><span class="line"></span><br><span class="line">this.getBrokerAddr(),</span><br><span class="line"></span><br><span class="line">this.brokerConfig.getBrokerName(),</span><br><span class="line"></span><br><span class="line">this.brokerConfig.getBrokerId(),</span><br><span class="line"></span><br><span class="line">this.getHAServerAddr(),</span><br><span class="line"></span><br><span class="line">topicConfigWrapper,</span><br><span class="line"></span><br><span class="line">this.filterServerManager.buildNewFilterServerList(),</span><br><span class="line"></span><br><span class="line">oneway,</span><br><span class="line"></span><br><span class="line">this.brokerConfig.getRegisterBrokerTimeoutMills());</span><br><span class="line"></span><br><span class="line">if (registerBrokerResult !&#x3D; null) &#123;</span><br><span class="line"></span><br><span class="line">if (this.updateMasterHAServerAddrPeriodically &amp;&amp; registerBrokerResult.getHaServerAddr() !&#x3D; null) &#123;</span><br><span class="line"></span><br><span class="line">this.messageStore.updateHaMasterAddress(registerBrokerResult.getHaServerAddr());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Slave同步Master信息 每分钟定时同步</span><br><span class="line"></span><br><span class="line">this.slaveSynchronize.setMasterAddr(registerBrokerResult.getMasterAddr());</span><br><span class="line"></span><br><span class="line">if (checkOrderConfig) &#123;</span><br><span class="line"></span><br><span class="line">this.getTopicConfigManager().updateOrderTopicConfig(registerBrokerResult.getKvTable());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ38# RocketMQ消息发送（二）</title>
    <url>/posts/bfe41dca/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="发送接口分类"><a href="#发送接口分类" class="headerlink" title="发送接口分类"></a>发送接口分类</h1><p>* 按照发送方式分类</p>
<ol>
<li><p>同步发送：等待返回结果</p>
</li>
<li><p>异步发送：异步回调发送结果</p>
</li>
<li><p>一次发送：无结果返回</p>
</li>
</ol>
<p>* 按一次发送消息数量分类</p>
<ol>
<li><p>单条消息发送</p>
</li>
<li><p>批量消息发送</p>
</li>
</ol>
<p>* 按照是否指定MessageQueue分类</p>
<ol>
<li><p>随机选择发送</p>
</li>
<li><p>指定特定MessageQueue</p>
</li>
<li><p>自定义MessageQueue选择器</p>
</li>
</ol>
<a id="more"></a>

<p><strong>详细接口</strong></p>
<p>|接口 |描述 |</p>
<p>| — | — |</p>
<p>| send(final Message msg) |同步单条消息发送 |</p>
<p>| send(final Message msg, final long timeout) |同步单条消息发送（超时设置） |</p>
<p>| send(final Message msg, final SendCallback sendCallback) | 异步单条消息发送 |</p>
<p>| send(final Message msg, final SendCallback sendCallback, final long timeout) |异步单条消息发送（超时） |</p>
<p>|sendOneway(final Message msg) | 一次单条消息发送 |</p>
<p>| send(final Message msg, final MessageQueue mq) | 同步单条发送指定Queue |</p>
<p>| send(final Message msg, final MessageQueue mq, final long timeout) | 同步单条发送指定 Queue（超时设置） |</p>
<p>| send(final Message msg, final MessageQueue mq, final SendCallback sendCallback) |异步单条发送指定 Queue |</p>
<p>| send(final Message msg, final MessageQueue mq, final SendCallback sendCallback, long timeout) |异步单条发送指定 Queue（超时设置） |</p>
<p>| sendOneway(final Message msg, final MessageQueue mq) |一次单条发送指定 Queue |</p>
<p>| send(final Message msg, final MessageQueueSelector selector, final Object arg) |同步单条发送自定义实现Queue选择器 |</p>
<p>| send(final Message msg, final MessageQueueSelector selector, final Object arg,final long timeout) |同步单条发送自定义实现Queue选择器（超时设置） |</p>
<p>| send(final Message msg, final MessageQueueSelector selector, final Object arg, final SendCallback sendCallback) |异步单条发送自定义实现Queue选择器 |</p>
<p>| send(final Message msg, final MessageQueueSelector selector, final Object arg,final SendCallback sendCallback, final long timeout) |异步单条发送自定义实现Queue选择器（超时设置） |</p>
<p>|sendOneway(final Message msg, final MessageQueueSelector selector, final Object arg) |一次单条发送自定义实现Queue选择器 |</p>
<p>|send(final Collection<Message> msgs) |批量同步发送 |</p>
<p>|send(final Collection<Message> msgs, final long timeout) |批量同步发送（超时设置） |</p>
<p>|send(final Collection<Message> msgs, final MessageQueue mq) |批量同步指定Queue发送 |</p>
<p>|send(final Collection<Message> msgs, final MessageQueue mq, final long timeout)|批量同步指定Queue发送（超时设置）|</p>
<h1 id="随机发送与自定义MessageQueue选择器"><a href="#随机发送与自定义MessageQueue选择器" class="headerlink" title="随机发送与自定义MessageQueue选择器"></a>随机发送与自定义MessageQueue选择器</h1><p>* 随机发送：消息发往topic的哪个Queue是不确定的</p>
<p>* 自定义MessageQueue发送：按照指定的算法路由到特定的MessageQueue，最常见需求，相同的key路由到相同的队列，实现发送分区有序</p>
<p><strong>随机发送</strong></p>
<p>* 通过自增数取模消息队列数选择队列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> MessageQueue <span class="title">selectOneMessageQueue</span><span class="params">(<span class="keyword">final</span> TopicPublishInfo tpInfo, <span class="keyword">final</span> String lastBrokerName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开启高可用(开启故障延迟机制)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.sendLatencyFaultEnable) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自增序号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> index = tpInfo.getSendWhichQueue().getAndIncrement();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tpInfo.getMessageQueueList().size(); i++) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//取模消息队列数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pos = Math.abs(index++) % tpInfo.getMessageQueueList().size();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pos &lt; <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">pos = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">MessageQueue mq = tpInfo.getMessageQueueList().get(pos);</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断队列是否为可用的</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (latencyFaultTolerance.isAvailable(mq.getBrokerName())) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//正常情况下lastBrokerName==null;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在消息重试（上次发送失败重新发送时）上次选择broker可用，优先选择</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> == lastBrokerName || mq.getBrokerName().equals(lastBrokerName))</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> mq;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> String notBestBroker = latencyFaultTolerance.pickOneAtLeast();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> writeQueueNums = tpInfo.getQueueIdByBroker(notBestBroker);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (writeQueueNums &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> MessageQueue mq = tpInfo.selectOneMessageQueue();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (notBestBroker != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">mq.setBrokerName(notBestBroker);</span><br><span class="line"></span><br><span class="line">mq.setQueueId(tpInfo.getSendWhichQueue().getAndIncrement() % writeQueueNums);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> mq;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">latencyFaultTolerance.remove(notBestBroker);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">log.error(<span class="string">&quot;Error occurred when selecting message queue&quot;</span>, e);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> tpInfo.selectOneMessageQueue();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不开启高可用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> tpInfo.selectOneMessageQueue(lastBrokerName);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> MessageQueue <span class="title">selectOneMessageQueue</span><span class="params">(<span class="keyword">final</span> String lastBrokerName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//轮询消息队列的过程</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (lastBrokerName == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> selectOneMessageQueue();</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> index = <span class="keyword">this</span>.sendWhichQueue.getAndIncrement();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.messageQueueList.size(); i++) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pos = Math.abs(index++) % <span class="keyword">this</span>.messageQueueList.size();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pos &lt; <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">pos = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">MessageQueue mq = <span class="keyword">this</span>.messageQueueList.get(pos);</span><br><span class="line"></span><br><span class="line"><span class="comment">//规避上次发送失败的broker</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!mq.getBrokerName().equals(lastBrokerName)) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> mq;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> selectOneMessageQueue();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>自定义Queue选择器</strong></p>
<p>* 分区有序：根据key进行路由选择，相同的key会路由到相同MessageQueue</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static MessageQueueSelector hashSelector &#x3D; new MessageQueueSelector() &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line"></span><br><span class="line">public MessageQueue select(List&lt;MessageQueue&gt; mqs, Message msg, Object arg) &#123;</span><br><span class="line"></span><br><span class="line">int id &#x3D; msg.getKeys().hashCode() % mqs.size();</span><br><span class="line"></span><br><span class="line">if (id &lt; 0) &#123;</span><br><span class="line"></span><br><span class="line">return mqs.get(-id);</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line"></span><br><span class="line">return mqs.get(id);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<!--more-->



<h1 id="发送Broker容错处理"><a href="#发送Broker容错处理" class="headerlink" title="发送Broker容错处理"></a>发送Broker容错处理</h1><p><strong>两种Broker规避时长</strong></p>
<p>* 正常发送规避时长为发送前后时间差值(endTimestamp-beginTimestampPrev)</p>
<p>* 异常发送规避时长为30秒.</p>
<p>为何是30秒呢? NameSrv每10秒中清理下线broker，在启动时每30秒清理broker本地缓存表</p>
<p>* 开启故障延迟需要设置producer.setSendLatencyFaultEnable(true)，默认为false不开启</p>
<p><strong>正常发送入参isolation为false</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">beginTimestampPrev &#x3D; System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">sendResult &#x3D; this.sendKernelImpl(msg, mq, communicationMode, sendCallback, topicPublishInfo, timeout);</span><br><span class="line"></span><br><span class="line">endTimestamp &#x3D; System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">this.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, false);</span><br></pre></td></tr></table></figure>



<p><strong>异常发送时入参isolation为true</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#125; catch (RemotingException e) &#123;</span><br><span class="line"></span><br><span class="line">endTimestamp &#x3D; System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">this.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, true);</span><br><span class="line"></span><br><span class="line">log.warn(String.format(&quot;sendKernelImpl exception, resend at once, InvokeID: %s, RT: %sms, Broker: %s&quot;, invokeID, endTimestamp - beginTimestampPrev, mq), e);</span><br><span class="line"></span><br><span class="line">log.warn(msg.toString());</span><br><span class="line"></span><br><span class="line">exception &#x3D; e;</span><br><span class="line"></span><br><span class="line">continue;</span><br><span class="line"></span><br><span class="line">&#125; catch (MQClientException e) &#123;</span><br><span class="line"></span><br><span class="line">endTimestamp &#x3D; System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">this.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, true);</span><br><span class="line"></span><br><span class="line">log.warn(String.format(&quot;sendKernelImpl exception, resend at once, InvokeID: %s, RT: %sms, Broker: %s&quot;, invokeID, endTimestamp - beginTimestampPrev, mq), e);</span><br><span class="line"></span><br><span class="line">log.warn(msg.toString());</span><br><span class="line"></span><br><span class="line">exception &#x3D; e;</span><br><span class="line"></span><br><span class="line">continue;</span><br><span class="line"></span><br><span class="line">&#125; catch (MQBrokerException e) &#123;</span><br></pre></td></tr></table></figure>



<p><strong>容错接口方法</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;代码位置：MQFaultStrategy-&gt;updateFaultItem</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"></span><br><span class="line">\* @param brokerName</span><br><span class="line"></span><br><span class="line">\* @param currentLatency 本次消息延迟时间（发送产生异常时的时间戳-开始发送消息时的时间戳）</span><br><span class="line"></span><br><span class="line">\* @param isolation 是否隔离，true 使用默认30s来计算Broker规避时长；如果false则使用本次消息发送延迟时间来计算Broker规避时长</span><br><span class="line"></span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">public void updateFaultItem(final String brokerName, final long currentLatency, boolean isolation) &#123;</span><br><span class="line"></span><br><span class="line">if (this.sendLatencyFaultEnable) &#123;</span><br><span class="line"></span><br><span class="line">long duration &#x3D; computeNotAvailableDuration(isolation ? 30000 : currentLatency);</span><br><span class="line"></span><br><span class="line">this.latencyFaultTolerance.updateFaultItem(brokerName, currentLatency, duration);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void updateFaultItem(final String name, final long currentLatency, final long notAvailableDuration) &#123;</span><br><span class="line"></span><br><span class="line">FaultItem old &#x3D; this.faultItemTable.get(name);</span><br><span class="line"></span><br><span class="line">if (null &#x3D;&#x3D; old) &#123;</span><br><span class="line"></span><br><span class="line">final FaultItem faultItem &#x3D; new FaultItem(name);</span><br><span class="line"></span><br><span class="line">faultItem.setCurrentLatency(currentLatency);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;startTimeStamp &#x3D; 当前系统时间+需要规避的时间</span><br><span class="line"></span><br><span class="line">faultItem.setStartTimestamp(System.currentTimeMillis() + notAvailableDuration);</span><br><span class="line"></span><br><span class="line">old &#x3D; this.faultItemTable.putIfAbsent(name, faultItem);</span><br><span class="line"></span><br><span class="line">if (old !&#x3D; null) &#123;</span><br><span class="line"></span><br><span class="line">old.setCurrentLatency(currentLatency);</span><br><span class="line"></span><br><span class="line">old.setStartTimestamp(System.currentTimeMillis() + notAvailableDuration);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line"></span><br><span class="line">old.setCurrentLatency(currentLatency);</span><br><span class="line"></span><br><span class="line">old.setStartTimestamp(System.currentTimeMillis() + notAvailableDuration);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>发送时的容错判断</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;代码位置：MQFaultStrategy-&gt;selectOneMessageQueue</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;判断队列是否为可用的</span><br><span class="line"></span><br><span class="line">if (latencyFaultTolerance.isAvailable(mq.getBrokerName())) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;正常情况下lastBrokerName&#x3D;&#x3D;null;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;在消息重试（上次发送失败重新发送时）上次选择broker可用，优先选择</span><br><span class="line"></span><br><span class="line">if (null &#x3D;&#x3D; lastBrokerName || mq.getBrokerName().equals(lastBrokerName))</span><br><span class="line"></span><br><span class="line">return mq;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean isAvailable(final String name) &#123;</span><br><span class="line"></span><br><span class="line">final FaultItem faultItem &#x3D; this.faultItemTable.get(name);</span><br><span class="line"></span><br><span class="line">if (faultItem !&#x3D; null) &#123;</span><br><span class="line"></span><br><span class="line">return faultItem.isAvailable();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return true;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean isAvailable() &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;判断broker是否可用，startTimestamp在设置时：&#x3D; 当前系统时间+需要规避的时间</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;所以此处判断当前时间与startTimestamp的大小即可</span><br><span class="line"></span><br><span class="line">return (System.currentTimeMillis() - startTimestamp) &gt;&#x3D; 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="发送失败时的重试次数"><a href="#发送失败时的重试次数" class="headerlink" title="发送失败时的重试次数"></a>发送失败时的重试次数</h1><p>* 同步发送和异步发送在发送失败时，会进行消息重试。一次发送没有消息重试。</p>
<p>* 重试次数由retryTimesWhenSendFailed和retryTimesWhenSendAsyncFailed参数决定，默认2. 总共重试3次。超过次数依然失败返回异常错误</p>
<p><strong>同步发送重试次数代码块</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;代码位置：DefaultMQProducerImpl-&gt;sendDefaultImpl()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;同步发送默认3(1+2)次 其他1次</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;异步发送通过retryTimesWhenSendAsyncFailed来控制，在发送结果返回后再处理</span><br><span class="line"></span><br><span class="line">int timesTotal &#x3D; communicationMode &#x3D;&#x3D; CommunicationMode.SYNC ? 1 + this.defaultMQProducer.getRetryTimesWhenSendFailed() : 1;</span><br><span class="line"></span><br><span class="line">int times &#x3D; 0;</span><br><span class="line"></span><br><span class="line">String[] brokersSent &#x3D; new String[timesTotal];</span><br><span class="line"></span><br><span class="line">for (; times &lt; timesTotal; times++) &#123;</span><br><span class="line"></span><br><span class="line">String lastBrokerName &#x3D; null &#x3D;&#x3D; mq ? null : mq.getBrokerName();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;选一个MessageQueue进行发送</span><br><span class="line"></span><br><span class="line">MessageQueue tmpmq &#x3D; this.selectOneMessageQueue(topicPublishInfo, lastBrokerName);</span><br><span class="line"></span><br><span class="line">if (tmpmq !&#x3D; null) &#123;</span><br><span class="line"></span><br><span class="line">mq &#x3D; tmpmq;</span><br><span class="line"></span><br><span class="line">brokersSent[times] &#x3D; mq.getBrokerName();</span><br><span class="line"></span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>异步发送重试次数代码块</strong></p>
<p>* 由if (needRetry &amp;&amp; tmp &lt;= timesTotal) 判断是否达到重试的阀值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;代码位置：MQClientAPIImpl.java</span><br><span class="line"></span><br><span class="line">private void sendMessageAsync(&#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">final String addr, &#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">final String brokerName, &#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">final Message msg, &#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">final long timeoutMillis, &#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">final RemotingCommand request, &#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">final SendCallback sendCallback, &#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">final TopicPublishInfo topicPublishInfo, &#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">final MQClientInstance instance, &#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">final int retryTimesWhenSendFailed, &#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">final AtomicInteger times, &#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">final SendMessageContext context, &#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">final DefaultMQProducerImpl producer &#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">) throws InterruptedException, RemotingException &#123;</span><br><span class="line"></span><br><span class="line">this.remotingClient.invokeAsync(addr, request, timeoutMillis, new InvokeCallback() &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line"></span><br><span class="line">public void operationComplete(ResponseFuture responseFuture) &#123;</span><br><span class="line"></span><br><span class="line">RemotingCommand response &#x3D; responseFuture.getResponseCommand();</span><br><span class="line"></span><br><span class="line">if (null &#x3D;&#x3D; sendCallback &amp;&amp; response !&#x3D; null) &#123;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">SendResult sendResult &#x3D; MQClientAPIImpl.this.processSendResponse(brokerName, msg, response);</span><br><span class="line"></span><br><span class="line">if (context !&#x3D; null &amp;&amp; sendResult !&#x3D; null) &#123;</span><br><span class="line"></span><br><span class="line">context.setSendResult(sendResult);</span><br><span class="line"></span><br><span class="line">context.getProducer().executeSendMessageHookAfter(context);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; catch (Throwable e) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">producer.updateFaultItem(brokerName, System.currentTimeMillis() - responseFuture.getBeginTimestamp(), false);</span><br><span class="line"></span><br><span class="line">return;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (response !&#x3D; null) &#123;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">SendResult sendResult &#x3D; MQClientAPIImpl.this.processSendResponse(brokerName, msg, response);</span><br><span class="line"></span><br><span class="line">assert sendResult !&#x3D; null;</span><br><span class="line"></span><br><span class="line">if (context !&#x3D; null) &#123;</span><br><span class="line"></span><br><span class="line">context.setSendResult(sendResult);</span><br><span class="line"></span><br><span class="line">context.getProducer().executeSendMessageHookAfter(context);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">sendCallback.onSuccess(sendResult);</span><br><span class="line"></span><br><span class="line">&#125; catch (Throwable e) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">producer.updateFaultItem(brokerName, System.currentTimeMillis() - responseFuture.getBeginTimestamp(), false);</span><br><span class="line"></span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">producer.updateFaultItem(brokerName, System.currentTimeMillis() - responseFuture.getBeginTimestamp(), true);</span><br><span class="line"></span><br><span class="line">onExceptionImpl(brokerName, msg, 0L, request, sendCallback, topicPublishInfo, instance,</span><br><span class="line"></span><br><span class="line">retryTimesWhenSendFailed, times, e, context, false, producer);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line"></span><br><span class="line">producer.updateFaultItem(brokerName, System.currentTimeMillis() - responseFuture.getBeginTimestamp(), true);</span><br><span class="line"></span><br><span class="line">if (!responseFuture.isSendRequestOK()) &#123;</span><br><span class="line"></span><br><span class="line">MQClientException ex &#x3D; new MQClientException(&quot;send request failed&quot;, responseFuture.getCause());</span><br><span class="line"></span><br><span class="line">onExceptionImpl(brokerName, msg, 0L, request, sendCallback, topicPublishInfo, instance,</span><br><span class="line"></span><br><span class="line">retryTimesWhenSendFailed, times, ex, context, true, producer);</span><br><span class="line"></span><br><span class="line">&#125; else if (responseFuture.isTimeout()) &#123;</span><br><span class="line"></span><br><span class="line">MQClientException ex &#x3D; new MQClientException(&quot;wait response timeout &quot; + responseFuture.getTimeoutMillis() + &quot;ms&quot;,</span><br><span class="line"></span><br><span class="line">responseFuture.getCause());</span><br><span class="line"></span><br><span class="line">onExceptionImpl(brokerName, msg, 0L, request, sendCallback, topicPublishInfo, instance,</span><br><span class="line"></span><br><span class="line">retryTimesWhenSendFailed, times, ex, context, true, producer);</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line"></span><br><span class="line">MQClientException ex &#x3D; new MQClientException(&quot;unknow reseaon&quot;, responseFuture.getCause());</span><br><span class="line"></span><br><span class="line">onExceptionImpl(brokerName, msg, 0L, request, sendCallback, topicPublishInfo, instance,</span><br><span class="line"></span><br><span class="line">retryTimesWhenSendFailed, times, ex, context, true, producer);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void onExceptionImpl(final String brokerName, &#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">final Message msg, &#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">final long timeoutMillis, &#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">final RemotingCommand request, &#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">final SendCallback sendCallback, &#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">final TopicPublishInfo topicPublishInfo, &#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">final MQClientInstance instance, &#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">final int timesTotal, &#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">final AtomicInteger curTimes, &#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">final Exception e, &#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">final SendMessageContext context, &#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">final boolean needRetry, &#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">final DefaultMQProducerImpl producer &#x2F;&#x2F; 12</span><br><span class="line"></span><br><span class="line">) &#123;</span><br><span class="line"></span><br><span class="line">int tmp &#x3D; curTimes.incrementAndGet();</span><br><span class="line"></span><br><span class="line">if (needRetry &amp;&amp; tmp &lt;&#x3D; timesTotal) &#123;</span><br><span class="line"></span><br><span class="line">String retryBrokerName &#x3D; brokerName;&#x2F;&#x2F;by default, it will send to the same broker</span><br><span class="line"></span><br><span class="line">if (topicPublishInfo !&#x3D; null) &#123; &#x2F;&#x2F;select one message queue accordingly, in order to determine which broker to send</span><br><span class="line"></span><br><span class="line">MessageQueue mqChosen &#x3D; producer.selectOneMessageQueue(topicPublishInfo, brokerName);</span><br><span class="line"></span><br><span class="line">retryBrokerName &#x3D; mqChosen.getBrokerName();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String addr &#x3D; instance.findBrokerAddressInPublish(retryBrokerName);</span><br><span class="line"></span><br><span class="line">log.info(&quot;async send msg by retry &#123;&#125; times. topic&#x3D;&#123;&#125;, brokerAddr&#x3D;&#123;&#125;, brokerName&#x3D;&#123;&#125;&quot;, tmp, msg.getTopic(), addr,</span><br><span class="line"></span><br><span class="line">retryBrokerName);</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">request.setOpaque(RemotingCommand.createNewRequestId());</span><br><span class="line"></span><br><span class="line">sendMessageAsync(addr, retryBrokerName, msg, timeoutMillis, request, sendCallback, topicPublishInfo, instance,</span><br><span class="line"></span><br><span class="line">timesTotal, curTimes, context, producer);</span><br><span class="line"></span><br><span class="line">&#125; catch (InterruptedException e1) &#123;</span><br><span class="line"></span><br><span class="line">onExceptionImpl(retryBrokerName, msg, timeoutMillis, request, sendCallback, topicPublishInfo, instance, timesTotal, curTimes, e1,</span><br><span class="line"></span><br><span class="line">context, false, producer);</span><br><span class="line"></span><br><span class="line">&#125; catch (RemotingConnectException e1) &#123;</span><br><span class="line"></span><br><span class="line">producer.updateFaultItem(brokerName, 3000, true);</span><br><span class="line"></span><br><span class="line">onExceptionImpl(retryBrokerName, msg, timeoutMillis, request, sendCallback, topicPublishInfo, instance, timesTotal, curTimes, e1,</span><br><span class="line"></span><br><span class="line">context, true, producer);</span><br><span class="line"></span><br><span class="line">&#125; catch (RemotingTooMuchRequestException e1) &#123;</span><br><span class="line"></span><br><span class="line">onExceptionImpl(retryBrokerName, msg, timeoutMillis, request, sendCallback, topicPublishInfo, instance, timesTotal, curTimes, e1,</span><br><span class="line"></span><br><span class="line">context, false, producer);</span><br><span class="line"></span><br><span class="line">&#125; catch (RemotingException e1) &#123;</span><br><span class="line"></span><br><span class="line">producer.updateFaultItem(brokerName, 3000, true);</span><br><span class="line"></span><br><span class="line">onExceptionImpl(retryBrokerName, msg, timeoutMillis, request, sendCallback, topicPublishInfo, instance, timesTotal, curTimes, e1,</span><br><span class="line"></span><br><span class="line">context, true, producer);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line"></span><br><span class="line">if (context !&#x3D; null) &#123;</span><br><span class="line"></span><br><span class="line">context.setException(e);</span><br><span class="line"></span><br><span class="line">context.getProducer().executeSendMessageHookAfter(context);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">sendCallback.onException(e);</span><br><span class="line"></span><br><span class="line">&#125; catch (Exception ignored) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ39# RocketMQ消息发送Broker端流程处理</title>
    <url>/posts/9126d179/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="Broker处理消息的入口类SendMessageProcessor"><a href="#Broker处理消息的入口类SendMessageProcessor" class="headerlink" title="Broker处理消息的入口类SendMessageProcessor"></a>Broker处理消息的入口类SendMessageProcessor</h1><p>processRequest方法主要三件事情：</p>
<p>1.处理consumer发回broker的消息重试</p>
<p>2.处理批量发送</p>
<p>3.处理单条消息发送</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line"></span><br><span class="line">public RemotingCommand processRequest(ChannelHandlerContext ctx, RemotingCommand request) throws RemotingCommandException &#123;</span><br><span class="line"></span><br><span class="line">SendMessageContext mqtraceContext;</span><br><span class="line"></span><br><span class="line">switch (request.getCode()) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;处理消息重试</span><br><span class="line"></span><br><span class="line">case RequestCode.CONSUMER_SEND_MSG_BACK:</span><br><span class="line"></span><br><span class="line">return this.consumerSendMsgBack(ctx, request);</span><br><span class="line"></span><br><span class="line">default:</span><br><span class="line"></span><br><span class="line">SendMessageRequestHeader requestHeader &#x3D; parseRequestHeader(request);</span><br><span class="line"></span><br><span class="line">if (requestHeader &#x3D;&#x3D; null) &#123;</span><br><span class="line"></span><br><span class="line">return null;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mqtraceContext &#x3D; buildMsgContext(ctx, requestHeader);</span><br><span class="line"></span><br><span class="line">this.executeSendMessageHookBefore(ctx, request, mqtraceContext);</span><br><span class="line"></span><br><span class="line">RemotingCommand response;</span><br><span class="line"></span><br><span class="line">if (requestHeader.isBatch()) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;批量发送</span><br><span class="line"></span><br><span class="line">response &#x3D; this.sendBatchMessage(ctx, request, mqtraceContext, requestHeader);</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;处理消息发送</span><br><span class="line"></span><br><span class="line">response &#x3D; this.sendMessage(ctx, request, mqtraceContext, requestHeader);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">this.executeSendMessageHookAfter(response, mqtraceContext);</span><br><span class="line"></span><br><span class="line">return response;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="单条处理流程"><a href="#单条处理流程" class="headerlink" title="单条处理流程"></a>单条处理流程</h1><p>批处理流程与单条处理基本一致</p>
<p>SendMessageProcessor.sendMessage主要流程：</p>
<p>1.broker可以在指定的时间开始服务通过startAcceptSendRequestTimeStamp设定</p>
<p>2.消息校验：</p>
<p>* broker没有写入权限并且topic为顺序topic则拒绝服务</p>
<p>* 检查Topic不能和系统保留Topic[TBW102]冲突</p>
<p>* 若Topic未创建，Broker开启自动创建</p>
<p>* queueId校验，不能大于队列最大值</p>
<p>3.判断是否超过消费次数（16次），决定是否写入死信队列</p>
<p>4.消息内容组织</p>
<p>* 设置Message扩展字段</p>
<p>* 设置Message在客户端生成的时间</p>
<p>* 设置发送Message机器的地址</p>
<p>* 设置存储Message的Broker地址</p>
<p>* 设置消费重试消息的次数</p>
<p>5.消息存储（单独梳理）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private RemotingCommand sendMessage(final ChannelHandlerContext ctx, &#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">final RemotingCommand request, &#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">final SendMessageContext sendMessageContext, &#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">final SendMessageRequestHeader requestHeader) throws RemotingCommandException &#123;</span><br><span class="line"></span><br><span class="line">final RemotingCommand response &#x3D; RemotingCommand.createResponseCommand(SendMessageResponseHeader.class);</span><br><span class="line"></span><br><span class="line">final SendMessageResponseHeader responseHeader &#x3D; (SendMessageResponseHeader) response.readCustomHeader();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;标识RPC的SeqNumber</span><br><span class="line"></span><br><span class="line">response.setOpaque(request.getOpaque());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;埋点不清楚用处</span><br><span class="line"></span><br><span class="line">response.addExtField(MessageConst.PROPERTY_MSG_REGION, this.brokerController.getBrokerConfig().getRegionId());</span><br><span class="line"></span><br><span class="line">response.addExtField(MessageConst.PROPERTY_TRACE_SWITCH, String.valueOf(this.brokerController.getBrokerConfig().isTraceOn()));</span><br><span class="line"></span><br><span class="line">log.debug(&quot;receive SendMessage request command, &#123;&#125;&quot;, request);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Broker启动后在设定的时间处理请求，通过startAcceptSendRequestTimeStamp来设置</span><br><span class="line"></span><br><span class="line">final long startTimstamp &#x3D; this.brokerController.getBrokerConfig().getStartAcceptSendRequestTimeStamp();</span><br><span class="line"></span><br><span class="line">if (this.brokerController.getMessageStore().now() &lt; startTimstamp) &#123;</span><br><span class="line"></span><br><span class="line">response.setCode(ResponseCode.SYSTEM_ERROR);</span><br><span class="line"></span><br><span class="line">response.setRemark(String.format(&quot;broker unable to service, until %s&quot;, UtilAll.timeMillisToHumanString2(startTimstamp)));</span><br><span class="line"></span><br><span class="line">return response;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">response.setCode(-1);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建Topic</span><br><span class="line"></span><br><span class="line">super.msgCheck(ctx, requestHeader, response);</span><br><span class="line"></span><br><span class="line">if (response.getCode() !&#x3D; -1) &#123;</span><br><span class="line"></span><br><span class="line">return response;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final byte[] body &#x3D; request.getBody();</span><br><span class="line"></span><br><span class="line">int queueIdInt &#x3D; requestHeader.getQueueId();</span><br><span class="line"></span><br><span class="line">TopicConfig topicConfig &#x3D; this.brokerController.getTopicConfigManager().selectTopicConfig(requestHeader.getTopic());</span><br><span class="line"></span><br><span class="line">if (queueIdInt &lt; 0) &#123;</span><br><span class="line"></span><br><span class="line">queueIdInt &#x3D; Math.abs(this.random.nextInt() % 99999999) % topicConfig.getWriteQueueNums();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MessageExtBrokerInner msgInner &#x3D; new MessageExtBrokerInner();</span><br><span class="line"></span><br><span class="line">msgInner.setTopic(requestHeader.getTopic());</span><br><span class="line"></span><br><span class="line">msgInner.setQueueId(queueIdInt);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;判断是否超过消费次数（16次），决定是否写入死信队列</span><br><span class="line"></span><br><span class="line">if (!handleRetryAndDLQ(requestHeader, response, request, msgInner, topicConfig)) &#123;</span><br><span class="line"></span><br><span class="line">return response;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">msgInner.setBody(body);</span><br><span class="line"></span><br><span class="line">msgInner.setFlag(requestHeader.getFlag());</span><br><span class="line"></span><br><span class="line">MessageAccessor.setProperties(msgInner, MessageDecoder.string2messageProperties(requestHeader.getProperties()));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Message扩展字段，比如：Unikey, Keys, Tag都在这里面</span><br><span class="line"></span><br><span class="line">msgInner.setPropertiesString(requestHeader.getProperties());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Message在客户端生成的时间</span><br><span class="line"></span><br><span class="line">msgInner.setBornTimestamp(requestHeader.getBornTimestamp());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;发送Message机器的地址</span><br><span class="line"></span><br><span class="line">msgInner.setBornHost(ctx.channel().remoteAddress());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;存储Message的Broker地址</span><br><span class="line"></span><br><span class="line">msgInner.setStoreHost(this.getStoreHost());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;重试消息的次数</span><br><span class="line"></span><br><span class="line">msgInner.setReconsumeTimes(requestHeader.getReconsumeTimes() &#x3D;&#x3D; null ? 0 : requestHeader.getReconsumeTimes());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;判断broker是否拒绝事物消息[rejectTransactionMessage]默认false</span><br><span class="line"></span><br><span class="line">if (this.brokerController.getBrokerConfig().isRejectTransactionMessage()) &#123;</span><br><span class="line"></span><br><span class="line">String traFlag &#x3D; msgInner.getProperty(MessageConst.PROPERTY_TRANSACTION_PREPARED);</span><br><span class="line"></span><br><span class="line">if (traFlag !&#x3D; null) &#123;</span><br><span class="line"></span><br><span class="line">response.setCode(ResponseCode.NO_PERMISSION);</span><br><span class="line"></span><br><span class="line">response.setRemark(</span><br><span class="line"></span><br><span class="line">&quot;the broker[&quot; + this.brokerController.getBrokerConfig().getBrokerIP1() + &quot;] sending transaction message is forbidden&quot;);</span><br><span class="line"></span><br><span class="line">return response;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;消息存储</span><br><span class="line"></span><br><span class="line">PutMessageResult putMessageResult &#x3D; this.brokerController.getMessageStore().putMessage(msgInner);</span><br><span class="line"></span><br><span class="line">return handlePutMessageResult(putMessageResult, response, request, msgInner, responseHeader, sendMessageContext, ctx, queueIdInt);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<!--more-->



<h1 id="处理消费重试消息"><a href="#处理消费重试消息" class="headerlink" title="处理消费重试消息"></a>处理消费重试消息</h1><p>SendMessageProcess.consumerSendMsgBack</p>
<p>处理流程：</p>
<p>1.如果broker没有写入权限则返回拒绝写入</p>
<p>2.如果重试队列不存在则创建（%RETRY%+consumergroup）</p>
<p>3.根据offset（来自requestHeader）从commitlog中查找该条重试消息</p>
<p>4.将该该消息中Property中RETRY_TOPIC为空，将原Topic设置到该属性中</p>
<p>5.超过消费重试次数或者delayLevel为负数，进入死信队列</p>
<p>6.新消息构建</p>
<p>* 设置新的Topic没有超过重试次数为%RETRY%+consumergroup，超过重试次数%DLQ%+consumergroup</p>
<p>* 设置延迟级别delayLevel，每次重试逐级递增，首次为3 + msgExt.getReconsumeTimes()</p>
<p>* 设置消息体、tagcode、queueId、sysFlag、BornTimestamp、BornHost、StoreHost、ReconsumeTimes</p>
<p>* 将原msgId存储到property中的ORIGIN_MESSAGE_ID属性</p>
<p>7.消息存储</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private RemotingCommand consumerSendMsgBack(final ChannelHandlerContext ctx, final RemotingCommand request)</span><br><span class="line"></span><br><span class="line">throws RemotingCommandException &#123;</span><br><span class="line"></span><br><span class="line">final RemotingCommand response &#x3D; RemotingCommand.createResponseCommand(null);</span><br><span class="line"></span><br><span class="line">final ConsumerSendMsgBackRequestHeader requestHeader &#x3D;</span><br><span class="line"></span><br><span class="line">(ConsumerSendMsgBackRequestHeader) request.decodeCommandCustomHeader(ConsumerSendMsgBackRequestHeader.class);</span><br><span class="line"></span><br><span class="line">if (this.hasConsumeMessageHook() &amp;&amp; !UtilAll.isBlank(requestHeader.getOriginMsgId())) &#123;</span><br><span class="line"></span><br><span class="line">ConsumeMessageContext context &#x3D; new ConsumeMessageContext();</span><br><span class="line"></span><br><span class="line">context.setConsumerGroup(requestHeader.getGroup());</span><br><span class="line"></span><br><span class="line">context.setTopic(requestHeader.getOriginTopic());</span><br><span class="line"></span><br><span class="line">context.setCommercialRcvStats(BrokerStatsManager.StatsType.SEND_BACK);</span><br><span class="line"></span><br><span class="line">context.setCommercialRcvTimes(1);</span><br><span class="line"></span><br><span class="line">context.setCommercialOwner(request.getExtFields().get(BrokerStatsManager.COMMERCIAL_OWNER));</span><br><span class="line"></span><br><span class="line">this.executeConsumeMessageHookAfter(context);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;消费组配置信息</span><br><span class="line"></span><br><span class="line">SubscriptionGroupConfig subscriptionGroupConfig &#x3D;</span><br><span class="line"></span><br><span class="line">this.brokerController.getSubscriptionGroupManager().findSubscriptionGroupConfig(requestHeader.getGroup());</span><br><span class="line"></span><br><span class="line">if (null &#x3D;&#x3D; subscriptionGroupConfig) &#123;</span><br><span class="line"></span><br><span class="line">response.setCode(ResponseCode.SUBSCRIPTION_GROUP_NOT_EXIST);</span><br><span class="line"></span><br><span class="line">response.setRemark(&quot;subscription group not exist, &quot; + requestHeader.getGroup() + &quot; &quot;</span><br><span class="line"></span><br><span class="line">\+ FAQUrl.suggestTodo(FAQUrl.SUBSCRIPTION_GROUP_NOT_EXIST));</span><br><span class="line"></span><br><span class="line">return response;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (!PermName.isWriteable(this.brokerController.getBrokerConfig().getBrokerPermission())) &#123;</span><br><span class="line"></span><br><span class="line">response.setCode(ResponseCode.NO_PERMISSION);</span><br><span class="line"></span><br><span class="line">response.setRemark(&quot;the broker[&quot; + this.brokerController.getBrokerConfig().getBrokerIP1() + &quot;] sending message is forbidden&quot;);</span><br><span class="line"></span><br><span class="line">return response;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (subscriptionGroupConfig.getRetryQueueNums() &lt;&#x3D; 0) &#123; &#x2F;&#x2F;重试队列数量需要大于等于1</span><br><span class="line"></span><br><span class="line">response.setCode(ResponseCode.SUCCESS);</span><br><span class="line"></span><br><span class="line">response.setRemark(null);</span><br><span class="line"></span><br><span class="line">return response;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String newTopic &#x3D; MixAll.getRetryTopic(requestHeader.getGroup()); &#x2F;&#x2F;重试队列</span><br><span class="line"></span><br><span class="line">int queueIdInt &#x3D; Math.abs(this.random.nextInt() % 99999999) % subscriptionGroupConfig.getRetryQueueNums(); &#x2F;&#x2F;随机队列</span><br><span class="line"></span><br><span class="line">int topicSysFlag &#x3D; 0;</span><br><span class="line"></span><br><span class="line">if (requestHeader.isUnitMode()) &#123;</span><br><span class="line"></span><br><span class="line">topicSysFlag &#x3D; TopicSysFlag.buildSysFlag(false, true);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建重试队列</span><br><span class="line"></span><br><span class="line">TopicConfig topicConfig &#x3D; this.brokerController.getTopicConfigManager().createTopicInSendMessageBackMethod(&#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">newTopic, &#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">subscriptionGroupConfig.getRetryQueueNums(), &#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">PermName.PERM_WRITE | PermName.PERM_READ, topicSysFlag);</span><br><span class="line"></span><br><span class="line">if (null &#x3D;&#x3D; topicConfig) &#123;</span><br><span class="line"></span><br><span class="line">response.setCode(ResponseCode.SYSTEM_ERROR);</span><br><span class="line"></span><br><span class="line">response.setRemark(&quot;topic[&quot; + newTopic + &quot;] not exist&quot;);</span><br><span class="line"></span><br><span class="line">return response;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (!PermName.isWriteable(topicConfig.getPerm())) &#123;</span><br><span class="line"></span><br><span class="line">response.setCode(ResponseCode.NO_PERMISSION);</span><br><span class="line"></span><br><span class="line">response.setRemark(String.format(&quot;the topic[%s] sending message is forbidden&quot;, newTopic));</span><br><span class="line"></span><br><span class="line">return response;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;从commitLog中查找消息</span><br><span class="line"></span><br><span class="line">MessageExt msgExt &#x3D; this.brokerController.getMessageStore().lookMessageByOffset(requestHeader.getOffset());</span><br><span class="line"></span><br><span class="line">if (null &#x3D;&#x3D; msgExt) &#123;</span><br><span class="line"></span><br><span class="line">response.setCode(ResponseCode.SYSTEM_ERROR);</span><br><span class="line"></span><br><span class="line">response.setRemark(&quot;look message by offset failed, &quot; + requestHeader.getOffset());</span><br><span class="line"></span><br><span class="line">return response;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final String retryTopic &#x3D; msgExt.getProperty(MessageConst.PROPERTY_RETRY_TOPIC);</span><br><span class="line"></span><br><span class="line">if (null &#x3D;&#x3D; retryTopic) &#123;</span><br><span class="line"></span><br><span class="line">MessageAccessor.putProperty(msgExt, MessageConst.PROPERTY_RETRY_TOPIC, msgExt.getTopic());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">msgExt.setWaitStoreMsgOK(false);</span><br><span class="line"></span><br><span class="line">int delayLevel &#x3D; requestHeader.getDelayLevel();</span><br><span class="line"></span><br><span class="line">int maxReconsumeTimes &#x3D; subscriptionGroupConfig.getRetryMaxTimes();</span><br><span class="line"></span><br><span class="line">if (request.getVersion() &gt;&#x3D; MQVersion.Version.V3_4_9.ordinal()) &#123;</span><br><span class="line"></span><br><span class="line">maxReconsumeTimes &#x3D; requestHeader.getMaxReconsumeTimes();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;超过重试次数或者delayLevel为负数，进入死信队列人工干预</span><br><span class="line"></span><br><span class="line">if (msgExt.getReconsumeTimes() &gt;&#x3D; maxReconsumeTimes&#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">|| delayLevel &lt; 0) &#123;</span><br><span class="line"></span><br><span class="line">newTopic &#x3D; MixAll.getDLQTopic(requestHeader.getGroup());</span><br><span class="line"></span><br><span class="line">queueIdInt &#x3D; Math.abs(this.random.nextInt() % 99999999) % DLQ_NUMS_PER_GROUP;</span><br><span class="line"></span><br><span class="line">topicConfig &#x3D; this.brokerController.getTopicConfigManager().createTopicInSendMessageBackMethod(newTopic, &#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">DLQ_NUMS_PER_GROUP, &#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">PermName.PERM_WRITE, 0</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">if (null &#x3D;&#x3D; topicConfig) &#123;</span><br><span class="line"></span><br><span class="line">response.setCode(ResponseCode.SYSTEM_ERROR);</span><br><span class="line"></span><br><span class="line">response.setRemark(&quot;topic[&quot; + newTopic + &quot;] not exist&quot;);</span><br><span class="line"></span><br><span class="line">return response;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line"></span><br><span class="line">if (0 &#x3D;&#x3D; delayLevel) &#123;</span><br><span class="line"></span><br><span class="line">delayLevel &#x3D; 3 + msgExt.getReconsumeTimes();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">msgExt.setDelayTimeLevel(delayLevel);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;构建新消息，会有新的消息Id</span><br><span class="line"></span><br><span class="line">MessageExtBrokerInner msgInner &#x3D; new MessageExtBrokerInner();</span><br><span class="line"></span><br><span class="line">msgInner.setTopic(newTopic);</span><br><span class="line"></span><br><span class="line">msgInner.setBody(msgExt.getBody());</span><br><span class="line"></span><br><span class="line">msgInner.setFlag(msgExt.getFlag());</span><br><span class="line"></span><br><span class="line">MessageAccessor.setProperties(msgInner, msgExt.getProperties());</span><br><span class="line"></span><br><span class="line">msgInner.setPropertiesString(MessageDecoder.messageProperties2String(msgExt.getProperties()));</span><br><span class="line"></span><br><span class="line">msgInner.setTagsCode(MessageExtBrokerInner.tagsString2tagsCode(null, msgExt.getTags()));</span><br><span class="line"></span><br><span class="line">msgInner.setQueueId(queueIdInt);</span><br><span class="line"></span><br><span class="line">msgInner.setSysFlag(msgExt.getSysFlag());</span><br><span class="line"></span><br><span class="line">msgInner.setBornTimestamp(msgExt.getBornTimestamp());</span><br><span class="line"></span><br><span class="line">msgInner.setBornHost(msgExt.getBornHost());</span><br><span class="line"></span><br><span class="line">msgInner.setStoreHost(this.getStoreHost());</span><br><span class="line"></span><br><span class="line">msgInner.setReconsumeTimes(msgExt.getReconsumeTimes() + 1);</span><br><span class="line"></span><br><span class="line">String originMsgId &#x3D; MessageAccessor.getOriginMessageId(msgExt); &#x2F;&#x2F;设置原来的messageId ORIGIN_MESSAGE_ID</span><br><span class="line"></span><br><span class="line">MessageAccessor.setOriginMessageId(msgInner, UtilAll.isBlank(originMsgId) ? msgExt.getMsgId() : originMsgId);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;消息存储</span><br><span class="line"></span><br><span class="line">PutMessageResult putMessageResult &#x3D; this.brokerController.getMessageStore().putMessage(msgInner);</span><br><span class="line"></span><br><span class="line">if (putMessageResult !&#x3D; null) &#123;</span><br><span class="line"></span><br><span class="line">switch (putMessageResult.getPutMessageStatus()) &#123;</span><br><span class="line"></span><br><span class="line">case PUT_OK:</span><br><span class="line"></span><br><span class="line">String backTopic &#x3D; msgExt.getTopic();</span><br><span class="line"></span><br><span class="line">String correctTopic &#x3D; msgExt.getProperty(MessageConst.PROPERTY_RETRY_TOPIC);</span><br><span class="line"></span><br><span class="line">if (correctTopic !&#x3D; null) &#123;</span><br><span class="line"></span><br><span class="line">backTopic &#x3D; correctTopic;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">this.brokerController.getBrokerStatsManager().incSendBackNums(requestHeader.getGroup(), backTopic);</span><br><span class="line"></span><br><span class="line">response.setCode(ResponseCode.SUCCESS);</span><br><span class="line"></span><br><span class="line">response.setRemark(null);</span><br><span class="line"></span><br><span class="line">return response;</span><br><span class="line"></span><br><span class="line">default:</span><br><span class="line"></span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">response.setCode(ResponseCode.SYSTEM_ERROR);</span><br><span class="line"></span><br><span class="line">response.setRemark(putMessageResult.getPutMessageStatus().name());</span><br><span class="line"></span><br><span class="line">return response;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">response.setCode(ResponseCode.SYSTEM_ERROR);</span><br><span class="line"></span><br><span class="line">response.setRemark(&quot;putMessageResult is null&quot;);</span><br><span class="line"></span><br><span class="line">return response;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ4# 查看RocketMQ Tps命令</title>
    <url>/posts/ba08ed95/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="查看所有Topic吞吐Tps"><a href="#查看所有Topic吞吐Tps" class="headerlink" title="查看所有Topic吞吐Tps"></a>查看所有Topic吞吐Tps</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin statsAll -n localhost:9876</span><br><span class="line"></span><br><span class="line">Topic Consumer Group InTPS OutTPS InMsg24Hour OutMsg24Hour</span><br><span class="line"></span><br><span class="line">T_SCANRECORD_NEW_groy 0.00 0 NO_CONSUMER</span><br><span class="line"></span><br><span class="line">T_SCANRECORD_NEW internationalScanRecordAll 5480.10 0.00 310165682 0</span><br><span class="line"></span><br><span class="line">T_SCANRECORD_NEW realnameConsumer 5480.10 79.98 310165682 29896917</span><br><span class="line"></span><br><span class="line">T_SCANRECORD_NEW AdpMqCluster_consumer2 5480.10 0.00 310165682 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<a id="more"></a>





<h1 id="查看特定Topic的吞吐Tps"><a href="#查看特定Topic的吞吐Tps" class="headerlink" title="查看特定Topic的吞吐Tps"></a>查看特定Topic的吞吐Tps</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin statsAll -t SCANRECORD -n 192.168.1.x:9876</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option PermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">Topic Consumer Group Accumulation InTPS OutTPS InMsg24Hour OutMsg24Hour</span><br><span class="line"></span><br><span class="line">SCANRECORD ZtoSignGroup 5826 2086.33 44.00 246409321 29988099</span><br><span class="line"></span><br><span class="line">SCANRECORD newOpenPartnerDeadlineJob 5447 2086.33 44.00 246409321 29988099</span><br><span class="line"></span><br><span class="line">SCANRECORD smartidivision-scanrecord-dis 3523 2086.33 14.32 246409321 31212557</span><br></pre></td></tr></table></figure></div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ40# RocketMQ一次消费性能问题排查</title>
    <url>/posts/302db5ac/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="需求描述"><a href="#需求描述" class="headerlink" title="需求描述"></a>需求描述</h1><p>在容器推广中，为了测试容器的性能，需要消息SDK与ECS上在发送和消费的性能对比；在对比消费性能时，发现容器中的消费性能居然是ECS的2倍。容器并发消费的20个线程TPS在3万左右，ECS中20个消费线程TPS在1.5万左右。</p>
<p>问题：配置均采用8C16G，容器中的性能几乎是ECS的两倍，这不科学，事出反常必有妖。</p>
<a id="more"></a>

<h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><h2 id="tcpdump网络情况"><a href="#tcpdump网络情况" class="headerlink" title="tcpdump网络情况"></a>tcpdump网络情况</h2><p>tcpdump显示在消费的机器存在频繁的域名解析过程；10.x.x.185向DNS服务器100.x.x.136.domain和10.x.x.138.domain请求解析。而10.x.x.185这台机器又是消息发送者的机器IP，测试的发送和消费分别部署在两台机器上。</p>
<p>问题：消费时为何会有消息发送方的IP呢？而且该IP还不断进行域名解析。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219150223.png"></p>
<!--more-->



<h2 id="查看消费线程堆栈"><a href="#查看消费线程堆栈" class="headerlink" title="查看消费线程堆栈"></a>查看消费线程堆栈</h2><p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219150247.png"></p>
<h1 id="消费代码定位"><a href="#消费代码定位" class="headerlink" title="消费代码定位"></a>消费代码定位</h1><p>在消费时有通过MessageExt.bornHost.getBornHostNameString获取消费这信息；问题由此引起。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MessageExt extends Message &#123;</span><br><span class="line"></span><br><span class="line">private static final long serialVersionUID &#x3D; 5720810158625748049L;</span><br><span class="line"></span><br><span class="line">private int queueId;</span><br><span class="line"></span><br><span class="line">private int storeSize;</span><br><span class="line"></span><br><span class="line">private long queueOffset;</span><br><span class="line"></span><br><span class="line">private int sysFlag;</span><br><span class="line"></span><br><span class="line">private long bornTimestamp;</span><br><span class="line"></span><br><span class="line">private SocketAddress bornHost;</span><br><span class="line"></span><br><span class="line">private long storeTimestamp;</span><br><span class="line"></span><br><span class="line">private SocketAddress storeHost;</span><br><span class="line"></span><br><span class="line">private String msgId;</span><br><span class="line"></span><br><span class="line">private long commitLogOffset;</span><br><span class="line"></span><br><span class="line">private int bodyCRC;</span><br><span class="line"></span><br><span class="line">private int reconsumeTimes;</span><br><span class="line"></span><br><span class="line">private long preparedTransactionOffset;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>调用GetBornHostNameString获取HostName时会根据IP反查DNS服务器；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">InetSocketAddress inetSocketAddress &#x3D; (InetSocketAddress)this.bornHost;</span><br><span class="line"></span><br><span class="line">return inetSocketAddress.getAddress().getHostName();</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>将getBornHostNameString注释或者直接返回IP，ECS的消费性能基本稳定在3万左右。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ42# RocketMQ消息轨迹</title>
    <url>/posts/ea80cc10/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="Broker配置"><a href="#Broker配置" class="headerlink" title="Broker配置"></a>Broker配置</h1><p>首先看下broker.conf配置的两个属性</p>
<p>| 属性 |默认值 |</p>
<p>| — | — |</p>
<p>|traceTopicEnable |false |</p>
<p>| msgTraceTopicName | RMQ_SYS_TRACE_TOPIC |</p>
<p>在一个集群中可以配置一台机器专门负责消息轨迹的收集工作，该台机器上配置traceTopicEnable = true,</p>
<p>borker启动的时候自动创建默认轨迹topic</p>
<p>TopicConfigManager.java构造方法，BrokerController在启动的时候，会初始化TopicConfigManager实现trace topic的创建工作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.brokerController.getBrokerConfig().isTraceTopicEnable()) &#123;</span><br><span class="line"></span><br><span class="line">String topic = <span class="keyword">this</span>.brokerController.getBrokerConfig().getMsgTraceTopicName();</span><br><span class="line"></span><br><span class="line">TopicConfig topicConfig = <span class="keyword">new</span> TopicConfig(topic);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.systemTopicList.add(topic);</span><br><span class="line"></span><br><span class="line">topicConfig.setReadQueueNums(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">topicConfig.setWriteQueueNums(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.topicConfigTable.put(topicConfig.getTopicName(), topicConfig);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h1 id="客户端发送实现"><a href="#客户端发送实现" class="headerlink" title="客户端发送实现"></a><strong>客户端发送实现</strong></h1><p>客户端发送</p>
<p>DefaultMQProducer producer = new DefaultMQProducer(“ProducerGroupName”,true);</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public DefaultMQProducer(final String producerGroup, RPCHook rpcHook, boolean enableMsgTrace,final String customizedTraceTopic) &#123;</span><br><span class="line"></span><br><span class="line">this.producerGroup &#x3D; producerGroup;</span><br><span class="line"></span><br><span class="line">defaultMQProducerImpl &#x3D; new DefaultMQProducerImpl(this, rpcHook);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;if client open the message trace feature</span><br><span class="line"></span><br><span class="line">if (enableMsgTrace) &#123;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">AsyncTraceDispatcher dispatcher &#x3D; new AsyncTraceDispatcher(customizedTraceTopic, rpcHook);</span><br><span class="line"></span><br><span class="line">dispatcher.setHostProducer(this.getDefaultMQProducerImpl());</span><br><span class="line"></span><br><span class="line">traceDispatcher &#x3D; dispatcher;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;为消息轨迹注册hook,在消息发送前执行</span><br><span class="line"></span><br><span class="line">this.getDefaultMQProducerImpl().registerSendMessageHook(</span><br><span class="line"></span><br><span class="line">new SendMessageTraceHookImpl(traceDispatcher));</span><br><span class="line"></span><br><span class="line">&#125; catch (Throwable e) &#123;</span><br><span class="line"></span><br><span class="line">log.error(&quot;system mqtrace hook init failed ,maybe can&#39;t send msg trace data&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SendMessageTraceHookImpl 实现了SendMessageHook接口，在消息发送前后会被调用</p>
<p>AsyncTraceDispatcher 主要负责消息的发送工作；内部队列，由线程池批量（100条）发送</p>
<h1 id="Hook调用"><a href="#Hook调用" class="headerlink" title="Hook调用"></a><strong>Hook调用</strong></h1><p>发送前hook调用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;如果有hook在消息发送前执行，消息轨迹通过这种方式记录</span><br><span class="line"></span><br><span class="line">if (this.hasSendMessageHook()) &#123;</span><br><span class="line"></span><br><span class="line">context &#x3D; new SendMessageContext();</span><br><span class="line"></span><br><span class="line">context.setProducer(this); &#x2F;&#x2F;发送对象</span><br><span class="line"></span><br><span class="line">context.setProducerGroup(this.defaultMQProducer.getProducerGroup()); &#x2F;&#x2F;生产组</span><br><span class="line"></span><br><span class="line">context.setCommunicationMode(communicationMode); &#x2F;&#x2F;发送模式</span><br><span class="line"></span><br><span class="line">context.setBornHost(this.defaultMQProducer.getClientIP()); &#x2F;&#x2F;客户端IP</span><br><span class="line"></span><br><span class="line">context.setBrokerAddr(brokerAddr); &#x2F;&#x2F;发往broker的地址</span><br><span class="line"></span><br><span class="line">context.setMessage(msg); &#x2F;&#x2F;消息内容</span><br><span class="line"></span><br><span class="line">context.setMq(mq); &#x2F;&#x2F;消息 Queue</span><br><span class="line"></span><br><span class="line">String isTrans &#x3D; msg.getProperty(MessageConst.PROPERTY_TRANSACTION_PREPARED);</span><br><span class="line"></span><br><span class="line">if (isTrans !&#x3D; null &amp;&amp; isTrans.equals(&quot;true&quot;)) &#123;</span><br><span class="line"></span><br><span class="line">context.setMsgType(MessageType.Trans_Msg_Half);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (msg.getProperty(&quot;__STARTDELIVERTIME&quot;) !&#x3D; null || msg.getProperty(MessageConst.PROPERTY_DELAY_TIME_LEVEL) !&#x3D; null) &#123;</span><br><span class="line"></span><br><span class="line">context.setMsgType(MessageType.Delay_Msg);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">this.executeSendMessageHookBefore(context); &#x2F;&#x2F;执行自定义个hook业务</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>发送后hook调用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;消息发送后执行的hook，消息轨迹会调用</span><br><span class="line"></span><br><span class="line">if (this.hasSendMessageHook()) &#123;</span><br><span class="line"></span><br><span class="line">context.setSendResult(sendResult);</span><br><span class="line"></span><br><span class="line">this.executeSendMessageHookAfter(context);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="发送轨迹"><a href="#发送轨迹" class="headerlink" title="发送轨迹"></a><strong>发送轨迹</strong></h1><p>Producer启动时注册钩子，该钩子持有负责消息发送的AsyncTraceDispatcher实例，消息发送后进而发送消息轨迹</p>
<p><strong>发送轨迹的消息格式</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219151653.png"></p>
<h1 id="客户端消费轨迹实现"><a href="#客户端消费轨迹实现" class="headerlink" title="客户端消费轨迹实现"></a>客户端消费轨迹实现</h1><p>消费轨迹：与消息发送的轨迹实现思路相同</p>
<p>DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(“CID_JODIE_1”,true);</p>
<p><strong>注册消费钩子</strong></p>
<p>ConsumeMessageTraceHookImpl实现了ConsumeMessageHook，在消费的前后会进行回调</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public DefaultMQPushConsumer(final String consumerGroup, RPCHook rpcHook,</span><br><span class="line"></span><br><span class="line">AllocateMessageQueueStrategy allocateMessageQueueStrategy, boolean enableMsgTrace, final String customizedTraceTopic) &#123;</span><br><span class="line"></span><br><span class="line">this.consumerGroup &#x3D; consumerGroup;</span><br><span class="line"></span><br><span class="line">this.allocateMessageQueueStrategy &#x3D; allocateMessageQueueStrategy;</span><br><span class="line"></span><br><span class="line">defaultMQPushConsumerImpl &#x3D; new DefaultMQPushConsumerImpl(this, rpcHook);</span><br><span class="line"></span><br><span class="line">if (enableMsgTrace) &#123;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">AsyncTraceDispatcher dispatcher &#x3D; new AsyncTraceDispatcher(customizedTraceTopic, rpcHook);</span><br><span class="line"></span><br><span class="line">dispatcher.setHostConsumer(this.getDefaultMQPushConsumerImpl());</span><br><span class="line"></span><br><span class="line">traceDispatcher &#x3D; dispatcher;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;注册消费hook</span><br><span class="line"></span><br><span class="line">this.getDefaultMQPushConsumerImpl().registerConsumeMessageHook(</span><br><span class="line"></span><br><span class="line">new ConsumeMessageTraceHookImpl(traceDispatcher));</span><br><span class="line"></span><br><span class="line">&#125; catch (Throwable e) &#123;</span><br><span class="line"></span><br><span class="line">log.error(&quot;system mqtrace hook init failed ,maybe can&#39;t send msg trace data&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ConsumeMessageConcurrentlyService.ConsumeRequest.run消费前执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;消费前执行hook 消费轨迹会执行</span><br><span class="line"></span><br><span class="line">ConsumeMessageContext consumeMessageContext &#x3D; null;</span><br><span class="line"></span><br><span class="line">if (ConsumeMessageConcurrentlyService.this.defaultMQPushConsumerImpl.hasHook()) &#123;</span><br><span class="line"></span><br><span class="line">consumeMessageContext &#x3D; new ConsumeMessageContext();</span><br><span class="line"></span><br><span class="line">consumeMessageContext.setConsumerGroup(defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line"></span><br><span class="line">consumeMessageContext.setProps(new HashMap&lt;String, String&gt;());</span><br><span class="line"></span><br><span class="line">consumeMessageContext.setMq(messageQueue);</span><br><span class="line"></span><br><span class="line">consumeMessageContext.setMsgList(msgs);</span><br><span class="line"></span><br><span class="line">consumeMessageContext.setSuccess(false); &#x2F;&#x2F;消费状态</span><br><span class="line"></span><br><span class="line">ConsumeMessageConcurrentlyService.this.defaultMQPushConsumerImpl.executeHookBefore(consumeMessageContext);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>消费后执行</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (ConsumeMessageConcurrentlyService.this.defaultMQPushConsumerImpl.hasHook()) &#123;</span><br><span class="line"></span><br><span class="line">consumeMessageContext.setStatus(status.toString());</span><br><span class="line"></span><br><span class="line">consumeMessageContext.setSuccess(ConsumeConcurrentlyStatus.CONSUME_SUCCESS &#x3D;&#x3D; status);</span><br><span class="line"></span><br><span class="line">ConsumeMessageConcurrentlyService.this.defaultMQPushConsumerImpl.executeHookAfter(consumeMessageContext);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>消费轨迹格式</strong></p>
<p>分为两部分，一部分为消费前，一部分为消费后</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219151820.png"></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219151831.png"></p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ44# RocketMQ最近几个经常被问的问题</title>
    <url>/posts/f75406c8/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="常见问题一"><a href="#常见问题一" class="headerlink" title="常见问题一"></a>常见问题一</h1><p><strong>问：</strong> RocketMQ消费者订阅了tag，但却收不到消息无法消费，并且根据 msgid 去查询，发现这条消息的状态为 CONSUMED_BUT_FILTERED，那这是为什么？</p>
<p><strong>答：</strong> 在RocketMQ中，一个消费组能同时订阅多个 tag，但一个消费组的不同消费者不能分开订阅不同的tag，即同一个消费组的订阅关系必须保持一样。例如：常见错误使用方式同一个项目中，一段消费代码订阅tagA，然后拷贝到这段代码再更改为tagB。</p>
<a id="more"></a>

<p><strong>正确用法</strong> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">()</span></span>&#123;</span><br><span class="line">	DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">&quot;melon_online_test_consumer&quot;</span>);</span><br><span class="line">	consumer.subscribe(<span class="string">&quot;melon_online_test&quot;</span>,<span class="string">&quot;tag1 || tag2 || tag3&quot;</span>);</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p><strong>错误用法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubscribeTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribeA</span><span class="params">()</span></span>&#123;</span><br><span class="line">    DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">&quot;melon_online_test_consumer&quot;</span>);</span><br><span class="line">    consumer.subscribe(<span class="string">&quot;melon_online_test&quot;</span>,<span class="string">&quot;tag1&quot;</span>);</span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribeB</span><span class="params">()</span></span>&#123;</span><br><span class="line">    DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">&quot;melon_online_test_consumer&quot;</span>);</span><br><span class="line">    consumer.subscribe(<span class="string">&quot;melon_online_test&quot;</span>,<span class="string">&quot;tag2&quot;</span>);</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="常见问题二"><a href="#常见问题二" class="headerlink" title="常见问题二"></a>常见问题二</h1><p><strong>问：</strong> 发现大量的RocketMQ client 大量的info日志输出，我不关心，如何禁用呢？</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210125093344.png"></p>
<p><strong>答：</strong> 尝试以下设置，项目中使用了Slf4j<br>@1 可以配置RocketmqClient的logger设置优先级为warn</p>
<p>@2 也可以通过-Drocketmq.client.logUseSlf4j=false 和 -Drocketmq.client.logLevel=WARN 关闭MQ客户端使用Slf4j并提高日志等级</p>
<p>项目中没有使用Slf4j，可以通过-Drocketmq.client.logLevel=WARN调高日志等级。</p>
<h1 id="常见问题三"><a href="#常见问题三" class="headerlink" title="常见问题三"></a>常见问题三</h1><p><strong>问：</strong> 我的服务消费后需要调用第三方接口，别人的接口调用有限制，Rocketmq消费可以限流吗？</p>
<p><strong>答：</strong> RocketMQ本身没有类似每秒消费多少条数据的精确限流，我们可以结合Sentienl来实现，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> String KEY = <span class="string">&quot;melon_topic:melon_consumer&quot;</span>; <span class="comment">// 资源名称由topic和消费组构成</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, MQClientException </span>&#123;</span><br><span class="line">    initFlowControlRule(); <span class="comment">// Sentinel流控规则</span></span><br><span class="line">    DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">&quot;melon_consumer&quot;</span>);</span><br><span class="line">    consumer.setNamesrvAddr(<span class="string">&quot;localhost:9876&quot;</span>);</span><br><span class="line">    consumer.subscribe(<span class="string">&quot;melon_topic&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">    consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class="line">    consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">                Entry entry = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ContextUtil.enter(KEY); <span class="comment">// 定义资源</span></span><br><span class="line">                    entry = SphU.entry(KEY, EntryType.OUT);</span><br><span class="line">                    System.out.printf(<span class="string">&quot;%s Receive New Messages: %s %n&quot;</span>, Thread.currentThread().getName(), msg);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BlockException ex) &#123;</span><br><span class="line">                    <span class="comment">// Blocked.被限流后消息重试</span></span><br><span class="line">                    <span class="keyword">return</span> ConsumeConcurrentlyStatus.RECONSUME_LATER;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (entry != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        entry.exit();</span><br><span class="line">                    &#125;</span><br><span class="line">                    ContextUtil.exit();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    consumer.start();</span><br><span class="line">    System.out.printf(<span class="string">&quot;Consumer Started.%n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initFlowControlRule</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FlowRule rule = <span class="keyword">new</span> FlowRule();</span><br><span class="line">    rule.setResource(KEY);</span><br><span class="line">    rule.setCount(<span class="number">5</span>);<span class="comment">// 每秒通过5条消息</span></span><br><span class="line">    rule.setGrade(RuleConstant.FLOW_GRADE_QPS);</span><br><span class="line">    rule.setControlBehavior(RuleConstant.CONTROL_BEHAVIOR_RATE_LIMITER);</span><br><span class="line">    rule.setMaxQueueingTimeMs(<span class="number">5</span> * <span class="number">1000</span>); <span class="comment">// 排队超时时间5秒</span></span><br><span class="line">    FlowRuleManager.loadRules(Collections.singletonList(rule));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<!--more-->



<h1 id="常见问题四"><a href="#常见问题四" class="headerlink" title="常见问题四"></a>常见问题四</h1><p><strong>问：</strong>RocketMQ默认延迟等级有18个，我可以扩增吗？</p>
<p><strong>答：</strong> 可以的，但是不建议扩增太多等级，可以通过修改broker属性messageDelayLevel来实现，注意修改了后需要重启broker。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">messageDelayLevel = 1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h <span class="number">1d</span> <span class="number">3d</span> <span class="number">7d</span> <span class="number">14d</span> <span class="number">21d</span></span><br></pre></td></tr></table></figure>







</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ5# RocketMQ Broker命令</title>
    <url>/posts/138ff78c/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="查看broker状态信息"><a href="#查看broker状态信息" class="headerlink" title="查看broker状态信息"></a>查看broker状态信息</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin brokerStatus -b 192.168.1.x:10911 -n 192.168.1.x:9876</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option PermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">bootTimestamp : 1535597348792</span><br><span class="line"></span><br><span class="line">brokerVersion : 232</span><br><span class="line"></span><br><span class="line">brokerVersionDesc : V4_1_0_SNAPSHOT</span><br><span class="line"></span><br><span class="line">commitLogDirCapacity : Total : 8.7 TiB, Free : 7.7 TiB.</span><br><span class="line"></span><br><span class="line">commitLogDiskRatio : 0.11147464487710743</span><br><span class="line"></span><br><span class="line">commitLogMaxOffset : 6652182757965</span><br><span class="line"></span><br><span class="line">commitLogMinOffset : 5676873023488</span><br><span class="line"></span><br><span class="line">consumeQueueDiskRatio : 0.11147464487710743</span><br><span class="line"></span><br><span class="line">dispatchBehindBytes : 0</span><br><span class="line"></span><br><span class="line">dispatchMaxBuffer : 0</span><br><span class="line"></span><br><span class="line">earliestMessageTimeStamp : 1539290831130</span><br><span class="line"></span><br><span class="line">getFoundTps : 24229.27707229277 24670.716261707163 24323.07766631239</span><br><span class="line"></span><br><span class="line">getMessageEntireTimeMax : 4895</span><br><span class="line"></span><br><span class="line">getMissTps : 23384.56154384562 24047.195280471955 23735.196223133637</span><br><span class="line"></span><br><span class="line">getTotalTps : 47613.83861613839 48717.91154217912 48058.27388944603</span><br><span class="line"></span><br><span class="line">getTransferedTps : 28046.395360463954 28519.931340199313 28905.699949690646</span><br><span class="line"></span><br><span class="line">msgGetTotalTodayMorning : 30682264110</span><br><span class="line"></span><br><span class="line">msgGetTotalTodayNow : 31750490006</span><br><span class="line"></span><br><span class="line">msgGetTotalYesterdayMorning : 29219504313</span><br><span class="line"></span><br><span class="line">msgPutTotalTodayMorning : 7329767893</span><br><span class="line"></span><br><span class="line">msgPutTotalTodayNow : 7523090457</span><br><span class="line"></span><br><span class="line">msgPutTotalYesterdayMorning : 7031035625</span><br><span class="line"></span><br><span class="line">pageCacheLockTimeMills : 0</span><br><span class="line"></span><br><span class="line">pullThreadPoolQueueCapacity : 100000</span><br><span class="line"></span><br><span class="line">pullThreadPoolQueueHeadWaitTimeMills: 0</span><br><span class="line"></span><br><span class="line">pullThreadPoolQueueSize : 0</span><br><span class="line"></span><br><span class="line">putMessageAverageSize : 807.2943103360182</span><br><span class="line"></span><br><span class="line">putMessageDistributeTime : [&lt;&#x3D;0ms]:229497 [0~10ms]:1275 [10~50ms]:4 [50~100ms]:0 [100~200ms]:0 [200~500ms]:0 [500ms~1s]:0 [1~2s]:0 [2~3s]:0 [3~4s]:0 [4~5s]:0 [5~10s]:0 [10s~]:0</span><br><span class="line"></span><br><span class="line">putMessageEntireTimeMax : 10885</span><br><span class="line"></span><br><span class="line">putMessageSizeTotal : 6073348121272</span><br><span class="line"></span><br><span class="line">putMessageTimesTotal : 7523090456</span><br><span class="line"></span><br><span class="line">putTps : 4424.957504249575 4466.0700596607 4577.724617932119</span><br><span class="line"></span><br><span class="line">remainHowManyDataToCommit : 6.9 KiB</span><br><span class="line"></span><br><span class="line">remainHowManyDataToFlush : 0 B</span><br><span class="line"></span><br><span class="line">remainTransientStoreBufferNumbs : 3</span><br><span class="line"></span><br><span class="line">runtime : [ 48 days, 7 hours, 52 minutes, 34 seconds ]</span><br><span class="line"></span><br><span class="line">scheduleMessageOffset_1 : 5169358,5169358</span><br><span class="line"></span><br><span class="line">scheduleMessageOffset_10 : 8161108,8171531</span><br><span class="line"></span><br><span class="line">scheduleMessageOffset_11 : 7864781,7877885</span><br><span class="line"></span><br><span class="line">scheduleMessageOffset_12 : 7584977,7601110</span><br><span class="line"></span><br><span class="line">scheduleMessageOffset_13 : 7278660,7297334</span><br><span class="line"></span><br><span class="line">scheduleMessageOffset_14 : 7123700,7146082</span><br><span class="line"></span><br><span class="line">scheduleMessageOffset_15 : 7013493,7063463</span><br><span class="line"></span><br><span class="line">scheduleMessageOffset_16 : 6864847,6950753</span><br><span class="line"></span><br><span class="line">scheduleMessageOffset_17 : 6549491,6803414</span><br><span class="line"></span><br><span class="line">scheduleMessageOffset_18 : 12887811,12894744</span><br><span class="line"></span><br><span class="line">scheduleMessageOffset_3 : 13667462,13667752</span><br><span class="line"></span><br><span class="line">scheduleMessageOffset_4 : 9780224,9781009</span><br><span class="line"></span><br><span class="line">scheduleMessageOffset_5 : 63142105,63144981</span><br><span class="line"></span><br><span class="line">scheduleMessageOffset_6 : 9185173,9188251</span><br><span class="line"></span><br><span class="line">scheduleMessageOffset_7 : 9002046,9006727</span><br><span class="line"></span><br><span class="line">scheduleMessageOffset_8 : 8834782,8841531</span><br><span class="line"></span><br><span class="line">scheduleMessageOffset_9 : 1112865066,1112879874</span><br><span class="line"></span><br><span class="line">sendThreadPoolQueueCapacity : 10000</span><br><span class="line"></span><br><span class="line">sendThreadPoolQueueHeadWaitTimeMills: 0</span><br><span class="line"></span><br><span class="line">sendThreadPoolQueueSize : 0</span><br><span class="line"></span><br><span class="line">startAcceptSendRequestTimeStamp : 0</span><br><span class="line"></span><br><span class="line">You have mail in &#x2F;var&#x2F;spool&#x2F;mail&#x2F;root</span><br></pre></td></tr></table></figure>



<a id="more"></a>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin brokerConsumeStats -b 192.168.1.x:10911 -n 192.168.1.x:9876</span><br><span class="line"></span><br><span class="line">zeus-package-mismatch-topic zeus-package-mismatch-consumer broker-a 0 698533 698532 1 2018-10-17 18:35:58</span><br><span class="line"></span><br><span class="line">zeus-package-mismatch-topic zeus-package-mismatch-consumer broker-a 1 698521 698520 1 2018-10-17 18:36:01</span><br><span class="line"></span><br><span class="line">zeus-package-mismatch-topic zeus-package-mismatch-consumer broker-a 2 698514 698513 1 2018-10-17 18:36:01</span><br><span class="line"></span><br><span class="line">zeus-package-mismatch-topic zeus-package-mismatch-consumer broker-a 3 698495 698494 1 2018-10-17 18:36:01</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h1 id="清除废弃的ConsumeQueue"><a href="#清除废弃的ConsumeQueue" class="headerlink" title="清除废弃的ConsumeQueue"></a>清除废弃的ConsumeQueue</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin cleanExpiredCQ -b 192.168.1.x:10911 -n 192.168.1.x:9876</span><br></pre></td></tr></table></figure>



<h1 id="清除废弃的Topic"><a href="#清除废弃的Topic" class="headerlink" title="清除废弃的Topic"></a>清除废弃的Topic</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin cleanUnusedTopic -b 192.168.1.x:10911 -n 192.168.1.x:9876</span><br></pre></td></tr></table></figure>



<h1 id="获取broker配置信息"><a href="#获取broker配置信息" class="headerlink" title="获取broker配置信息"></a>获取broker配置信息</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin getBrokerConfig -b 192.168.1.x:10911 -n 192.168.1.x:9876</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option PermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;192.168.1.x:10911&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">autoCreateSubscriptionGroup &#x3D; false</span><br><span class="line"></span><br><span class="line">brokerName &#x3D; broker-a</span><br><span class="line"></span><br><span class="line">haListenPort &#x3D; 10912</span><br><span class="line"></span><br><span class="line">clientManagerThreadPoolQueueCapacity &#x3D; 1000000</span><br><span class="line"></span><br><span class="line">flushCommitLogThoroughInterval &#x3D; 10000</span><br><span class="line"></span><br><span class="line">flushCommitLogLeastPages &#x3D; 4</span><br><span class="line"></span><br><span class="line">clientCallbackExecutorThreads &#x3D; 48</span><br><span class="line"></span><br><span class="line">notifyConsumerIdsChangedEnable &#x3D; true</span><br><span class="line"></span><br><span class="line">cleanResourceInterval &#x3D; 10000</span><br><span class="line"></span><br><span class="line">channelNotActiveInterval &#x3D; 60000</span><br><span class="line"></span><br><span class="line">diskMaxUsedSpaceRatio &#x3D; 88</span><br><span class="line"></span><br><span class="line">debugLockEnable &#x3D; false</span><br><span class="line"></span><br><span class="line">messageDelayLevel &#x3D; 1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h</span><br><span class="line"></span><br><span class="line">clusterTopicEnable &#x3D; true</span><br><span class="line"></span><br><span class="line">messageIndexEnable &#x3D; true</span><br><span class="line"></span><br><span class="line">serverPooledByteBufAllocatorEnable &#x3D; true</span><br><span class="line"></span><br><span class="line">shortPollingTimeMills &#x3D; 1000</span><br><span class="line"></span><br><span class="line">commercialEnable &#x3D; true</span><br><span class="line"></span><br><span class="line">redeleteHangedFileInterval &#x3D; 120000</span><br><span class="line"></span><br><span class="line">flushConsumerOffsetInterval &#x3D; 5000</span><br><span class="line"></span><br><span class="line">flushCommitLogTimed &#x3D; false</span><br><span class="line"></span><br><span class="line">maxMessageSize &#x3D; 65536</span><br><span class="line"></span><br><span class="line">brokerId &#x3D; 0</span><br><span class="line"></span><br><span class="line">syncFlushTimeout &#x3D; 5000</span><br><span class="line"></span><br><span class="line">flushConsumeQueueThoroughInterval &#x3D; 60000</span><br><span class="line"></span><br><span class="line">clientChannelMaxIdleTimeSeconds &#x3D; 120</span><br><span class="line"></span><br><span class="line">flushDelayOffsetInterval &#x3D; 10000</span><br><span class="line"></span><br><span class="line">serverSocketRcvBufSize &#x3D; 131072</span><br><span class="line"></span><br><span class="line">flushDiskType &#x3D; ASYNC_FLUSH</span><br><span class="line"></span><br><span class="line">maxTransferBytesOnMessageInMemory &#x3D; 262144</span><br><span class="line"></span><br><span class="line">clientManageThreadPoolNums &#x3D; 32</span><br><span class="line"></span><br><span class="line">serverChannelMaxIdleTimeSeconds &#x3D; 120</span><br><span class="line"></span><br><span class="line">serverCallbackExecutorThreads &#x3D; 0</span><br><span class="line"></span><br><span class="line">transientStorePoolSize &#x3D; 5</span><br><span class="line"></span><br><span class="line">maxTransferBytesOnMessageInDisk &#x3D; 65536</span><br><span class="line"></span><br><span class="line">pullMessageThreadPoolNums &#x3D; 128</span><br><span class="line"></span><br><span class="line">clientCloseSocketIfTimeout &#x3D; false</span><br><span class="line"></span><br><span class="line">fetchNamesrvAddrByAddressServer &#x3D; false</span><br><span class="line"></span><br><span class="line">sendThreadPoolQueueCapacity &#x3D; 10000</span><br><span class="line"></span><br><span class="line">diskFallRecorded &#x3D; true</span><br><span class="line"></span><br><span class="line">transientStorePoolEnable &#x3D; true</span><br><span class="line"></span><br><span class="line">offsetCheckInSlave &#x3D; false</span><br><span class="line"></span><br><span class="line">disableConsumeIfConsumerReadSlowly &#x3D; false</span><br><span class="line"></span><br><span class="line">commitCommitLogThoroughInterval &#x3D; 200</span><br><span class="line"></span><br><span class="line">consumerManagerThreadPoolQueueCapacity &#x3D; 1000000</span><br><span class="line"></span><br><span class="line">flushIntervalConsumeQueue &#x3D; 1000</span><br><span class="line"></span><br><span class="line">clientOnewaySemaphoreValue &#x3D; 65535</span><br><span class="line"></span><br><span class="line">warmMapedFileEnable &#x3D; true</span><br><span class="line"></span><br><span class="line">slaveReadEnable &#x3D; false</span><br><span class="line"></span><br><span class="line">transferMsgByHeap &#x3D; true</span><br><span class="line"></span><br><span class="line">consumerFallbehindThreshold &#x3D; 17179869184</span><br><span class="line"></span><br><span class="line">serverAsyncSemaphoreValue &#x3D; 64</span><br><span class="line"></span><br><span class="line">startAcceptSendRequestTimeStamp &#x3D; 0</span><br><span class="line"></span><br><span class="line">flushConsumerOffsetHistoryInterval &#x3D; 60000</span><br><span class="line"></span><br><span class="line">brokerIP2 &#x3D; 192.168.1.x</span><br><span class="line"></span><br><span class="line">maxTransferCountOnMessageInDisk &#x3D; 8</span><br><span class="line"></span><br><span class="line">brokerIP1 &#x3D; 192.168.1.x</span><br><span class="line"></span><br><span class="line">deleteCommitLogFilesInterval &#x3D; 100</span><br><span class="line"></span><br><span class="line">adminBrokerThreadPoolNums &#x3D; 16</span><br><span class="line"></span><br><span class="line">storePathCommitLog &#x3D; &#x2F;data&#x2F;rocketmq&#x2F;store&#x2F;commitlog</span><br><span class="line"></span><br><span class="line">filterServerNums &#x3D; 0</span><br><span class="line"></span><br><span class="line">deleteConsumeQueueFilesInterval &#x3D; 100</span><br><span class="line"></span><br><span class="line">checkCRCOnRecover &#x3D; true</span><br><span class="line"></span><br><span class="line">serverOnewaySemaphoreValue &#x3D; 256</span><br><span class="line"></span><br><span class="line">defaultQueryMaxNum &#x3D; 32</span><br><span class="line"></span><br><span class="line">clientWorkerThreads &#x3D; 4</span><br><span class="line"></span><br><span class="line">clientSocketRcvBufSize &#x3D; 131072</span><br><span class="line"></span><br><span class="line">maxDelayTime &#x3D; 40</span><br><span class="line"></span><br><span class="line">connectTimeoutMillis &#x3D; 3000</span><br><span class="line"></span><br><span class="line">clientPooledByteBufAllocatorEnable &#x3D; false</span><br><span class="line"></span><br><span class="line">commercialTimerCount &#x3D; 1</span><br><span class="line"></span><br><span class="line">serverSocketSndBufSize &#x3D; 131072</span><br><span class="line"></span><br><span class="line">regionId &#x3D; DefaultRegion</span><br><span class="line"></span><br><span class="line">duplicationEnable &#x3D; false</span><br><span class="line"></span><br><span class="line">cleanFileForciblyEnable &#x3D; true</span><br><span class="line"></span><br><span class="line">fastFailIfNoBufferInStorePool &#x3D; false</span><br><span class="line"></span><br><span class="line">rejectTransactionMessage &#x3D; false</span><br><span class="line"></span><br><span class="line">serverSelectorThreads &#x3D; 3</span><br><span class="line"></span><br><span class="line">consumerManageThreadPoolNums &#x3D; 32</span><br><span class="line"></span><br><span class="line">haSendHeartbeatInterval &#x3D; 5000</span><br><span class="line"></span><br><span class="line">mapedFileSizeConsumeQueue &#x3D; 50000000</span><br><span class="line"></span><br><span class="line">storeCheckpoint &#x3D; &#x2F;data&#x2F;rocketmq&#x2F;store&#x2F;checkpoint</span><br><span class="line"></span><br><span class="line">commitCommitLogLeastPages &#x3D; 4</span><br><span class="line"></span><br><span class="line">longPollingEnable &#x3D; true</span><br><span class="line"></span><br><span class="line">flushConsumeQueueLeastPages &#x3D; 2</span><br><span class="line"></span><br><span class="line">storePathRootDir &#x3D; &#x2F;data&#x2F;rocketmq&#x2F;store</span><br><span class="line"></span><br><span class="line">defaultTopicQueueNums &#x3D; 4</span><br><span class="line"></span><br><span class="line">highSpeedMode &#x3D; false</span><br><span class="line"></span><br><span class="line">commercialBaseCount &#x3D; 1</span><br><span class="line"></span><br><span class="line">checkTransactionMessageEnable &#x3D; false</span><br><span class="line"></span><br><span class="line">accessMessageInMemoryMaxRatio &#x3D; 40</span><br><span class="line"></span><br><span class="line">autoCreateTopicEnable &#x3D; false</span><br><span class="line"></span><br><span class="line">commitIntervalCommitLog &#x3D; 200</span><br><span class="line"></span><br><span class="line">brokerTopicEnable &#x3D; true</span><br><span class="line"></span><br><span class="line">namesrvAddr &#x3D; 192.168.1.x:9876;192.168.1.x:9876</span><br><span class="line"></span><br><span class="line">clientAsyncSemaphoreValue &#x3D; 65535</span><br><span class="line"></span><br><span class="line">maxMsgsNumBatch &#x3D; 64</span><br><span class="line"></span><br><span class="line">storePathConsumeQueue &#x3D; &#x2F;data&#x2F;rocketmq&#x2F;store&#x2F;consumequeue</span><br><span class="line"></span><br><span class="line">fileReservedTime &#x3D; 120</span><br><span class="line"></span><br><span class="line">deleteWhen &#x3D; 04</span><br><span class="line"></span><br><span class="line">waitTimeMillsInSendQueue &#x3D; 200</span><br><span class="line"></span><br><span class="line">commercialTransCount &#x3D; 1</span><br><span class="line"></span><br><span class="line">osPageCacheBusyTimeOutMills &#x3D; 1000</span><br><span class="line"></span><br><span class="line">abortFile &#x3D; &#x2F;data&#x2F;rocketmq&#x2F;store&#x2F;abort</span><br><span class="line"></span><br><span class="line">maxIndexNum &#x3D; 20000000</span><br><span class="line"></span><br><span class="line">registerBrokerTimeoutMills &#x3D; 6000</span><br><span class="line"></span><br><span class="line">messageIndexSafe &#x3D; false</span><br><span class="line"></span><br><span class="line">putMsgIndexHightWater &#x3D; 600000</span><br><span class="line"></span><br><span class="line">listenPort &#x3D; 10911</span><br><span class="line"></span><br><span class="line">serverWorkerThreads &#x3D; 8</span><br><span class="line"></span><br><span class="line">clientSocketSndBufSize &#x3D; 131072</span><br><span class="line"></span><br><span class="line">traceOn &#x3D; true</span><br><span class="line"></span><br><span class="line">maxHashSlotNum &#x3D; 5000000</span><br><span class="line"></span><br><span class="line">brokerRole &#x3D; ASYNC_MASTER</span><br><span class="line"></span><br><span class="line">storePathIndex &#x3D; &#x2F;data&#x2F;rocketmq&#x2F;store&#x2F;index</span><br><span class="line"></span><br><span class="line">rocketmqHome &#x3D; &#x2F;home&#x2F;baseuser&#x2F;rocketmq</span><br><span class="line"></span><br><span class="line">useReentrantLockWhenPutMessage &#x3D; false</span><br><span class="line"></span><br><span class="line">haHousekeepingInterval &#x3D; 20000</span><br><span class="line"></span><br><span class="line">brokerPermission &#x3D; 6</span><br><span class="line"></span><br><span class="line">maxTransferCountOnMessageInMemory &#x3D; 1000</span><br><span class="line"></span><br><span class="line">useEpollNativeSelector &#x3D; false</span><br><span class="line"></span><br><span class="line">haSlaveFallbehindMax &#x3D; 268435456</span><br><span class="line"></span><br><span class="line">haTransferBatchSize &#x3D; 32768</span><br><span class="line"></span><br><span class="line">messageStorePlugIn &#x3D;</span><br><span class="line"></span><br><span class="line">pullThreadPoolQueueCapacity &#x3D; 100000</span><br><span class="line"></span><br><span class="line">brokerClusterName &#x3D; ZmsClusterB</span><br><span class="line"></span><br><span class="line">destroyMapedFileIntervalForcibly &#x3D; 120000</span><br><span class="line"></span><br><span class="line">mapedFileSizeCommitLog &#x3D; 1073741824</span><br><span class="line"></span><br><span class="line">commercialBigCount &#x3D; 1</span><br><span class="line"></span><br><span class="line">flushLeastPagesWhenWarmMapedFile &#x3D; 4096</span><br><span class="line"></span><br><span class="line">sendMessageThreadPoolNums &#x3D; 1</span><br><span class="line"></span><br><span class="line">flushIntervalCommitLog &#x3D; 500</span><br></pre></td></tr></table></figure>





<h1 id="发送消息到broker"><a href="#发送消息到broker" class="headerlink" title="发送消息到broker"></a>发送消息到broker</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin sendMsgStatus -b 192.168.1.x:10911 -n 192.168.1.x:9876</span><br></pre></td></tr></table></figure>



<h1 id="更新broker信息"><a href="#更新broker信息" class="headerlink" title="更新broker信息"></a>更新broker信息</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin updateBrokerConfig -b 192.168.1.x:10911 -n 192.168.1.x:9876 -k key -v value</span><br></pre></td></tr></table></figure></div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ6# RocketMQ NameSrv命令</title>
    <url>/posts/7ee60e46/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="获取namesrv配置"><a href="#获取namesrv配置" class="headerlink" title="获取namesrv配置"></a>获取namesrv配置</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[baseuser@HZPL00xxxx rocketmq]$ sh bin&#x2F;mqadmin getNamesrvConfig -n 192.168.1.x:9876</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option PermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;192.168.1.x:9876&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">serverChannelMaxIdleTimeSeconds &#x3D; 120</span><br><span class="line"></span><br><span class="line">listenPort &#x3D; 9876</span><br><span class="line"></span><br><span class="line">serverCallbackExecutorThreads &#x3D; 0</span><br><span class="line"></span><br><span class="line">serverAsyncSemaphoreValue &#x3D; 64</span><br><span class="line"></span><br><span class="line">serverSocketSndBufSize &#x3D; 4096</span><br><span class="line"></span><br><span class="line">rocketmqHome &#x3D; &#x2F;home&#x2F;baseuser&#x2F;rocketmq</span><br><span class="line"></span><br><span class="line">clusterTest &#x3D; false</span><br><span class="line"></span><br><span class="line">serverSelectorThreads &#x3D; 3</span><br><span class="line"></span><br><span class="line">useEpollNativeSelector &#x3D; false</span><br><span class="line"></span><br><span class="line">orderMessageEnable &#x3D; false</span><br><span class="line"></span><br><span class="line">serverPooledByteBufAllocatorEnable &#x3D; true</span><br><span class="line"></span><br><span class="line">kvConfigPath &#x3D; &#x2F;home&#x2F;baseuser&#x2F;namesrv&#x2F;kvConfig.json</span><br><span class="line"></span><br><span class="line">serverWorkerThreads &#x3D; 8</span><br><span class="line"></span><br><span class="line">serverSocketRcvBufSize &#x3D; 4096</span><br><span class="line"></span><br><span class="line">productEnvName &#x3D; center</span><br><span class="line"></span><br><span class="line">serverOnewaySemaphoreValue &#x3D; 256</span><br><span class="line"></span><br><span class="line">configStorePath &#x3D; &#x2F;home&#x2F;baseuser&#x2F;namesrv&#x2F;namesrv.properties</span><br></pre></td></tr></table></figure>



<a id="more"></a>



<h1 id="删除nameSrv配置"><a href="#删除nameSrv配置" class="headerlink" title="删除nameSrv配置"></a>删除nameSrv配置</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh bin&#x2F;mqadmin deleteKvConfig -n 192.168.1.x:9876 -s namesapce -k key</span><br><span class="line"></span><br><span class="line">Delete KV config.</span><br><span class="line"></span><br><span class="line">-s set the namespace</span><br><span class="line"></span><br><span class="line">-k key set the key name</span><br></pre></td></tr></table></figure>



<h1 id="更新了nameSrv配置"><a href="#更新了nameSrv配置" class="headerlink" title="更新了nameSrv配置"></a>更新了nameSrv配置</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh bin&#x2F;mqadmin updateKvConfig -n 192.168.1.x:9876 -s namesapce -k key</span><br><span class="line"></span><br><span class="line">update KV config.</span><br><span class="line"></span><br><span class="line">-s set the namespace</span><br><span class="line"></span><br><span class="line">-k key set the key name</span><br><span class="line"></span><br><span class="line">-v value set the key value</span><br></pre></td></tr></table></figure>



<h1 id="更新nameSrv配置"><a href="#更新nameSrv配置" class="headerlink" title="更新nameSrv配置"></a>更新nameSrv配置</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh bin&#x2F;mqadmin updateNamesrvConfig -n 192.168.1.x:9876 -s namesapce -k key</span><br><span class="line"></span><br><span class="line">update KV config.</span><br><span class="line"></span><br><span class="line">-k key set the key name</span><br><span class="line"></span><br><span class="line">-v value set the key value</span><br></pre></td></tr></table></figure>



<h1 id="取消Broker写权限"><a href="#取消Broker写权限" class="headerlink" title="取消Broker写权限"></a>取消Broker写权限</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh bin&#x2F;mqadmin wipeWritePerm -n 192.168.1.x:9876 -b brokerAddr</span><br><span class="line"></span><br><span class="line">Wipe write perm of broker in all name server</span><br><span class="line"></span><br><span class="line">-b brokerName</span><br></pre></td></tr></table></figure>

</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ7# RocketMQ Message相关命令</title>
    <url>/posts/40c12a8c/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="发送测试消息"><a href="#发送测试消息" class="headerlink" title="发送测试消息"></a>发送测试消息</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin checkMsgSendRT -n 192.168.x.x:9876 -t topic_online_test -s 1024</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option PermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize&#x3D;128m; support was removed in 8.0Broker Name           QID #Send Result      RTbroker-a             0   true          314broker-a             1   true          0broker-a             2   true          0</span><br><span class="line"></span><br><span class="line">broker-a             3   true          0</span><br><span class="line"></span><br><span class="line">broker-b             0   true          2</span><br><span class="line"></span><br><span class="line">broker-b             1   true          1</span><br><span class="line"></span><br><span class="line">broker-b             2   true          1</span><br><span class="line"></span><br><span class="line">broker-b             3   true          0</span><br><span class="line"></span><br><span class="line">broker-a             0   true          1</span><br><span class="line"></span><br><span class="line">broker-a             1   true          0</span><br><span class="line"></span><br><span class="line">broker-a             2   true          0</span><br><span class="line"></span><br><span class="line">broker-a             3   true          1</span><br><span class="line"></span><br><span class="line">broker-b             0   true          4</span><br><span class="line"></span><br><span class="line">-t topic topic name</span><br><span class="line"></span><br><span class="line">-a amount message amout | default 100</span><br><span class="line"></span><br><span class="line">-s size message size | default 128 Byte</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h1 id="print-message-by-queue"><a href="#print-message-by-queue" class="headerlink" title="print message by queue"></a>print message by queue</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin printMsgByQueue -n 192.168.1.x:9876 -b 192.168.1.x -i 0</span><br></pre></td></tr></table></figure>





<h1 id="打印topic中的信息"><a href="#打印topic中的信息" class="headerlink" title="打印topic中的信息"></a>打印topic中的信息</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin printMsg -n 192.168.1.x:9876 -t SCANRECORD</span><br><span class="line"></span><br><span class="line">&quot;t&quot;, &quot;topic&quot;, true, &quot;topic name&quot;</span><br><span class="line"></span><br><span class="line">&quot;c&quot;, &quot;charsetName &quot;, true, &quot;CharsetName(eg: UTF-8,GBK)&quot;</span><br><span class="line"></span><br><span class="line">&quot;s&quot;, &quot;subExpression &quot;, true, &quot;Subscribe Expression(eg: TagA || TagB)&quot;</span><br><span class="line"></span><br><span class="line">&quot;b&quot;, &quot;beginTimestamp &quot;, true,  Begin timestamp[currentTimeMillis|yyyy-MM-dd#HH:mm:ss:SSS]</span><br><span class="line"></span><br><span class="line">&quot;e&quot;, &quot;endTimestamp &quot;, true, End timestamp[currentTimeMillis|yyyy-MM-dd#HH:mm:ss:SSS]</span><br><span class="line"></span><br><span class="line">&quot;d&quot;, &quot;printBody &quot;, true,&quot;print body&quot;</span><br><span class="line"></span><br><span class="line">MSGID: C0A81F8166832F2C9B1953831616FB45 MessageExt [queueId&#x3D;20, storeSize&#x3D;686, queueOffset&#x3D;35052080, sysFlag&#x3D;0, bornTimestamp&#x3D;1539724299798, bornHost&#x3D;&#x2F;192.168.x.x:29781, storeTimestamp&#x3D;1539724299179, storeHost&#x3D;&#x2F;192.168.x.x:10911, msgId&#x3D;C0A801B400002A9F000005F308F9B3A5, commitLogOffset&#x3D;6541385773989, bodyCRC&#x3D;1167936923, reconsumeTimes&#x3D;0, preparedTransactionOffset&#x3D;0, toString()&#x3D;Message [topic&#x3D;SCANRECORD, flag&#x3D;0, properties&#x3D;&#123;MIN_OFFSET&#x3D;35046369, MAX_OFFSET&#x3D;40298522, KEYS&#x3D;1dd04932-b7d9-43ee-8b31-39d16dd043d4, UNIQ_KEY&#x3D;C0A81F8166832F2C9B1953831616FB45, WAIT&#x3D;true, TAGS&#x3D;2&#125;, body&#x3D;484]] BODY: &#123;&quot;billCode&quot;:&quot;640010206680&quot;,&quot;blReturnBillId&quot;:0,&quot;blUntreadPieceId&quot;:0,&quot;clazz&quot;:&quot;2&quot;,&quot;dataFrom&quot;:&quot;2&quot;,&quot;dispatchId&quot;:0,&quot;ownerBagNo&quot;:&quot;3783585805&quot;,&quot;pdaCode&quot;:&quot;S50117101164&quot;,&quot;piece&quot;:1,&quot;preOrNexStaId&quot;:14761,&quot;preOrNextStation&quot;:&quot;\u6F6E\u6C55\u4E2D\u5FC3&quot;,&quot;prepProvinceId&quot;:440000,&quot;registerDate&quot;:1539724298000,&quot;scanDate&quot;:1539724241000,&quot;scanMan&quot;:&quot;\u9648\u4E9A\u5973&quot;,&quot;scanManCode&quot;:&quot;020019.0865&quot;,&quot;scanProvinceId&quot;:440000,&quot;scanSite&quot;:&quot;\u5E7F\u5DDE\u5E7F\u56ED&quot;,&quot;scanSiteId&quot;:1051037,&quot;scanType&quot;:&quot;\u53D1\u4EF6&quot;&#125;</span><br></pre></td></tr></table></figure>



<h1 id="通过messageId查询消息"><a href="#通过messageId查询消息" class="headerlink" title="通过messageId查询消息"></a>通过messageId查询消息</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin queryMsgById -n 192.168.x.x:9876 -i C0A801B400002A9F000005F308F9B3A5</span><br><span class="line"></span><br><span class="line">&quot;i&quot;, &quot;msgId&quot;, true, &quot;Message Id&quot;</span><br><span class="line"></span><br><span class="line">&quot;consumerGroup&quot;, true, &quot;consumer group name&quot;</span><br><span class="line"></span><br><span class="line">&quot;clientId&quot;, true, &quot;The consumer&#39;s client id&quot;</span><br><span class="line"></span><br><span class="line">&quot;sendMessage&quot;, true, &quot;resend message&quot;</span><br><span class="line"></span><br><span class="line">&quot;unitName&quot;, true, &quot;unit name&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin queryMsgById -n 192.168.x.x:9876 -i C0A801B400002A9F000005F308F9B3A5</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option PermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">OffsetID:      C0A801B400002A9F000005F308F9B3A5</span><br><span class="line"></span><br><span class="line">OffsetID:      C0A801B400002A9F000005F308F9B3A5</span><br><span class="line"></span><br><span class="line">Topic:        SCANRECORD</span><br><span class="line"></span><br><span class="line">Tags:        [2]</span><br><span class="line"></span><br><span class="line">Keys:        [1dd04932-b7d9-43ee-8b31-39d16dd043d4]</span><br><span class="line"></span><br><span class="line">Queue ID:      20</span><br><span class="line"></span><br><span class="line">Queue Offset:    35052080</span><br><span class="line"></span><br><span class="line">CommitLog Offset:  6541385773989</span><br><span class="line"></span><br><span class="line">Reconsume Times:   0</span><br><span class="line"></span><br><span class="line">Born Timestamp:   2018-10-17 05:11:39,798</span><br><span class="line"></span><br><span class="line">Store Timestamp:   2018-10-17 05:11:39,179</span><br><span class="line"></span><br><span class="line">Born Host:      192.168.31.129:29781</span><br><span class="line"></span><br><span class="line">Store Host:     192.168.1.180:10911</span><br><span class="line"></span><br><span class="line">System Flag:     0</span><br><span class="line"></span><br><span class="line">Properties:     &#123;KEYS&#x3D;1dd04932-b7d9-43ee-8b31-39d16dd043d4, UNIQ_KEY&#x3D;C0A81F8166832F2C9B1953831616FB45, WAIT&#x3D;true, TAGS&#x3D;2&#125;</span><br><span class="line"></span><br><span class="line">Message Body Path:  &#x2F;tmp&#x2F;rocketmq&#x2F;msgbodys&#x2F;C0A81F8166832F2C9B1953831616FB45</span><br><span class="line"></span><br><span class="line">MessageTrack [consumerGroup&#x3D;ZtoSignGroup, trackType&#x3D;CONSUMED_BUT_FILTERED, exceptionDesc&#x3D;null]MessageTrack [consumerGroup&#x3D;newOpenPartnerDeadlineJob, trackType&#x3D;CONSUMED_BUT_FILTERED, exceptionDesc&#x3D;null]MessageTrack [consumerGroup&#x3D;smartidivision-scanrecord-dis, trackType&#x3D;CONSUMED_BUT_FILTERED, exceptionDesc&#x3D;null]MessageTrack [consumerGroup&#x3D;PanguRecordGroup, trackType&#x3D;CONSUMED, exceptionDesc&#x3D;null]MessageTrack [consumerGroup&#x3D;code-send-consumer, trackType&#x3D;CONSUMED_BUT_FILTERED, exceptionDesc&#x3D;null]MessageTrack [consumerGroup&#x3D;shenZhouOneSiteKpiConsumer, trackType&#x3D;CONSUMED, exceptionDesc&#x3D;null]MessageTrack [consumerGroup&#x3D;SortComplementConsumer, trackType&#x3D;CONSUMED_BUT_FILTERED, exceptionDesc&#x3D;null]MessageTrack [consumerGroup&#x3D;tf_wonder_waybill_center_scanrecord, trackType&#x3D;CONSUMED_BUT_FILTERED, exceptionDesc&#x3D;null]MessageTrack [consumerGroup&#x3D;dpmComScanRecordConsumer, trackType&#x3D;UNKNOWN, exceptionDesc&#x3D;org.apache.rocketmq.client.exception.MQClientException: CODE: 17 DESC: No topic route info in name server for the topic: %RETRY%dpmComScanRecordConsumer</span><br><span class="line"></span><br><span class="line">See [http:&#x2F;&#x2F;rocketmq.apache.org&#x2F;docs&#x2F;faq&#x2F;](http:&#x2F;&#x2F;rocketmq.apache.org&#x2F;docs&#x2F;faq&#x2F;) for further details., org.apache.rocketmq.client.impl.MQClientAPIImpl.getTopicRouteInfoFromNameServer(MQClientAPIImpl.java:1212)]MessageTrack</span><br></pre></td></tr></table></figure>



<h1 id="根据key查询存储消息"><a href="#根据key查询存储消息" class="headerlink" title="根据key查询存储消息"></a>根据key查询存储消息</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin queryMsgByKey -n 192.168.x.x:9876 -t SCANRECORD -k 1dd04932-b7d9-43ee-8b31-39d16dd043d4</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option PermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">Message ID                    QID                 Offset</span><br><span class="line"></span><br><span class="line">C0A81F8166832F2C9B1953831616FB45           20                 35052080</span><br></pre></td></tr></table></figure>



<h1 id="根据offset查询储存消息"><a href="#根据offset查询储存消息" class="headerlink" title="根据offset查询储存消息"></a>根据offset查询储存消息</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin queryMsgByOffset -n 192.168.x.x:9876 -t SCANRECORD -b broker-a -i 20 -o 35052080</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option PermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">OffsetID:      C0A801B400002A9F000005F308F9B3A5</span><br><span class="line"></span><br><span class="line">OffsetID:      C0A801B400002A9F000005F308F9B3A5</span><br><span class="line"></span><br><span class="line">Topic:        SCANRECORD</span><br><span class="line"></span><br><span class="line">Tags:        [2]</span><br><span class="line"></span><br><span class="line">Keys:        [1dd04932-b7d9-43ee-8b31-39d16dd043d4]</span><br><span class="line"></span><br><span class="line">Queue ID:      20</span><br><span class="line"></span><br><span class="line">Queue Offset:    35052080</span><br><span class="line"></span><br><span class="line">CommitLog Offset:  6541385773989</span><br><span class="line"></span><br><span class="line">Reconsume Times:   0</span><br><span class="line"></span><br><span class="line">Born Timestamp:   2018-10-17 05:11:39,798</span><br><span class="line"></span><br><span class="line">Store Timestamp:   2018-10-17 05:11:39,179</span><br><span class="line"></span><br><span class="line">Born Host:      192.168.31.129:29781</span><br><span class="line"></span><br><span class="line">Store Host:     192.168.1.180:10911</span><br><span class="line"></span><br><span class="line">System Flag:     0</span><br><span class="line"></span><br><span class="line">Properties:     &#123;MIN_OFFSET&#x3D;35046369, MAX_OFFSET&#x3D;40342481, KEYS&#x3D;1dd04932-b7d9-43ee-8b31-39d16dd043d4, UNIQ_KEY&#x3D;C0A81F8166832F2C9B1953831616FB45, WAIT&#x3D;true, TAGS&#x3D;2&#125;</span><br><span class="line"></span><br><span class="line">Message Body Path:  &#x2F;tmp&#x2F;rocketmq&#x2F;msgbodys&#x2F;C0A81F8166832F2C9B1953831616FB45</span><br><span class="line"></span><br><span class="line">MessageTrack [consumerGroup&#x3D;ZtoSignGroup, trackType&#x3D;CONSUMED_BUT_FILTERED, exceptionDesc&#x3D;null]MessageTrack [consumerGroup&#x3D;newOpenPartnerDeadlineJob, trackType&#x3D;CONSUMED_BUT_FILTERED, exceptionDesc&#x3D;null]MessageTrack [consumerGroup&#x3D;smartidivision-scanrecord-dis, trackType&#x3D;CONSUMED_BUT_FILTERED, exceptionDesc&#x3D;null]MessageTrack [consumerGroup&#x3D;PanguRecordGroup, trackType&#x3D;CONSUMED, exceptionDesc&#x3D;null]MessageTrack [consumerGroup&#x3D;code-send-consumer, trackType&#x3D;CONSUMED_BUT_FILTERED, exceptionDesc&#x3D;null]MessageTrack [consumerGroup&#x3D;shenZhouOneSiteKpiConsumer, trackType&#x3D;CONSUMED, exceptionDesc&#x3D;null]MessageTrack [consumerGroup&#x3D;SortComplementConsumer, trackType&#x3D;CONSUMED_BUT_FILTERED, exceptionDesc&#x3D;null]MessageTrack [consumerGroup&#x3D;tf_wonder_waybill_center_scanrecord, trackType&#x3D;CONSUMED_BUT_FILTERED, exceptionDesc&#x3D;null]MessageTrack [consumerGroup&#x3D;dpmComScanRecordConsumer, trackType&#x3D;UNKNOWN, exceptionDesc&#x3D;org.apache.rocketmq.client.exception.MQClientException: CODE: 17 DESC: No topic route info in name server for the topic: %RETRY%dpmComScanRecordConsumer</span><br><span class="line"></span><br><span class="line">See [http:&#x2F;&#x2F;rocketmq.apache.org&#x2F;docs&#x2F;faq&#x2F;](http:&#x2F;&#x2F;rocketmq.apache.org&#x2F;docs&#x2F;faq&#x2F;) for further details., org.apache.rocketmq.client.impl.MQClientAPIImpl.getTopicRouteInfoFromNameServer(MQClientAPIImpl.java:1212)]MessageTrack [</span><br><span class="line"></span><br><span class="line">&quot;t&quot;, &quot;topic&quot;, true, &quot;topic name&quot;</span><br><span class="line"></span><br><span class="line">&quot;b&quot;, &quot;brokerName&quot;, true, &quot;Broker Name&quot;</span><br><span class="line"></span><br><span class="line">&quot;i&quot;, &quot;queueId&quot;, true, &quot;Queue Id&quot;</span><br><span class="line"></span><br><span class="line">&quot;o&quot;, &quot;offset&quot;, true, &quot;Queue Offset&quot;</span><br></pre></td></tr></table></figure>



<h1 id="通过UniqueKey查询消息内容"><a href="#通过UniqueKey查询消息内容" class="headerlink" title="通过UniqueKey查询消息内容"></a>通过UniqueKey查询消息内容</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin queryMsgByUniqueKey -n 192.168.x.x:9876 -t SCANRECORD -i C0A801B400002A9F000005F308F9B3A5</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option PermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">Topic:        SCANRECORD</span><br><span class="line"></span><br><span class="line">Tags:        [2]</span><br><span class="line"></span><br><span class="line">Keys:        [1dd04932-b7d9-43ee-8b31-39d16dd043d4]</span><br><span class="line"></span><br><span class="line">Queue ID:      20</span><br><span class="line"></span><br><span class="line">Queue Offset:    35052080</span><br><span class="line"></span><br><span class="line">CommitLog Offset:  6541385773989</span><br><span class="line"></span><br><span class="line">Reconsume Times:   0</span><br><span class="line"></span><br><span class="line">Born Timestamp:   2018-10-17 05:11:39,798</span><br><span class="line"></span><br><span class="line">Store Timestamp:   2018-10-17 05:11:39,179</span><br><span class="line"></span><br><span class="line">Born Host:      192.168.31.129:29781</span><br><span class="line"></span><br><span class="line">Store Host:     192.168.1.180:10911</span><br><span class="line"></span><br><span class="line">System Flag:     0</span><br><span class="line"></span><br><span class="line">Properties:     &#123;KEYS&#x3D;1dd04932-b7d9-43ee-8b31-39d16dd043d4, UNIQ_KEY&#x3D;C0A81F8166832F2C9B1953831616FB45, WAIT&#x3D;true, TAGS&#x3D;2&#125;</span><br><span class="line"></span><br><span class="line">Message Body Path:  &#x2F;tmp&#x2F;rocketmq&#x2F;msgbodys&#x2F;C0A81F8166832F2C9B1953831616FB45</span><br><span class="line"></span><br><span class="line">MessageTrack [consumerGroup&#x3D;ZtoSignGroup, trackType&#x3D;CONSUMED_BUT_FILTERED, exceptionDesc&#x3D;null]MessageTrack [consumerGroup&#x3D;newOpenPartnerDeadlineJob, trackType&#x3D;CONSUMED_BUT_FILTERED, exceptionDesc&#x3D;null]MessageTrack [consumerGroup&#x3D;smartidivision-scanrecord-dis, trackType&#x3D;CONSUMED_BUT_FILTERED, exceptionDesc&#x3D;null]MessageTrack [consumerGroup&#x3D;PanguRecordGroup, trackType&#x3D;CONSUMED, exceptionDesc&#x3D;null]MessageTrack [consumerGroup&#x3D;code-send-consumer, trackType&#x3D;CONSUMED_BUT_FILTERED, exceptionDesc&#x3D;null]MessageTrack [consumerGroup&#x3D;shenZhouOneSiteKpiConsumer, trackType&#x3D;CONSUMED, exceptionDesc&#x3D;null]MessageTrack [consumerGroup&#x3D;SortComplementConsumer, trackType&#x3D;CONSUMED_BUT_FILTERED, exceptionDesc&#x3D;null]MessageTrack [consumerGroup&#x3D;tf_wonder_waybill_center_scanrecord, trackType&#x3D;CONSUMED_BUT_FILTERED, exceptionDesc&#x3D;null]MessageTrack [consumerGroup&#x3D;dpmComScanRecordConsumer, trackType&#x3D;UNKNOWN, exceptionDesc&#x3D;org.apache.rocketmq.client.exception.MQClientException: CODE: 17 DESC: No topic route info in name server for the topic: %RETRY%dpmComScanRecordConsumer</span><br><span class="line"></span><br><span class="line">See [http:&#x2F;&#x2F;rocketmq.apache.org&#x2F;docs&#x2F;faq&#x2F;](http:&#x2F;&#x2F;rocketmq.apache.org&#x2F;docs&#x2F;faq&#x2F;) for further details., org.apache.rocketmq.client.impl.MQClientAPIImpl.getTopicRouteInfoFromNameServer(MQClientAPIImpl.java:1212)]MessageTrack </span><br><span class="line"></span><br><span class="line">&quot;i&quot;, &quot;msgId&quot;, true, &quot;Message Id&quot;</span><br><span class="line"></span><br><span class="line">&quot;g&quot;, &quot;consumerGroup&quot;, true, &quot;consumer group name&quot;</span><br><span class="line"></span><br><span class="line">&quot;d&quot;, &quot;clientId&quot;, true, &quot;The consumer&#39;s client id&quot;</span><br><span class="line"></span><br><span class="line">&quot;t&quot;, &quot;topic&quot;, true, &quot;The topic of msg&quot;</span><br></pre></td></tr></table></figure>

</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ8# RocketMQ Topic相关命令</title>
    <url>/posts/48072e7/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="分配MQ"><a href="#分配MQ" class="headerlink" title="分配MQ"></a>分配MQ</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin allocateMQ -n localhost:9876 -t tst-topic -i ipList</span><br><span class="line"></span><br><span class="line">ipList 以逗号分隔</span><br></pre></td></tr></table></figure>



<h1 id="删除topic"><a href="#删除topic" class="headerlink" title="删除topic"></a>删除topic</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin deleteTopic -n localhost:9876 -t zto-example -c DefultCluster</span><br></pre></td></tr></table></figure>



<a id="more"></a>



<h1 id="获取topic的cluster"><a href="#获取topic的cluster" class="headerlink" title="获取topic的cluster"></a>获取topic的cluster</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin topicClusterList -n 192.168.1.x:9876 -t SCANRECORD</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option PermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">ZmsClusterB</span><br></pre></td></tr></table></figure>



<h1 id="查看Topic列表信息"><a href="#查看Topic列表信息" class="headerlink" title="查看Topic列表信息"></a>查看Topic列表信息</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin topicList -n localhost:9876</span><br></pre></td></tr></table></figure>



<h1 id="查看Topic路由信息"><a href="#查看Topic路由信息" class="headerlink" title="查看Topic路由信息"></a>查看Topic路由信息</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin topicRoute -n 192.168.1.x:9876 -t SCANRECORD</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option PermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&quot;brokerDatas&quot;:[</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&quot;brokerAddrs&quot;:&#123;0:&quot;192.168.1.x:10911&quot;,1:&quot;192.168.1.x:10920&quot;</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&quot;brokerName&quot;:&quot;broker-d&quot;</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&quot;brokerAddrs&quot;:&#123;0:&quot;192.168.1.x:10911&quot;,1:&quot;192.168.1.x:10920&quot;</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&quot;brokerName&quot;:&quot;broker-b&quot;</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&quot;brokerAddrs&quot;:&#123;0:&quot;192.168.1.x:10911&quot;,1:&quot;192.168.1.x:10915&quot;</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&quot;brokerName&quot;:&quot;broker-c&quot;</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&quot;brokerAddrs&quot;:&#123;0:&quot;192.168.1.x:10911&quot;,1:&quot;192.168.1.x:10915&quot;</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&quot;brokerName&quot;:&quot;broker-a&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">],</span><br><span class="line"></span><br><span class="line">&quot;filterServerTable&quot;:&#123;&#125;,</span><br><span class="line"></span><br><span class="line">&quot;queueDatas&quot;:[</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&quot;brokerName&quot;:&quot;broker-b&quot;,</span><br><span class="line"></span><br><span class="line">&quot;perm&quot;:6,</span><br><span class="line"></span><br><span class="line">&quot;readQueueNums&quot;:64,</span><br><span class="line"></span><br><span class="line">&quot;topicSynFlag&quot;:0,</span><br><span class="line"></span><br><span class="line">&quot;writeQueueNums&quot;:64</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&quot;brokerName&quot;:&quot;broker-a&quot;,</span><br><span class="line"></span><br><span class="line">&quot;perm&quot;:6,</span><br><span class="line"></span><br><span class="line">&quot;readQueueNums&quot;:64,</span><br><span class="line"></span><br><span class="line">&quot;topicSynFlag&quot;:0,</span><br><span class="line"></span><br><span class="line">&quot;writeQueueNums&quot;:64</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&quot;brokerName&quot;:&quot;broker-c&quot;,</span><br><span class="line"></span><br><span class="line">&quot;perm&quot;:6,</span><br><span class="line"></span><br><span class="line">&quot;readQueueNums&quot;:64,</span><br><span class="line"></span><br><span class="line">&quot;topicSynFlag&quot;:0,</span><br><span class="line"></span><br><span class="line">&quot;writeQueueNums&quot;:64</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&quot;brokerName&quot;:&quot;broker-d&quot;,</span><br><span class="line"></span><br><span class="line">&quot;perm&quot;:6,</span><br><span class="line"></span><br><span class="line">&quot;readQueueNums&quot;:64,</span><br><span class="line"></span><br><span class="line">&quot;topicSynFlag&quot;:0,</span><br><span class="line"></span><br><span class="line">&quot;writeQueueNums&quot;:64</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="查看topic状态"><a href="#查看topic状态" class="headerlink" title="查看topic状态"></a>查看topic状态</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin topicStatus -n 192.168.1.174:9876 -t SCANRECORD</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option PermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">Broker Name QID Min Offset Max Offset Last Updated</span><br><span class="line"></span><br><span class="line">broker-a 0 34757063 39718709 2018-10-22 13:54:32,526</span><br><span class="line"></span><br><span class="line">broker-a 1 34760194 39722786 2018-10-22 13:54:32,149</span><br><span class="line"></span><br><span class="line">broker-a 2 34765030 39734966 2018-10-22 13:54:32,537</span><br><span class="line"></span><br><span class="line">broker-a 3 34775398 39758820 2018-10-22 13:54:32,507</span><br><span class="line"></span><br><span class="line">broker-a 4 34804472 39800334 2018-10-22 13:54:32,511</span><br><span class="line"></span><br><span class="line">broker-a 5 34835232 39854584 2018-10-22 13:54:32,528</span><br><span class="line"></span><br><span class="line">broker-a 6 34863554 39910095 2018-10-22 13:54:32,528</span><br></pre></td></tr></table></figure>



<h1 id="更新orderConf"><a href="#更新orderConf" class="headerlink" title="更新orderConf"></a>更新orderConf</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh bin&#x2F;mqadmin updateOrderConf -t SCANRECORD -m put -n 192.168.1.x:9876</span><br><span class="line"></span><br><span class="line">-m option type [eg. put|get|delete</span><br></pre></td></tr></table></figure>



<h1 id="更改Topic权限"><a href="#更改Topic权限" class="headerlink" title="更改Topic权限"></a>更改Topic权限</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin updateTopicPerm -t SCANRECORD -p put -n 192.168.1.x:9876</span><br><span class="line"></span><br><span class="line">-p : set topic&#39;s permission(2|4|6), intro[2:W; 4:R; 6:RW]</span><br><span class="line"></span><br><span class="line">bin&#x2F;mqadmin updateTopicPerm -c ZmsClusterB -t %DLQ%starunion-freight -p 6 -n 192.168.1.x:9876</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option PermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">update topic perm from 2 to 6 in 192.168.1.x:10911 success.</span><br><span class="line"></span><br><span class="line">update topic perm from 2 to 6 in 192.168.1.x:10911 success.</span><br><span class="line"></span><br><span class="line">update topic perm from 2 to 6 in 192.168.1.x:10911 success.</span><br><span class="line"></span><br><span class="line">update topic perm from 2 to 6 in 192.168.1.x:10911 success.</span><br></pre></td></tr></table></figure>









<h1 id="创建-修改Topic"><a href="#创建-修改Topic" class="headerlink" title="创建/修改Topic"></a>创建/修改Topic</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh bin&#x2F;mqadmin updateTopic -c DefaultCluster -n localhost:9876 -t threezto-test -r 12 -w 12</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option PermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">create topic to x.x.x.40:10911 success.</span><br><span class="line"></span><br><span class="line">TopicConfig [topicName&#x3D;threezto-test, readQueueNums&#x3D;12, writeQueueNums&#x3D;12, perm&#x3D;RW-, topicFilterType&#x3D;SINGLE_TAG, topicSysFlag&#x3D;0, order&#x3D;false]</span><br><span class="line"></span><br><span class="line">-b brokerAddr create topic to which broker</span><br><span class="line"></span><br><span class="line">-c clusterName create topic to which cluster</span><br><span class="line"></span><br><span class="line">-t topic topic name</span><br><span class="line"></span><br><span class="line">-r readQueueNums set read queue nums</span><br><span class="line"></span><br><span class="line">-w writeQueueNums set write queue nums</span><br><span class="line"></span><br><span class="line">-p perm set topic&#39;s permission(2|4|6), intro[2:W 4:R; 6:RW]</span><br><span class="line"></span><br><span class="line">-o order set topic&#39;s order(true|false</span><br><span class="line"></span><br><span class="line">-u unit is unit topic (true|false</span><br><span class="line"></span><br><span class="line">-s hasUnitSub has unit sub (true|false</span><br></pre></td></tr></table></figure>

</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ9# RocketMQ Offset 相关命令</title>
    <url>/posts/5c6eeeec/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="克隆消费组的offset（同一个集群）"><a href="#克隆消费组的offset（同一个集群）" class="headerlink" title="克隆消费组的offset（同一个集群）"></a>克隆消费组的offset（同一个集群）</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin cloneGroupOffset -n 192.168.1.x:9876 -s SCANRECORD_GROUP -d my-tst-cloneoffset -t SCANRECORD</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option PermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">clone group offset success. srcGroup[SCANRECORD_GROUP], destGroup&#x3D;[my-tst-cloneoffset], topic[SCANRECORD][baseuser@HZPL001180 rocketmq]$</span><br></pre></td></tr></table></figure>



<a id="more"></a>



<h1 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin statsAll -t SCANRECORD -n 192.168.1.x:9876</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option PermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">Topic Consumer Group Accumulation InTPS OutTPS InMsg24Hour OutMsg24Hour</span><br><span class="line"></span><br><span class="line">SCANRECORD ZtoSignGroup 2290 3063.95 522.72 233588408 29106863</span><br><span class="line"></span><br><span class="line">SCANRECORD newOpenPartnerDeadlineJob 2641 3063.95 522.72 233588408 29052057</span><br><span class="line"></span><br><span class="line">SCANRECORD smartidivision-scanrecord-dis 3110 3063.95 399.03 233588408 30052791</span><br><span class="line"></span><br><span class="line">SCANRECORD PanguRecordGroup 574 3063.95 2041.17 233588408 174462813</span><br><span class="line"></span><br><span class="line">SCANRECORD code-send-consumer 881 3063.95 1162.63 233588408 60072932</span><br><span class="line"></span><br><span class="line">SCANRECORD shenZhouOneSiteKpiConsumer 669 3063.95 1798.57 233588408 137543100</span><br><span class="line"></span><br><span class="line">SCANRECORD SortComplementConsumer 2746 3063.95 522.72 233588408 11466488</span><br><span class="line"></span><br><span class="line">SCANRECORD **my-tst-cloneoffset** 0 3063.95 0.00 233588408 0</span><br><span class="line"></span><br><span class="line">SCANRECORD tf_wonder_waybill_center_scanrec 2516 3063.95 522.72 233588408 29056664</span><br><span class="line"></span><br><span class="line">SCANRECORD dpmComScanRecordConsumer 0 3063.95 0.00 233588408 0</span><br><span class="line"></span><br><span class="line">SCANRECORD zms_syncer_SCANRECORD 286 3063.95 3063.73 233588408 233588419</span><br></pre></td></tr></table></figure>





<h1 id="根据时间重置消费位点"><a href="#根据时间重置消费位点" class="headerlink" title="根据时间重置消费位点"></a>根据时间重置消费位点</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin resetOffsetByTime -n 192.168.1.x:9876 -g ReceiveOrderGroupNew -t SCANRECORD -s now</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option PermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">rollback consumer offset by specified group[ReceiveOrderGroupNew], topic[SCANRECORD], force[true], timestamp(string)[now], timestamp(long)[1540196941761]</span><br><span class="line"></span><br><span class="line">brokerName queueId offset</span><br><span class="line"></span><br><span class="line">broker-a 20 40375806</span><br><span class="line"></span><br><span class="line">broker-b 55 40209057</span><br><span class="line"></span><br><span class="line">broker-c 24 40151853</span><br><span class="line"></span><br><span class="line">broker-b 22 40284014</span><br><span class="line"></span><br><span class="line">broker-a 53 40321569</span><br><span class="line"></span><br><span class="line">broker-d 59 39980239</span><br><span class="line"></span><br><span class="line">bin&#x2F;mqadmin resetOffsetByTime -n 192.168.1.x:9876 -g ReceiveOrderGroupNew -t SCANRECORD -s 1540196941761</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option PermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize&#x3D;128m; support was removed in 8.0</span><br><span class="line"></span><br><span class="line">rollback consumer offset by specified group[ReceiveOrderGroupNew], topic[SCANRECORD], force[true], timestamp(string)[1540196941761], timestamp(long)[1540196941761]</span><br><span class="line"></span><br><span class="line">brokerName queueId offset</span><br><span class="line"></span><br><span class="line">broker-a 20 40375806</span><br><span class="line"></span><br><span class="line">broker-b 55 40209057</span><br><span class="line"></span><br><span class="line">broker-c 24 40151853</span><br><span class="line"></span><br><span class="line">broker-b 22 40284014</span><br><span class="line"></span><br><span class="line">&quot;g&quot;, &quot;group&quot;, true, &quot;set the consumer group&quot;</span><br><span class="line"></span><br><span class="line">&quot;s&quot;, &quot;timestamp&quot;, true, &quot;set the timestamp[now|currentTimeMillis|yyyy-MM-dd#HH:mm:ss:SSS]&quot;</span><br><span class="line"></span><br><span class="line">&quot;f&quot;, &quot;force&quot;, true, &quot;set the force rollback by timestamp switch[true|false]&quot;</span><br><span class="line"></span><br><span class="line">&quot;c&quot;, &quot;cplus&quot;, false, &quot;reset c++ client offset&quot;</span><br></pre></td></tr></table></figure>

</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty1# Netty组件之Channel实例化</title>
    <url>/posts/8e76511e/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="一、Channel概述"><a href="#一、Channel概述" class="headerlink" title="一、Channel概述"></a>一、Channel概述</h1><p>Channel提供了I/O的基本操作。从以下子接口中可以看出Netty对不同的底层协议提供了对应的channel来处理，例如：TCP/IP、UDP/IP、SCTP/IP、HTTP2等。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202185721.png"></p>
<a id="more"></a>



<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202185853.png"></p>
<h1 id="二、实例化流程"><a href="#二、实例化流程" class="headerlink" title="二、实例化流程"></a>二、实例化流程</h1><p>从客户端引导类示例中查看Channel初始化过程。示例中使用NioSocketChannel作为通信通道，在java中通信中会建立socket连接</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">Http2ClientInitializer initializer = <span class="keyword">new</span> Http2ClientInitializer(sslCtx, Integer.MAX_VALUE);</span><br><span class="line"></span><br><span class="line">Bootstrap b = <span class="keyword">new</span> Bootstrap();</span><br><span class="line"></span><br><span class="line">b.group(workerGroup);</span><br><span class="line"></span><br><span class="line">b.channel(NioSocketChannel.class);</span><br><span class="line"></span><br><span class="line">b.option(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">b.remoteAddress(HOST, PORT);</span><br><span class="line"></span><br><span class="line">b.handler(initializer);</span><br><span class="line"></span><br><span class="line">Channel channel = b.connect().syncUninterruptibly().channel();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;Connected to [&quot;</span> + HOST + <span class="string">&#x27;:&#x27;</span> + PORT + <span class="string">&#x27;]&#x27;</span>);</span><br></pre></td></tr></table></figure>



<p>Channel通过ChannelFactory创建，下面看一下ChannelFactory类图。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202185957.png"></p>
<p>ReflectiveChannelFactory提供了newChannel()方法通过反射实例化。</p>
<p>示例中通过b.channel(NioSocketChannel.class)将NioSocketChannel.class赋值给ReflectiveChannelFactory的成员变量Constructor&lt;? extends T&gt; constructor，Channel在connect的时候实例化，下面为实例化调用链路。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202190011.png"></p>
<!--more-->



<h1 id="三、实例化过程"><a href="#三、实例化过程" class="headerlink" title="三、实例化过程"></a>三、实例化过程</h1><p><strong>客户端实例化过程</strong></p>
<p>了解了Channel初始化调用链，再来看下以NioSocketChannel为例初始化做了哪些事情。下面是NioSocketChannel的四个构造重载方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioSocketChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>(DEFAULT_SELECTOR_PROVIDER); <span class="comment">// @1</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioSocketChannel</span><span class="params">(SelectorProvider provider)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>(newSocket(provider)); <span class="comment">// @2</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioSocketChannel</span><span class="params">(SocketChannel socket)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>(<span class="keyword">null</span>, socket);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioSocketChannel</span><span class="params">(Channel parent, SocketChannel socket)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">super</span>(parent, socket);</span><br><span class="line"></span><br><span class="line">config = <span class="keyword">new</span> NioSocketChannelConfig(<span class="keyword">this</span>, socket.socket());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractNioChannel</span><span class="params">(Channel parent, SelectableChannel ch, <span class="keyword">int</span> readInterestOp)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">super</span>(parent);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.ch = ch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.readInterestOp = readInterestOp;</span><br><span class="line"></span><br><span class="line">ch.configureBlocking(<span class="keyword">false</span>); <span class="comment">// @3</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>代码解读</strong></p>
<p>@1 默认使用SelectorProvider.provider()</p>
<p>@2 使用Provider创建SocketChannel。provider.openSocketChannel()-&gt;new SocketChannelImpl(this)。</p>
<p>@3 设置NioChannel非阻塞模式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：客户端NioSocketChannel实例化过程中已经回到所熟悉的java nio。创建了通道SocketChannel，并设置为非阻塞。</span><br></pre></td></tr></table></figure>



<p><strong>服务端实例化过程</strong></p>
<p>Channel服务端的实例化流程与客户端是相同的，下面以NioServerSocketChannel为例走查实例化过程。服务端引导初始化示例代码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line"></span><br><span class="line">b.option(ChannelOption.SO_BACKLOG, <span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">b.group(group)</span><br><span class="line"></span><br><span class="line">.channel(NioServerSocketChannel.class)</span><br><span class="line"></span><br><span class="line">.handler(<span class="keyword">new</span> LoggingHandler(LogLevel.INFO))</span><br><span class="line"></span><br><span class="line">.childHandler(<span class="keyword">new</span> Http2ServerInitializer(sslCtx));</span><br><span class="line"></span><br><span class="line">Channel ch = b.bind(PORT).sync().channel();</span><br></pre></td></tr></table></figure>



<p>NioServerSocketChannel的构造方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioServerSocketChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>(newSocket(DEFAULT_SELECTOR_PROVIDER)); <span class="comment">// @1</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioServerSocketChannel</span><span class="params">(SelectorProvider provider)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>(newSocket(provider)); <span class="comment">// @2</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioServerSocketChannel</span><span class="params">(ServerSocketChannel channel)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">super</span>(<span class="keyword">null</span>, channel, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">config = <span class="keyword">new</span> NioServerSocketChannelConfig(<span class="keyword">this</span>, javaChannel().socket());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractNioChannel</span><span class="params">(Channel parent, SelectableChannel ch, <span class="keyword">int</span> readInterestOp)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">super</span>(parent);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.ch = ch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.readInterestOp = readInterestOp;</span><br><span class="line"></span><br><span class="line">ch.configureBlocking(<span class="keyword">false</span>); <span class="comment">// @3</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>代码解读</strong></p>
<p>@1 使用默认Provider类SelectorProvider</p>
<p>@2 开启服务端通道ServerSocketChannel。provider.openServerSocketChannel()-&gt;new ServerSocketChannelImpl(this)。</p>
<p>@3 将ServerSocketChanne设置为非阻塞。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：服务端NioServerSocketChannel的实例化过程同样回到熟悉的Java NIO，创建非阻塞ServerSocketChanne通道。</span><br></pre></td></tr></table></figure>



<p><strong>实例化其他事项</strong> </p>
<p>在实例化的过程中，会调父类的构造方法super(parent)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractChannel</span><span class="params">(Channel parent)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.parent = parent;</span><br><span class="line"></span><br><span class="line">id = newId(); <span class="comment">// @1</span></span><br><span class="line"></span><br><span class="line">unsafe = newUnsafe(); <span class="comment">// @2</span></span><br><span class="line"></span><br><span class="line">pipeline = newChannelPipeline(); <span class="comment">// @3</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>@1 ChannelId初始化</strong></p>
<p>ChannelId是Channel的唯一标识，下面看下DefaultChannelId的生成规则。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">DefaultChannelId</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">data = <span class="keyword">new</span> <span class="keyword">byte</span>[MACHINE_ID.length + PROCESS_ID_LEN + SEQUENCE_LEN + TIMESTAMP_LEN + RANDOM_LEN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// machineId</span></span><br><span class="line"></span><br><span class="line">System.arraycopy(MACHINE_ID, <span class="number">0</span>, data, i, MACHINE_ID.length);</span><br><span class="line"></span><br><span class="line">i += MACHINE_ID.length;</span><br><span class="line"></span><br><span class="line"><span class="comment">// processId</span></span><br><span class="line"></span><br><span class="line">i = writeInt(i, PROCESS_ID);</span><br><span class="line"></span><br><span class="line"><span class="comment">// sequence</span></span><br><span class="line"></span><br><span class="line">i = writeInt(i, nextSequence.getAndIncrement());</span><br><span class="line"></span><br><span class="line"><span class="comment">// timestamp (kind of)</span></span><br><span class="line"></span><br><span class="line">i = writeLong(i, Long.reverse(System.nanoTime()) ^ System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line"><span class="comment">// random</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> random = PlatformDependent.threadLocalRandom().nextInt();</span><br><span class="line"></span><br><span class="line">i = writeInt(i, random);</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> i == data.length;</span><br><span class="line"></span><br><span class="line">hashCode = Arrays.hashCode(data);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：默认的ChannelId由machineId、processId、sequence、timestamp、random构成。</span><br><span class="line">machineId：可以由参数io.netty.machineId自定义，默认为8位随机byte构成</span><br><span class="line">processId：可以由参数io.netty.processId自定义，默认为4位进程ID</span><br><span class="line">sequence：原子自增序号AtomicInteger，每创建一个Chanenl会进行自增</span><br><span class="line">timestamp：8位的timestamp</span><br><span class="line">random：4位的随机整数</span><br></pre></td></tr></table></figure>

<p><strong>@2 unsafe初始化</strong></p>
<p>unsafe即I/O的核心操作，byte的读写都靠它来处理。服务端NioServerSocketChannel初始化使用NioMessageUnsafe。客户端NioSocketChannel初始化使用NioSocketChannelUnsafe。以NIO为例看下Unsafe的类图结构。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202190316.png"></p>
<p><strong>@3 ChannelPipeline初始化</strong></p>
<p>默认使用DefaultChannelPipeline，从构造方法可以看出为链表结构，详细分析另文分析。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">DefaultChannelPipeline</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.channel = ObjectUtil.checkNotNull(channel, <span class="string">&quot;channel&quot;</span>);</span><br><span class="line"></span><br><span class="line">succeededFuture = <span class="keyword">new</span> SucceededChannelFuture(channel, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">voidPromise = <span class="keyword">new</span> VoidChannelPromise(channel, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">tail = <span class="keyword">new</span> TailContext(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">head = <span class="keyword">new</span> HeadContext(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">head.next = tail;</span><br><span class="line"></span><br><span class="line">tail.prev = head;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty10# 堆外内存底盘PlatformDependent</title>
    <url>/posts/821aaf66/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>非池化/池化内存如何分配的？该撸这块了，奈何到处都在调用PlatformDependent类的方法，要不各种判断，要不分配堆外内存。反正到处都能看到它，得，索性先把这个撸一把。PlatformDependent又依赖了PlatformDependent0，那就一层一层剥好了。</p>
<p>嗯，有点碎，大伙随便看看。</p>
<a id="more"></a>



<h1 id="PlatformDependent0"><a href="#PlatformDependent0" class="headerlink" title="PlatformDependent0"></a>PlatformDependent0</h1><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><table>
<thead>
<tr>
<th>名称</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td>ADDRESS_FIELD_OFFSET</td>
<td align="left">Buffer#address字段的内存偏移地址</td>
</tr>
<tr>
<td>BYTE_ARRAY_BASE_OFFSET</td>
<td align="left">获取内存中第一个元素的内存偏移量</td>
</tr>
<tr>
<td>DIRECT_BUFFER_CONSTRUCTOR</td>
<td align="left">DirectByteBuffer构造器对象，用于反射实例化</td>
</tr>
<tr>
<td>EXPLICIT_NO_UNSAFE_CAUSE</td>
<td align="left">平台不支持UNSAFE时，不支持异常封装在EXPLICIT_NO_UNSAFE_CAUSE中</td>
</tr>
<tr>
<td>ALLOCATE_ARRAY_METHOD</td>
<td align="left">Unsafe#allocateUninitializedArray Method对象，用于反射调用</td>
</tr>
<tr>
<td>JAVA_VERSION</td>
<td align="left">获取Java版本</td>
</tr>
<tr>
<td>IS_ANDROID</td>
<td align="left">系统是否为Android</td>
</tr>
<tr>
<td>UNSAFE_UNAVAILABILITY_CAUSE</td>
<td align="left">系统不支持UNSAFE会将异常封装在此变量中</td>
</tr>
<tr>
<td>INTERNAL_UNSAFE</td>
<td align="left">Java9中Unsafe实例对象</td>
</tr>
<tr>
<td>IS_EXPLICIT_TRY_REFLECTION_SET_ACCESSIBLE</td>
<td align="left">启用反射访问，在Java9版本之前是禁止的；Java9以及之后版本需要开启（这点要注意，Netty到处都有对Java9之后的兼容判断）</td>
</tr>
<tr>
<td>UNSAFE</td>
<td align="left">Unsafe实例对象，操作堆外内存</td>
</tr>
<tr>
<td>UNSAFE_COPY_THRESHOLD</td>
<td align="left">Java8以及以下版本内存拷贝时的最大阈值，最大为1M（1024L * 1024L）</td>
</tr>
<tr>
<td>UNALIGNED</td>
<td align="left">java.nio.Bits#unaligned方法在当前系统是否可用</td>
</tr>
</tbody></table>
<h3 id="赋值流程"><a href="#赋值流程" class="headerlink" title="赋值流程"></a>赋值流程</h3><p>这部分主要针对当前运行的系统平台是否支持UNSAFE等众多涉及到堆外内存分配的属性是否支持，以及赋值给成员变量，在static静态块中判断。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210131171437.png"></p>
<p><strong>@1 检查平台是否支持Unsafe，不支持将异常错误封装在UNSAFE_UNAVAILABILITY_CAUSE中</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210131102931.png"></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210131103148.png"></p>
<p><strong>@2 如果系统支持Unsafe，检查Unsafe类中是否包含copyMemory方法，不支持禁用Unsaf</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210131103401.png"></p>
<p><strong>@3 检查Buffer类的内存地址address功能，不支持禁用Unsafe</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210131103802.png"></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210131172146.png"></p>
<p><strong>@4 检查Unsafe类中的arrayIndexScale方法是否支持，不支持禁用Unsafe</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210131104315.png"></p>
<p><strong>@5 检查是否支持反射获取DirectBuffer的构造器，方便堆外内存分配</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210131110146.png"></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210131110242.png"></p>
<p><strong>@6 检查系统是否支持java.nio.Bits#unaligned方法</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210131172239.png"></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210131172305.png"></p>
<p><strong>@7 Java9以及以上版本检查jdk.internal.misc.Unsafe以及其方法allocateUninitializedArray，并赋值给INTERNAL_UNSAFE和ALLOCATE_ARRAY_METHOD</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210131111631.png"></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210131172450.png"></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210131111747.png"></p>
<h3 id="重要方法走查"><a href="#重要方法走查" class="headerlink" title="重要方法走查"></a>重要方法走查</h3><p>PlatformDependent0提供的方法，主要判断Unsafe是否可用、Unsafe分配堆外内存、Unsafe从堆外内存获取数据等。下面挑几个走查下。</p>
<p><strong>@1 检查UNSAFE是否可用</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasUnsafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> UNSAFE != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>@2 DirectByteBuffer的构造函数是否可用</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasDirectBufferNoCleanerConstructor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> DIRECT_BUFFER_CONSTRUCTOR != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>@3 堆外内存分配</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  malloc()返回获得内存空间的首地址，失败返回null</span></span><br><span class="line"><span class="comment">*  根据返回的内存地址构造DirectBuffer</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> capacity</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> ByteBuffer <span class="title">allocateDirectNoCleaner</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * malloc()返回获得内存空间的首地址，失败返回null</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">	<span class="keyword">return</span> newDirectBuffer(UNSAFE.allocateMemory(Math.max(<span class="number">1</span>, capacity)), capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>@4 调用DirectByteBuffer构造函数分配堆外内存</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ByteBuffer <span class="title">newDirectBuffer</span><span class="params">(<span class="keyword">long</span> address, <span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        ObjectUtil.checkPositiveOrZero(capacity, <span class="string">&quot;capacity&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (ByteBuffer) DIRECT_BUFFER_CONSTRUCTOR.newInstance(address, capacity);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable cause) &#123;</span><br><span class="line">            <span class="comment">// Not expected to ever throw!</span></span><br><span class="line">            <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> Error) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (Error) cause;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(cause);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>@5 获取堆外内存数据</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">byte</span> <span class="title">getByte</span><span class="params">(<span class="keyword">long</span> address)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> UNSAFE.getByte(address);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="PlatformDependent"><a href="#PlatformDependent" class="headerlink" title="PlatformDependent"></a>PlatformDependent</h1><h3 id="成员变量-1"><a href="#成员变量-1" class="headerlink" title="成员变量"></a>成员变量</h3><table>
<thead>
<tr>
<th>名称</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>MAX_DIRECT_MEMORY_SIZE_ARG_PATTERN</td>
<td>允许最大堆外内存的正则表达式，可以通过MaxDirectMemorySize参数在应用启动时指定</td>
</tr>
<tr>
<td>IS_WINDOWS</td>
<td>判断系统是否为windows系统</td>
</tr>
<tr>
<td>IS_OSX</td>
<td>判断是否为MacOS系统</td>
</tr>
<tr>
<td>IS_J9_JVM</td>
<td>是否为jdk9版本</td>
</tr>
<tr>
<td>IS_IVKVM_DOT_NET</td>
<td>判断是否为IKVM.NET</td>
</tr>
<tr>
<td>MAYBE_SUPER_USER</td>
<td>判断是否为root超级用户</td>
</tr>
<tr>
<td>CAN_ENABLE_TCP_NODELAY_BY_DEFAULT</td>
<td>Linux系统可以开启TCP_NODELAY参数，当开启时数据会以最快的速度发出去同时也就禁用了纳格算法（Nagle algorithm）；如果不设置（开启纳格算法），数据会缓存满足阈值后发出</td>
</tr>
<tr>
<td>UNSAFE_UNAVAILABILITY_CAUSE</td>
<td>平台不支持UNSAFE会将异常封装在UNSAFE_UNAVAILABILITY_CAUSE中</td>
</tr>
<tr>
<td>DIRECT_BUFFER_PREFERRED</td>
<td>默认优先使用堆外内存分配</td>
</tr>
<tr>
<td>MAX_DIRECT_MEMORY</td>
<td>获取最大堆外内存通过sun.misc.VM#maxDirectMemory方法获取</td>
</tr>
<tr>
<td>MPSC_CHUNK_SIZE</td>
<td>使用JCTools提供的无锁队列，初始化队列容量，默认1024</td>
</tr>
<tr>
<td>MIN_MAX_MPSC_CAPACITY</td>
<td>使用JCTools提供的无锁队列，最大队列容量；MIN_MAX_MPSC_CAPACITY =  MPSC_CHUNK_SIZE * 2</td>
</tr>
<tr>
<td>MAX_ALLOWED_MPSC_CAPACITY</td>
<td>使用JCTools提供的无锁队列，允许队列最大容量，默认为1073741824（1 &lt;&lt; 30）；MAX_ALLOWED_MPSC_CAPACITY = Pow2.MAX_POW2</td>
</tr>
<tr>
<td>BYTE_ARRAY_BASE_OFFSET</td>
<td>获取内存中第一个元素的内存偏移量；UNSAFE.arrayBaseOffset</td>
</tr>
<tr>
<td>TMPDIR</td>
<td>Netty临时目录</td>
</tr>
<tr>
<td>BIT_MODE</td>
<td>操作系统是32位还是64位</td>
</tr>
<tr>
<td>NORMALIZED_ARCH</td>
<td>获取操作系统CPU architecture，例如：x86_64</td>
</tr>
<tr>
<td>NORMALIZED_OS</td>
<td>获取操作系统名称，例如：Linux</td>
</tr>
<tr>
<td>ALLOWED_LINUX_OS_CLASSIFIERS</td>
<td>Linux系统演化了众多版本，下面是允许的的Linux版本</td>
</tr>
<tr>
<td>LINUX_OS_CLASSIFIERS</td>
<td>通过系统识别文件将支持的Linux版本填充到该集合中，是ALLOWED_LINUX_OS_CLASSIFIERS子集</td>
</tr>
<tr>
<td>ADDRESS_SIZE</td>
<td>返回系统指针的大小，32位系统返回4；64位系统返回8</td>
</tr>
<tr>
<td>USE_DIRECT_BUFFER_NO_CLEANER</td>
<td>堆外内存是否能分配（系统是否支持unsafe、DirectByteBuffer是否可用）</td>
</tr>
<tr>
<td>DIRECT_MEMORY_COUNTER</td>
<td>堆外内存使用限制</td>
</tr>
<tr>
<td>ThreadLocalRandomProvider</td>
<td>随机数字生成器</td>
</tr>
<tr>
<td>CLEANER</td>
<td>可以用于堆外内存回收</td>
</tr>
<tr>
<td>UNINITIALIZED_ARRAY_ALLOCATION_THRESHOLD</td>
<td>堆外内存分配阈值，默认为1024（字节）；小于该阈值分配堆内存，大于分配堆外内存；可以通过-Dio.netty.uninitializedArrayAllocationThreshold指定</td>
</tr>
<tr>
<td>OS_RELEASE_FILES</td>
<td>包含了操作系统识别数据 /etc/os-release与/usr/lib/os-release；String[] OS_RELEASE_FILES = {“/etc/os-release”, “/usr/lib/os-release”}</td>
</tr>
<tr>
<td>BIG_ENDIAN_NATIVE_ORDER</td>
<td>是否为大端排序（默认大端排序）；boolean BIG_ENDIAN_NATIVE_ORDER = ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN</td>
</tr>
</tbody></table>
<h3 id="重要方法走查-1"><a href="#重要方法走查-1" class="headerlink" title="重要方法走查"></a>重要方法走查</h3><p>挑几个比较重要的方法走查下，</p>
<p><strong>@1 内存分配</strong></p>
<p>小于阈值默认1024（字节），使用堆内存；大于阈值使用堆外内存</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] allocateUninitializedArray(<span class="keyword">int</span> size) &#123;</span><br><span class="line">        <span class="keyword">return</span> UNINITIALIZED_ARRAY_ALLOCATION_THRESHOLD &lt; <span class="number">0</span> || UNINITIALIZED_ARRAY_ALLOCATION_THRESHOLD &gt; size ?</span><br><span class="line">                <span class="keyword">new</span> <span class="keyword">byte</span>[size] : PlatformDependent0.allocateUninitializedArray(size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>@2释放堆外内存</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">freeDirectBuffer</span><span class="params">(ByteBuffer buffer)</span> </span>&#123;</span><br><span class="line">        CLEANER.freeDirectBuffer(buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>@3 构造Queue</strong></p>
<p>使用了使用JCTools提供的无锁队列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Queue&lt;T&gt; <span class="title">newMpscQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Mpsc.newMpscQueue();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function">Queue&lt;T&gt; <span class="title">newMpscQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> USE_MPSC_CHUNKED_ARRAY_QUEUE ? <span class="keyword">new</span> MpscUnboundedArrayQueue&lt;T&gt;(MPSC_CHUNK_SIZE)</span><br><span class="line">    : <span class="keyword">new</span> MpscUnboundedAtomicArrayQueue&lt;T&gt;(MPSC_CHUNK_SIZE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>其他的方法基本在判断成员变量或者调用PlatformDependent0的方法分配堆外内存、获取堆外内存数据、释放堆外内存等。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>PlatformDependent与PlatformDependent0主要针对操作系统、JDK版本等环境因素是否支持堆外内存Unsafe以及一些关联类进行判断；通过封装Unsafe申请堆外内存、释放、获取数据等操作。另外Netty为了提高性能使用了JCTools提供的无锁队列、可以通过-XX:MaxDirectMemorySize参数调整Netty允许使用的最大堆外内存，超过最大限制将使堆外内存分配失败，抛出 “failed to allocate byte(s) of direct memory” 异常。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty11# 非池化内存分配</title>
    <url>/posts/f74d0239/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>非池化内存的分配由UnpooledByteBufAllocator负责，本文梳理下由其负责分配的堆内存和堆外内存如何实现的 。</p>
<p>Netty在非池化堆内存分配上Java9与Java8以下版本有啥不同呢？Netty堆外内存回收默认机制使用JDK提供的Cleaner吗？</p>
<a id="more"></a>



<h1 id="非池化堆内内存分配"><a href="#非池化堆内内存分配" class="headerlink" title="非池化堆内内存分配"></a>非池化堆内内存分配</h1><p>下面这小段代码摘自UnpooledByteBufAllocator#newHeapBuffer，通过此方法分析非池化堆内存的分配。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ByteBuf <span class="title">newHeapBuffer</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> PlatformDependent.hasUnsafe() ?</span><br><span class="line">  <span class="keyword">new</span> InstrumentedUnpooledUnsafeHeapByteBuf(<span class="keyword">this</span>, initialCapacity, maxCapacity) :</span><br><span class="line">  <span class="keyword">new</span> InstrumentedUnpooledHeapByteBuf(<span class="keyword">this</span>, initialCapacity, maxCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>解读：</strong> 堆内内存分配由newHeapBuffer方法负责，如果平台支持Unsafe则创建InstrumentedUnpooledUnsafeHeapByteBuf，否则创建</p>
<p>InstrumentedUnpooledHeapByteBuf，下图为非池化相关类图，分别从两个类UnpooledDirectByteBuf和UnpooledHeapByteBuf延伸开来。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/%E9%9D%9E%E6%B1%A0%E5%8C%96%E7%B1%BB%E5%9B%BE.png"></p>
<p>还是聚集到堆内存的分配上来，主要分析上图中红色部分。InstrumentedUnpooledUnsafeHeapByteBuf和InstrumentedUnpooledHeapByteBuf有啥区别？</p>
<h3 id="InstrumentedUnpooledUnsafeHeapByteBuf"><a href="#InstrumentedUnpooledUnsafeHeapByteBuf" class="headerlink" title="InstrumentedUnpooledUnsafeHeapByteBuf"></a>InstrumentedUnpooledUnsafeHeapByteBuf</h3><p>下面看下InstrumentedUnpooledUnsafeHeapByteBuf其内存分配的行为allocateArray().</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210206144813.png"></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210206144919.png"></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210206145307.png"></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210206180549.png"></p>
<p><strong>注解@1</strong> 调用了父类UnpooledUnsafeHeapByteBuf的allocateArray()</p>
<p><strong>注解@2</strong> 父类UnpooledUnsafeHeapByteBuf调用了PlatformDependent#allocateUninitializedArray</p>
<p><strong>注解@3/@4</strong>  Java9以上版本：如果待分配的内存小于1K使用堆内存，待分配的内存大于等于1K使用堆外内存。</p>
<p>Java8以及以下版本全部在堆内存分配</p>
<p><u><strong>小结：</strong>  使用InstrumentedUnpooledUnsafeHeapByteBuf进行内存分配时：</u></p>
<p><u>Java9以及以上版本：如果待分配的内存小于1K使用堆内存；待分配的内存大于等于1K使用堆外内存（调用底层PlatformDependent#allocateUninitializedArray）。</u></p>
<p><u>Java8以及以下版本：使用堆内存分配。</u></p>
<h3 id="InstrumentedUnpooledHeapByteBuf"><a href="#InstrumentedUnpooledHeapByteBuf" class="headerlink" title="InstrumentedUnpooledHeapByteBuf"></a>InstrumentedUnpooledHeapByteBuf</h3><p>下面为InstrumentedUnpooledHeapByteBuf的内存分配allocateArray().</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210206150611.png"></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210206150640.png"></p>
<p><strong>注解@1</strong> 调用父类 UnpooledHeapByteBuf的内存分配</p>
<p><strong>注解@2</strong> UnpooledHeapByteBuf的通过new byte直接在堆内存分配</p>
<p><u><strong>小结：</strong> InstrumentedUnpooledHeapByteBuf直接在堆内存分配空间。</u></p>
<h3 id="数据获取方式"><a href="#数据获取方式" class="headerlink" title="数据获取方式"></a>数据获取方式</h3><p><strong>UnpooledUnsafeHeapByteBuf数据获取</strong> </p>
<p>UnpooledUnsafeHeapByteBuf的数据获取方式getByte()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">byte</span> <span class="title">_getByte</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> UnsafeByteBufUtil.getByte(array, index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法调用UnsafeByteBufUtil的getByte，跟进去看下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">byte</span> <span class="title">getByte</span><span class="params">(<span class="keyword">byte</span>[] array, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> PlatformDependent.getByte(array, index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>底层通过UNSAFE.getByte这种地址+偏移量的方式获取内存中的数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">byte</span> <span class="title">getByte</span><span class="params">(<span class="keyword">byte</span>[] data, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> UNSAFE.getByte(data, BYTE_ARRAY_BASE_OFFSET + index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>UnpooledHeapByteBuf数据获取</strong> </p>
<p>UnpooledHeapByteBuf数据获取方式_getByte()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">byte</span> <span class="title">_getByte</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> HeapByteBufUtil.getByte(array, index);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>该方法调用HeapByteBufUtil.getByte，跟进去看下，即直接从数组中获取数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">byte</span> <span class="title">getByte</span><span class="params">(<span class="keyword">byte</span>[] memory, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> memory[index];</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<p><u><strong>小结：</strong> UnpooledUnsafeHeapByteBuf通过UNSAFE.getByte这种地址+偏移量的方式获取内存中的数据；UnpooledHeapByteBuf通过数组直接从堆内存获取。</u></p>
<h3 id="非池化堆内存分配总结"><a href="#非池化堆内存分配总结" class="headerlink" title="非池化堆内存分配总结"></a>非池化堆内存分配总结</h3><p><u>当使用Netty非池化进行堆内存分配时：</u></p>
<p><u>1.Java8及其以下版本：直接在堆空间分配内存。</u></p>
<p><u>2.Java9及其以上版本：如果系统支持Unsafe时（通常都是支持的），对于小于1K（默认）的在堆内存分配，大于1K的分配堆外内存；如果系统不支持Unsafe直接在堆内存分配；默认大小阈值可以通过-Dio.netty.uninitializedArrayAllocationThreshold来指定，默认为1024字节。</u></p>
<p><u>3.堆内存数据获取通过数组实现；堆外内存获取通过UNSAFE.getByte这种地址+偏移量的方式获取。</u></p>
<h1 id="非池化堆外内存分配"><a href="#非池化堆外内存分配" class="headerlink" title="非池化堆外内存分配"></a>非池化堆外内存分配</h1><p>下面这段代码摘自UnpooledByteBufAllocator#newDirectBuffer方法，通过此方法分析非池化堆外存的分配。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ByteBuf <span class="title">newDirectBuffer</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> ByteBuf buf;</span><br><span class="line">  <span class="keyword">if</span> (PlatformDependent.hasUnsafe()) &#123;</span><br><span class="line">  	buf = noCleaner ? <span class="keyword">new</span> InstrumentedUnpooledUnsafeNoCleanerDirectByteBuf(<span class="keyword">this</span>, initialCapacity, maxCapacity) :</span><br><span class="line">  	<span class="keyword">new</span> InstrumentedUnpooledUnsafeDirectByteBuf(<span class="keyword">this</span>, initialCapacity, maxCapacity);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  	buf = <span class="keyword">new</span> InstrumentedUnpooledDirectByteBuf(<span class="keyword">this</span>, initialCapacity, maxCapacity);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> disableLeakDetector ? buf : toLeakAwareBuffer(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解读：</strong> 平台不支持支持Unsafe，构造InstrumentedUnpooledDirectByteBuf；平台支持Unsafe并且noCleaner=true构造InstrumentedUnpooledUnsafeNoCleanerDirectByteBuf；平台支持Unsafe并且noCleaner=false，构造InstrumentedUnpooledUnsafeDirectByteBuf。那问题来了，这三个有啥区别呢？</p>
<h3 id="noCleaner"><a href="#noCleaner" class="headerlink" title="noCleaner"></a>noCleaner</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">noCleaner = tryNoCleaner &amp;&amp; PlatformDependent.hasUnsafe()</span><br><span class="line">               &amp;&amp; PlatformDependent.hasDirectBufferNoCleanerConstructor();</span><br></pre></td></tr></table></figure>

<p><strong>解读</strong> ：三个判断条件一个一个来看：</p>
<p>@1 tryNoCleaner=PlatformDependent.useDirectBufferNoCleaner()该方法在前一篇文章中也分析过，当maxDirectMemory!=0 &amp;&amp; 支持Unsafe &amp;&amp; DirectByteBuffer的构造函数可用时，tryNoCleaner = true。</p>
<p>@2 PlatformDependent.hasUnsafe() 在上一篇文章中分析过具体 UNSAFE_UNAVAILABILITY_CAUSE == null，平台不支持UNSAFE会将异常封装在UNSAFE_UNAVAILABILITY_CAUSE中，等于null意味着平台支持Unsafe。</p>
<p>@3 PlatformDependent.hasDirectBufferNoCleanerConstructor() 指的是通过反射DirectByteBuffer构造器对象是否可用。</p>
<p>所以看出，通常在实践中（Linux、JDK8）上面这些条件都是支持的，也就是Netty默认noCleaner为true。</p>
<h3 id="InstrumentedUnpooledUnsafeNoCleanerDirectByteBuf"><a href="#InstrumentedUnpooledUnsafeNoCleanerDirectByteBuf" class="headerlink" title="InstrumentedUnpooledUnsafeNoCleanerDirectByteBuf"></a>InstrumentedUnpooledUnsafeNoCleanerDirectByteBuf</h3><p>下面看下堆外内存的分配和回收：</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210208102959.png"></p>
<p><strong>注解@1</strong>  堆外内存分配底层调用了PlatformDependent0#allocateDirectNoCleaner方法，malloc()返回获得内存空间的首地址，失败返回null，然后根据返回的内存地址调用DirectByteBuffer构造函数分配堆外内存。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ByteBuffer <span class="title">allocateDirectNoCleaner</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Calling malloc with capacity of 0 may return a null ptr or a memory address that can be used.</span></span><br><span class="line">  <span class="comment">// Just use 1 to make it safe to use in all cases:</span></span><br><span class="line">  <span class="comment">// See: http://pubs.opengroup.org/onlinepubs/009695399/functions/malloc.html</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * malloc()返回获得内存空间的首地址，失败返回null</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">	<span class="keyword">return</span> newDirectBuffer(UNSAFE.allocateMemory(Math.max(<span class="number">1</span>, capacity)), capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@2</strong> 堆外内存释放底层调用了PlatformDependent0#freeMemory方法，通过UNSAFE.freeMemory释放堆外内存。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">freeMemory</span><span class="params">(<span class="keyword">long</span> address)</span> </span>&#123;</span><br><span class="line">    UNSAFE.freeMemory(address);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="InstrumentedUnpooledUnsafeDirectByteBuf"><a href="#InstrumentedUnpooledUnsafeDirectByteBuf" class="headerlink" title="InstrumentedUnpooledUnsafeDirectByteBuf"></a>InstrumentedUnpooledUnsafeDirectByteBuf</h3><p>下面看下堆外内存的分配与回收</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210209094247.png"></p>
<p><strong>注解@1</strong> 底层调用ByteBuffer#allocateDirect来分配堆外内存，具体为直接new DirectByteBuffer()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">allocateDirect</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DirectByteBuffer(capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@2</strong> 释放堆外内存调用了PlatformDependent#freeDirectBuffer()底层调用CLEANER.freeDirectBuffer实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">freeDirectBuffer</span><span class="params">(ByteBuffer buffer)</span> </span>&#123;</span><br><span class="line">   CLEANER.freeDirectBuffer(buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="nstrumentedUnpooledDirectByteBuf"><a href="#nstrumentedUnpooledDirectByteBuf" class="headerlink" title="nstrumentedUnpooledDirectByteBuf"></a>nstrumentedUnpooledDirectByteBuf</h3><p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210210074748.png"></p>
<p><strong>注解@1</strong> 堆外内存分配同InstrumentedUnpooledUnsafeDirectByteBuf，通过父类UnpooledDirectByteBuf#allocateDirect调用ByteBuffer#allocateDirect来分配堆外内存，堆内存直接new DirectByteBuffer</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">allocateDirect</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DirectByteBuffer(capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>注解@2</strong> 堆外内存释放同InstrumentedUnpooledUnsafeDirectByteBuf，通过父类UnpooledDirectByteBuf#freeDirect调用底层调用CLEANER.freeDirectBuffer实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">freeDirectBuffer</span><span class="params">(ByteBuffer buffer)</span> </span>&#123;</span><br><span class="line">    CLEANER.freeDirectBuffer(buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>小结：</strong> @1 InstrumentedUnpooledUnsafeNoCleanerDirectByteBuf的内存释放调用UNSAFE.freeMemory(address)实现</p>
<p>​             @2 InstrumentedUnpooledUnsafeDirectByteBuf和nstrumentedUnpooledDirectByteBuf的内存释放是一样的，使用了JDK提供的CLEANER.freeDirectBuffer(buffer)。</p>
<p>​            @3 Netty默认自行管理堆外内存的分配与释放，并未使用JDK提供的释放方式，而是通过底层API自行释放。</p>
<h3 id="堆外内存数据获取"><a href="#堆外内存数据获取" class="headerlink" title="堆外内存数据获取"></a>堆外内存数据获取</h3><p>下面是三个buffer获取内存数据的方式：</p>
<p>InstrumentedUnpooledUnsafeNoCleanerDirectByteBuf通过UnpooledUnsafeDirectByteBuf#_getByte()获取数据</p>
<p>InstrumentedUnpooledUnsafeDirectByteBuf通过UnpooledUnsafeDirectByteBuf#_getByte()获取数据</p>
<p>nstrumentedUnpooledDirectByteBuf通过UnpooledDirectByteBuf#_getByte()获取数据</p>
<p>InstrumentedUnpooledUnsafeNoCleanerDirectByteBuf和InstrumentedUnpooledUnsafeDirectByteBuf获取方式一样；下面看下这两类获取方式。</p>
<p><strong>UnpooledUnsafeDirectByteBuf获取内存数据</strong> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">byte</span> <span class="title">_getByte</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> UnsafeByteBufUtil.getByte(addr(index)); <span class="comment">// 注解@1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@1</strong> 底层通过UNSAFE.getByte(address)这种“地址+偏移量” 的方式获取内存数据。</p>
<p><strong>UnpooledDirectByteBuf获取内存数据</strong> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">byte</span> <span class="title">_getByte</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> buffer.get(index); <span class="comment">// 注解@2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@2</strong> 通过ByteBuffer#get方式获取，底层通过Bits#unsafe.getByte(address)获取内存数据。</p>
<h3 id="非池化堆外内存总结"><a href="#非池化堆外内存总结" class="headerlink" title="非池化堆外内存总结"></a>非池化堆外内存总结</h3><p>Netty在堆外内存分配上，在系统支持的情况下，默认自己通过UNSAFE.freeMemory去释放内存，也就是noCleaner，没有使用JDK提供的Cleaner释放机制。至于为啥netty选择自己实现，不用JDK提供的方式，主要考虑性能原因，与JDK Bits设计有关系。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty2# Netty组件之Channel初始化</title>
    <url>/posts/7d3cb711/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>继上文分析Channel实例化流程后，本文通过分析Channel的初始化流程。旨在从整体上厘清DefaultChannelPipeline、ChannelHandlerContext、ChannelHandler的逻辑关系。</p>
<a id="more"></a>



<h1 id="一、DefaultChannelPipeline实例化"><a href="#一、DefaultChannelPipeline实例化" class="headerlink" title="一、DefaultChannelPipeline实例化"></a>一、DefaultChannelPipeline实例化</h1><p>DefaultChannelPipeline随着Channel的创建而创建，即只要创建了Channel就会同时创建与其对应的ChannelPipeline。下面代码是Channel实例化时调用，上篇文章文末的代码。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202184535.png"></p>
<p><strong>ChannelHandlerContext类图结构</strong> </p>
<p>ChannelHandlerContext直观从命名上看出为ChannelHandler上下文，每次构造DefaultChannelHandlerContext都会传入与之对应的ChannelHandler.</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202184642.png"></p>
<p><strong>ChannelHandlerContext类图结构</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202184711.png"></p>
<p><strong>ChannelPipeline类图结构</strong></p>
<p>从下面类图结构可以看出，ChannelPipeline提供了很多操作链表的方法，addFirst/addLast/addBefore/addLast/remove/replace等，入参为ChannelHandler。ChannelPipeline的各种fire操作均通过HandlerContext进行处理。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202184932.png"></p>
<p><strong>链表关系图示</strong></p>
<p>先从下面代码看下运营时的链表结构，截图如下。</p>
<p><strong>示例代码</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202185015.png"></p>
<p><strong>内存结构</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/1612263172761.jpg"></p>
<p>画个示意图来说明ChannelPipeline、ChannelHandlerContext、ChannelHandler的关系。</p>
<p><strong>关系图示</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202185341.png"></p>
<h1 id="二、Channel初始化"><a href="#二、Channel初始化" class="headerlink" title="二、Channel初始化"></a>二、Channel初始化</h1><p>切换到Channel初始化过程，在客户端引导类Bootstrap调用b.connect()或者服务端引导类ServerBootstrap调用bind()时，会调用到抽象引导类AbstractBootstrap的initAndRegister()。下面红色部分即channel初始化入口。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202185411.png"></p>
<p><strong>客户端初始化</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202185431.png"></p>
<p>@1 客户端初始化代码中，将ChannelHandler通过DefaultChannelHandlerContext加入ChannelPipeline链表中</p>
<p>@2 setChannelOptions以NioChannelOption为例，客户端最后调用到SocketChannelImpl#setOption(); 可以对以下属性进行设置。</p>
<p>* StandardSocketOptions.SO_RCVBUF // 接受缓存区大小</p>
<p>* StandardSocketOptions.SO_SNDBUF // 发送缓存区大小</p>
<p>* StandardSocketOptions.SO_LINGER // 设置延迟关闭的时间</p>
<p>* StandardSocketOptions.IP_TOS // 设置数据包优先级</p>
<p>* StandardSocketOptions.IP_MULTICAST_TTL // 设置多播组数据的TTL值</p>
<p>* …</p>
<p><strong>服务端初始化</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202185459.png"></p>
<p>@1 setChannelOptions同样以NioChannelOption为例，服务端会调用到ServerSocketChannelImpl#setOption()，参数含义见客户端端初始化@1</p>
<p>@2 ChannelInitializer实现了ChannelHandler加入到了ChannelPipeline的链表中，其中的逻辑在另文分析EventLoopGroup时梳理。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty3# Netty组件之Channel注册</title>
    <url>/posts/d7c49a97/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文将分析EventLoopGroup初始化、EventLoop的选择策略以及Channel是如何通过EventLoop注册到Selector上的。</p>
<a id="more"></a>



<h1 id="一、EventLoopGroup类图概览"><a href="#一、EventLoopGroup类图概览" class="headerlink" title="一、EventLoopGroup类图概览"></a>一、EventLoopGroup类图概览</h1><p>在客户端示例代码中的中实例化了NioEventLoopGroup，接下来分析下该实例化过程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">Bootstrap b = <span class="keyword">new</span> Bootstrap();</span><br><span class="line"></span><br><span class="line">b.group(workerGroup);</span><br></pre></td></tr></table></figure>



<p>从以下类图结构io.netty.util.concurrent.AbstractEventExecutorGroup分支主要负责多线程任务的处理；io.netty.channel.EventLoopGroup分支主要负责Channel相关的注册。MultithreadEventExecutorGroup与MultithreadEventLoopGroup分别继承和实现了上面AbstractEventExecutorGroup和EventLoopGroup，将其负责的功能进行融合。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202180638.png"></p>
<h1 id="二、构造函数解读"><a href="#二、构造函数解读" class="headerlink" title="二、构造函数解读"></a>二、构造函数解读</h1><p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202180703.png"></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202180713.png"></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202180724.png"></p>
<p><strong>构造函数</strong></p>
<p>nThreads：eventLoopThreads线程数量，默认值0时取CPU核数的2倍，可以通过参数io.netty.eventLoopThreads指定</p>
<p>Executor：默认ThreadPerTaskExecutor</p>
<p>SelectorProvider默认SelectorProvider.provider()，用于开启Selector和Channel</p>
<p>SelectStrategyFactory：SelectStrategy工厂类，默认DefaultSelectStrategyFactory</p>
<p>EventExecutorChooserFactory：EventExecutor选择器，默认为DefaultEventExecutorChooserFactory</p>
<h1 id="三、初始化EventExecutor数组"><a href="#三、初始化EventExecutor数组" class="headerlink" title="三、初始化EventExecutor数组"></a>三、初始化EventExecutor数组</h1><p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202180746.png"></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202180802.png"></p>
<p><strong>代码解读</strong></p>
<p>EventExecutor[] children：数组大小为nThreads，默认为CPU核数乘以2。</p>
<p>EventExecutor继承了EventExecutorGroup本质上为线程框架类Executor</p>
<p>children[i]：数据元素为EventLoop，本示例中为NioEventLoop。</p>
<p><strong>NioEventLoop类图</strong></p>
<p>NioEventLoop继承了SingleThreadEventLoop，SingleThreadEventLoop同时继承和实现了EventExecutor和EventLoop。即：NioEventLoop拥有了线程类框架处理多线程任务的能力和处理Channel能力。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202180841.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">备注：本文中EventExecutor数组children的元素为NioEventLoop，NioEventLoop同时拥有线程框架能力和Channel注册等处理能力。</span><br></pre></td></tr></table></figure>



<h1 id="四、EventExecutor选择器"><a href="#四、EventExecutor选择器" class="headerlink" title="四、EventExecutor选择器"></a>四、EventExecutor选择器</h1><p>第三部分对EventExecutor[] children进行初始化分析，然在使用时如何选择其中一个元素呢？</p>
<p>在初始化过程中有以下一行代码，用于初始化EventExecutorChooser。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">chooser = chooserFactory.newChooser(children);</span><br></pre></td></tr></table></figure>



<p><strong>EventExecutorChooser类图结构</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202180923.png"></p>
<p><strong>选择策略</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202180943.png"></p>
<p>@1 如果数组长度是2的幂次方，选择PowerOfTwoEventExecutorChooser，在选取EventExecutor时使用executors[idx.getAndIncrement() &amp; executors.length - 1]</p>
<p>@2 如果数组长度不是2的幂次方，选择GenericEventExecutorChooser，executors[Math.abs(idx.getAndIncrement() % executors.length)]。</p>
<h1 id="五、Channel注册"><a href="#五、Channel注册" class="headerlink" title="五、Channel注册"></a>五、Channel注册</h1><p><strong>Channel注册入口</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202181021.png"></p>
<p><strong>选择EventLoop</strong></p>
<p>本文为NioEventLoop</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202181034.png"></p>
<p><strong>绑定Channel到EventExecutor</strong></p>
<p>通过DefaultChannelPromise绑定Channel到EventExecutor（NioEventLoop）。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202181106.png"></p>
<p><strong>将Channel注册到Selector</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202181120.png"></p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty4# Netty之异步通知机制</title>
    <url>/posts/9fda0b0b/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前面的文章分析了Channel实例化、初始化、注册机制，本文分析下异步结果的通知，也就是回调，同时梳理下Future、Promise、ChannelFuture、ChannelPromise的关系。</p>
<a id="more"></a>



<h1 id="一、异步通知代码走查"><a href="#一、异步通知代码走查" class="headerlink" title="一、异步通知代码走查"></a>一、异步通知代码走查</h1><p>在Channel注册到Selector后，会返回ChannelFuture。如果注册未完成，会通过增加Listener来进行异步通知注册结果，接下来看下是如何回调的。</p>
<p><strong>代码块</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202175023.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">备注：上面代码块中在注册完Channel后返回ChannelFuture，在ChannelFuture注册了ChannelFutureListener，通过异步通知的方式获取注册结果。</span><br></pre></td></tr></table></figure>

<p><strong>代码块</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202175039.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">备注：构建DefaultChannelPromise绑定了EventLoop和Channel，上面注册的ChannelFutureListener实际注册到了DefaultChannelPromise。</span><br></pre></td></tr></table></figure>

<p><strong>代码块</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202175059.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">备注：通过ChannelPromise标记Channel注册成功。</span><br></pre></td></tr></table></figure>

<p><strong>代码块</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202175115.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">备注：在DefaultPromise中通过cas设置Channel注册结果，并回调加在其身上的Listener。</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202175138.png"></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202175150.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">备注：将注册的所有Listener，通过回调GenericFutureListener的operationComplete方法，完成结果的通知。</span><br></pre></td></tr></table></figure>



<h1 id="二、异步通知流程图"><a href="#二、异步通知流程图" class="headerlink" title="二、异步通知流程图"></a>二、异步通知流程图</h1><p>下面以channel注册为例，勾勒异步回调流程图。Future/Promise作为结果载体与执行Listener的执行主体。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202175347.png"></p>
<h1 id="三、Future-Promise关系图谱"><a href="#三、Future-Promise关系图谱" class="headerlink" title="三、Future/Promise关系图谱"></a>三、Future/Promise关系图谱</h1><p>以下类图中展现了Future/Promise的类图结构，Netty中Future继承Java中的Future并<code>增加了基于Listener的异步通知机制</code>。</p>
<p>Promise允许在标志某个操作结果后再回调Listener（比如：在注册成功后调用Promise#trySuccess将成功结果在Promise中标记，并回调Listener）。</p>
<p>ChannelFuture与特定的Channel绑定，ChannelPromise继承ChannelFuture与Promise即拥有绑定特定Channel与标记操作结果回调Listener的能力。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202175418.png"></p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty5# Netty之客户端连接调用</title>
    <url>/posts/5e7437e/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文主要梳理Netty客户端如何发起连接请求的以及最终通过SocketChannel与服务端建立连接，顺便分析了在此过程中涉及到的地址解析过程。</p>
<a id="more"></a>



<h1 id="一、获取地址解析器"><a href="#一、获取地址解析器" class="headerlink" title="一、获取地址解析器"></a>一、获取地址解析器</h1><p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202173713.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">备注：在Netty客户端发起连接前，先获取了AddressResolver，并进行了解析判断。</span><br></pre></td></tr></table></figure>



<p><strong>获取AddressResolver过程</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202173747.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">备注： 创建AddressResolver并将其放到缓存Map中，key为executor。</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202173813.png"></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202173826.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">备注：默认使用DefaultAddressResolverGroup中的DefaultNameResolver构建InetSocketAddressResolver。</span><br><span class="line">小结：从上面获取地址解析过程中，AddressResolverGroup拥有一组AddressResolver存储于Map中，key为EventExecutor，而AddressResolver是通过NameResolver构建的。</span><br></pre></td></tr></table></figure>







<h1 id="二、地址解析器图谱"><a href="#二、地址解析器图谱" class="headerlink" title="二、地址解析器图谱"></a>二、地址解析器图谱</h1><p><strong>AddressResolverGroup类图</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202173916.png"></p>
<p><strong>AddressResolver类图</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202173950.png"></p>
<p><strong>NameResolver类图</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202174015.png"></p>
<p><strong>关系图示</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202174037.png"></p>
<h1 id="三、地址解析过程"><a href="#三、地址解析过程" class="headerlink" title="三、地址解析过程"></a>三、地址解析过程</h1><p>地址解析通过下面的方法来实现。分别看下isSupported、isResolved、doResolve的逻辑。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202174104.png"></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202174118.png"></p>
<p>@1 isSupported主要判断传入socket地址是否属于InetSocketAddress，通过JDK中isInstance来实现。</p>
<p>@2 doIsResolved判断包含了isSupported和非空判断，入参非空并且属于InetSocketAddress则标记解析成功</p>
<p>@3 doResolve 根据host name解析成InetSocketAddress，通过InetAddress.getByName(hostname)实现。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：地址解析主要得到SocketAddress是合法有效的，如果为host name默认为通过InetAddress.getByName转换为InetAddress。</span><br></pre></td></tr></table></figure>



<h1 id="四、建立连接"><a href="#四、建立连接" class="headerlink" title="四、建立连接"></a>四、建立连接</h1><p>在地址解析成功后，该建立连接了，接下来看下netty是如何发起的。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202174150.png"></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202174201.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">备注：接着调用AbstractChannel的connect方法，即：DefaultChannelPipeline#connect。</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202174244.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">备注：从链表的最后一个tail发起连接。</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202174256.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">备注：从之前文章分析中，我们知道链表构成。会调用到AbstractChannelHandlerContext#connect方法。通过方法findContextOutbound查找链表中负责出站的HandlerContext调用其connect方法，结束后向下一个出站HandlerContext传递调用。</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202174326.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">备注：出站HandlerContext查找过程。</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202174340.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">备注：上图为运行时DefaultChannelPipeline链表中的Handler结构。尾部为TailContext，头部为HeadContext。</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202174416.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">备注：继续上面的连接传递，最后会调用HeaderContext的connect方法。通过unsafe.connect向服务端发起连接调用。</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202174434.png"></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210202174446.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">备注：调用NioSocketChannel#doConnect方法，最后通过Java NIO的SocketChannel#connect发起连接请求。</span><br></pre></td></tr></table></figure>





















</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty6# Netty之事件轮询与处理</title>
    <url>/posts/a3306fb0/</url>
    <content><![CDATA[<div id="vip-container"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在前面的文章第三篇《Netty组件之Channel注册》分析了channel是如何注册到Selector上的。第五篇《Netty之客户端连接调用》，分析了建立连接的过程。本文将梳理如下内容：</p>
<p>1.就绪事件如何轮询的？bossGroup和workGroup都轮询什么感兴趣的事件</p>
<p>2.bossGroup的职责是什么？又是如何将客户端新建连接Channel传递到workGroup的？</p>
<p>3.workGroup的职责是什么？如何回调到我们自己加入的childHandler中的？</p>
<a id="more"></a>





<h2 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h2><h4 id="1-示例代码"><a href="#1-示例代码" class="headerlink" title="1.示例代码"></a>1.示例代码</h4><p>本文将以这段示例为入口进行分析，示例中设置了bossGroup、workerGroup以及childHandler为HttpUploadServerInitializer。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">b.group(bossGroup, workerGroup);</span><br><span class="line">b.channel(NioServerSocketChannel.class);</span><br><span class="line">b.handler(<span class="keyword">new</span> LoggingHandler(LogLevel.INFO));</span><br><span class="line">b.childHandler(<span class="keyword">new</span> HttpUploadServerInitializer(sslCtx));</span><br><span class="line"></span><br><span class="line">Channel ch = b.bind(PORT).sync().channel();</span><br></pre></td></tr></table></figure>



<h4 id="2-原理文章"><a href="#2-原理文章" class="headerlink" title="2.原理文章"></a>2.原理文章</h4><p>在阅读本文前，可以先阅读下之前的两篇文章。<a href="https://mp.weixin.qq.com/s/A4x5xCqHOV4HXdU3R4frnw">系统五种I/O模型</a> 和 <a href="https://mp.weixin.qq.com/s/WZB4ChAsail2dPD8zuCutA">Reactor线程模型</a>。</p>
<h2 id="二、就绪事件轮询"><a href="#二、就绪事件轮询" class="headerlink" title="二、就绪事件轮询"></a>二、就绪事件轮询</h2><p>接着第三篇《Netty组件之Channel注册》channel注册到Selector，返回selectionKey。其中包含isReadable、isWritable、isConnectable、isAcceptable等通道的就绪状态。一起看下Netty是如何轮询这些就绪事件的。</p>
<h4 id="1-注册selectionKey集合"><a href="#1-注册selectionKey集合" class="headerlink" title="1.注册selectionKey集合"></a>1.注册selectionKey集合</h4><p>将Channel注册到Selector时再往后看下implRegister()方法以及实现AbstractPollSelectorImpl。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected abstract void implRegister(SelectionKeyImpl ski)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">implRegister</span><span class="params">(SelectionKeyImpl ski)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (closeLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (closed)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClosedSelectorException();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check to see if the array is large enough</span></span><br><span class="line">        <span class="keyword">if</span> (channelArray.length == totalChannels) &#123;</span><br><span class="line">            <span class="comment">// Make a larger array</span></span><br><span class="line">            <span class="keyword">int</span> newSize = pollWrapper.totalChannels * <span class="number">2</span>;</span><br><span class="line">            SelectionKeyImpl temp[] = <span class="keyword">new</span> SelectionKeyImpl[newSize];</span><br><span class="line">            <span class="comment">// Copy over</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=channelOffset; i&lt;totalChannels; i++)</span><br><span class="line">                temp[i] = channelArray[i];</span><br><span class="line">            channelArray = temp;</span><br><span class="line">            <span class="comment">// Grow the NativeObject poll array</span></span><br><span class="line">            pollWrapper.grow(newSize);</span><br><span class="line">        &#125;</span><br><span class="line">        channelArray[totalChannels] = ski;</span><br><span class="line">        ski.setIndex(totalChannels);</span><br><span class="line">        pollWrapper.addEntry(ski.channel);</span><br><span class="line">        totalChannels++;</span><br><span class="line">        keys.add(ski); <span class="comment">// 注解@1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">SelectorImpl</span><span class="params">(SelectorProvider sp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(sp);</span><br><span class="line">    keys = <span class="keyword">new</span> HashSet&lt;SelectionKey&gt;();</span><br><span class="line">    selectedKeys = <span class="keyword">new</span> HashSet&lt;SelectionKey&gt;();</span><br><span class="line">    <span class="keyword">if</span> (Util.atBugLevel(<span class="string">&quot;1.4&quot;</span>)) &#123;</span><br><span class="line">        publicKeys = keys;</span><br><span class="line">        publicSelectedKeys = selectedKeys;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        publicKeys = Collections.unmodifiableSet(keys); <span class="comment">// 注解@2</span></span><br><span class="line">        publicSelectedKeys = Util.ungrowableSet(selectedKeys); <span class="comment">// 注解@3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注解@1：将注册channel返回的selectionKey放入到了HashSet<SelectionKey> keys中。</p>
<p>注解@2：Set<SelectionKey> publicKeys 也就是selectionKey的集合。</p>
<p>小结：SelectorImpl类中有这么一个结合publicKeys存储了selectionKey，而就绪事件的轮询需要依靠轮询selectionKey。</p>
<h4 id="2-就绪selectionKey集合"><a href="#2-就绪selectionKey集合" class="headerlink" title="2.就绪selectionKey集合"></a>2.就绪selectionKey集合</h4><p>当执行select()方法时，以AbstractPollSelectorImpl为例，会执行到updateSelectedKeys()方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Copy the information in the pollfd structs into the opss</span></span><br><span class="line"><span class="comment"> * of the corresponding Channels. Add the ready keys to the</span></span><br><span class="line"><span class="comment"> * ready queue.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">updateSelectedKeys</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> numKeysUpdated = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Skip zeroth entry; it is for interrupts only</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=channelOffset; i&lt;totalChannels; i++) &#123;</span><br><span class="line">        <span class="comment">// 获取通道就绪操作类型（可读、可写、错误等）</span></span><br><span class="line">        <span class="keyword">int</span> rOps = pollWrapper.getReventOps(i);</span><br><span class="line">        <span class="keyword">if</span> (rOps != <span class="number">0</span>) &#123;</span><br><span class="line">            SelectionKeyImpl sk = channelArray[i];</span><br><span class="line">            pollWrapper.putReventOps(i, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (selectedKeys.contains(sk)) &#123;</span><br><span class="line">                <span class="comment">// 将ReventOps就绪的操作类型转换到SelectionKeyImpl</span></span><br><span class="line">                <span class="keyword">if</span> (sk.channel.translateAndSetReadyOps(rOps, sk)) &#123;</span><br><span class="line">                    numKeysUpdated++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sk.channel.translateAndSetReadyOps(rOps, sk);</span><br><span class="line">                <span class="keyword">if</span> ((sk.nioReadyOps() &amp; sk.nioInterestOps()) != <span class="number">0</span>) &#123;</span><br><span class="line">                    selectedKeys.add(sk); <span class="comment">// 注解@4</span></span><br><span class="line">                    numKeysUpdated++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numKeysUpdated;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注解@3：由SelectorImpl方法可以看出publicSelectedKeys即为selectedKeys。</p>
<p>注解@4：将就绪的key放入了selectedKeys集合中。</p>
<p>小结：SelectorImpl中的publicSelectedKeys存放了就绪selectedKey。</p>
<h4 id="3-轮询就绪selectionKey集合"><a href="#3-轮询就绪selectionKey集合" class="headerlink" title="3.轮询就绪selectionKey集合"></a>3.轮询就绪selectionKey集合</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doBind0</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> ChannelFuture regFuture, <span class="keyword">final</span> Channel channel,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    channel.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123; <span class="comment">// 注解@5</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (regFuture.isSuccess()) &#123;</span><br><span class="line">                channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                promise.setFailure(regFuture.cause());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注解@5： 顺着示例b.bind(PORT)进入到doBind0()方法。channel.eventLoop().execute(…)，此处的eventLoop()即NioEventLoop。也就是后续的轮询事件在该NioEventLoop线程中进行。SingleThreadEventExecutor是NioEventLoop的父类，实际执行到SingleThreadEventExecutor的execute方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">    ObjectUtil.checkNotNull(task, <span class="string">&quot;task&quot;</span>);</span><br><span class="line">    execute(task, !(task <span class="keyword">instanceof</span> LazyRunnable) &amp;&amp; wakesUpForTask(task));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task, <span class="keyword">boolean</span> immediate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> inEventLoop = inEventLoop();</span><br><span class="line">    addTask(task); <span class="comment">// 注解@6</span></span><br><span class="line">    <span class="keyword">if</span> (!inEventLoop) &#123;</span><br><span class="line">        startThread(); <span class="comment">// 注解@7</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doStartThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            SingleThreadEventExecutor.<span class="keyword">this</span>.run(); <span class="comment">// 注解@8</span></span><br><span class="line">            <span class="comment">//...   </span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注解@6：将Runnable放入Queue中。</p>
<p>注解@7：此处启动了一个线程默认为ThreadPerTaskExecutor。</p>
<p>注解@8：具体执行逻辑由NioEventLoop#run()来执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> selectCnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;  <span class="comment">// 注解@9</span></span><br><span class="line">     <span class="comment">// ... </span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">     		  <span class="comment">// ...</span></span><br><span class="line">      		 processSelectedKeys(); <span class="comment">// @10</span></span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      	 <span class="comment">// Ensure we always run tasks.</span></span><br><span class="line">         ranTasks = runAllTasks(); <span class="comment">// @11</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// ...   </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注解@9：一个死循环在不断轮询就绪事件</p>
<p>注解@10：处理就绪事件</p>
<p>注解@11：处理放入Queue中的Runnable任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processSelectedKeys</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (selectedKeys != <span class="keyword">null</span>) &#123;</span><br><span class="line">        processSelectedKeysOptimized();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        processSelectedKeysPlain(selector.selectedKeys()); <span class="comment">// 注解@12</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注解@12：selector.selectedKeys()即为SelectorImpl的publicSelectedKeys，即获取了就绪事件集合。</p>
<p>小结：就绪事件的轮询SingleThreadEventExecutor#run方法负责，不断轮询就绪事件集合publicSelectedKeys，来判断是否有就绪事件。</p>
<h2 id="三、事件处理"><a href="#三、事件处理" class="headerlink" title="三、事件处理"></a>三、事件处理</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processSelectedKey</span><span class="params">(SelectionKey k, AbstractNioChannel ch)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AbstractNioChannel.NioUnsafe unsafe = ch.unsafe();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> readyOps = k.readyOps();</span><br><span class="line">        <span class="comment">// We first need to call finishConnect() before try to trigger a read(...) or write(...) as otherwise</span></span><br><span class="line">        <span class="comment">// the NIO JDK channel implementation may throw a NotYetConnectedException.</span></span><br><span class="line">        <span class="keyword">if</span> ((readyOps &amp; SelectionKey.OP_CONNECT) != <span class="number">0</span>) &#123; <span class="comment">// 注解@13</span></span><br><span class="line">            <span class="comment">// remove OP_CONNECT as otherwise Selector.select(..) will always return without blocking</span></span><br><span class="line">            <span class="comment">// See https://github.com/netty/netty/issues/924</span></span><br><span class="line">            <span class="keyword">int</span> ops = k.interestOps();</span><br><span class="line">            ops &amp;= ~SelectionKey.OP_CONNECT;</span><br><span class="line">            k.interestOps(ops);</span><br><span class="line"></span><br><span class="line">            unsafe.finishConnect();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Process OP_WRITE first as we may be able to write some queued buffers and so free memory.</span></span><br><span class="line">        <span class="keyword">if</span> ((readyOps &amp; SelectionKey.OP_WRITE) != <span class="number">0</span>) &#123; <span class="comment">// 注解@14</span></span><br><span class="line">          <span class="comment">// Call forceFlush which will also take care of clear the OP_WRITE once there is nothing left to write</span></span><br><span class="line">          ch.unsafe().forceFlush();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Also check for readOps of 0 to workaround possible JDK bug which may otherwise lead</span></span><br><span class="line">        <span class="comment">// to a spin loop</span></span><br><span class="line">        <span class="keyword">if</span> ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="number">0</span> || readyOps == <span class="number">0</span>) &#123; <span class="comment">// 注解@15</span></span><br><span class="line">            unsafe.read();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CancelledKeyException ignored) &#123;</span><br><span class="line">        unsafe.close(unsafe.voidPromise());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注解@13：处理连接事件</p>
<p>注解@14：处理可写事件</p>
<p>注解@15：处理可读事件和处理客户端连接事件</p>
<p>小结：在以上的事件处理中，bossGroup主要处理客户端连接OP_ACCEPT事件。当有新的客户端的连接时触发unsafe.read()执行。具体为NioMessageUnsafe#read()方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void read() &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    try &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            do &#123;</span><br><span class="line">                int localRead &#x3D; doReadMessages(readBuf); &#x2F;&#x2F; 注解@16</span><br><span class="line">                &#x2F;&#x2F; ...</span><br><span class="line">                allocHandle.incMessagesRead(localRead);</span><br><span class="line">            &#125; while (allocHandle.continueReading());</span><br><span class="line">        &#125; catch (Throwable t) &#123;</span><br><span class="line">            exception &#x3D; t;</span><br><span class="line">        &#125;</span><br><span class="line">			  int size &#x3D; readBuf.size();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; size; i ++) &#123;</span><br><span class="line">            readPending &#x3D; false;</span><br><span class="line">            pipeline.fireChannelRead(readBuf.get(i)); &#x2F;&#x2F; 注解@17</span><br><span class="line">        &#125;</span><br><span class="line">      	&#x2F;&#x2F; ...</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注解@16：见下面doReadMessages逻辑。</p>
<p>注解@17：pipeline.fireChannelRead触发了pipeline链表向下执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doReadMessages</span><span class="params">(List&lt;Object&gt; buf)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    SocketChannel ch = SocketUtils.accept(javaChannel()); <span class="comment">// 注解@18</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch != <span class="keyword">null</span>) &#123;</span><br><span class="line">            buf.add(<span class="keyword">new</span> NioSocketChannel(<span class="keyword">this</span>, ch)); <span class="comment">// 注解@19</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractNioByteChannel</span><span class="params">(Channel parent, SelectableChannel ch)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(parent, ch, SelectionKey.OP_READ);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注解@18：获取新建立的连接通道SocketChannel。</p>
<p>注解@19：将连接通道SocketChannel转换为NioSocketChannel，建立时注册的OP_READ读事件。并将新建立的连接通道放入了List中。</p>
<p>再回到注解@17，pipeline.fireChannelRead触发了链表向下传递。具体传递到那个Handler中需要翻前面初始化代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">    setChannelOptions(channel, newOptionsArray(), logger); </span><br><span class="line">    setAttributes(channel, attrs0().entrySet().toArray(EMPTY_ATTRIBUTE_ARRAY));</span><br><span class="line"></span><br><span class="line">    ChannelPipeline p = channel.pipeline();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> EventLoopGroup currentChildGroup = childGroup;</span><br><span class="line">    <span class="keyword">final</span> ChannelHandler currentChildHandler = childHandler;</span><br><span class="line">    <span class="keyword">final</span> Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] currentChildOptions;</span><br><span class="line">    <span class="keyword">synchronized</span> (childOptions) &#123;</span><br><span class="line">        currentChildOptions = childOptions.entrySet().toArray(EMPTY_OPTION_ARRAY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] currentChildAttrs = childAttrs.entrySet().toArray(EMPTY_ATTRIBUTE_ARRAY);</span><br><span class="line"></span><br><span class="line">    p.addLast(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123; </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(<span class="keyword">final</span> Channel ch)</span> </span>&#123; <span class="comment">// 注解@20</span></span><br><span class="line">            <span class="keyword">final</span> ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">            ChannelHandler handler = config.handler();</span><br><span class="line">            <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                pipeline.addLast(handler);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ch.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> ServerBootstrapAcceptor( <span class="comment">// 注解21</span></span><br><span class="line">                            ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注解@20：在Server初始化时回调</p>
<p>注解@21：Server初始化后在pipeline加入了ServerBootstrapAcceptor，同时注意参数currentChildGroup和currentChildHandler，分别对应示例中传入的childGroup和childHandler。</p>
<p>接着看下ServerBootstrapAcceptor的channelRead方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Channel child = (Channel) msg; <span class="comment">// 注解@22</span></span><br><span class="line"></span><br><span class="line">    child.pipeline().addLast(childHandler); <span class="comment">// 注解@23</span></span><br><span class="line"></span><br><span class="line">    setChannelOptions(child, childOptions, logger);</span><br><span class="line">    setAttributes(child, childAttrs);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        childGroup.register(child).addListener(<span class="keyword">new</span> ChannelFutureListener() &#123; <span class="comment">// 注解@24</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (!future.isSuccess()) &#123;</span><br><span class="line">                    forceClose(child, future.cause());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        forceClose(child, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注解@22：注意此处有“注解@17”步回调回来，传入的msg为新建立连接的NioSocketChannel，再强调下该通道注册了可读事件。</p>
<p>注解@23：把childHandler加入到新建立连接Channel的pipeline，也就是示例中的HttpUploadServerInitializer。HttpUploadServerInitializer的初始化（channel注册后回调）又加入了HttpRequestDecoder、HttpResponseEncoder、HttpContentCompressor、HttpUploadServerHandler到该channel的pipeline。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> </span>&#123;</span><br><span class="line">    ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sslCtx != <span class="keyword">null</span>) &#123;</span><br><span class="line">        pipeline.addLast(sslCtx.newHandler(ch.alloc()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pipeline.addLast(<span class="keyword">new</span> HttpRequestDecoder());</span><br><span class="line">    pipeline.addLast(<span class="keyword">new</span> HttpResponseEncoder());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remove the following line if you don&#x27;t want automatic content compression.</span></span><br><span class="line">    pipeline.addLast(<span class="keyword">new</span> HttpContentCompressor());</span><br><span class="line"></span><br><span class="line">    pipeline.addLast(<span class="keyword">new</span> HttpUploadServerHandler());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>注解@24：将childGroup绑定到该NioSocketChannel，并将该NioSocketChannel注册到Selector。</p>
<p>小结：1.当轮询到有新的客户端连接建立时，将该新建的通道NioSocketChannel通过pipeline转发给ServerBootstrapAcceptor，这个过程由线程池bossGroup分配的线程负责。</p>
<p>2.当ServerBootstrapAcceptor收到新建立的通道NioSocketChannel时与workGroup分配的线程绑定，并将用户添加的childHandler加入到该channel的pipeline，注册OP_READ读事件到Selector。该过程由线程池workGroup分配的线程负责。</p>
<p>3.当有数据可读时由线程池workGroup分配的线程处理，并一路通过pipeline回调到我们自己加入的ChannelHandler 见注解@23.</p>
<p>例如：示例中加入的HttpUploadServerHandler，父类为SimpleChannelInboundHandler。当监听到有可读时间时，通过pipeline一路回调到SimpleChannelInboundHandler的channelRead()，进而调用到HttpUploadServerHandler的channelRead0()方法，从而处理我们的逻辑。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty8# Netty之ByteBuf初体验</title>
    <url>/posts/17c9a786/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>字节的流动形成了流，Netty作为优秀的通信框架他的字节是如何流动的，本文就理一下这个事。梳理完Netty的字节流动与JDK提供的ByteBuffer一对比看下Netty方便在哪里。本分从官方文档概念原理入手梳理，然后看下源码解读下这些原理如何实现的，体验一把Netty写入数据自动扩容，探究下这个过程如何实现的。</p>
<a id="more"></a>



<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p><strong>ByteBuf创建</strong></p>
<p>使用Unpooled类来创建ByteBuf，不建议使用ByteBuf的构造函数自己去创建。</p>
<p><strong>读写索引</strong></p>
<p>ByteBuf提供了两个指针readerIndex和writerIndex，分别记录读、写的开始位置。两个指针将ByteBuf分成了三个区域。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210102104805.png"></p>
<p><strong>discardable bytes</strong> </p>
<p>这个区间的范围为0~readerIndex，已经被读过的、可废弃的区域。通过调用discardReadBytes()，可以释放discardable bytes区域。这个区域释放后，可写区域（writable bytes）部分增多。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210102141428.png"></p>
<p><strong>readable bytes</strong></p>
<p>可读区域的范围为（writerIndex-readerIndex）</p>
<p><strong>writable bytes</strong></p>
<p>可写区域的范围为（capacity-writerIndex）</p>
<p><strong>清理索引</strong></p>
<p>调用Buffer.clear()后，读写索引全部归零，缓存buffer被释放。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210102143322.png"></p>
<h1 id="ByteBuf的构建"><a href="#ByteBuf的构建" class="headerlink" title="ByteBuf的构建"></a><strong>ByteBuf的构建</strong></h1><p>接下来通过示例窜下上面的知识点，看下源码是如何实现的，示例中将字符串写入ByteBuf中，然后再读出来打印。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWriteUtf81</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     String str1 = <span class="string">&quot;瓜农&quot;</span>;</span><br><span class="line">     ByteBuf buf = Unpooled.buffer(<span class="number">1</span>);</span><br><span class="line">     buf.writeBytes(str1.getBytes(CharsetUtil.UTF_8));</span><br><span class="line">     ByteBuf readByteBuf = ByteBufUtil.readBytes(UnpooledByteBufAllocator.DEFAULT,buf,str1.getBytes(CharsetUtil.UTF_8).length);</span><br><span class="line">     System.out.print(readByteBuf.toString(CharsetUtil.UTF_8));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>源码解读</strong> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuf <span class="title">buffer</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> ALLOC.heapBuffer(initialCapacity); <span class="comment">// 注解@1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">heapBuffer</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> heapBuffer(initialCapacity, DEFAULT_MAX_CAPACITY); <span class="comment">// 注解@2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">InstrumentedUnpooledUnsafeHeapByteBuf(UnpooledByteBufAllocator alloc, <span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity) &#123;</span><br><span class="line">  <span class="keyword">super</span>(alloc, initialCapacity, maxCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UnpooledHeapByteBuf</span><span class="params">(ByteBufAllocator alloc, <span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>(maxCapacity);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (initialCapacity &gt; maxCapacity) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(</span><br><span class="line">      <span class="string">&quot;initialCapacity(%d) &gt; maxCapacity(%d)&quot;</span>, initialCapacity, maxCapacity));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.alloc = checkNotNull(alloc, <span class="string">&quot;alloc&quot;</span>);</span><br><span class="line">  setArray(allocateArray(initialCapacity)); <span class="comment">// 注解@3</span></span><br><span class="line">  setIndex(<span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 注解@4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@1</strong> 使用ByteBufAllocator来分配ByteBuf，默认为UnpooledByteBufAllocator。</p>
<p><strong>注解@2</strong> initialCapacity为初始容量例子中给的为16，maxCapacity为默认的DEFAULT_MAX_CAPACITY=Integer.MAX_VALUE。</p>
<p><strong>注解@3</strong> allocateArray()的方法如下，此时使用JDK的byte[]初始化缓存区。通过setArray()，UnpooledHeapByteBuf持有byte[]缓存区。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">protected</span> <span class="keyword">byte</span>[] allocateArray(<span class="keyword">int</span> initialCapacity) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">byte</span>[initialCapacity];</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setArray</span><span class="params">(<span class="keyword">byte</span>[] initialArray)</span> </span>&#123;</span><br><span class="line">  array = initialArray;</span><br><span class="line">  tmpNioBuf = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@4</strong> 初始化readerIndex和writerIndex，均为0。</p>
<p><strong>小结</strong> ByteBuf的构建通过Unpooled来分配，示例中通过UnpooledByteBufAllocator持有byte[]、 readerIndex、writerIndex、maxCapacity完成ByteBuf的初始化。 示例中array数组大小为16；readerIndex=writerIndex=0；maxCapacity=Integer.MAX_VALUE。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210103092431.png"></p>
<h1 id="写入数据"><a href="#写入数据" class="headerlink" title="写入数据"></a>写入数据</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">writeBytes</span><span class="params">(<span class="keyword">byte</span>[] src, <span class="keyword">int</span> srcIndex, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">  ensureWritable(length); <span class="comment">// 注解@5</span></span><br><span class="line">  setBytes(writerIndex, src, srcIndex, length); <span class="comment">// 注解@6</span></span><br><span class="line">  writerIndex += length; <span class="comment">// 注解@7</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@5</strong> 确保剩余的空间能够容纳需写入的数据。</p>
<p>具体逻辑如下：<br>如果写入的数据长度小于已经分配的容量空间capacity则允许直接返回；</p>
<p>如果写入的数据长度超过允许的最大容量maxCapacity直接抛出IndexOutOfBoundsException拒绝；</p>
<p>如果写入数据长度大于已经分配的空间capacity但是小于最大最大允许空间maxCapacity，则需要扩容。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">ensureWritable0</span><span class="params">(<span class="keyword">int</span> minWritableBytes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> writerIndex = writerIndex(); <span class="comment">// 注解@5.1</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> targetCapacity = writerIndex + minWritableBytes; <span class="comment">// 注解@5.2</span></span><br><span class="line">    <span class="keyword">if</span> (targetCapacity &lt;= capacity()) &#123; <span class="comment">// 注解@5.3</span></span><br><span class="line">        ensureAccessible();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (checkBounds &amp;&amp; targetCapacity &gt; maxCapacity) &#123; <span class="comment">// 注解@5.4 </span></span><br><span class="line">        ensureAccessible();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(String.format(</span><br><span class="line">                <span class="string">&quot;writerIndex(%d) + minWritableBytes(%d) exceeds maxCapacity(%d): %s&quot;</span>,</span><br><span class="line">                writerIndex, minWritableBytes, maxCapacity, <span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Normalize the target capacity to the power of 2.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> fastWritable = maxFastWritableBytes(); <span class="comment">// 注解@5.5 </span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = fastWritable &gt;= minWritableBytes ? writerIndex + fastWritable</span><br><span class="line">            : alloc().calculateNewCapacity(targetCapacity, maxCapacity); <span class="comment">// 注解@5.6</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Adjust to the new capacity.</span></span><br><span class="line">    capacity(newCapacity); <span class="comment">// 注解@5.7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@5.1</strong>  获取当前写索引</p>
<p><strong>注解@5.2</strong> 计算需要的容量</p>
<p>**注解@5.3 ** 与当前已分配的容量capacity进行比较</p>
<p><strong>注解@5.4</strong> 不能超过最大允许的容量maxCapacity</p>
<p><strong>注解@5.5</strong> fastWritable = capacity() - writerIndex</p>
<p><strong>注解@5.6</strong> newCapacity的判断通常走到这里应该为，剩余的空间不够了。所以通常会进入alloc().calculateNewCapacity(targetCapacity, maxCapacity)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculateNewCapacity</span><span class="params">(<span class="keyword">int</span> minNewCapacity, <span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> threshold = CALCULATE_THRESHOLD; <span class="comment">// 4 MiB page</span></span><br><span class="line">        <span class="keyword">if</span> (minNewCapacity == threshold) &#123; <span class="comment">// 注解@5.6.1</span></span><br><span class="line">            <span class="keyword">return</span> threshold;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// If over threshold, do not double but just increase by threshold.</span></span><br><span class="line">        <span class="keyword">if</span> (minNewCapacity &gt; threshold) &#123; <span class="comment">// 注解@5.6.2</span></span><br><span class="line">            <span class="keyword">int</span> newCapacity = minNewCapacity / threshold * threshold;</span><br><span class="line">            <span class="keyword">if</span> (newCapacity &gt; maxCapacity - threshold) &#123;</span><br><span class="line">                newCapacity = maxCapacity;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                newCapacity += threshold;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> newCapacity;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Not over threshold. Double up to 4 MiB, starting from 64.</span></span><br><span class="line">        <span class="keyword">int</span> newCapacity = <span class="number">64</span>;</span><br><span class="line">        <span class="keyword">while</span> (newCapacity &lt; minNewCapacity) &#123; <span class="comment">// 注解@5.6.3</span></span><br><span class="line">            newCapacity &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Math.min(newCapacity, maxCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@5.6.1</strong> 如果写入的数据长度刚好为4M则返回threshold=4M</p>
<p><strong>注解@5.6.2</strong> 如果写入的数据长度大于4M，newCapacity不再翻倍增长，通过minNewCapacity / threshold * threshold计算刚容下需要的数据即可。</p>
<p><strong>注解@5.6.3</strong> 如果写入的数据长度小于4M，则newCapacity从64翻倍增长（128、256、512…），直到newCapacity能够容纳需要写入的数据。</p>
<p><strong>注解@5.7</strong> 确定了要扩容的容量newCapacity后，我们看下如何扩容的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">capacity</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">    checkNewCapacity(newCapacity);</span><br><span class="line">    <span class="keyword">byte</span>[] oldArray = array;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldArray.length;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity == oldCapacity) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> bytesToCopy;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity &gt; oldCapacity) &#123;</span><br><span class="line">      bytesToCopy = oldCapacity;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      trimIndicesToCapacity(newCapacity);</span><br><span class="line">      bytesToCopy = newCapacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">byte</span>[] newArray = allocateArray(newCapacity); <span class="comment">// 注解@5.7.1</span></span><br><span class="line">    System.arraycopy(oldArray, <span class="number">0</span>, newArray, <span class="number">0</span>, bytesToCopy); <span class="comment">// 注解@5.7.2</span></span><br><span class="line">    setArray(newArray); <span class="comment">// 注解@5.7.3</span></span><br><span class="line">    freeArray(oldArray); <span class="comment">// 注解@5.7.4</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@5.7.1</strong> 使用新的容量初始化newArray=new byte[initialCapacity]</p>
<p><strong>注解@5.7.2</strong> 将旧的oldArray数据拷贝到新的newArray=new中</p>
<p><strong>注解@5.7.3</strong> 将UnpooledHeapByteBuf的byte[]引用替换为newArray</p>
<p><strong>注解@5.7.4</strong> oldArray清理操作</p>
<p><strong>注解@6</strong> 写入数据，通过System.arraycopy将数据写入array中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">setBytes</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">byte</span>[] src, <span class="keyword">int</span> srcIndex, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">  checkSrcIndex(index, length, srcIndex, src.length);</span><br><span class="line">  System.arraycopy(src, srcIndex, array, index, length);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@7</strong> 移动writerIndex指针。</p>
<p><strong>小结：</strong> 将上面例子的initialCapacity设置成1，促使写入数据时扩充容量。下面运行时截图：array被扩容到64，writerIndex从0位置移动到6. </p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210103110741.png"></p>
<p>在写入数据时，判断剩余容量是否足够；不够则需要扩容，如果写入的数据小于4M，则双倍增长，直到容纳写写入的数据。如果写入的数据大于4M，通过（minNewCapacity / threshold * threshold）计算需要扩容的大小。</p>
<h1 id="读出数据"><a href="#读出数据" class="headerlink" title="读出数据"></a>读出数据</h1><p>从buf中把刚才写入的数据（”瓜农“）读出来，通过工具类ByteBufUtil.readBytes来实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ByteBuf readByteBuf = ByteBufUtil.readBytes(UnpooledByteBufAllocator.DEFAULT,buf,str1.getBytes(CharsetUtil.UTF_8).length);</span><br><span class="line">System.out.print(readByteBuf.toString(CharsetUtil.UTF_8));</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuf <span class="title">readBytes</span><span class="params">(ByteBufAllocator alloc, ByteBuf buffer, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> release = <span class="keyword">true</span>;</span><br><span class="line">    ByteBuf dst = alloc.buffer(length); <span class="comment">// 注解@8</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        buffer.readBytes(dst); <span class="comment">// 注解@9</span></span><br><span class="line">        release = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> dst;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (release) &#123;</span><br><span class="line">            dst.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@8</strong> 重新构造了一个ByteBuf（dst）用于存储读取的数据</p>
<p><strong>注解@9</strong> 读取数据，并移动读索引。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">readBytes</span><span class="params">(ByteBuf dst, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (checkBounds) &#123;</span><br><span class="line">        <span class="keyword">if</span> (length &gt; dst.writableBytes()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(String.format(</span><br><span class="line">                    <span class="string">&quot;length(%d) exceeds dst.writableBytes(%d) where dst is: %s&quot;</span>, length, dst.writableBytes(), dst));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    readBytes(dst, dst.writerIndex(), length); <span class="comment">// 注解@9.1</span></span><br><span class="line">    dst.writerIndex(dst.writerIndex() + length); <span class="comment">// 注解@9.2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@9.1</strong> 读取字节到新的ByteBuf。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">readBytes</span><span class="params">(ByteBuf dst, <span class="keyword">int</span> dstIndex, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    checkReadableBytes(length);</span><br><span class="line">    getBytes(readerIndex, dst, dstIndex, length); <span class="comment">// 注解@9.1.1</span></span><br><span class="line">    readerIndex += length; <span class="comment">// 注解@9.1.2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@9.1.1</strong> 通过native api UNSAFE.copyMemory() 实现byte数组之间的拷贝</p>
<p><strong>注解@9.1.2</strong> 源byteBuf读索引readerIndex向前移动</p>
<p><strong>注解@9.2</strong> 数据读入新构建的缓存区dst，dst的写索引向前移动</p>
<p><strong>小结：</strong> 示例中通过构造一个新的ByteBuf（dst），将源ByteBuf（buf）的数据读入到dst。数据读取结束后，源ByteBuf（buf）readerIndex向前移动；ByteBuf（dst）的writerIndex向前移动。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210103125302.png"></p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty9# Netty抽象内存分配器实现原理</title>
    <url>/posts/2e57625b/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p> 本文通过分析抽象内存分配器API梳理其基于堆内存、堆外内存分配的实现原理。最后走查了CompositeByteBuf这种类似数据库视图的实现原理。</p>
<a id="more"></a>



<h1 id="内存分配器概览"><a href="#内存分配器概览" class="headerlink" title="内存分配器概览"></a>内存分配器概览</h1><p><strong>堆外内存&amp;堆内存</strong> </p>
<table>
<thead>
<tr>
<th>分配方式</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>堆内存</td>
<td>JVM负责内存的分配与回收</td>
<td>数据过多会引起频繁GC和停顿；<br />多一次拷贝，在用户态分配、I/O通信需要数据拷贝到内核态</td>
</tr>
<tr>
<td>堆外内存</td>
<td>I/O性能高，直接在内核态分配<br />降低GC频率和停顿</td>
<td>内存分配和收回比较慢、需要手动处理</td>
</tr>
</tbody></table>
<p><strong>内存分配器类图</strong> </p>
<p>字节缓存的分配出自ByteBufAllocator，其实现类AbstractByteBufAllocator（抽象类）、PooledByteBufAllocator（池化内存分配器）、UnpooledByteBufAllocator（非池化内存分配器）、PreferHeapByteBufAllocator（堆内存分配器）、PreferredDirectByteBufAllocator（堆外内存分配器）。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8%E7%B1%BB%E5%9B%BE%20(1).png"></p>
<p><strong>主要接口</strong> </p>
<table>
<thead>
<tr>
<th>接口</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>ByteBuf buffer()</td>
<td>分配一块字节缓存，由其实现类决定堆外内存或者堆内存</td>
</tr>
<tr>
<td>ByteBuf ioBuffer()</td>
<td>系统支持UNSAFE和CLEANER则优先分配堆外内存；否则分配堆内存。</td>
</tr>
<tr>
<td>ByteBuf heapBuffer()</td>
<td>分配堆内存字节缓存区</td>
</tr>
<tr>
<td>ByteBuf directBuffer()</td>
<td>分配堆外内存字节缓存区</td>
</tr>
<tr>
<td>CompositeByteBuf compositeBuffer()</td>
<td>分配一个CompositeByteBuf（将多个buffers组合成一个buffer）<br />由实现类决定堆内存或者堆外内存</td>
</tr>
</tbody></table>
<h1 id="内存分配器API解读"><a href="#内存分配器API解读" class="headerlink" title="内存分配器API解读"></a>内存分配器API解读</h1><p>下面走查下抽象内存分配器AbstractByteBufAllocator的API。</p>
<p><strong>构造函数</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> directByDefault;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ByteBuf emptyBuf;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractByteBufAllocator</span><span class="params">(<span class="keyword">boolean</span> preferDirect)</span> </span>&#123;</span><br><span class="line">  directByDefault = preferDirect &amp;&amp; PlatformDependent.hasUnsafe(); <span class="comment">// 注解@1</span></span><br><span class="line">  emptyBuf = <span class="keyword">new</span> EmptyByteBuf(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@1</strong> directByDefault是否使用堆外内存分配，满足两个条件。preferDirect布尔型用户传入；PlatformDependent.hasUnsafe() 系统是否支持UNSAFE（通过内存指针进行堆外内存分配）；即：用户传入preferDirect=true并且系统支持UNSAFE则使用堆外内存。</p>
<p><strong>buffer()</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">buffer</span><span class="params">()</span> </span>&#123; <span class="comment">// 注解@2</span></span><br><span class="line">  <span class="keyword">if</span> (directByDefault) &#123;</span><br><span class="line">    <span class="keyword">return</span> directBuffer();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> heapBuffer();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@2</strong> directByDefault如果为true使用堆外内存分配DirectByteBuffer，底层使用unsafe.allocateMemory分配。</p>
<p>directByDefault如果为false使用堆内存分配 new byte[initialCapacity]。</p>
<p><strong>ioBuffer</strong> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">ioBuffer</span><span class="params">()</span> </span>&#123; <span class="comment">// 注解@3</span></span><br><span class="line">  <span class="keyword">if</span> (PlatformDependent.hasUnsafe() || isDirectBufferPooled()) &#123;</span><br><span class="line">  <span class="keyword">return</span> directBuffer(DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> heapBuffer(DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@3</strong> 如果系统支持UNSAFE或者使用池化内存，优先分配堆外内存，否则分配堆内存。</p>
<p><strong>heapBuffer</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">heapBuffer</span><span class="params">()</span> </span>&#123; <span class="comment">// 注解@4</span></span><br><span class="line">	<span class="keyword">return</span> heapBuffer(DEFAULT_INITIAL_CAPACITY, DEFAULT_MAX_CAPACITY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@4</strong> 分配堆外内存new一个byte数组（new byte[]）。</p>
<p><strong>directBuffer</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">directBuffer</span><span class="params">()</span> </span>&#123; <span class="comment">// 注解@5</span></span><br><span class="line">	<span class="keyword">return</span> directBuffer(DEFAULT_INITIAL_CAPACITY, DEFAULT_MAX_CAPACITY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@5</strong> 分配堆外内存。</p>
<p><strong>compositeBuffer</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompositeByteBuf <span class="title">compositeBuffer</span><span class="params">()</span> </span>&#123; <span class="comment">// 注解@6</span></span><br><span class="line">  <span class="keyword">if</span> (directByDefault) &#123;</span><br><span class="line">  	<span class="keyword">return</span> compositeDirectBuffer();</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="keyword">return</span> compositeHeapBuffer();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@6</strong> 跟上面一样的，只是分配的CompositeByteBuf。下面看下这种将多个个buffer组合成一个buffer是如何实现的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompositeByteBuf <span class="title">compositeHeapBuffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> compositeHeapBuffer(DEFAULT_MAX_COMPONENTS);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompositeByteBuf <span class="title">compositeHeapBuffer</span><span class="params">(<span class="keyword">int</span> maxNumComponents)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> toLeakAwareBuffer(<span class="keyword">new</span> CompositeByteBuf(<span class="keyword">this</span>, <span class="keyword">false</span>, maxNumComponents));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">CompositeByteBuf</span><span class="params">(ByteBufAllocator alloc, <span class="keyword">boolean</span> direct, <span class="keyword">int</span> maxNumComponents, <span class="keyword">int</span> initSize)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>(AbstractByteBufAllocator.DEFAULT_MAX_CAPACITY);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.alloc = ObjectUtil.checkNotNull(alloc, <span class="string">&quot;alloc&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (maxNumComponents &lt; <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">  <span class="string">&quot;maxNumComponents: &quot;</span> + maxNumComponents + <span class="string">&quot; (expected: &gt;= 1)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.direct = direct;</span><br><span class="line">  <span class="keyword">this</span>.maxNumComponents = maxNumComponents;</span><br><span class="line">  components = newCompArray(initSize, maxNumComponents); <span class="comment">// 注解@6.1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@6.1</strong> 在CompositeByteBuf的构造方法中初始化了一个components，这个默认initSize=0；maxNumComponents默认为16。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Component[] newCompArray(<span class="keyword">int</span> initComponents, <span class="keyword">int</span> maxNumComponents) &#123;</span><br><span class="line">	<span class="keyword">int</span> capacityGuess = Math.min(AbstractByteBufAllocator.DEFAULT_MAX_COMPONENTS, maxNumComponents);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> Component[Math.max(initComponents, capacityGuess)]; <span class="comment">// 注解@6.2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@6.2</strong> components是Component的对象数组，数组大小默认为16. </p>
<h1 id="CompositeByteBuf实现原理"><a href="#CompositeByteBuf实现原理" class="headerlink" title="CompositeByteBuf实现原理"></a>CompositeByteBuf实现原理</h1><p>下面通过例子来体验一把CompositeByteBuf，先直观感受下。</p>
<p><strong>示例代码</strong> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCompositeByteBuf</span><span class="params">()</span></span>&#123;</span><br><span class="line">  String str1 = <span class="string">&quot;瓜农&quot;</span>;</span><br><span class="line">  String str2 = <span class="string">&quot;老梁&quot;</span>;</span><br><span class="line">  ByteBuf buf1 = Unpooled.buffer(<span class="number">10</span>);</span><br><span class="line">  buf1.writeBytes(str1.getBytes(CharsetUtil.UTF_8));</span><br><span class="line">  System.out.println(<span class="string">&quot;buf1&#x27;s readerIndex:&quot;</span> + buf1.readerIndex());</span><br><span class="line">  System.out.println(<span class="string">&quot;buf1&#x27;s writeIndex&quot;</span> + buf1.writerIndex());</span><br><span class="line"></span><br><span class="line">  ByteBuf buf2 = Unpooled.buffer(<span class="number">10</span>);</span><br><span class="line">  buf2.writeBytes(str2.getBytes(CharsetUtil.UTF_8));</span><br><span class="line">  System.out.println(<span class="string">&quot;buf2&#x27;s readerIndex:&quot;</span> + buf2.readerIndex());</span><br><span class="line">  System.out.println(<span class="string">&quot;buf2&#x27;s writeIndex&quot;</span> + buf2.writerIndex());</span><br><span class="line"></span><br><span class="line">  ByteBuf compositeByteBuf = Unpooled.wrappedBuffer(buf1,buf2);</span><br><span class="line">  System.out.println(<span class="string">&quot;compositeByteBuf&#x27;s readerIndex:&quot;</span> + compositeByteBuf.readerIndex());</span><br><span class="line">  System.out.println(<span class="string">&quot;compositeByteBuf&#x27;s writeIndex&quot;</span> + compositeByteBuf.writerIndex());</span><br><span class="line">  System.out.print(compositeByteBuf.toString(CharsetUtil.UTF_8));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结果输出</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">buf1&#39;s readerIndex:0</span><br><span class="line">buf1&#39;s writeIndex6</span><br><span class="line">buf2&#39;s readerIndex:0</span><br><span class="line">buf2&#39;s writeIndex6</span><br><span class="line">compositeByteBuf&#39;s readerIndex:0</span><br><span class="line">compositeByteBuf&#39;s writeIndex12</span><br><span class="line">瓜农老梁</span><br></pre></td></tr></table></figure>

<p><strong>小结</strong>  Unpooled.wrappedBuffer(buf1,buf2)将两个ByteBuf进行了合并一个ByteBuf；对外提供统一的读写指针供使用。</p>
<p>接下来看下他是如何合并的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuf <span class="title">wrappedBuffer</span><span class="params">(<span class="keyword">int</span> maxNumComponents, ByteBuf... buffers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (buffers.length) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            ByteBuf buffer = buffers[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span> (buffer.isReadable()) &#123;</span><br><span class="line">                <span class="keyword">return</span> wrappedBuffer(buffer.order(BIG_ENDIAN));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                buffer.release();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buffers.length; i++) &#123;</span><br><span class="line">                ByteBuf buf = buffers[i];</span><br><span class="line">                <span class="keyword">if</span> (buf.isReadable()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> CompositeByteBuf(ALLOC, <span class="keyword">false</span>, maxNumComponents, buffers, i); <span class="comment">// 注解@7</span></span><br><span class="line">                &#125;</span><br><span class="line">                buf.release();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> EMPTY_BUFFER;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@7</strong> 通过创建一个CompositeByteBuf，将ByteBuf数组传入构造函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompositeByteBuf(ByteBufAllocator alloc, <span class="keyword">boolean</span> direct, <span class="keyword">int</span> maxNumComponents,</span><br><span class="line">            ByteBuf[] buffers, <span class="keyword">int</span> offset) &#123;</span><br><span class="line">            <span class="keyword">this</span>(alloc, direct, maxNumComponents, buffers.length - offset);</span><br><span class="line"></span><br><span class="line">	addComponents0(<span class="keyword">false</span>, <span class="number">0</span>, buffers, offset); <span class="comment">// 注解@8</span></span><br><span class="line">	consolidateIfNeeded();</span><br><span class="line">	setIndex0(<span class="number">0</span>, capacity()); <span class="comment">// 注解@9</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@8</strong>  填充Component[]数据，每个Component元素包含了传入的ByteBuf。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> CompositeByteBuf <span class="title">addComponents0</span><span class="params">(<span class="keyword">boolean</span> increaseWriterIndex,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">final</span> <span class="keyword">int</span> cIndex, ByteBuf[] buffers, <span class="keyword">int</span> arrOffset)</span> </span>&#123;</span><br><span class="line">  			<span class="comment">//  buffers数组的长度；本例中arrOffset=0；count=len</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> len = buffers.length, count = len - arrOffset;</span><br><span class="line">        <span class="keyword">int</span> ci = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            checkComponentIndex(cIndex); <span class="comment">// 合法性校验</span></span><br><span class="line">            shiftComps(cIndex, count); <span class="comment">// 注解@8.1</span></span><br><span class="line">            <span class="keyword">int</span> nextOffset = cIndex &gt; <span class="number">0</span> ? components[cIndex - <span class="number">1</span>].endOffset : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (ci = cIndex; arrOffset &lt; len; arrOffset++, ci++) &#123; <span class="comment">// 注解@8.2</span></span><br><span class="line">                <span class="comment">// 从数组中拿出传入的ByteBuf</span></span><br><span class="line">              	ByteBuf b = buffers[arrOffset];</span><br><span class="line">                <span class="keyword">if</span> (b == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 构建Component</span></span><br><span class="line">                Component c = newComponent(ensureAccessible(b), nextOffset); </span><br><span class="line">              	<span class="comment">// 加入components数组</span></span><br><span class="line">                components[ci] = c;</span><br><span class="line">                <span class="comment">// 递增endOffset</span></span><br><span class="line">                nextOffset = c.endOffset;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@8.1</strong> 扩容Component数组，默认的数量为16个，当添加的buffer的数量超过16时就需要扩容了，下面看下其如何扩容的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">shiftComps</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> size = componentCount, newSize = size + count;</span><br><span class="line">        <span class="keyword">assert</span> i &gt;= <span class="number">0</span> &amp;&amp; i &lt;= size &amp;&amp; count &gt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (newSize &gt; components.length) &#123;</span><br><span class="line">            <span class="comment">// grow the array </span></span><br><span class="line">          	<span class="keyword">int</span> newArrSize = Math.max(size + (size &gt;&gt; <span class="number">1</span>), newSize); <span class="comment">// 注解@8.1.1</span></span><br><span class="line">            Component[] newArr;</span><br><span class="line">            <span class="comment">// 注解@8.1.2</span></span><br><span class="line">            <span class="keyword">if</span> (i == size) &#123;</span><br><span class="line">                newArr = Arrays.copyOf(components, newArrSize, Component[].class);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                newArr = <span class="keyword">new</span> Component[newArrSize];</span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    System.arraycopy(components, <span class="number">0</span>, newArr, <span class="number">0</span>, i);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i &lt; size) &#123;</span><br><span class="line">                    System.arraycopy(components, i, newArr, i + count, size - i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            components = newArr;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; size) &#123;</span><br><span class="line">            System.arraycopy(components, i, components, i + count, size - i);</span><br><span class="line">        &#125;</span><br><span class="line">        componentCount = newSize;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>**注解@8.1.1 ** 默认size=16，size &gt;&gt; 1 = 8 也就是扩容会以原大小一半的容量进行扩容。</p>
<p><strong>注解@8.1.2</strong> 下面判断根据场景通过Arrays.copyOf、System.arraycopy将Component数组扩容；插入尾部、中部、头部等情况。本示例中没有超过16，所以不会扩容，componentCount=2。</p>
<p><strong>注解@8.2</strong> 循环拿出传入的ByteBuf数组构建Component，并将其加入Component数组中；最后移动nextOffset。关于各个参数的含义，源码给出了注释。构造函数中</p>
<p>第一个参数：传入的ByteBuf<br>第二个参数：源ByteBuf的readerIndex<br>第三个参数：unwrapped的buffer<br>第四个参数：unwrappedIndex<br>第五个参数：offset = components[cIndex - 1].endOffset<br>第六个参数：len = buf.readableBytes()  buf为源buffer<br>第七个参数：slice = null （示例）</p>
<p>以endOffset为例，等于插入数组中上一个Conponent的endOffset + 当前ByteBuf的可读长度，从而维护了其在整个CompositeByteBuf的写索引情况。</p>
<p>一个buffer对应一个Component，每个Component持有源buffer并维护了其在整个CompositeByteBuf的索引情况。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210117101614.png"></p>
<p><strong>注解@9</strong> 设置整个CompositeByteBuf的读索引和写索引，读索引初始值为0；写索引为components[size - 1].endOffset，也就是整个Conponent数组中其每个元素维护的ByteBuf可读字节（writerIndex - readerIndex）大小的总和。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setIndex0</span><span class="params">(<span class="keyword">int</span> readerIndex, <span class="keyword">int</span> writerIndex)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.readerIndex = readerIndex;</span><br><span class="line">	<span class="keyword">this</span>.writerIndex = writerIndex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">capacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> size = componentCount;</span><br><span class="line">  <span class="keyword">return</span> size &gt; <span class="number">0</span> ? components[size - <span class="number">1</span>].endOffset : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>小结：</strong> CompositeByteBuf通过将多个ByteBuf装入component数组中，对其统一维护读写索引，在外面看起来是一个统一的buffer；类似数据库中的视图。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>SK1# 给老板画饼</title>
    <url>/posts/4eda328d/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>大家好，我是老梁，一个想跟大家分享点干活的家伙。</p>
<p>今天周末，这上海的天也冷了，晚上喝了点羊汤，到了一周中最放松的时刻。</p>
<p>今天不聊技术，咱聊聊给老板画饼。 </p>
<a id="more"></a>



<h1 id="一"><a href="#一" class="headerlink" title="一"></a>一</h1><p>崇祯元年七月十四日，崇祯在平台召见袁崇焕，聊辽东的事。</p>
<p>崇祯说卿是我大明的忠诚义士，有你在收复辽东我就放心了，卿需要多久可收复？</p>
<p>袁崇焕答：“臣受陛下眷顾，以臣便宜行事，计五年全辽可复！”。</p>
<p>崇祯太高兴了，说收复辽东，朕给你封侯赏赐绝不吝啬。</p>
<p>会后，兵科给事中许誉卿向袁大人讨教平辽方略，袁大人答”聊慰上意“，看到皇上如此操劳，好言劝慰而已。许大人这下傻眼了，到时候干不成，皇上怪罪下来如何是好。</p>
<p>再次会见时，袁大人意识到吹的大了，跟皇上要人、要钱、要权。崇祯全部答应，召集六部要求全部落实，嗯，皇上是认真的。</p>
<p>崇祯二年十一月，皇太极率数十万大军绕道蒙古，避开山海关，突破长城，威胁北京。最后袁大人虽然统领各地援军最终逼退后金军队，北京解围。对了，袁大人在这一年多在未请示皇上的情况下，干掉了皮岛军区司令员毛文龙。</p>
<p>崇祯二年十二月，后金退兵后，袁大人却下狱了。</p>
<p>崇祯三年八月，袁崇焕被凌迟处死，被割了3000多刀，家人流徙三千里，财产没收。</p>
<p>袁大人是从底层一点一点干起来的，自己的能力得到贵人兵部尚书、东阁大学士孙承宗赏识才有了后来的袁督师。对袁崇焕的奋斗史很受感动。临终绝笔诗《临刑口占》述说着他奋斗的一生。</p>
<p>一生事业总成空，半世功名在梦中。<br>死后不愁无勇将，忠魂依旧守辽东。</p>
<p>袁大人被杀的原因很多什么通敌、政治迫害就不聊这个了。</p>
<p>有一点是袁大人忽悠了老板，而且忽悠的没了边，老板虽然不太懂军事，你不能这么忽悠。</p>
<p>所谓期望越高失望越大，你说五年平辽，第二年后金打到了京城，这怎么解释？</p>
<h1 id="二"><a href="#二" class="headerlink" title="二"></a>二</h1><p>多年前老梁所在公司计划成立中间件团队，成立后大领导发现缺一个团队负责人，眼下无人索性让以前管业务的同学来带。几个月后经人介绍给大领导，来了一位大神。</p>
<p>大神第一次会议是在一个大方桌举行的，大领导也在，介绍了新来的团队负责人，并邀请大神发言。大神开口就语出惊人，”我熟读Linux源码“。</p>
<p>老梁我赶紧直了直腰，寻思着能从大神那里学点干货。第一次会议开得很成功，大领导很是欣慰，相见恨晚，团队小伙伴们也有士气。</p>
<p>大神上任三把火开始了，先规划未来。写了很多PPT，我们要完成什么什么什么。看了后你会发现除了BAT外基础设施就该我们最牛了。另外大神有个特点，业务运维的对团队的需求都能接，还承诺实现时间。大神写的PPT也得到了大领导认可。</p>
<p>但是后面的会议，每次会议都是天南海北的说，就是不见落地的具体措施。几次后老梁索性不参加了，年底绩效看着给吧，所谓的学习干货，除了听了忽悠也没学到啥。</p>
<p>三个季度大半年过去了，老梁在公司代码仓库上看了看，发现大神就没提交过代码。提交过，大致是不到10行的代码。但是PPT上的东西没看到一样落地，原来是什么样还是什么样。</p>
<p>年底看结果了，承诺的一个没实现，PPT什么样还是什么样，承诺运维的没实现，承诺业务部门的没实现。同样承诺领导的也没实现。</p>
<p>大领导在众多不满的声音中只好换人，大神只好去别的地方去跳了。</p>
<h1 id="三"><a href="#三" class="headerlink" title="三"></a>三</h1><p>我们应该给领导画饼吗？老梁觉得是应该的，但是这个饼是自己踮起脚尖能实现的。</p>
<p>如果有些领域的确没做过，在尝试的过程中及时跟领导保持沟通，把其中面临的问题及时反馈给领导。</p>
<p>能做你领导思考问题的方式和调动的资源必然比你多，跟领导一起去干不熟悉的领域，就算失败通常领导也愿意给你交学费。</p>
<p>过分忽悠领导就不应该了，如果遇到领导不熟悉这块领域听了你的忽悠信了你，但是技术这个东西是要落地的，落不了呢？</p>
<p>如果领导也懂这块领域，你忽悠不了他，在领导心里留下好大喜功的印象，何必呢？</p>
<p>能做你领导，通常必然有些能力超过你，能让你坐在这个位置上，也能让你滚蛋。</p>
<p>能捧得起你，自然可以踩得扁你。或许不出彩，或许绩效平平，但是有如何呢？多了一份踏实</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>思考随记</category>
      </categories>
      <tags>
        <tag>思考随记</tag>
      </tags>
  </entry>
  <entry>
    <title>SK1# 仰望星空</title>
    <url>/posts/8a7728e3/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="仰望星空"><a href="#仰望星空" class="headerlink" title="仰望星空"></a>仰望星空</h1><p>大家好，我是老梁，一个想跟大伙分享点干货的家伙。</p>
<p>今天周末，晚上喝了点啤酒，又到了一周中最放松的时刻，咱接着聊聊天。</p>
<p>上周写了篇小文《给老板画饼》，老板看了后怼了一句，脚踏实地和仰望星空其实缺一不可。</p>
<p>老梁想了想，他是对的。老梁我就佩服他这点，总能发现你的问题所在，指出前进的方向。</p>
<p>嗯，不是谁都能当老板。</p>
<p>老梁仰望星空，看到那些闪闪发光的星星……</p>
<a id="more"></a>



<h1 id="多看看历史星空中的星星"><a href="#多看看历史星空中的星星" class="headerlink" title="多看看历史星空中的星星"></a>多看看历史星空中的星星</h1><p>明正统十四年（1449年）八月，明英宗朱祁镇率军50万御驾亲征瓦刺，命弟弟朱祁钰留守京城。</p>
<p>皇上这年22岁，还是一个容易被蛊惑的年轻人，说是御驾亲征，实际由太监王振指挥。</p>
<p>王振不懂军事，一通乱指挥后，被瓦刺首领也先在今河北省张家口市怀来县境内的土木堡围猎。</p>
<p>20万大军损失大半，精锐尽失，皇上也被瓦刺掳走了，跟随出征的高官阵亡五十余人。</p>
<p>国不可一日无君，八月十八日皇太后命朱祁钰监国，八月二十九日百官拥立朱祁钰为帝，即景帝。</p>
<p>这一个月的变化真是太大了，而且瓦刺马上就要打到北京了，大明危在旦夕。</p>
<p>景帝命于谦为兵部尚书，原来的尚书邝埜呢？也在土木堡阵亡了。然而主战还是南迁成了争论的焦点。</p>
<p>以徐珵为代表的大臣主张南迁，北京守不住，原因很简单，精锐部队都埋葬在土木堡了，拿什么守！</p>
<p>于谦主战认为“京师天下根本，一动则大事去矣”。呵斥 “言南迁者，可斩也”。</p>
<p>于谦的建议得到了吏部尚书等人的支持，廷议最后决定固守北京，皇上把北京守卫重任交给了于谦。</p>
<p>皇上心里也没底，守说着容易，20万都打没了，现在京城不到10万军队还都是老弱病残居多。</p>
<p>有兵的话还廷议个啥，直接打就完了，这不是没兵嘛。</p>
<p>没了精锐就拿后备军凑，于谦命令各地备操军、备倭军、运粮军按时到京城布防，违令者斩！</p>
<p>嗯，清一色后备役。。。</p>
<p>这些后备役差不多有10万人，并要求途径通州粮仓把粮食顺便带到京城。</p>
<p>九月初，各路人马总算集合完毕，二十二万人，粮食问题也解决了。</p>
<p>十月十一日瓦刺军队来了，他们只用了11天就打到了北京城下，更增加了他们拿下北京的信心。</p>
<p>“京城必破，大元必兴”！</p>
<p>于谦召集将领召开战前会议，聊如何退敌。</p>
<p>大将石享提出敌军实力远超明军，应该坚壁清野，等待敌军疲惫后自然退兵。</p>
<p>大家比较赞同这个，但是一个人反对，这个是于谦，他是总指挥，是说了算的人。</p>
<p>找你们来，不是跟你们商量的，让你们来听令的！他的军令：</p>
<p>“大军全部开出九门之外，列阵迎敌”</p>
<p>“锦衣卫巡查城内，但凡查到有盔甲军士不出城作战者，格杀勿论！”</p>
<p>“九门是京城门户，若有丢失立斩！”</p>
<p>“临阵，将不顾军先退者，立斩！“</p>
<p>“临阵，军不顾将先退者，后队斩前队！”</p>
<p>“敢违军令者，格杀勿论！”</p>
<p>“大军开战之日，众将率军出城之后，立即关闭九门，有敢擅自放入城者立斩！”</p>
<p>嗯，在玩命！不玩命，大明就完了，这次输不起。</p>
<p>最终于谦带领着这只大部分的后备役军队逼退了瓦刺军，取得了北京保卫战的胜利。</p>
<p>于谦有大明再造之功！下面是他老人家的一首《石灰吟》，感受下他的风骨：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">千锤万凿出深山，烈火焚烧若等闲。</span><br><span class="line"></span><br><span class="line">粉骨碎身浑不怕，要留清白在人间。</span><br></pre></td></tr></table></figure>



<p>他那是历史星空中耀眼的一颗星星，每次翻开这段历史，总是那么明亮，让人充满敬意！</p>
<h1 id="多发现工作生活中的星星"><a href="#多发现工作生活中的星星" class="headerlink" title="多发现工作生活中的星星"></a>多发现工作生活中的星星</h1><p>我们在写ORK目标时，经常提到打造业界领先的、对齐业界一流的某些能力！</p>
<p>这些业界领先的东西就是我们的星星，需要时常抬头仰望，好让我们跟的紧一点。</p>
<p>工作中优秀的人，需要时常抬头仰望，好让我们与优秀者同行。</p>
<p>比如老梁吧，平时工作比较忙，基本上是995的节凑，周末还得抽出时间看源码写文章，不写不行吗？</p>
<p>也想不写，也想懈怠，但是抬头仰望星空，老梁看到了啥？老梁看到了丁威，那家伙又输出很多东西。</p>
<p>输出倒逼输入，输入倒逼输出，不断输入输出让自己能力提升。</p>
<p>这家伙不知疲倦，笔耕不戳！典型的湖南人性格，耐得烦、吃得苦、霸得蛮！</p>
<p>还特别有恒心，一坚持就7、8年，没一点停的意思！你说气人不气人。</p>
<p>能咋办？喝口水，擦把汗，接着干呗。。。</p>
<h4 id="最后说两句"><a href="#最后说两句" class="headerlink" title="最后说两句"></a>最后说两句</h4><p>当你生活不如意时看看以前和周围的人和事，在历史长河中，你的那点事其实没多大点事，不值得怨天尤人、寻死觅活。</p>
<p>当你春风得意时看看以前和周围的人和事，在历史长河中，你再大的成就不过沧海一粟，不值得骄傲自大、目中无人。</p>
<p>当你遇到无论什么样的困惑时，多仰望星空，历史的星星、身边的星星会给你照前进的路。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>思考随记</category>
      </categories>
      <tags>
        <tag>思考随记</tag>
      </tags>
  </entry>
  <entry>
    <title>SK3# 苍天饶过谁</title>
    <url>/posts/bb2245d5/</url>
    <content><![CDATA[<div id="vip-container"><h2 id="一"><a href="#一" class="headerlink" title="一"></a>一</h2><p>大家好，我是老梁，一个想跟大伙分享点干货的家伙。</p>
<p>今天周末，晚上喝了点女儿红，又到了一周中最放松的时候，咱接着聊聊天。</p>
<p>上周文章《仰望星空》，老梁说多看看历史和生活中的星星，让他们给咱照亮前进的路。</p>
<p>有朋友怼老梁，管看星星有啥用，看就能解决问题了？该踩的坑还要踩，该流的泪还要流。</p>
<p>老梁想了想，可不是么？该受的难还得受，苍天绕过谁。。。</p>
<a id="more"></a>



<h2 id="二"><a href="#二" class="headerlink" title="二"></a>二</h2><p>弘治元年（1488年）杨慎生于北京，祖籍四川成都人。爹是内阁首辅、东阁大学士杨廷和。不当爹是副国级，爷爷也是1481年的进士。</p>
<p>进士可不是那么容易的，首先你得先考中秀才，再考中举人，才有资格参加进士考试。进士考试的录取比例大约9%，平均每年也就百八十号人。。。</p>
<p>嗯，妥妥的官二代。</p>
<p>总有那么有些人，长得比你帅，出生比你好，还比你更努力，杨慎就是这号人。11岁就能作诗，12岁做的文章就得到当时文学家、书法家李东阳赞赏，收到其门下学习。</p>
<p>嗯，读书是要点天分的。</p>
<p>明武宗正德六年（1511年），24岁的杨慎考中状元，进士及第，授翰林院修撰。刚毕业就是修撰从六品官职，县太爷是七品，多少人体制内的人，熬啊熬。熬一辈子才是副科待遇，副科也就是从九品吧。</p>
<p>关键是在翰林院就业，这地方能进去的都是蔗吉士。啥概念，一甲三人（状元、榜眼、探花）和二甲中的头几名才有资格进去的。这是宰相培训班、帝国柱梁的摇篮。</p>
<p>这么下去，杨慎就是做不了宰相，最少熬个副部级没问题，前途一片光明。</p>
<p>嘉靖三年（1524年），发生了”大议礼“事件后，杨慎确挨了板子，被贬出京城，这年33岁。</p>
<p>明武宗朱厚照，去世时没子嗣。按照兄终弟及的祖训，朱厚熜被选为帝国皇帝，即嘉靖。</p>
<p>大议礼争来争去就是给朱厚熜他爸的主祀及封号问题。杨廷和给出的他爹封号为“皇叔考兴献大王”，他妈为“皇叔母兴国大妃”，祭祀时其亲生父母自称“侄皇帝”。原因很简单，他爹是王爷没做过皇帝，皇位是从堂兄手上继承过来的，朱厚熜不同意。</p>
<p>在这次事件中，杨慎与两百多位官员，在左順門哭天喊地，请皇上同意他们的主张。杨慎是带头大哥之一，并说”國家養士百五十年，仗節死義，正在今日“。</p>
<p>那会当官还真团结，一起跟皇上叫板。</p>
<p>皇上也不客气，两百多位，一个别想跑，廷杖！廷杖就是打屁股，还褪去裤子打，被打的还是高干们，这次廷杖死了16人。</p>
<p>杨慎也被打了，被打的皮开肉绽，差点昏死过去，然后被贬到了今云南保山市，年七十二岁终于被贬之地，终身未再复用。</p>
<p>就这事争了三年才算完，最后嘉靖赢了，其父上尊号“皇考恭穆献皇帝”，其母尊号“圣母章圣皇太后”。</p>
<p>惨不惨，是真的惨！自幼才华横溢、家世显赫、高中状元、进士极第，一次事件中就被扫到祖国边疆终身不许离开一直到老。</p>
<p>如果这都不算难的话，什么才是难！受此劫难后，安邦立国、指点江山不可能了，他把余生投入到读书写作中。《明史》记载杨慎的 “明世记诵之博，著作之富，推慎为第一。詩文外，雜著至一百余種，并行于世。” </p>
<p>下面《三国演义》第一回的开篇词就是出自杨慎大才子的《临江仙》：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">滚滚长江东逝水，浪花淘尽英雄。是非成败转头空，青山依旧在，几度夕阳红。</span><br><span class="line">白发渔樵江渚上，惯看秋月春风。一壶浊酒喜相逢，古今多少事，都付笑谈中。</span><br></pre></td></tr></table></figure>



<p>嗯，至于杨慎落难时如何熬过去的，只有他知道。。。</p>
<h2 id="三"><a href="#三" class="headerlink" title="三"></a>三</h2><p>“历史记下来的都是有本事的人，大部分都是不普通人，有什么可比的！”</p>
<p>你能说这话不对吗？不能，那接着聊聊身边的事。</p>
<p>老梁有个朋友，在前两年工作中遇到点难处，工作和生活的双重压力下抑郁了！按照他的说法是根本没法写代码了，严重时连续10多天晚上不能入眠，想死的心都有了！此时安慰都是苍白的。</p>
<p>能咋办，只好离职先休养一段时间。此后很长一段时间没了他的消息。再联系时是他看房子的时候，联系同事们看看周围的配套。老梁见他时也蛮惊讶的，小子阔达了很多，谈笑风生！</p>
<p>房子买好后请以前处的不错的同事们吃饭，大家都替他高兴，听他讲起那段往事时，感觉是别人的事。</p>
<p>嗯，困难就是这样，熬过去就会让你更阔达！当初经历时的痛苦，谁又能体会的到呢？</p>
<p>谁的苦谁受，谁的福谁享。</p>
<p>该来的总会来，该怕的依然怕，只是有勇气面对了！</p>
<p>下面是老梁长白头发时琢磨的一首打油诗，你品品有没有点老酒的味道：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	《十年回首》 作者：老梁						</span><br><span class="line"></span><br><span class="line">十年奋斗总成空，半世浮华在梦中。</span><br><span class="line"></span><br><span class="line">莫愁前路无机遇，病树前头万木春。</span><br></pre></td></tr></table></figure>



<p>生活岂能事事如意！正所谓大有大的难，小有小的困惑，各有各的难。</p>
<p>熬过去就是佳酿！</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>思考随记</category>
      </categories>
      <tags>
        <tag>思考随记</tag>
      </tags>
  </entry>
  <entry>
    <title>SK4# 让心静下来</title>
    <url>/posts/43fa99ab/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>大家好，我是老梁，一个想跟大伙分享点干货的家伙。</p>
<p>今天周末，晚上喝了点鸡尾酒，又到了一周中最放松的时候，咱接着聊聊天。</p>
<p>上周文章《苍天绕过谁》，一个读者朋友看了发微信给老梁，问我那朋友怎么走出来的，他最近想太多，有些睡眠障碍。</p>
<p>写着写着咋感觉有点像苦情文了，好在有读者朋友说虽然不是技术文章，但他受益匪浅。</p>
<p>嗯嗯，有些帮助就好，老梁想着文章能有点思考、有点故事。</p>
<p>除了积累点技术外，也积累些生活思考，在小故事中的一点思考。</p>
<p>如何度过困难期呢？困难千千万万，每个人都不同？困难有大有小，多大的事算困难？</p>
<p>这事老梁其实也不知道，可不是么？帮人度苦度难那是菩萨的事情呀。。。</p>
<p>把天聊死了，还能聊不？老梁想了想，让我给讲两个故事吧。。。</p>
<a id="more"></a>



<h1 id="一"><a href="#一" class="headerlink" title="一"></a>一</h1><p>杨博，今湖北石首市人。27岁考了全省第一（解元），28岁中进士，考了全国第21名（二甲18名）。</p>
<p>授予翰林院编修，翰林院之前说过，这个地方是宰相培训班，帝国栋梁的摇篮。</p>
<p>永乐初年改授洗马，洗马是官职，可以理解为幕僚，跟着太子朱高炽混，这份工作很有前途，太子未来的皇帝。</p>
<p>嗯，看到了吧，管自己能干也不行，还得跟着赏识你的老板才行！</p>
<p>明永乐十二年（1414年），瓦刺（蒙古族）逐渐发展壮大，经常冒犯大明边界。</p>
<p>永乐大帝朱棣决定御驾亲征，率领50万大军远征，令太子朱高炽监国。</p>
<p>朱棣是个厉害的皇帝，上马能打仗，下马能治国，全能型的。</p>
<p>这次出征朱棣打赢了，瓦刺受到重创，被打怕了，以后多年不敢犯边。</p>
<p>班师凯旋，太子朱高炽迎驾慢了点。朱棣大怒，迁怒太子，把太子的随从都扔进了诏狱。</p>
<p>就因为迎驾慢了点就这么玩？也太搞了吧。。。明面是迎驾慢，其实是有人进了谗言诋毁太子。</p>
<p>毕竟想当太子的还有朱高炽的弟弟朱高煦。总之诋毁起了作用，太子势力被打压。</p>
<p>很不幸杨博也被关进了诏狱。。。这一关就是10年啊，这年杨博42岁，出来都52岁了。</p>
<p>诏狱就是皇上下诏要关的人，这里没皇上说话基本这辈子算是交代了。</p>
<p>诏狱刑法非常残酷，上夹棍、剥皮、舌、断脊、堕指、刺心、琵琶等几十种。用这种东西招呼人，生不如死。不是怀疑人生的问题，是后悔生出来。</p>
<p>人生能有几个十年，一般在里面呆这么久基本算是废了。杨博就这么进去了，想送钱捞人不不知道送给谁。</p>
<p>皇帝下的旨，难不成给皇帝送礼去？那地方过了今天不知道能不能熬过明天。</p>
<p>很多跟杨博一起进去的忍受不了这份煎熬，死在了里面。</p>
<p>好在杨博没受大的刑法，家里没能力给皇上送钱，给看监狱的送还是可以的，家里送了很多书给杨博。</p>
<p>反正也出不去，也不知道哪天就没命了，索性不想了。</p>
<p>能读一天是一天吧，杨博把所有的精力和时间全部投入到读书之中。</p>
<p>读啥书呢？各类经史子集书籍。</p>
<p>在杨博45岁那边，太子朱高炽的地位总算是稳固了，他弟弟被赶到山东惠民县就藩汉王。朱棣也没再为难杨博，但是一直关着直到朱棣去世，太子朱高炽继位才被放出来。</p>
<p>毕竟因为太子才坐了十年的牢，朱高炽非常怜惜杨博。为了报答，一路重用高升，历经三朝最终官至内阁首辅、武英殿大学士。</p>
<p>经历了十年牢灾的杨博，为人宽静、大家有争议时都能平心处之、大家都佩服。</p>
<p>看到了吧，为人宽静、平心处之！这份豁达与蹲了十年监狱不无关系。</p>
<p>坐牢还坐出好来了，所以有时候经历点挫折也不是坏事。</p>
<h1 id="二"><a href="#二" class="headerlink" title="二"></a>二</h1><p>她18岁考入上海交通大学，2000年毕业获得学士学位。赴挪威奥斯陆大学留学，获得硕士学位、复旦大学博士。后在复旦大学留校任教。</p>
<p>这一轮下来参加工作要2008年了，交大、海归、博士哪一个不是那么靓丽，太优秀了。</p>
<p>她于2000年结婚，期间忙于学业奔波，直到2008年9月才生了孩子。</p>
<p>幸福的生活才刚刚开启，2009年十二月一场剧痛，去医院检查被告知为乳腺癌晚期，已经扩散转移！</p>
<p>医生断言，最多存活两年。。。</p>
<p>哎，天地不仁以万物为刍狗。</p>
<p>她只好放下一切，去医院接受治疗。她把自己的生病期间的痛苦、见闻写在了自己的博客。</p>
<p>她叫于娟，生于1978年，2011年4月19日在上海去世，享年33岁。</p>
<p>住院期间她写了70篇的癌症日记，去世后家人好友整理出版《此生未完成》。</p>
<p>这是老梁多年前读过的一本书，这段老梁也有点不想写，她真是太苦了，再次翻开还是太震撼了，震撼到老梁有点受不了。</p>
<p>一次次被她的乐观、坚强、挣扎、无奈、善良、幽默感动！</p>
<p>她太热爱生活了，就是想活下去，陪着孩子一天天长大。。。</p>
<p>”在生死临界点的时候，你会发现，任何的加班（长期熬夜等于慢性自杀），给自己太多的压力，买房买车的需求，这些都是浮云。如果有时间，好好陪陪你的孩子，把买车的钱给父母亲买双鞋子，不要拼命去换什么大房子，和相爱的人在一起，蜗居也温暖。“</p>
<p>”三十岁之前的努力更多是因为自己有着太多的欲望和执著，从没有“只要活着就好”的简单。我不是高僧，若不是这病患，自然放不下尘世。这场癌症却让我不得不放下一切。如此一来，索性简单了，索性真的很容易快乐。若天有定数，我过好我的每一天就是。若天不绝我，那么癌症却真是个警钟：我何苦像之前的三十年那样辛勤地做蚍蜉。名利权情，没有一样是不辛苦的，却没有一样可以带去。“</p>
<p>”生不如死、九死一生、死里逃生、生生死死后，我突然觉得，一生轻松。不想去控制大局小局，不想去多管闲事，我不再有对手，</p>
<p>不再有敌人，我也不关心。“</p>
<p>”透过生死，你会觉得名利权情都很虚无，尤其是首当其冲的名，说穿了，无非是别人茶余饭后的谈资。即便你名声四海皆知响彻云天，也无非是一时猎奇，各种各样的人揣着各种各样的心态唾沫四溅过后，你仍然是你，其实，你一直是你，只是别人在谈论你的时候，你忘记了你自己是谁而已。“</p>
<p>”我甚至想，哪怕就让我那般痛，痛得不能动，每日像个瘫痪的人，污衣垢面趴在国泰路和政立路的十字路口上，任千人唾骂万人践踏，只要能看着爸妈牵着土豆的手蹦蹦跳跳去幼儿园上学，我也是愿意的。“</p>
<p>…</p>
<p>于娟会是一直感动着我的人，每次读她的《此生未完成》情不自禁饱含着泪水。</p>
<h1 id="三"><a href="#三" class="headerlink" title="三"></a>三</h1><p>写在后面的话。。。</p>
<p>杨博坐牢那十年，旦夕不保的日子是怎么熬过的呢？</p>
<p>答：杨博的方式是读书！</p>
<p>于娟在经历癌症痛苦，病痛折磨是如何熬过的呢？</p>
<p>答：于娟的方式是写博客！把她患病以来的所见、所闻、所思写出来，希望能帮助更多的人！她说：“我做不了什么了，能做的只有无畏施了。”</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>思考随记</category>
      </categories>
      <tags>
        <tag>思考随记</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ13# RocketMQ性能测试</title>
    <url>/posts/5d180165/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.概述</span><br><span class="line"></span><br><span class="line">2.1个线程测试记录</span><br><span class="line"></span><br><span class="line">a.1个线程 消息1K 8个队列</span><br><span class="line"></span><br><span class="line">b.1个线程 消息3K 8个队列</span><br><span class="line"></span><br><span class="line">c.1个线程 消息1K 16个队列</span><br><span class="line"></span><br><span class="line">d.1个线程 消息3K 16个队列</span><br><span class="line"></span><br><span class="line">3.10个线程测试记录</span><br><span class="line"></span><br><span class="line">a.10个线程 消息1K 8个队列</span><br><span class="line"></span><br><span class="line">b.10个线程 消息3K 8个队列</span><br><span class="line"></span><br><span class="line">c.10个线程 消息1K 16个队列</span><br><span class="line"></span><br><span class="line">d.10个线程 消息3K 16个队列</span><br><span class="line"></span><br><span class="line">4.30个线程测试记录</span><br><span class="line"></span><br><span class="line">a.30个线程 消息1K 8个队列</span><br><span class="line"></span><br><span class="line">b.30个线程 消息3K 8个队列</span><br><span class="line"></span><br><span class="line">c.30个线程 消息1K 16个队列</span><br><span class="line"></span><br><span class="line">d.30个线程 消息3K 16个队列</span><br><span class="line"></span><br><span class="line">5.45个线程测试记录</span><br><span class="line"></span><br><span class="line">a.45个线程 消息1K 8个队列</span><br><span class="line"></span><br><span class="line">b.45个线程 消息3K 8个队列</span><br><span class="line"></span><br><span class="line">c.45个线程 消息1K 16个队列</span><br><span class="line"></span><br><span class="line">d.45个线程 消息3K 16个队列</span><br><span class="line"></span><br><span class="line">6.60个线程测试记录</span><br><span class="line"></span><br><span class="line">a.60个线程 消息1K 8个队列</span><br><span class="line"></span><br><span class="line">b.60个线程 消息3K 8个队列</span><br><span class="line"></span><br><span class="line">c.60个线程 消息1K 16个队列</span><br><span class="line"></span><br><span class="line">d.60个线程 消息3K 16个队列</span><br><span class="line"></span><br><span class="line">7.75个线程测试记录</span><br><span class="line"></span><br><span class="line">a.75个线程 消息1K 8个队列</span><br><span class="line"></span><br><span class="line">b.75个线程 消息3K 8个队列</span><br><span class="line"></span><br><span class="line">c.75个线程 消息1K 16个队列</span><br><span class="line"></span><br><span class="line">d.75个线程 消息3K 16个队列</span><br><span class="line"></span><br><span class="line">8.100个线程测试记录</span><br><span class="line"></span><br><span class="line">a.100个线程 消息1K 8个队列</span><br><span class="line"></span><br><span class="line">b.100个线程 消息3K 8个队列</span><br><span class="line"></span><br><span class="line">c.100个线程 消息1K 16个队列</span><br><span class="line"></span><br><span class="line">d.100个线程 消息3K 16个队列</span><br><span class="line"></span><br><span class="line">9.150个线程测试记录</span><br><span class="line"></span><br><span class="line">a.150个线程 消息1K 8个队列</span><br><span class="line"></span><br><span class="line">b.150个线程 消息3K 8个队列</span><br><span class="line"></span><br><span class="line">c.150个线程 消息1K 16个队列</span><br><span class="line"></span><br><span class="line">d.150个线程 消息3K 16个队列</span><br><span class="line"></span><br><span class="line">10.200个线程测试记录</span><br><span class="line"></span><br><span class="line">a.200个线程 消息1K 8个队列</span><br><span class="line"></span><br><span class="line">b.200个线程 消息3K 8个队列</span><br><span class="line"></span><br><span class="line">c.200个线程 消息1K 16个队列</span><br><span class="line"></span><br><span class="line">d.200个线程 消息3K 16个队列</span><br></pre></td></tr></table></figure>



<a id="more"></a>



<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>目的：对生产环境RocketMQ集群进行性能测试,该集群4主4从。</p>
<p>过程：线程数1、线程数10、线程数30、线程数60、线程数100、线程数150、线程数200对消息大小为1K、3K；队列为8个、16个分别进行测试。</p>
<p>结果：其中最大TPS为12.6万，最小TPS为3.6万。</p>
<h1 id="1个线程测试记录"><a href="#1个线程测试记录" class="headerlink" title="1个线程测试记录"></a>1个线程测试记录</h1><h3 id="1个线程-消息1K-8个队列"><a href="#1个线程-消息1K-8个队列" class="headerlink" title="1个线程 消息1K 8个队列"></a>1个线程 消息1K 8个队列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh producer.sh -t zms-clusterB-perf-tst8 -w 1 -s 1024 -n 192.168.x.x:9876</span><br><span class="line"></span><br><span class="line">Send TPS: 4281 Max RT: 299 Average RT: 0.233 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 4237 Max RT: 299 Average RT: 0.236 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 4533 Max RT: 299 Average RT: 0.221 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 4404 Max RT: 299 Average RT: 0.227 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 4360 Max RT: 299 Average RT: 0.229 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 4269 Max RT: 299 Average RT: 0.234 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 4319 Max RT: 299 Average RT: 0.231 Send Failed: 0 Response Failed: 0</span><br></pre></td></tr></table></figure>



<h3 id="1个线程-消息3K-8个队列"><a href="#1个线程-消息3K-8个队列" class="headerlink" title="1个线程 消息3K 8个队列"></a>1个线程 消息3K 8个队列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh producer.sh -t zms-clusterB-perf-tst8 -w 1 -s 3072 -n 192.168.x.x:9876</span><br><span class="line"></span><br><span class="line">Send TPS: 4120 Max RT: 255 Average RT: 0.242 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 4054 Max RT: 255 Average RT: 0.246 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 4010 Max RT: 255 Average RT: 0.249 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 4125 Max RT: 255 Average RT: 0.242 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 4093 Max RT: 255 Average RT: 0.244 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 4093 Max RT: 255 Average RT: 0.244 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 3999 Max RT: 255 Average RT: 0.250 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 3957 Max RT: 255 Average RT: 0.253 Send Failed: 0 Response Failed: 0</span><br></pre></td></tr></table></figure>

<h3 id="1个线程-消息1K-16个队列"><a href="#1个线程-消息1K-16个队列" class="headerlink" title="1个线程 消息1K 16个队列"></a>1个线程 消息1K 16个队列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh producer.sh -t zms-clusterB-perf-tst16 -w 1 -s 1024 -n 192.168.x.x:9876</span><br><span class="line"></span><br><span class="line">Send TPS: 5289 Max RT: 225 Average RT: 0.189 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 5252 Max RT: 225 Average RT: 0.190 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 5124 Max RT: 225 Average RT: 0.195 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 5146 Max RT: 225 Average RT: 0.194 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 4861 Max RT: 225 Average RT: 0.206 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 4998 Max RT: 225 Average RT: 0.200 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 5063 Max RT: 225 Average RT: 0.198 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 5039 Max RT: 225 Average RT: 0.198 Send Failed: 0 Response Failed: 0</span><br></pre></td></tr></table></figure>

<h3 id="1个线程-消息3K-16个队列"><a href="#1个线程-消息3K-16个队列" class="headerlink" title="1个线程 消息3K 16个队列"></a>1个线程 消息3K 16个队列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh producer.sh -t zms-clusterB-perf-tst16 -w 1 -s 3072 -n 192.168.x.x:9876</span><br><span class="line"></span><br><span class="line">Send TPS: 4778 Max RT: 244 Average RT: 0.209 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 5011 Max RT: 244 Average RT: 0.199 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 4826 Max RT: 244 Average RT: 0.207 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 4762 Max RT: 244 Average RT: 0.210 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 4663 Max RT: 244 Average RT: 0.214 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 4648 Max RT: 244 Average RT: 0.215 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 4778 Max RT: 244 Average RT: 0.209 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 4737 Max RT: 244 Average RT: 0.211 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 4523 Max RT: 244 Average RT: 0.221 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 4544 Max RT: 244 Average RT: 0.220 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 4683 Max RT: 244 Average RT: 0.213 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 4838 Max RT: 244 Average RT: 0.207 Send Failed: 0 Response Failed: 0</span><br></pre></td></tr></table></figure>





<h1 id="10个线程测试记录"><a href="#10个线程测试记录" class="headerlink" title="10个线程测试记录"></a>10个线程测试记录</h1><h3 id="10个线程-消息1K-8个队列"><a href="#10个线程-消息1K-8个队列" class="headerlink" title="10个线程 消息1K 8个队列"></a>10个线程 消息1K 8个队列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh producer.sh -t zms-clusterB-perf-tst16 -w 1 -s 3072 -n 192.168.x.x:9876</span><br><span class="line"></span><br><span class="line">Send TPS: 4778 Max RT: 244 Average RT: 0.209 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 5011 Max RT: 244 Average RT: 0.199 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 4826 Max RT: 244 Average RT: 0.207 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 4762 Max RT: 244 Average RT: 0.210 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 4663 Max RT: 244 Average RT: 0.214 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 4648 Max RT: 244 Average RT: 0.215 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 4778 Max RT: 244 Average RT: 0.209 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 4737 Max RT: 244 Average RT: 0.211 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 4523 Max RT: 244 Average RT: 0.221 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 4544 Max RT: 244 Average RT: 0.220 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 4683 Max RT: 244 Average RT: 0.213 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 4838 Max RT: 244 Average RT: 0.207 Send Failed: 0 Response Failed: 0</span><br></pre></td></tr></table></figure>



<h3 id="10个线程-消息3K-8个队列"><a href="#10个线程-消息3K-8个队列" class="headerlink" title="10个线程 消息3K 8个队列"></a>10个线程 消息3K 8个队列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh producer.sh -t zms-clusterB-perf-tst8 -w 10 -s 3072 -n 192.168.x.x:9876</span><br><span class="line"></span><br><span class="line">Send TPS: 40085 Max RT: 265 Average RT: 0.249 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 37710 Max RT: 265 Average RT: 0.265 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 39305 Max RT: 265 Average RT: 0.254 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 39881 Max RT: 265 Average RT: 0.251 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 38428 Max RT: 265 Average RT: 0.260 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 39280 Max RT: 265 Average RT: 0.255 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 38539 Max RT: 265 Average RT: 0.259 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 40927 Max RT: 265 Average RT: 0.244 Send Failed: 0 Response Failed: 0</span><br></pre></td></tr></table></figure>



<h3 id="10个线程-消息1K-16个队列"><a href="#10个线程-消息1K-16个队列" class="headerlink" title="10个线程 消息1K 16个队列"></a>10个线程 消息1K 16个队列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh producer.sh -t zms-clusterB-perf-tst16 -w 10 -s 1024 -n 192.168.x.x:9876</span><br><span class="line"></span><br><span class="line">Send TPS: 41301 Max RT: 243 Average RT: 0.242 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 42365 Max RT: 243 Average RT: 0.236 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 42181 Max RT: 243 Average RT: 0.237 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 42261 Max RT: 243 Average RT: 0.237 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 40831 Max RT: 243 Average RT: 0.245 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 43010 Max RT: 243 Average RT: 0.232 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 41871 Max RT: 243 Average RT: 0.239 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 40970 Max RT: 243 Average RT: 0.244 Send Failed: 0 Response Failed: 0</span><br></pre></td></tr></table></figure>



<h3 id="10个线程-消息3K-16个队列"><a href="#10个线程-消息3K-16个队列" class="headerlink" title="10个线程 消息3K 16个队列"></a>10个线程 消息3K 16个队列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh producer.sh -t zms-clusterB-perf-tst16 -w 10 -s 3072 -n 192.168.x.x:9876</span><br><span class="line"></span><br><span class="line">Send TPS: 36245 Max RT: 237 Average RT: 0.276 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 38713 Max RT: 237 Average RT: 0.258 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 36327 Max RT: 237 Average RT: 0.275 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 39005 Max RT: 237 Average RT: 0.256 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 37926 Max RT: 237 Average RT: 0.264 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 38804 Max RT: 237 Average RT: 0.258 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 39976 Max RT: 237 Average RT: 0.250 Send Failed: 0 Response Failed: 0</span><br></pre></td></tr></table></figure>



<h1 id="30个线程测试记录"><a href="#30个线程测试记录" class="headerlink" title="30个线程测试记录"></a>30个线程测试记录</h1><h3 id="30个线程-消息1K-8个队列"><a href="#30个线程-消息1K-8个队列" class="headerlink" title="30个线程 消息1K 8个队列"></a>30个线程 消息1K 8个队列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh producer.sh -t zms-clusterB-perf-tst8 -w 30 -s 1024 -n 192.168.x.x:9876</span><br><span class="line"></span><br><span class="line">Send TPS: 86259 Max RT: 309 Average RT: 0.348 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 85335 Max RT: 309 Average RT: 0.351 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 81850 Max RT: 309 Average RT: 0.366 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 87712 Max RT: 309 Average RT: 0.342 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 89288 Max RT: 309 Average RT: 0.336 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 86732 Max RT: 309 Average RT: 0.346 Send Failed: 0 Response Failed: 0</span><br></pre></td></tr></table></figure>



<h3 id="30个线程-消息3K-8个队列"><a href="#30个线程-消息3K-8个队列" class="headerlink" title="30个线程 消息3K 8个队列"></a>30个线程 消息3K 8个队列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh producer.sh -t zms-clusterB-perf-tst8 -w 30 -s 3072 -n 192.168.x.x:9876</span><br><span class="line"></span><br><span class="line">Send TPS: 74085 Max RT: 334 Average RT: 0.405 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 71014 Max RT: 334 Average RT: 0.422 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 77792 Max RT: 334 Average RT: 0.386 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 73913 Max RT: 334 Average RT: 0.406 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 77337 Max RT: 334 Average RT: 0.392 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 72184 Max RT: 334 Average RT: 0.416 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 77271 Max RT: 334 Average RT: 0.388 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 75016 Max RT: 334 Average RT: 0.400 Send Failed: 0 Response Failed: 0</span><br></pre></td></tr></table></figure>



<h3 id="30个线程-消息1K-16个队列"><a href="#30个线程-消息1K-16个队列" class="headerlink" title="30个线程 消息1K 16个队列"></a>30个线程 消息1K 16个队列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh producer.sh -t zms-clusterB-perf-tst16 -w 30 -s 1024 -n 192.168.x.x:9876</span><br><span class="line"></span><br><span class="line">Send TPS: 82946 Max RT: 306 Average RT: 0.362 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 86902 Max RT: 306 Average RT: 0.345 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 83157 Max RT: 306 Average RT: 0.365 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 86804 Max RT: 306 Average RT: 0.345 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 87009 Max RT: 306 Average RT: 0.345 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 80219 Max RT: 306 Average RT: 0.374 Send Failed: 0 Response Failed: 0</span><br></pre></td></tr></table></figure>



<h3 id="30个线程-消息3K-16个队列"><a href="#30个线程-消息3K-16个队列" class="headerlink" title="30个线程 消息3K 16个队列"></a>30个线程 消息3K 16个队列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh producer.sh -t zms-clusterB-perf-tst16 -w 30 -s 3072 -n 192.168.x.x:9876</span><br><span class="line"></span><br><span class="line">Send TPS: 73864 Max RT: 329 Average RT: 0.403 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 78555 Max RT: 329 Average RT: 0.382 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 75200 Max RT: 329 Average RT: 0.406 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 73925 Max RT: 329 Average RT: 0.406 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 69955 Max RT: 329 Average RT: 0.429 Send Failed: 0 Response Failed: 0</span><br></pre></td></tr></table></figure>



<h1 id="45个线程测试记录"><a href="#45个线程测试记录" class="headerlink" title="45个线程测试记录"></a>45个线程测试记录</h1><h3 id="45个线程-消息1K-8个队列"><a href="#45个线程-消息1K-8个队列" class="headerlink" title="45个线程 消息1K 8个队列"></a>45个线程 消息1K 8个队列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh producer.sh -t zms-clusterB-perf-tst8 -w 45 -s 1024 -n 192.168.x.x:9876</span><br><span class="line"></span><br><span class="line">Send TPS: 91266 Max RT: 2063 Average RT: 0.493 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 87279 Max RT: 2063 Average RT: 0.515 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 92130 Max RT: 2063 Average RT: 0.487 Send Failed: 0 Response Failed: 1</span><br><span class="line"></span><br><span class="line">Send TPS: 95227 Max RT: 2063 Average RT: 0.472 Send Failed: 0 Response Failed: 1</span><br><span class="line"></span><br><span class="line">Send TPS: 96340 Max RT: 2063 Average RT: 0.467 Send Failed: 0 Response Failed: 1</span><br><span class="line"></span><br><span class="line">Send TPS: 84272 Max RT: 2063 Average RT: 0.534 Send Failed: 0 Response Failed: 1</span><br></pre></td></tr></table></figure>



<h3 id="45个线程-消息3K-8个队列"><a href="#45个线程-消息3K-8个队列" class="headerlink" title="45个线程 消息3K 8个队列"></a>45个线程 消息3K 8个队列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh producer.sh -t zms-clusterB-perf-tst8 -w 45 -s 3072 -n 192.168.x.x:9876</span><br><span class="line"></span><br><span class="line">Send TPS: 89334 Max RT: 462 Average RT: 0.503 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 84237 Max RT: 462 Average RT: 0.534 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 86051 Max RT: 462 Average RT: 0.523 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 86475 Max RT: 462 Average RT: 0.520 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 86088 Max RT: 462 Average RT: 0.523 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 90403 Max RT: 462 Average RT: 0.498 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 84229 Max RT: 462 Average RT: 0.534 Send Failed: 0 Response Failed: 0</span><br></pre></td></tr></table></figure>



<h3 id="45个线程-消息1K-16个队列"><a href="#45个线程-消息1K-16个队列" class="headerlink" title="45个线程 消息1K 16个队列"></a>45个线程 消息1K 16个队列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh producer.sh -t zms-clusterB-perf-tst16 -w 45 -s 1024 -n 192.168.x.:9876</span><br><span class="line"></span><br><span class="line">Send TPS: 91724 Max RT: 604 Average RT: 0.490 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 90414 Max RT: 604 Average RT: 0.498 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 89904 Max RT: 604 Average RT: 0.500 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 100158 Max RT: 604 Average RT: 0.449 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 99658 Max RT: 604 Average RT: 0.451 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 92440 Max RT: 604 Average RT: 0.489 Send Failed: 0 Response Failed: 0</span><br></pre></td></tr></table></figure>



<h3 id="45个线程-消息3K-16个队列"><a href="#45个线程-消息3K-16个队列" class="headerlink" title="45个线程 消息3K 16个队列"></a>45个线程 消息3K 16个队列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh producer.sh -t zms-clusterB-perf-tst16 -w 30 -s 3072 -n 192.168.x.x:9876</span><br><span class="line"></span><br><span class="line">Send TPS: 75159 Max RT: 436 Average RT: 0.399 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 75315 Max RT: 436 Average RT: 0.398 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 77297 Max RT: 436 Average RT: 0.388 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 72188 Max RT: 436 Average RT: 0.415 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 77525 Max RT: 436 Average RT: 0.387 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 71535 Max RT: 436 Average RT: 0.422 Send Failed: 0 Response Failed: 0</span><br></pre></td></tr></table></figure>





<h1 id="60个线程测试记录"><a href="#60个线程测试记录" class="headerlink" title="60个线程测试记录"></a>60个线程测试记录</h1><h3 id="60个线程-消息1K-8个队列"><a href="#60个线程-消息1K-8个队列" class="headerlink" title="60个线程 消息1K 8个队列"></a>60个线程 消息1K 8个队列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh producer.sh -t zms-clusterB-perf-tst8 -w 60 -s 1024 -n 192.168.x.x:9876</span><br><span class="line"></span><br><span class="line">Send TPS: 110067 Max RT: 369 Average RT: 0.545 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 111395 Max RT: 369 Average RT: 0.538 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 103114 Max RT: 369 Average RT: 0.582 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 107466 Max RT: 369 Average RT: 0.558 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 106655 Max RT: 369 Average RT: 0.562 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 107241 Max RT: 369 Average RT: 0.559 Send Failed: 0 Response Failed: 1</span><br><span class="line"></span><br><span class="line">Send TPS: 110672 Max RT: 369 Average RT: 0.540 Send Failed: 0 Response Failed: 1</span><br><span class="line"></span><br><span class="line">Send TPS: 109037 Max RT: 369 Average RT: 0.552 Send Failed: 0 Response Failed: 1</span><br></pre></td></tr></table></figure>



<h3 id="60个线程-消息3K-8个队列"><a href="#60个线程-消息3K-8个队列" class="headerlink" title="60个线程 消息3K 8个队列"></a>60个线程 消息3K 8个队列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh producer.sh -t zms-clusterB-perf-tst8 -w 60 -s 3072 -n 192.168.x.x:9876</span><br><span class="line"></span><br><span class="line">Send TPS: 92572 Max RT: 583 Average RT: 0.648 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 95163 Max RT: 583 Average RT: 0.640 Send Failed: 0 Response Failed: 1</span><br><span class="line"></span><br><span class="line">Send TPS: 93823 Max RT: 583 Average RT: 0.654 Send Failed: 0 Response Failed: 1</span><br><span class="line"></span><br><span class="line">Send TPS: 97091 Max RT: 583 Average RT: 0.628 Send Failed: 0 Response Failed: 1</span><br><span class="line"></span><br><span class="line">Send TPS: 98205 Max RT: 583 Average RT: 0.628 Send Failed: 0 Response Failed: 1</span><br><span class="line"></span><br><span class="line">Send TPS: 99535 Max RT: 583 Average RT: 0.596 Send Failed: 0 Response Failed: 3</span><br></pre></td></tr></table></figure>



<h3 id="60个线程-消息1K-16个队列"><a href="#60个线程-消息1K-16个队列" class="headerlink" title="60个线程 消息1K 16个队列"></a>60个线程 消息1K 16个队列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh producer.sh -t zms-clusterB-perf-tst16 -w 60 -s 1024 -n 192.168.x.x:9876</span><br><span class="line"></span><br><span class="line">Send TPS: 105229 Max RT: 358 Average RT: 0.578 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 103003 Max RT: 358 Average RT: 0.582 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 95497 Max RT: 358 Average RT: 0.628 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 108878 Max RT: 358 Average RT: 0.551 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 109265 Max RT: 358 Average RT: 0.549 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 105545 Max RT: 358 Average RT: 0.568 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 111667 Max RT: 358 Average RT: 0.537 Send Failed: 0 Response Failed: 0</span><br></pre></td></tr></table></figure>



<h3 id="60个线程-消息3K-16个队列"><a href="#60个线程-消息3K-16个队列" class="headerlink" title="60个线程 消息3K 16个队列"></a>60个线程 消息3K 16个队列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh producer.sh -t zms-clusterB-perf-tst16 -w 60 -s 3072 -n 192.168.x.x:9876</span><br><span class="line"></span><br><span class="line">Send TPS: 98899 Max RT: 358 Average RT: 0.606 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 101073 Max RT: 358 Average RT: 0.594 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 97295 Max RT: 358 Average RT: 0.617 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 97923 Max RT: 358 Average RT: 0.609 Send Failed: 0 Response Failed: 1</span><br><span class="line"></span><br><span class="line">Send TPS: 96111 Max RT: 358 Average RT: 0.620 Send Failed: 0 Response Failed: 2</span><br><span class="line"></span><br><span class="line">Send TPS: 93873 Max RT: 358 Average RT: 0.639 Send Failed: 0 Response Failed: 2</span><br><span class="line"></span><br><span class="line">Send TPS: 96466 Max RT: 358 Average RT: 0.622 Send Failed: 0 Response Failed: 2</span><br><span class="line"></span><br><span class="line">Send TPS: 96579 Max RT: 358 Average RT: 0.621 Send Failed: 0 Response Failed: 2</span><br></pre></td></tr></table></figure>



<h1 id="75个线程测试记录"><a href="#75个线程测试记录" class="headerlink" title="75个线程测试记录"></a>75个线程测试记录</h1><h3 id="75个线程-消息1K-8个队列"><a href="#75个线程-消息1K-8个队列" class="headerlink" title="75个线程 消息1K 8个队列"></a>75个线程 消息1K 8个队列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh producer.sh -t zms-clusterB-perf-tst8 -w 75 -s 1024 -n 192.168.x.x:9876</span><br><span class="line"></span><br><span class="line">Send TPS: 108367 Max RT: 384 Average RT: 0.692 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 107516 Max RT: 384 Average RT: 0.701 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 110974 Max RT: 384 Average RT: 0.680 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 109754 Max RT: 384 Average RT: 0.683 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 111917 Max RT: 384 Average RT: 0.670 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 104764 Max RT: 384 Average RT: 0.712 Send Failed: 0 Response Failed: 1</span><br><span class="line"></span><br><span class="line">Send TPS: 112208 Max RT: 384 Average RT: 0.668 Send Failed: 0 Response Failed: 1</span><br><span class="line"></span><br><span class="line">Send TPS: 112707 Max RT: 384 Average RT: 0.665 Send Failed: 0 Response Failed: 1</span><br></pre></td></tr></table></figure>



<h3 id="75个线程-消息3K-8个队列"><a href="#75个线程-消息3K-8个队列" class="headerlink" title="75个线程 消息3K 8个队列"></a>75个线程 消息3K 8个队列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh producer.sh -t zms-clusterB-perf-tst8 -w 75 -s 3072 -n 192.168.x.x:9876</span><br><span class="line"></span><br><span class="line">Send TPS: 102311 Max RT: 370 Average RT: 0.733 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 93722 Max RT: 370 Average RT: 0.800 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 101091 Max RT: 370 Average RT: 0.742 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 100404 Max RT: 370 Average RT: 0.747 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 102328 Max RT: 370 Average RT: 0.733 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 103953 Max RT: 370 Average RT: 0.722 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 103454 Max RT: 370 Average RT: 0.725 Send Failed: 0 Response Failed: 0</span><br></pre></td></tr></table></figure>



<h3 id="75个线程-消息1K-16个队列"><a href="#75个线程-消息1K-16个队列" class="headerlink" title="75个线程 消息1K 16个队列"></a>75个线程 消息1K 16个队列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh producer.sh -t zms-clusterB-perf-tst16 -w 75 -s 1024 -n 192.168.x.x:9876</span><br><span class="line"></span><br><span class="line">Send TPS: 106813 Max RT: 605 Average RT: 0.687 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 110828 Max RT: 605 Average RT: 0.673 Send Failed: 0 Response Failed: 1</span><br><span class="line"></span><br><span class="line">Send TPS: 109855 Max RT: 605 Average RT: 0.676 Send Failed: 0 Response Failed: 3</span><br><span class="line"></span><br><span class="line">Send TPS: 102741 Max RT: 605 Average RT: 0.730 Send Failed: 0 Response Failed: 3</span><br><span class="line"></span><br><span class="line">Send TPS: 110123 Max RT: 605 Average RT: 0.681 Send Failed: 0 Response Failed: 3</span><br><span class="line"></span><br><span class="line">Send TPS: 115659 Max RT: 605 Average RT: 0.648 Send Failed: 0 Response Failed: 3</span><br><span class="line"></span><br><span class="line">Send TPS: 108157 Max RT: 605 Average RT: 0.693 Send Failed: 0 Response Failed: 3</span><br></pre></td></tr></table></figure>



<h3 id="75个线程-消息3K-16个队列"><a href="#75个线程-消息3K-16个队列" class="headerlink" title="75个线程 消息3K 16个队列"></a>75个线程 消息3K 16个队列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh producer.sh -t zms-clusterB-perf-tst16 -w 75 -s 3072 -n 192.168.x.x:9876</span><br><span class="line"></span><br><span class="line">Send TPS: 90459 Max RT: 499 Average RT: 0.829 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 96838 Max RT: 499 Average RT: 0.770 Send Failed: 0 Response Failed: 1</span><br><span class="line"></span><br><span class="line">Send TPS: 96590 Max RT: 499 Average RT: 0.776 Send Failed: 0 Response Failed: 1</span><br><span class="line"></span><br><span class="line">Send TPS: 95137 Max RT: 499 Average RT: 0.788 Send Failed: 0 Response Failed: 1</span><br><span class="line"></span><br><span class="line">Send TPS: 89502 Max RT: 499 Average RT: 0.834 Send Failed: 0 Response Failed: 2</span><br><span class="line"></span><br><span class="line">Send TPS: 90255 Max RT: 499 Average RT: 0.831 Send Failed: 0 Response Failed: 2</span><br><span class="line"></span><br><span class="line">Send TPS: 99871 Max RT: 499 Average RT: 0.725 Send Failed: 0 Response Failed: 9</span><br></pre></td></tr></table></figure>



<h1 id="100个线程测试记录"><a href="#100个线程测试记录" class="headerlink" title="100个线程测试记录"></a>100个线程测试记录</h1><h3 id="100个线程-消息1K-8个队列"><a href="#100个线程-消息1K-8个队列" class="headerlink" title="100个线程 消息1K 8个队列"></a>100个线程 消息1K 8个队列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh producer.sh -t zms-clusterB-perf-tst8 -w 100 -s 1024 -n 192.168.x.x:9876</span><br><span class="line"></span><br><span class="line">Send TPS: 113204 Max RT: 402 Average RT: 0.883 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 114872 Max RT: 402 Average RT: 0.868 Send Failed: 0 Response Failed: 1</span><br><span class="line"></span><br><span class="line">Send TPS: 116261 Max RT: 402 Average RT: 0.860 Send Failed: 0 Response Failed: 1</span><br><span class="line"></span><br><span class="line">Send TPS: 118116 Max RT: 402 Average RT: 0.847 Send Failed: 0 Response Failed: 1</span><br><span class="line"></span><br><span class="line">Send TPS: 112594 Max RT: 402 Average RT: 0.888 Send Failed: 0 Response Failed: 1</span><br><span class="line"></span><br><span class="line">Send TPS: 124407 Max RT: 402 Average RT: 0.801 Send Failed: 0 Response Failed: 2</span><br><span class="line"></span><br><span class="line">Send TPS: 126590 Max RT: 402 Average RT: 0.790 Send Failed: 0 Response Failed: 2</span><br></pre></td></tr></table></figure>



<h3 id="100个线程-消息3K-8个队列"><a href="#100个线程-消息3K-8个队列" class="headerlink" title="100个线程 消息3K 8个队列"></a>100个线程 消息3K 8个队列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh producer.sh -t zms-clusterB-perf-tst8 -w 100 -s 3072 -n 192.168.x.x:9876</span><br><span class="line"></span><br><span class="line">Send TPS: 106723 Max RT: 426 Average RT: 0.937 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 104768 Max RT: 426 Average RT: 0.943 Send Failed: 0 Response Failed: 1</span><br><span class="line"></span><br><span class="line">Send TPS: 106697 Max RT: 426 Average RT: 0.935 Send Failed: 0 Response Failed: 2</span><br><span class="line"></span><br><span class="line">Send TPS: 105147 Max RT: 426 Average RT: 0.951 Send Failed: 0 Response Failed: 2</span><br><span class="line"></span><br><span class="line">Send TPS: 105814 Max RT: 426 Average RT: 0.935 Send Failed: 0 Response Failed: 5</span><br><span class="line"></span><br><span class="line">Send TPS: 108616 Max RT: 426 Average RT: 0.916 Send Failed: 0 Response Failed: 6</span><br><span class="line"></span><br><span class="line">Send TPS: 101429 Max RT: 426 Average RT: 0.986 Send Failed: 0 Response Failed: 6</span><br></pre></td></tr></table></figure>



<h3 id="100个线程-消息1K-16个队列"><a href="#100个线程-消息1K-16个队列" class="headerlink" title="100个线程 消息1K 16个队列"></a>100个线程 消息1K 16个队列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh producer.sh -t zms-clusterB-perf-tst16 -w 100 -s 1024 -n 192.168.x.x:9876</span><br><span class="line"></span><br><span class="line">Send TPS: 123424 Max RT: 438 Average RT: 0.805 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 111418 Max RT: 438 Average RT: 0.897 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 110360 Max RT: 438 Average RT: 0.905 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 118734 Max RT: 438 Average RT: 0.842 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 120725 Max RT: 438 Average RT: 0.816 Send Failed: 0 Response Failed: 4</span><br><span class="line"></span><br><span class="line">Send TPS: 113823 Max RT: 438 Average RT: 0.878 Send Failed: 0 Response Failed: 4</span><br><span class="line"></span><br><span class="line">Send TPS: 115639 Max RT: 438 Average RT: 0.865 Send Failed: 0 Response Failed: 4</span><br><span class="line"></span><br><span class="line">Send TPS: 112787 Max RT: 438 Average RT: 0.889 Send Failed: 0 Response Failed: 4</span><br><span class="line"></span><br><span class="line">Send TPS: 106677 Max RT: 438 Average RT: 0.937 Send Failed: 0 Response Failed: 4</span><br><span class="line"></span><br><span class="line">Send TPS: 112635 Max RT: 438 Average RT: 0.888 Send Failed: 0 Response Failed: 4</span><br><span class="line"></span><br><span class="line">Send TPS: 108470 Max RT: 438 Average RT: 0.922 Send Failed: 0 Response Failed: 4</span><br></pre></td></tr></table></figure>



<h3 id="100个线程-消息3K-16个队列"><a href="#100个线程-消息3K-16个队列" class="headerlink" title="100个线程 消息3K 16个队列"></a>100个线程 消息3K 16个队列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh producer.sh -t zms-clusterB-perf-tst16 -w 100 -s 3072 -n 192.168.x.x:9876</span><br><span class="line"></span><br><span class="line">Send TPS: 93374 Max RT: 441 Average RT: 1.071 Send Failed: 0 Response Failed: 3</span><br><span class="line"></span><br><span class="line">Send TPS: 98421 Max RT: 441 Average RT: 1.017 Send Failed: 0 Response Failed: 3</span><br><span class="line"></span><br><span class="line">Send TPS: 103664 Max RT: 441 Average RT: 0.964 Send Failed: 0 Response Failed: 4</span><br><span class="line"></span><br><span class="line">Send TPS: 98234 Max RT: 441 Average RT: 0.995 Send Failed: 0 Response Failed: 6</span><br><span class="line"></span><br><span class="line">Send TPS: 103563 Max RT: 441 Average RT: 0.960 Send Failed: 0 Response Failed: 7</span><br><span class="line"></span><br><span class="line">Send TPS: 103807 Max RT: 441 Average RT: 0.962 Send Failed: 0 Response Failed: 7</span><br><span class="line"></span><br><span class="line">Send TPS: 102715 Max RT: 441 Average RT: 0.973 Send Failed: 0 Response Failed: 7</span><br></pre></td></tr></table></figure>



<h1 id="150个线程测试记录"><a href="#150个线程测试记录" class="headerlink" title="150个线程测试记录"></a>150个线程测试记录</h1><h3 id="150个线程-消息1K-8个队列"><a href="#150个线程-消息1K-8个队列" class="headerlink" title="150个线程 消息1K 8个队列"></a>150个线程 消息1K 8个队列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh producer.sh -t zms-clusterB-perf-tst8 -w 150 -s 1024 -n 192.168.x.x:9876</span><br><span class="line"></span><br><span class="line">Send TPS: 124458 Max RT: 633 Average RT: 1.205 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 124567 Max RT: 633 Average RT: 1.204 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 121324 Max RT: 633 Average RT: 1.236 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 124928 Max RT: 633 Average RT: 1.201 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 122830 Max RT: 633 Average RT: 1.242 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 118825 Max RT: 633 Average RT: 1.262 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 124085 Max RT: 633 Average RT: 1.209 Send Failed: 0 Response Failed: 0</span><br></pre></td></tr></table></figure>



<h3 id="150个线程-消息3K-8个队列"><a href="#150个线程-消息3K-8个队列" class="headerlink" title="150个线程 消息3K 8个队列"></a>150个线程 消息3K 8个队列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh producer.sh -t zms-clusterB-perf-tst8 -w 150 -s 3072 -n 192.168.x.x:9876</span><br><span class="line"></span><br><span class="line">Send TPS: 106575 Max RT: 582 Average RT: 1.404 Send Failed: 0 Response Failed: 1</span><br><span class="line"></span><br><span class="line">Send TPS: 101830 Max RT: 582 Average RT: 1.477 Send Failed: 0 Response Failed: 1</span><br><span class="line"></span><br><span class="line">Send TPS: 99666 Max RT: 582 Average RT: 1.505 Send Failed: 0 Response Failed: 1</span><br><span class="line"></span><br><span class="line">Send TPS: 102139 Max RT: 582 Average RT: 1.465 Send Failed: 0 Response Failed: 2</span><br><span class="line"></span><br><span class="line">Send TPS: 105405 Max RT: 582 Average RT: 1.419 Send Failed: 0 Response Failed: 3</span><br><span class="line"></span><br><span class="line">Send TPS: 107032 Max RT: 582 Average RT: 1.399 Send Failed: 0 Response Failed: 4</span><br><span class="line"></span><br><span class="line">Send TPS: 103416 Max RT: 582 Average RT: 1.448 Send Failed: 0 Response Failed: 5</span><br></pre></td></tr></table></figure>



<h3 id="150个线程-消息1K-16个队列"><a href="#150个线程-消息1K-16个队列" class="headerlink" title="150个线程 消息1K 16个队列"></a>150个线程 消息1K 16个队列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh producer.sh -t zms-clusterB-perf-tst16 -w 150 -s 1024 -n 192.168.x.x:9876</span><br><span class="line"></span><br><span class="line">Send TPS: 115151 Max RT: 574 Average RT: 1.299 Send Failed: 0 Response Failed: 1</span><br><span class="line"></span><br><span class="line">Send TPS: 106960 Max RT: 574 Average RT: 1.402 Send Failed: 0 Response Failed: 1</span><br><span class="line"></span><br><span class="line">Send TPS: 116382 Max RT: 574 Average RT: 1.289 Send Failed: 0 Response Failed: 1</span><br><span class="line"></span><br><span class="line">Send TPS: 110587 Max RT: 574 Average RT: 1.349 Send Failed: 0 Response Failed: 4</span><br><span class="line"></span><br><span class="line">Send TPS: 122832 Max RT: 574 Average RT: 1.220 Send Failed: 0 Response Failed: 4</span><br><span class="line"></span><br><span class="line">Send TPS: 124474 Max RT: 574 Average RT: 1.213 Send Failed: 0 Response Failed: 4</span><br><span class="line"></span><br><span class="line">Send TPS: 112153 Max RT: 574 Average RT: 1.337 Send Failed: 0 Response Failed: 4</span><br><span class="line"></span><br><span class="line">Send TPS: 120450 Max RT: 574 Average RT: 1.261 Send Failed: 0 Response Failed: 4</span><br></pre></td></tr></table></figure>



<h3 id="150个线程-消息3K-16个队列"><a href="#150个线程-消息3K-16个队列" class="headerlink" title="150个线程 消息3K 16个队列"></a>150个线程 消息3K 16个队列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh producer.sh -t zms-clusterB-perf-tst16 -w 150 -s 3072 -n 192.168.x.x:9876</span><br><span class="line"></span><br><span class="line">Send TPS: 105061 Max RT: 535 Average RT: 1.428 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 102117 Max RT: 535 Average RT: 1.465 Send Failed: 0 Response Failed: 1</span><br><span class="line"></span><br><span class="line">Send TPS: 105569 Max RT: 535 Average RT: 1.421 Send Failed: 0 Response Failed: 1</span><br><span class="line"></span><br><span class="line">Send TPS: 100689 Max RT: 535 Average RT: 1.489 Send Failed: 0 Response Failed: 2</span><br><span class="line"></span><br><span class="line">Send TPS: 108464 Max RT: 535 Average RT: 1.381 Send Failed: 0 Response Failed: 2</span><br><span class="line"></span><br><span class="line">Send TPS: 111285 Max RT: 535 Average RT: 1.348 Send Failed: 0 Response Failed: 2</span><br><span class="line"></span><br><span class="line">Send TPS: 103406 Max RT: 535 Average RT: 1.451 Send Failed: 0 Response Failed: 2</span><br><span class="line"></span><br><span class="line">Send TPS: 109203 Max RT: 535 Average RT: 1.388 Send Failed: 0 Response Failed: 2</span><br></pre></td></tr></table></figure>



<h1 id="200个线程测试记录"><a href="#200个线程测试记录" class="headerlink" title="200个线程测试记录"></a>200个线程测试记录</h1><h3 id="200个线程-消息1K-8个队列"><a href="#200个线程-消息1K-8个队列" class="headerlink" title="200个线程 消息1K 8个队列"></a>200个线程 消息1K 8个队列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh producer.sh -t zms-clusterB-perf-tst8 -w 200 -s 1024 -n 192.168.x.x:9876</span><br><span class="line"></span><br><span class="line">Send TPS: 117965 Max RT: 628 Average RT: 1.674 Send Failed: 0 Response Failed: 7</span><br><span class="line"></span><br><span class="line">Send TPS: 115583 Max RT: 628 Average RT: 1.715 Send Failed: 0 Response Failed: 12</span><br><span class="line"></span><br><span class="line">Send TPS: 118732 Max RT: 628 Average RT: 1.672 Send Failed: 0 Response Failed: 16</span><br><span class="line"></span><br><span class="line">Send TPS: 126170 Max RT: 628 Average RT: 1.582 Send Failed: 0 Response Failed: 17</span><br><span class="line"></span><br><span class="line">Send TPS: 116203 Max RT: 628 Average RT: 1.719 Send Failed: 0 Response Failed: 18</span><br><span class="line"></span><br><span class="line">Send TPS: 114793 Max RT: 628 Average RT: 1.739 Send Failed: 0 Response Failed: 19</span><br></pre></td></tr></table></figure>



<h3 id="200个线程-消息3K-8个队列"><a href="#200个线程-消息3K-8个队列" class="headerlink" title="200个线程 消息3K 8个队列"></a>200个线程 消息3K 8个队列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh producer.sh -t zms-clusterB-perf-tst8 -w 200 -s 3072 -n 192.168.x.x:9876</span><br><span class="line"></span><br><span class="line">Send TPS: 107240 Max RT: 761 Average RT: 1.865 Send Failed: 0 Response Failed: 0</span><br><span class="line"></span><br><span class="line">Send TPS: 104585 Max RT: 761 Average RT: 1.906 Send Failed: 0 Response Failed: 2</span><br><span class="line"></span><br><span class="line">Send TPS: 110892 Max RT: 761 Average RT: 1.803 Send Failed: 0 Response Failed: 2</span><br><span class="line"></span><br><span class="line">Send TPS: 105414 Max RT: 761 Average RT: 1.898 Send Failed: 0 Response Failed: 2</span><br><span class="line"></span><br><span class="line">Send TPS: 105904 Max RT: 761 Average RT: 1.885 Send Failed: 0 Response Failed: 3</span><br><span class="line"></span><br><span class="line">Send TPS: 110748 Max RT: 761 Average RT: 1.806 Send Failed: 0 Response Failed: 3</span><br></pre></td></tr></table></figure>



<h3 id="200个线程-消息1K-16个队列"><a href="#200个线程-消息1K-16个队列" class="headerlink" title="200个线程 消息1K 16个队列"></a>200个线程 消息1K 16个队列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh producer.sh -t zms-clusterB-perf-tst16 -w 200 -s 1024 -n 192.168.x.x:9876</span><br><span class="line"></span><br><span class="line">Send TPS: 118892 Max RT: 601 Average RT: 1.679 Send Failed: 0 Response Failed: 4</span><br><span class="line"></span><br><span class="line">Send TPS: 118839 Max RT: 601 Average RT: 1.668 Send Failed: 0 Response Failed: 12</span><br><span class="line"></span><br><span class="line">Send TPS: 117122 Max RT: 601 Average RT: 1.704 Send Failed: 0 Response Failed: 12</span><br><span class="line"></span><br><span class="line">Send TPS: 122670 Max RT: 601 Average RT: 1.630 Send Failed: 0 Response Failed: 12</span><br><span class="line"></span><br><span class="line">Send TPS: 119592 Max RT: 601 Average RT: 1.672 Send Failed: 0 Response Failed: 12</span><br><span class="line"></span><br><span class="line">Send TPS: 121243 Max RT: 601 Average RT: 1.649 Send Failed: 0 Response Failed: 12</span><br><span class="line"></span><br><span class="line">Send TPS: 124760 Max RT: 601 Average RT: 1.603 Send Failed: 0 Response Failed: 12</span><br><span class="line"></span><br><span class="line">Send TPS: 124354 Max RT: 601 Average RT: 1.608 Send Failed: 0 Response Failed: 12</span><br><span class="line"></span><br><span class="line">Send TPS: 119272 Max RT: 601 Average RT: 1.677 Send Failed: 0 Response Failed: 12</span><br></pre></td></tr></table></figure>



<h3 id="200个线程-消息3K-16个队列"><a href="#200个线程-消息3K-16个队列" class="headerlink" title="200个线程 消息3K 16个队列"></a>200个线程 消息3K 16个队列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh producer.sh -t zms-clusterB-perf-tst16 -w 200 -s 3072 -n 192.168.x.x:9876</span><br><span class="line"></span><br><span class="line">Send TPS: 105091 Max RT: 963 Average RT: 1.896 Send Failed: 0 Response Failed: 4</span><br><span class="line"></span><br><span class="line">Send TPS: 106243 Max RT: 963 Average RT: 1.882 Send Failed: 0 Response Failed: 4</span><br><span class="line"></span><br><span class="line">Send TPS: 103994 Max RT: 963 Average RT: 1.958 Send Failed: 0 Response Failed: 5</span><br><span class="line"></span><br><span class="line">Send TPS: 109741 Max RT: 963 Average RT: 1.822 Send Failed: 0 Response Failed: 5</span><br><span class="line"></span><br><span class="line">Send TPS: 103788 Max RT: 963 Average RT: 1.927 Send Failed: 0 Response Failed: 5</span><br><span class="line"></span><br><span class="line">Send TPS: 110597 Max RT: 963 Average RT: 1.805 Send Failed: 0 Response Failed: 6</span><br><span class="line"></span><br><span class="line">Send TPS: 111201 Max RT: 963 Average RT: 1.798 Send Failed: 0 Response Failed: 6</span><br></pre></td></tr></table></figure>

</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ37# RocketMQ消息发送（一）</title>
    <url>/posts/d473d7d3/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="消息发送代码"><a href="#消息发送代码" class="headerlink" title="消息发送代码"></a>消息发送代码</h1><p>* 需要设置produerGroup</p>
<p>* 需要设置NameServer地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DefaultMQProducer producer &#x3D; new DefaultMQProducer(&quot;melon-tst&quot;);</span><br><span class="line"></span><br><span class="line">producer.setNamesrvAddr(&quot;localhost:9876&quot;);</span><br><span class="line"></span><br><span class="line">producer.setVipChannelEnabled(false);</span><br><span class="line"></span><br><span class="line">producer.start();</span><br><span class="line"></span><br><span class="line">for(int i&#x3D;0;i&lt;100;i++)&#123;</span><br><span class="line"></span><br><span class="line">Message msg &#x3D; new Message(&quot;topic_online_test&quot;,(&quot;Hello RocketMQ&quot; + i).getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;msg.setDelayTimeLevel(10);</span><br><span class="line"></span><br><span class="line">SendResult sendResult &#x3D; producer.send(msg);</span><br><span class="line"></span><br><span class="line">System.out.printf(&quot;%s%n&quot;,sendResult);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">producer.shutdown();</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h1 id="方法启动所做的事情"><a href="#方法启动所做的事情" class="headerlink" title="方法启动所做的事情"></a>方法启动所做的事情</h1><p>* 将instanceName从默认值DEFAULT修改为PID</p>
<ol>
<li><p>MQClientInstance封装了网络通信的管道，存储于factoryTable（ConcurrentHashMap）</p>
</li>
<li><p>factoryTable为MQClientManager的成员变量，MQClientManager是单例模式</p>
</li>
<li><p>key为clientId对应一个MQClientInstance，被客户端共享使用</p>
</li>
<li><p>clientId的组成ClientIP@InstanceName，在同一个客户端连接多个集群时需要修改ClientIP或者InstanceName以确保clientId唯一</p>
</li>
</ol>
<p>* 注册producer到producerTable（ConcurrentHashMap）, key为producerGroup名称，不同的produer需要设置不同的producerGroup名称</p>
<p>* 客户端工厂实例启动</p>
<p>* 设置默认主题TBW102的路由信息</p>
<p>* 向各个broker发送心跳包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;defaultMQProducerImpl.start()</span><br><span class="line"></span><br><span class="line">public void start(final boolean startFactory) throws MQClientException &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;注意：此处的serviceState默认为CREATE_JUST 是DefaultMQProducer的成员变量</span><br><span class="line"></span><br><span class="line">switch (this.serviceState) &#123;</span><br><span class="line"></span><br><span class="line">case CREATE_JUST:</span><br><span class="line"></span><br><span class="line">this.serviceState &#x3D; ServiceState.START_FAILED;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;合法性校验</span><br><span class="line"></span><br><span class="line">this.checkConfig();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将实例的名称改成PID 避免一台机器上启动多个实例造成clientId重名</span><br><span class="line"></span><br><span class="line">if (!this.defaultMQProducer.getProducerGroup().equals(MixAll.CLIENT_INNER_PRODUCER_GROUP)) &#123;</span><br><span class="line"></span><br><span class="line">this.defaultMQProducer.changeInstanceNameToPID();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取MQClientInstance,作为生产者与NameServer,Broker沟通的通道</span><br><span class="line"></span><br><span class="line">this.mQClientFactory &#x3D; MQClientManager.getInstance().getAndCreateMQClientInstance(this.defaultMQProducer, rpcHook);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将当前生产者加入到MQClientInstance管理中，方便后续调用网络请求、进行心跳检测</span><br><span class="line"></span><br><span class="line">boolean registerOK &#x3D; mQClientFactory.registerProducer(this.defaultMQProducer.getProducerGroup(), this);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;一个ProductGroup只允许注册一次</span><br><span class="line"></span><br><span class="line">if (!registerOK) &#123;</span><br><span class="line"></span><br><span class="line">this.serviceState &#x3D; ServiceState.CREATE_JUST;</span><br><span class="line"></span><br><span class="line">throw new MQClientException(&quot;The producer group[&quot; + this.defaultMQProducer.getProducerGroup()</span><br><span class="line"></span><br><span class="line">\+ &quot;] has been created before, specify another name please.&quot; + FAQUrl.suggestTodo(FAQUrl.GROUP_NAME_DUPLICATE_URL),</span><br><span class="line"></span><br><span class="line">null);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设置默认主题TBW102的路由信息</span><br><span class="line"></span><br><span class="line">this.topicPublishInfoTable.put(this.defaultMQProducer.getCreateTopicKey(), new TopicPublishInfo());</span><br><span class="line"></span><br><span class="line">if (startFactory) &#123;</span><br><span class="line"></span><br><span class="line">mQClientFactory.start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.info(&quot;the producer [&#123;&#125;] start OK. sendMessageWithVIPChannel&#x3D;&#123;&#125;&quot;, this.defaultMQProducer.getProducerGroup(),</span><br><span class="line"></span><br><span class="line">this.defaultMQProducer.isSendMessageWithVIPChannel());</span><br><span class="line"></span><br><span class="line">this.serviceState &#x3D; ServiceState.RUNNING;</span><br><span class="line"></span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">case RUNNING:</span><br><span class="line"></span><br><span class="line">case START_FAILED:</span><br><span class="line"></span><br><span class="line">case SHUTDOWN_ALREADY:</span><br><span class="line"></span><br><span class="line">throw new MQClientException(&quot;The producer service state not OK, maybe started once, &quot;&#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">\+ this.serviceState&#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">\+ FAQUrl.suggestTodo(FAQUrl.CLIENT_SERVICE_NOT_OK),</span><br><span class="line"></span><br><span class="line">null);</span><br><span class="line"></span><br><span class="line">default:</span><br><span class="line"></span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">this.mQClientFactory.sendHeartbeatToAllBrokerWithLock();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"></span><br><span class="line">\* 同一个JVM中的不同消费者和不同生产者在启动时获取的MQClientInstance实例都是同一个</span><br><span class="line"></span><br><span class="line">\* MQClientInstance封装了RocketMQ网络处理的API，是消息生产者（Producer）、消息消费者(Consumer)与NameServer、Broker打交道的网络通道</span><br><span class="line"></span><br><span class="line">\* @param clientConfig</span><br><span class="line"></span><br><span class="line">\* @param rpcHook</span><br><span class="line"></span><br><span class="line">\* @return</span><br><span class="line"></span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">public MQClientInstance getAndCreateMQClientInstance(final ClientConfig clientConfig, RPCHook rpcHook) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;clientId由ip地址@实例名称构成</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;如果ProducerGroup为CLIENT_INNER_PRODUCER，实例名称为被更改为PID进程ID</span><br><span class="line"></span><br><span class="line">String clientId &#x3D; clientConfig.buildMQClientId();</span><br><span class="line"></span><br><span class="line">MQClientInstance instance &#x3D; this.factoryTable.get(clientId);</span><br><span class="line"></span><br><span class="line">if (null &#x3D;&#x3D; instance) &#123;</span><br><span class="line"></span><br><span class="line">instance &#x3D;</span><br><span class="line"></span><br><span class="line">new MQClientInstance(clientConfig.cloneClientConfig(),</span><br><span class="line"></span><br><span class="line">this.factoryIndexGenerator.getAndIncrement(), clientId, rpcHook);</span><br><span class="line"></span><br><span class="line">MQClientInstance prev &#x3D; this.factoryTable.putIfAbsent(clientId, instance);</span><br><span class="line"></span><br><span class="line">if (prev !&#x3D; null) &#123;</span><br><span class="line"></span><br><span class="line">instance &#x3D; prev;</span><br><span class="line"></span><br><span class="line">log.warn(&quot;Returned Previous MQClientInstance for clientId:[&#123;&#125;]&quot;, clientId);</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line"></span><br><span class="line">log.info(&quot;Created new MQClientInstance for clientId:[&#123;&#125;]&quot;, clientId);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return instance;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String buildMQClientId() &#123;</span><br><span class="line"></span><br><span class="line">StringBuilder sb &#x3D; new StringBuilder();</span><br><span class="line"></span><br><span class="line">sb.append(this.getClientIP());</span><br><span class="line"></span><br><span class="line">sb.append(&quot;@&quot;);</span><br><span class="line"></span><br><span class="line">sb.append(this.getInstanceName());</span><br><span class="line"></span><br><span class="line">if (!UtilAll.isBlank(this.unitName)) &#123;</span><br><span class="line"></span><br><span class="line">sb.append(&quot;@&quot;);</span><br><span class="line"></span><br><span class="line">sb.append(this.unitName);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return sb.toString();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<!--more-->



<h1 id="客户端工厂实例启动"><a href="#客户端工厂实例启动" class="headerlink" title="客户端工厂实例启动"></a>客户端工厂实例启动</h1><p>* 开启消息通道（Netty客户端启动）</p>
<p>* 启动系列定时任务</p>
<ol>
<li><p>每30秒定时从NameServer获取Topic的路由信息</p>
</li>
<li><p>每30秒定时清理下线的broker以及向broker发送心跳</p>
</li>
<li><p>持久化消息消费进度，默认5秒保存一次（本地存储和Broker存储）</p>
</li>
</ol>
<p>* 开启拉去消息的线程pullMessageService</p>
<p>* 队列消费负载实现</p>
<p>* 发送消息服务启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;MQClientInstance mQClientFactory.start()</span><br><span class="line"></span><br><span class="line">public void start(final boolean startFactory) throws MQClientException &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;注意：此处的serviceState默认为CREATE_JUST 是DefaultMQProducer的成员变量</span><br><span class="line"></span><br><span class="line">switch (this.serviceState) &#123;</span><br><span class="line"></span><br><span class="line">case CREATE_JUST:</span><br><span class="line"></span><br><span class="line">this.serviceState &#x3D; ServiceState.START_FAILED;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;合法性校验</span><br><span class="line"></span><br><span class="line">this.checkConfig();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将实例的名称改成PID 避免一台机器上启动多个实例造成clientId重名</span><br><span class="line"></span><br><span class="line">if (!this.defaultMQProducer.getProducerGroup().equals(MixAll.CLIENT_INNER_PRODUCER_GROUP)) &#123;</span><br><span class="line"></span><br><span class="line">this.defaultMQProducer.changeInstanceNameToPID();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取MQClientInstance,作为生产者与NameServer,Broker沟通的通道</span><br><span class="line"></span><br><span class="line">this.mQClientFactory &#x3D; MQClientManager.getInstance().getAndCreateMQClientInstance(this.defaultMQProducer, rpcHook);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将当前生产者加入到MQClientInstance管理中，方便后续调用网络请求、进行心跳检测</span><br><span class="line"></span><br><span class="line">boolean registerOK &#x3D; mQClientFactory.registerProducer(this.defaultMQProducer.getProducerGroup(), this);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;一个ProductGroup只允许注册一次</span><br><span class="line"></span><br><span class="line">if (!registerOK) &#123;</span><br><span class="line"></span><br><span class="line">this.serviceState &#x3D; ServiceState.CREATE_JUST;</span><br><span class="line"></span><br><span class="line">throw new MQClientException(&quot;The producer group[&quot; + this.defaultMQProducer.getProducerGroup()</span><br><span class="line"></span><br><span class="line">\+ &quot;] has been created before, specify another name please.&quot; + FAQUrl.suggestTodo(FAQUrl.GROUP_NAME_DUPLICATE_URL),</span><br><span class="line"></span><br><span class="line">null);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设置默认主题的路由信息</span><br><span class="line"></span><br><span class="line">this.topicPublishInfoTable.put(this.defaultMQProducer.getCreateTopicKey(), new TopicPublishInfo());</span><br><span class="line"></span><br><span class="line">if (startFactory) &#123;</span><br><span class="line"></span><br><span class="line">mQClientFactory.start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.info(&quot;the producer [&#123;&#125;] start OK. sendMessageWithVIPChannel&#x3D;&#123;&#125;&quot;, this.defaultMQProducer.getProducerGroup(),</span><br><span class="line"></span><br><span class="line">this.defaultMQProducer.isSendMessageWithVIPChannel());</span><br><span class="line"></span><br><span class="line">this.serviceState &#x3D; ServiceState.RUNNING;</span><br><span class="line"></span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">case RUNNING:</span><br><span class="line"></span><br><span class="line">case START_FAILED:</span><br><span class="line"></span><br><span class="line">case SHUTDOWN_ALREADY:</span><br><span class="line"></span><br><span class="line">throw new MQClientException(&quot;The producer service state not OK, maybe started once, &quot;&#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">\+ this.serviceState&#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">\+ FAQUrl.suggestTodo(FAQUrl.CLIENT_SERVICE_NOT_OK),</span><br><span class="line"></span><br><span class="line">null);</span><br><span class="line"></span><br><span class="line">default:</span><br><span class="line"></span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;向各个broker发送心跳包</span><br><span class="line"></span><br><span class="line">this.mQClientFactory.sendHeartbeatToAllBrokerWithLock();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h1><p>* 获取Topic路由信息</p>
<ol>
<li><p>先从缓存topicPublishInfoTable中获取</p>
</li>
<li><p>没有再从NameServer中请求获取</p>
</li>
<li><p>依然没有则使用默认topic（TBW102）的路由信息</p>
</li>
</ol>
<p>* 选择一个MessageQueue进行发送</p>
<p>* 组装requestHeader发送消息</p>
<ol>
<li><p>设置客户端MsgId</p>
</li>
<li><p>超过4K消息压缩设置压缩消息标记</p>
</li>
<li><p>设置事务消息标记</p>
</li>
<li><p>判断发送前钩子执行</p>
</li>
<li><p>消息发送完钩子执行</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SendResult <span class="title">sendDefaultImpl</span><span class="params">(//</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">Message msg, //待发送的消息</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">final</span> CommunicationMode communicationMode, //</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">final</span> SendCallback sendCallback, //</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">final</span> <span class="keyword">long</span> timeout//</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="keyword">throws</span> MQClientException, RemotingException, MQBrokerException, InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//确保初始化完成</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.makeSureStateOK();</span><br><span class="line"></span><br><span class="line"><span class="comment">//消息校验</span></span><br><span class="line"></span><br><span class="line">Validators.checkMessage(msg, <span class="keyword">this</span>.defaultMQProducer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">long</span> invokeID = random.nextLong();</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> beginTimestampFirst = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> beginTimestampPrev = beginTimestampFirst;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> endTimestamp = beginTimestampFirst;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取Topic的路由信息,1.本地缓存 2.NameServer 3.TBW102 默认Topic的路由信息</span></span><br><span class="line"></span><br><span class="line">TopicPublishInfo topicPublishInfo = <span class="keyword">this</span>.tryToFindTopicPublishInfo(msg.getTopic());</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (topicPublishInfo != <span class="keyword">null</span> &amp;&amp; topicPublishInfo.ok()) &#123;</span><br><span class="line"></span><br><span class="line">MessageQueue mq = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">Exception exception = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">SendResult sendResult = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同步发送默认3(1+2)次 其他1次</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//异步发送通过retryTimesWhenSendAsyncFailed来控制，在发送结果返回后再处理</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> timesTotal = communicationMode == CommunicationMode.SYNC ? <span class="number">1</span> + <span class="keyword">this</span>.defaultMQProducer.getRetryTimesWhenSendFailed() : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> times = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">String[] brokersSent = <span class="keyword">new</span> String[timesTotal];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (; times &lt; timesTotal; times++) &#123;</span><br><span class="line"></span><br><span class="line">String lastBrokerName = <span class="keyword">null</span> == mq ? <span class="keyword">null</span> : mq.getBrokerName();</span><br><span class="line"></span><br><span class="line"><span class="comment">//选一个MessageQueue进行发送</span></span><br><span class="line"></span><br><span class="line">MessageQueue tmpmq = <span class="keyword">this</span>.selectOneMessageQueue(topicPublishInfo, lastBrokerName);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tmpmq != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">mq = tmpmq;</span><br><span class="line"></span><br><span class="line">brokersSent[times] = mq.getBrokerName();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">beginTimestampPrev = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">sendResult = <span class="keyword">this</span>.sendKernelImpl(msg, mq, communicationMode, sendCallback, topicPublishInfo, timeout);</span><br><span class="line"></span><br><span class="line">endTimestamp = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (communicationMode) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> ASYNC:</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> ONEWAY:</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> SYNC:</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sendResult.getSendStatus() != SendStatus.SEND_OK) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.defaultMQProducer.isRetryAnotherBrokerWhenNotStoreOK()) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> sendResult;</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line"></span><br><span class="line">endTimestamp = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">log.warn(String.format(<span class="string">&quot;sendKernelImpl exception, resend at once, InvokeID: %s, RT: %sms, Broker: %s&quot;</span>, invokeID, endTimestamp - beginTimestampPrev, mq), e);</span><br><span class="line"></span><br><span class="line">log.warn(msg.toString());</span><br><span class="line"></span><br><span class="line">exception = e;</span><br><span class="line"></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (MQClientException e) &#123;</span><br><span class="line"></span><br><span class="line">endTimestamp = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">log.warn(String.format(<span class="string">&quot;sendKernelImpl exception, resend at once, InvokeID: %s, RT: %sms, Broker: %s&quot;</span>, invokeID, endTimestamp - beginTimestampPrev, mq), e);</span><br><span class="line"></span><br><span class="line">log.warn(msg.toString());</span><br><span class="line"></span><br><span class="line">exception = e;</span><br><span class="line"></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (MQBrokerException e) &#123;</span><br><span class="line"></span><br><span class="line">endTimestamp = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">log.warn(String.format(<span class="string">&quot;sendKernelImpl exception, resend at once, InvokeID: %s, RT: %sms, Broker: %s&quot;</span>, invokeID, endTimestamp - beginTimestampPrev, mq), e);</span><br><span class="line"></span><br><span class="line">log.warn(msg.toString());</span><br><span class="line"></span><br><span class="line">exception = e;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (e.getResponseCode()) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> ResponseCode.TOPIC_NOT_EXIST:</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> ResponseCode.SERVICE_NOT_AVAILABLE:</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> ResponseCode.SYSTEM_ERROR:</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> ResponseCode.NO_PERMISSION:</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> ResponseCode.NO_BUYER_ID:</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> ResponseCode.NOT_IN_CURRENT_UNIT:</span><br><span class="line"></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sendResult != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> sendResult;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">throw</span> e;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">endTimestamp = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">log.warn(String.format(<span class="string">&quot;sendKernelImpl exception, throw exception, InvokeID: %s, RT: %sms, Broker: %s&quot;</span>, invokeID, endTimestamp - beginTimestampPrev, mq), e);</span><br><span class="line"></span><br><span class="line">log.warn(msg.toString());</span><br><span class="line"></span><br><span class="line">log.warn(<span class="string">&quot;sendKernelImpl exception&quot;</span>, e);</span><br><span class="line"></span><br><span class="line">log.warn(msg.toString());</span><br><span class="line"></span><br><span class="line"><span class="keyword">throw</span> e;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sendResult != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> sendResult;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String info = String.format(<span class="string">&quot;Send [%d] times, still failed, cost [%d]ms, Topic: %s, BrokersSent: %s&quot;</span>,</span><br><span class="line"></span><br><span class="line">times,</span><br><span class="line"></span><br><span class="line">System.currentTimeMillis() - beginTimestampFirst,</span><br><span class="line"></span><br><span class="line">msg.getTopic(),</span><br><span class="line"></span><br><span class="line">Arrays.toString(brokersSent));</span><br><span class="line"></span><br><span class="line">info += FAQUrl.suggestTodo(FAQUrl.SEND_MSG_FAILED);</span><br><span class="line"></span><br><span class="line">MQClientException mqClientException = <span class="keyword">new</span> MQClientException(info, exception);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (exception <span class="keyword">instanceof</span> MQBrokerException) &#123;</span><br><span class="line"></span><br><span class="line">mqClientException.setResponseCode(((MQBrokerException) exception).getResponseCode());</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> RemotingConnectException) &#123;</span><br><span class="line"></span><br><span class="line">mqClientException.setResponseCode(ClientErrorCode.CONNECT_BROKER_EXCEPTION);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> RemotingTimeoutException) &#123;</span><br><span class="line"></span><br><span class="line">mqClientException.setResponseCode(ClientErrorCode.ACCESS_BROKER_TIMEOUT);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> MQClientException) &#123;</span><br><span class="line"></span><br><span class="line">mqClientException.setResponseCode(ClientErrorCode.BROKER_NOT_EXIST_EXCEPTION);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">throw</span> mqClientException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//没有设置NameServer地址错误</span></span><br><span class="line"></span><br><span class="line">List&lt;String&gt; nsList = <span class="keyword">this</span>.getmQClientFactory().getMQClientAPIImpl().getNameServerAddressList();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> == nsList || nsList.isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;No name server address, please set it.&quot;</span> + FAQUrl.suggestTodo(FAQUrl.NAME_SERVER_ADDR_NOT_EXIST_URL), <span class="keyword">null</span>).setResponseCode(ClientErrorCode.NO_NAME_SERVER_EXCEPTION);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送抛错没有找到Topic路由信息</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">&quot;No route info of this topic, &quot;</span> + msg.getTopic() + FAQUrl.suggestTodo(FAQUrl.NO_TOPIC_ROUTE_INFO),</span><br><span class="line"></span><br><span class="line"><span class="keyword">null</span>).setResponseCode(ClientErrorCode.NOT_FOUND_TOPIC_EXCEPTION);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> SendResult <span class="title">sendKernelImpl</span><span class="params">(<span class="keyword">final</span> Message msg, //待发送的消息</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">final</span> MessageQueue mq, //将消息发送到该队列上</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">final</span> CommunicationMode communicationMode, //消息发送模式，SYNC、ASYNC、ONEWAY</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">final</span> SendCallback sendCallback, //异步消息回调函数</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">final</span> TopicPublishInfo topicPublishInfo, //主题路由信息</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">final</span> <span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> MQClientException, RemotingException, MQBrokerException, InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">String brokerAddr = <span class="keyword">this</span>.mQClientFactory.findBrokerAddressInPublish(mq.getBrokerName());</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> == brokerAddr) &#123;</span><br><span class="line"></span><br><span class="line">tryToFindTopicPublishInfo(mq.getTopic());</span><br><span class="line"></span><br><span class="line">brokerAddr = <span class="keyword">this</span>.mQClientFactory.findBrokerAddressInPublish(mq.getBrokerName());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SendMessageContext context = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (brokerAddr != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">brokerAddr = MixAll.brokerVIPChannel(<span class="keyword">this</span>.defaultMQProducer.isSendMessageWithVIPChannel(), brokerAddr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] prevBody = msg.getBody();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//for MessageBatch,ID has been set in the generating process</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置客户端MsgId</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!(msg <span class="keyword">instanceof</span> MessageBatch)) &#123;</span><br><span class="line"></span><br><span class="line">MessageClientIDSetter.setUniqID(msg);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sysFlag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//超过4K消息压缩 压缩消息标记</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.tryToCompressMessage(msg)) &#123;</span><br><span class="line"></span><br><span class="line">sysFlag |= MessageSysFlag.COMPRESSED_FLAG;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//事务消息标记</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> String tranMsg = msg.getProperty(MessageConst.PROPERTY_TRANSACTION_PREPARED);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tranMsg != <span class="keyword">null</span> &amp;&amp; Boolean.parseBoolean(tranMsg)) &#123;</span><br><span class="line"></span><br><span class="line">sysFlag |= MessageSysFlag.TRANSACTION_PREPARED_TYPE;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//限制发送钩子</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (hasCheckForbiddenHook()) &#123;</span><br><span class="line"></span><br><span class="line">CheckForbiddenContext checkForbiddenContext = <span class="keyword">new</span> CheckForbiddenContext();</span><br><span class="line"></span><br><span class="line">checkForbiddenContext.setNameSrvAddr(<span class="keyword">this</span>.defaultMQProducer.getNamesrvAddr());</span><br><span class="line"></span><br><span class="line">checkForbiddenContext.setGroup(<span class="keyword">this</span>.defaultMQProducer.getProducerGroup());</span><br><span class="line"></span><br><span class="line">checkForbiddenContext.setCommunicationMode(communicationMode);</span><br><span class="line"></span><br><span class="line">checkForbiddenContext.setBrokerAddr(brokerAddr);</span><br><span class="line"></span><br><span class="line">checkForbiddenContext.setMessage(msg);</span><br><span class="line"></span><br><span class="line">checkForbiddenContext.setMq(mq);</span><br><span class="line"></span><br><span class="line">checkForbiddenContext.setUnitMode(<span class="keyword">this</span>.isUnitMode());</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.executeCheckForbiddenHook(checkForbiddenContext);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送前钩子</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.hasSendMessageHook()) &#123;</span><br><span class="line"></span><br><span class="line">context = <span class="keyword">new</span> SendMessageContext();</span><br><span class="line"></span><br><span class="line">context.setProducer(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">context.setProducerGroup(<span class="keyword">this</span>.defaultMQProducer.getProducerGroup());</span><br><span class="line"></span><br><span class="line">context.setCommunicationMode(communicationMode);</span><br><span class="line"></span><br><span class="line">context.setBornHost(<span class="keyword">this</span>.defaultMQProducer.getClientIP());</span><br><span class="line"></span><br><span class="line">context.setBrokerAddr(brokerAddr);</span><br><span class="line"></span><br><span class="line">context.setMessage(msg);</span><br><span class="line"></span><br><span class="line">context.setMq(mq);</span><br><span class="line"></span><br><span class="line">String isTrans = msg.getProperty(MessageConst.PROPERTY_TRANSACTION_PREPARED);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isTrans != <span class="keyword">null</span> &amp;&amp; isTrans.equals(<span class="string">&quot;true&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">context.setMsgType(MessageType.Trans_Msg_Half);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (msg.getProperty(<span class="string">&quot;__STARTDELIVERTIME&quot;</span>) != <span class="keyword">null</span> || msg.getProperty(MessageConst.PROPERTY_DELAY_TIME_LEVEL) != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">context.setMsgType(MessageType.Delay_Msg);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.executeSendMessageHookBefore(context);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//组装RequestHeader</span></span><br><span class="line"></span><br><span class="line">SendMessageRequestHeader requestHeader = <span class="keyword">new</span> SendMessageRequestHeader();</span><br><span class="line"></span><br><span class="line">requestHeader.setProducerGroup(<span class="keyword">this</span>.defaultMQProducer.getProducerGroup());<span class="comment">//生产者组</span></span><br><span class="line"></span><br><span class="line">requestHeader.setTopic(msg.getTopic());<span class="comment">//主题名称</span></span><br><span class="line"></span><br><span class="line">requestHeader.setDefaultTopic(<span class="keyword">this</span>.defaultMQProducer.getCreateTopicKey());<span class="comment">//默认创建主题key</span></span><br><span class="line"></span><br><span class="line">requestHeader.setDefaultTopicQueueNums(<span class="keyword">this</span>.defaultMQProducer.getDefaultTopicQueueNums());<span class="comment">//队列数量</span></span><br><span class="line"></span><br><span class="line">requestHeader.setQueueId(mq.getQueueId());<span class="comment">//队列ID</span></span><br><span class="line"></span><br><span class="line">requestHeader.setSysFlag(sysFlag);<span class="comment">//消息系统标记 标志压缩，事务消息</span></span><br><span class="line"></span><br><span class="line">requestHeader.setBornTimestamp(System.currentTimeMillis());<span class="comment">//消息发送时间</span></span><br><span class="line"></span><br><span class="line">requestHeader.setFlag(msg.getFlag());<span class="comment">//消息标记，RocketMQ中不做处理</span></span><br><span class="line"></span><br><span class="line">requestHeader.setProperties(MessageDecoder.messageProperties2String(msg.getProperties()));<span class="comment">//消息扩展属性</span></span><br><span class="line"></span><br><span class="line">requestHeader.setReconsumeTimes(<span class="number">0</span>);<span class="comment">//重试第一次为0</span></span><br><span class="line"></span><br><span class="line">requestHeader.setUnitMode(<span class="keyword">this</span>.isUnitMode());<span class="comment">//问题？：默认false不清楚做何使用</span></span><br><span class="line"></span><br><span class="line">requestHeader.setBatch(msg <span class="keyword">instanceof</span> MessageBatch);<span class="comment">//是否批量消息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//重试队列设置requestHeader</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (requestHeader.getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取已消费的次数</span></span><br><span class="line"></span><br><span class="line">String reconsumeTimes = MessageAccessor.getReconsumeTime(msg);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (reconsumeTimes != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">requestHeader.setReconsumeTimes(Integer.valueOf(reconsumeTimes));</span><br><span class="line"></span><br><span class="line">MessageAccessor.clearProperty(msg, MessageConst.PROPERTY_RECONSUME_TIME);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最大消费次数</span></span><br><span class="line"></span><br><span class="line">String maxReconsumeTimes = MessageAccessor.getMaxReconsumeTimes(msg);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (maxReconsumeTimes != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">requestHeader.setMaxReconsumeTimes(Integer.valueOf(maxReconsumeTimes));</span><br><span class="line"></span><br><span class="line">MessageAccessor.clearProperty(msg, MessageConst.PROPERTY_MAX_RECONSUME_TIMES);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用通道发送消息</span></span><br><span class="line"></span><br><span class="line">SendResult sendResult = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (communicationMode) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> ASYNC:</span><br><span class="line"></span><br><span class="line">sendResult = <span class="keyword">this</span>.mQClientFactory.getMQClientAPIImpl().sendMessage(<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">brokerAddr, <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">mq.getBrokerName(), <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">msg, <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">requestHeader, <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">timeout, <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">communicationMode, <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line">sendCallback, <span class="comment">// 7</span></span><br><span class="line"></span><br><span class="line">topicPublishInfo, <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.mQClientFactory, <span class="comment">// 9</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.defaultMQProducer.getRetryTimesWhenSendAsyncFailed(), <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">context, <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> ONEWAY:</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> SYNC:</span><br><span class="line"></span><br><span class="line">sendResult = <span class="keyword">this</span>.mQClientFactory.getMQClientAPIImpl().sendMessage(</span><br><span class="line"></span><br><span class="line">brokerAddr,</span><br><span class="line"></span><br><span class="line">mq.getBrokerName(),</span><br><span class="line"></span><br><span class="line">msg,</span><br><span class="line"></span><br><span class="line">requestHeader,</span><br><span class="line"></span><br><span class="line">timeout,</span><br><span class="line"></span><br><span class="line">communicationMode,</span><br><span class="line"></span><br><span class="line">context,</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消息发送完毕钩子</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.hasSendMessageHook()) &#123;</span><br><span class="line"></span><br><span class="line">context.setSendResult(sendResult);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.executeSendMessageHookAfter(context);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> sendResult;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.hasSendMessageHook()) &#123;</span><br><span class="line"></span><br><span class="line">context.setException(e);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.executeSendMessageHookAfter(context);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">throw</span> e;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (MQBrokerException e) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.hasSendMessageHook()) &#123;</span><br><span class="line"></span><br><span class="line">context.setException(e);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.executeSendMessageHookAfter(context);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">throw</span> e;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.hasSendMessageHook()) &#123;</span><br><span class="line"></span><br><span class="line">context.setException(e);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.executeSendMessageHookAfter(context);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">throw</span> e;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">msg.setBody(prevBody);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">&quot;The broker[&quot;</span> + mq.getBrokerName() + <span class="string">&quot;] not exist&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ41# RocketMQ特性--事物消息</title>
    <url>/posts/2f29fd72/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="问题思考"><a href="#问题思考" class="headerlink" title="问题思考"></a>问题思考</h1><p>从官方给的例子入手，代码如下:</p>
<p>示例类：org.apache.rocketmq.example.transaction.TransactionProducer.java</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) throws MQClientException, InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@1 定义TransactionListener</span><br><span class="line"></span><br><span class="line">TransactionListener transactionListener &#x3D; new TransactionListenerImpl();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@2 使用事务发送Producer</span><br><span class="line"></span><br><span class="line">TransactionMQProducer producer &#x3D; new TransactionMQProducer(&quot;please_rename_unique_group_name&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@3 定义线程池</span><br><span class="line"></span><br><span class="line">ExecutorService executorService &#x3D; new ThreadPoolExecutor(2, 5, 100, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(2000), new ThreadFactory() &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line"></span><br><span class="line">public Thread newThread(Runnable r) &#123;</span><br><span class="line"></span><br><span class="line">Thread thread &#x3D; new Thread(r);</span><br><span class="line"></span><br><span class="line">thread.setName(&quot;client-transaction-msg-check-thread&quot;);</span><br><span class="line"></span><br><span class="line">return thread;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设置线程池</span><br><span class="line"></span><br><span class="line">producer.setExecutorService(executorService);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设置监听器</span><br><span class="line"></span><br><span class="line">producer.setTransactionListener(transactionListener);</span><br><span class="line"></span><br><span class="line">producer.setNamesrvAddr(&quot;127.0.0.1:9876&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@4 发送者启动</span><br><span class="line"></span><br><span class="line">producer.start();</span><br><span class="line"></span><br><span class="line">String[] tags &#x3D; new String[] &#123;&quot;TagA&quot;, &quot;TagB&quot;, &quot;TagC&quot;, &quot;TagD&quot;, &quot;TagE&quot;&#125;;</span><br><span class="line"></span><br><span class="line">for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">Message msg &#x3D;</span><br><span class="line"></span><br><span class="line">new Message(&quot;TopicTest1234&quot;, tags[i % tags.length], &quot;KEY&quot; + i,</span><br><span class="line"></span><br><span class="line">(&quot;Hello RocketMQ &quot; + i).getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@5 消息发送</span><br><span class="line"></span><br><span class="line">SendResult sendResult &#x3D; producer.sendMessageInTransaction(msg, null);</span><br><span class="line"></span><br><span class="line">System.out.printf(&quot;%s%n&quot;, sendResult);</span><br><span class="line"></span><br><span class="line">Thread.sleep(10);</span><br><span class="line"></span><br><span class="line">&#125; catch (MQClientException | UnsupportedEncodingException e) &#123;</span><br><span class="line"></span><br><span class="line">e.printStackTrace();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (int i &#x3D; 0; i &lt; 100000; i++) &#123;</span><br><span class="line"></span><br><span class="line">Thread.sleep(1000);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;发送者关闭</span><br><span class="line"></span><br><span class="line">producer.shutdown();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>从上面客户端例子中思考一些问题：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. @1定义TransactionListener做什么用？</span><br><span class="line">2. @2定义的TransactionMQProducer与普通Produer区别在哪里？</span><br><span class="line">3. @3定义线程池executorService又是干啥的？</span><br><span class="line">4. @4事务发送者启动发送流程是怎么样？</span><br><span class="line">5. 发送事务消息如何和Broker进行交互的？</span><br></pre></td></tr></table></figure>



<h1 id="事务消息客户端发送流程"><a href="#事务消息客户端发送流程" class="headerlink" title="事务消息客户端发送流程"></a>事务消息客户端发送流程</h1><h2 id="事务发送与普通启动差异"><a href="#事务发送与普通启动差异" class="headerlink" title="事务发送与普通启动差异"></a>事务发送与普通启动差异</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@1 producer.start();</span><br><span class="line"></span><br><span class="line">@2 TransactionMQProducer#start</span><br><span class="line"></span><br><span class="line">this.defaultMQProducerImpl.initTransactionEnv();</span><br><span class="line"></span><br><span class="line">super.start();</span><br><span class="line"></span><br><span class="line">@3 DefaultMQProducerImpl#initTransactionEnv()</span><br><span class="line"></span><br><span class="line">this.checkExecutor &#x3D; producer.getExecutorService();</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：事务发送时比普通发送启动多了initTransactionEnv操作，即：给ExecutorService checkExecutor赋值。</span><br></pre></td></tr></table></figure>



<h2 id="事务消息发送调用链"><a href="#事务消息发送调用链" class="headerlink" title="事务消息发送调用链"></a>事务消息发送调用链</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@1 SendResult sendResult &#x3D; producer.sendMessageInTransaction</span><br><span class="line"></span><br><span class="line">@2 TransactionMQProducer#sendMessageInTransaction</span><br><span class="line"></span><br><span class="line">@3 DefaultMQProducerImpl#sendMessageInTransaction</span><br></pre></td></tr></table></figure>



<h2 id="事务消息发送分析"><a href="#事务消息发送分析" class="headerlink" title="事务消息发送分析"></a>事务消息发送分析</h2><p>方法：DefaultMQProducerImpl#sendMessageInTransaction</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;@1</span><br><span class="line"></span><br><span class="line">TransactionListener transactionListener &#x3D; getCheckListener();</span><br><span class="line"></span><br><span class="line">if (null &#x3D;&#x3D; localTransactionExecuter &amp;&amp; null &#x3D;&#x3D; transactionListener) &#123;</span><br><span class="line"></span><br><span class="line">throw new MQClientException(&quot;tranExecutor is null&quot;, null);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Validators.checkMessage(msg, this.defaultMQProducer);</span><br><span class="line"></span><br><span class="line">SendResult sendResult &#x3D; null;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@2 表示消息的prepare消息</span><br><span class="line"></span><br><span class="line">MessageAccessor.putProperty(msg, MessageConst.PROPERTY_TRANSACTION_PREPARED, &quot;true&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@3 生产者组，用于回查本地事务事，从生产者组中选择随机选择一个生产者即可</span><br><span class="line"></span><br><span class="line">MessageAccessor.putProperty(msg, MessageConst.PROPERTY_PRODUCER_GROUP, this.defaultMQProducer.getProducerGroup());</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@4 消息发送</span><br><span class="line"></span><br><span class="line">sendResult &#x3D; this.send(msg);</span><br><span class="line"></span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">throw new MQClientException(&quot;send message Exception&quot;, e);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>方法：DefaultMQProducerImpl#sendKernelImpl</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;事务消息发送，设置PREPARED标记</span><br><span class="line"></span><br><span class="line">final String tranMsg &#x3D; msg.getProperty(MessageConst.PROPERTY_TRANSACTION_PREPARED);</span><br><span class="line"></span><br><span class="line">if (tranMsg !&#x3D; null &amp;&amp; Boolean.parseBoolean(tranMsg)) &#123;</span><br><span class="line"></span><br><span class="line">sysFlag |&#x3D; MessageSysFlag.TRANSACTION_PREPARED_TYPE;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@5 请求header中设置事务标记</span><br><span class="line"></span><br><span class="line">requestHeader.setSysFlag(sysFlag);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@6 发送消息请求的RequestCode</span><br><span class="line"></span><br><span class="line">request &#x3D; RemotingCommand.createRequestCommand(RequestCode.SEND_MESSAGE, requestHeader);</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：</span><br><span class="line">@1获取TransactionListener即示例代码传入的Listener</span><br><span class="line">@2在消息属性中加入PROPERTY_TRANSACTION_PREPARED &#x3D; &quot;TRAN_MSG&quot;即事务半消息</span><br><span class="line">@3设置ProducerGroup Broker在事务回查时调用</span><br><span class="line">@4事务消息发送采用同步发送，发送流程与普通消息发送一致</span><br><span class="line">@5请求header中设置事务标记SEND_MESSAGE &#x3D; 10</span><br></pre></td></tr></table></figure>



<h2 id="事务消息发送结果分析"><a href="#事务消息发送结果分析" class="headerlink" title="事务消息发送结果分析"></a>事务消息发送结果分析</h2><p>方法：DefaultMQProducerImpl#sendMessageInTransaction</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LocalTransactionState localTransactionState &#x3D; LocalTransactionState.UNKNOW;</span><br><span class="line"></span><br><span class="line">switch (sendResult.getSendStatus()) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@1</span><br><span class="line"></span><br><span class="line">case SEND_OK: &#123;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@2 执行本地事务</span><br><span class="line"></span><br><span class="line">localTransactionState &#x3D; transactionListener.executeLocalTransaction(msg, arg);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">case FLUSH_DISK_TIMEOUT:</span><br><span class="line"></span><br><span class="line">case FLUSH_SLAVE_TIMEOUT:</span><br><span class="line"></span><br><span class="line">case SLAVE_NOT_AVAILABLE:</span><br><span class="line"></span><br><span class="line">localTransactionState &#x3D; LocalTransactionState.ROLLBACK_MESSAGE;</span><br><span class="line"></span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">default:</span><br><span class="line"></span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：</span><br><span class="line">@1 发送半消息（Prepared）消息成功，设置transactionId。</span><br><span class="line">@2 发送半消息成功后，通过transactionListener回调客户端查询本地事务执行情况，并返回事务执行状态。</span><br><span class="line">LocalTransactionState有COMMIT_MESSAGE、ROLLBACK_MESSAGE、UNKNOW三种状态。</span><br></pre></td></tr></table></figure>



<h2 id="结束事务分析"><a href="#结束事务分析" class="headerlink" title="结束事务分析"></a>结束事务分析</h2><p>方法：DefaultMQProducerImpl#sendMessageInTransaction</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@1 结束事务，根据返回的事务状态执行提交、回滚、暂时不处理</span><br><span class="line"></span><br><span class="line">this.endTransaction(sendResult, localTransactionState, localException);</span><br><span class="line"></span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">log.warn(&quot;local transaction execute &quot; + localTransactionState + &quot;, but end broker transaction failed&quot;, e);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TransactionSendResult transactionSendResult &#x3D; new TransactionSendResult();</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">return transactionSendResult;</span><br></pre></td></tr></table></figure>



<p>方法：DefaultMQProducerImpl#endTransaction</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">switch (localTransactionState) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@2 设置事务提交标记Header</span><br><span class="line"></span><br><span class="line">case COMMIT_MESSAGE: requestHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_COMMIT_TYPE);</span><br><span class="line"></span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@3 设置事务回滚标记Header</span><br><span class="line"></span><br><span class="line">case ROLLBACK_MESSAGE:</span><br><span class="line"></span><br><span class="line">requestHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_ROLLBACK_TYPE);</span><br><span class="line"></span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@4 设置事务未知标记Header</span><br><span class="line"></span><br><span class="line">case UNKNOW:</span><br><span class="line"></span><br><span class="line">requestHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_NOT_TYPE);</span><br><span class="line"></span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">default:</span><br><span class="line"></span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@5 通过一次发送方式向Broker提交事务 this.mQClientFactory.getMQClientAPIImpl().endTransactionOneway(brokerAddr, requestHeader, remark,</span><br><span class="line"></span><br><span class="line">this.defaultMQProducer.getSendMsgTimeout());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：</span><br><span class="line">@1 根据本地事务执行返回的状态localTransactionState，调用结束事务方法</span><br><span class="line">@2 requestHeader设置事务提交标记0x2 &lt;&lt; 2&#x3D;8</span><br><span class="line">@3 requestHeader设置事务回滚标记0x3 &lt;&lt; 2&#x3D;12</span><br><span class="line">@4 requestHeader设置未知标记0</span><br><span class="line">@5 通过一次发送方式向Broker提交事务 RequestCode为END_TRANSACTION &#x3D; 37</span><br></pre></td></tr></table></figure>



<h1 id="事务消息服务端存储流程"><a href="#事务消息服务端存储流程" class="headerlink" title="事务消息服务端存储流程"></a>事务消息服务端存储流程</h1><h2 id="事务消息存储调用链"><a href="#事务消息存储调用链" class="headerlink" title="事务消息存储调用链"></a>事务消息存储调用链</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@1 SendMessageProcessor#processRequest</span><br><span class="line"></span><br><span class="line">response &#x3D; this.sendMessage(ctx, request, mqtraceContext, requestHeader)</span><br><span class="line"></span><br><span class="line">@2 SendMessageProcessor#sendMessage</span><br></pre></td></tr></table></figure>



<h2 id="事务半消息存储代码分析（一）"><a href="#事务半消息存储代码分析（一）" class="headerlink" title="事务半消息存储代码分析（一）"></a>事务半消息存储代码分析（一）</h2><p>方法：SendMessageProcessor#sendMessage</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;@1 可以通过配置来是否接受事务消息存储</span><br><span class="line"></span><br><span class="line">if (traFlag !&#x3D; null &amp;&amp; Boolean.parseBoolean(traFlag)) &#123;</span><br><span class="line"></span><br><span class="line">if (this.brokerController.getBrokerConfig().isRejectTransactionMessage())&#123;</span><br><span class="line"></span><br><span class="line">response.setCode(ResponseCode.NO_PERMISSION);</span><br><span class="line"></span><br><span class="line">response.setRemark(</span><br><span class="line"></span><br><span class="line">&quot;the broker[&quot; + this.brokerController.getBrokerConfig().getBrokerIP1()</span><br><span class="line"></span><br><span class="line">\+ &quot;] sending transaction message is forbidden&quot;);</span><br><span class="line"></span><br><span class="line">return response;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@2 prepare消息存储</span><br><span class="line"></span><br><span class="line">putMessageResult &#x3D; this.brokerController.getTransactionalMessageService().prepareMessage(msgInner);</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line"></span><br><span class="line">putMessageResult &#x3D; this.brokerController.getMessageStore().putMessage(msgInner);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：</span><br><span class="line">@1 可以通过Broker配置属性rejectTransactionMessage来决定是否接受事务消息请求，默认为false即接受。</span><br><span class="line">@2 半消息存储</span><br></pre></td></tr></table></figure>



<!--more-->



<h2 id="事务半消息存储代码分析（二）"><a href="#事务半消息存储代码分析（二）" class="headerlink" title="事务半消息存储代码分析（二）"></a>事务半消息存储代码分析（二）</h2><p>方法：TransactionalMessageBridge#putHalfMessage</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public PutMessageResult putHalfMessage(MessageExtBrokerInner messageInner)&#123;</span><br><span class="line"></span><br><span class="line">return store.putMessage(parseHalfMessageInner(messageInner));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>方法：TransactionalMessageBridge#parseHalfMessageInner</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;@1 备份原主题</span><br><span class="line"></span><br><span class="line">MessageAccessor.putProperty(msgInner, MessageConst.PROPERTY_REAL_TOPIC, msgInner.getTopic());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@2 备份原queueID</span><br><span class="line"></span><br><span class="line">MessageAccessor.putProperty(msgInner, MessageConst.PROPERTY_REAL_QUEUE_ID,</span><br><span class="line"></span><br><span class="line">String.valueOf(msgInner.getQueueId()));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@3 重置sysFlag</span><br><span class="line"></span><br><span class="line">msgInner.setSysFlag(</span><br><span class="line"></span><br><span class="line">MessageSysFlag.resetTransactionValue(msgInner.getSysFlag(), MessageSysFlag.TRANSACTION_NOT_TYPE));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@3 主题变更 RMQ_SYS_TRANS_HALF_TOPIC</span><br><span class="line"></span><br><span class="line">msgInner.setTopic(TransactionalMessageUtil.buildHalfTopic());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@4 消息队列变更为0</span><br><span class="line"></span><br><span class="line">msgInner.setQueueId(0);</span><br><span class="line"></span><br><span class="line">msgInner.setPropertiesString(MessageDecoder.messageProperties2String(msgInner.getProperties()));</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：半消息在存储前将存储的主题设置为RMQ_SYS_TRANS_HALF_TOPIC，将原来的Topic备份到属性中，同时也备份了原来的QueueId。这也是为什么半消息不会被消费者消费的原因。</span><br></pre></td></tr></table></figure>

<h1 id="事务消息服务端响应结束事务请求"><a href="#事务消息服务端响应结束事务请求" class="headerlink" title="事务消息服务端响应结束事务请求"></a>事务消息服务端响应结束事务请求</h1><h2 id="处理未知类型请求"><a href="#处理未知类型请求" class="headerlink" title="处理未知类型请求"></a>处理未知类型请求</h2><p>方法：EndTransactionProcessor#processRequest</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">case MessageSysFlag.TRANSACTION_NOT_TYPE: &#123;</span><br><span class="line"></span><br><span class="line">LOGGER.warn(&quot;The producer[&#123;&#125;] end transaction in sending message, and it&#39;s pending status.&quot;</span><br><span class="line"></span><br><span class="line">\+ &quot;RequestHeader: &#123;&#125; Remark: &#123;&#125;&quot;,</span><br><span class="line"></span><br><span class="line">RemotingHelper.parseChannelRemoteAddr(ctx.channel()),</span><br><span class="line"></span><br><span class="line">requestHeader.toString(),</span><br><span class="line"></span><br><span class="line">request.getRemark());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@1</span><br><span class="line"></span><br><span class="line">return null;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：结束事务在处理未知类型TRANSACTION_NOT_TYPE时，只打印告警日志不做处理。</span><br></pre></td></tr></table></figure>



<h2 id="处理事务提交请求"><a href="#处理事务提交请求" class="headerlink" title="处理事务提交请求"></a>处理事务提交请求</h2><p>半消息查找。方法：EndTransactionProcessor#processRequest</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (MessageSysFlag.TRANSACTION_COMMIT_TYPE</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D; requestHeader.getCommitOrRollback())&#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@1 将prepare消息找出来</span><br><span class="line"></span><br><span class="line">result &#x3D; this.brokerController.getTransactionalMessageService()</span><br><span class="line"></span><br><span class="line">.commitMessage(requestHeader);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@2</span><br><span class="line"></span><br><span class="line">MessageExtBrokerInner msgInner &#x3D; endMessageTransaction(result.getPrepareMessage());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>半消息还原。方法：EndTransactionProcessor#endMessageTransaction</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MessageExtBrokerInner msgInner &#x3D; new MessageExtBrokerInner();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@3 置换为原来的Topic</span><br><span class="line"></span><br><span class="line">msgInner.setTopic(msgExt.getUserProperty(MessageConst.PROPERTY_REAL_TOPIC));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@4 置换为原来的QueueId</span><br><span class="line"></span><br><span class="line">msgInner.setQueueId(Integer.parseInt(msgExt.getUserProperty(MessageConst.PROPERTY_REAL_QUEUE_ID)));</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;清除属性设置</span><br><span class="line"></span><br><span class="line">MessageAccessor.clearProperty(msgInner, MessageConst.PROPERTY_REAL_TOPIC);</span><br><span class="line"></span><br><span class="line">MessageAccessor.clearProperty(msgInner, MessageConst.PROPERTY_REAL_QUEUE_ID);</span><br><span class="line"></span><br><span class="line">return msgInner;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：</span><br><span class="line">@1 根据偏移量将半消息查找出来</span><br><span class="line">@2 将存储在RMQ_SYS_TRANS_HALF_TOPIC还原</span><br><span class="line">@3 置换为原来的Topic</span><br><span class="line">@4 置换为原来的QueueId</span><br></pre></td></tr></table></figure>



<p>还原后消息存储。方法：EndTransactionProcessor#processRequest</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;@1 新组装的消息存储（提交）</span><br><span class="line"></span><br><span class="line">RemotingCommand sendResult &#x3D; sendFinalMessage(msgInner);</span><br><span class="line"></span><br><span class="line">if (sendResult.getCode() &#x3D;&#x3D; ResponseCode.SUCCESS) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@2 删除prepare消息 是将消息存储于RMQ_SYS_TRANS_OP_HALF_TOPIC中</span><br><span class="line"></span><br><span class="line">this.brokerController.getTransactionalMessageService().deletePrepareMessage(result.getPrepareMessage());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：</span><br><span class="line">@1 将还原后的消息存储</span><br><span class="line">@2 删除半消息消息</span><br></pre></td></tr></table></figure>

<p>半消息删除。方法：TransactionalMessageServiceImpl#putOpMessage</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean putOpMessage(MessageExt messageExt, String opType) &#123;</span><br><span class="line"></span><br><span class="line">MessageQueue messageQueue &#x3D; new MessageQueue(messageExt.getTopic(),</span><br><span class="line"></span><br><span class="line">this.brokerController.getBrokerConfig().getBrokerName(), messageExt.getQueueId());</span><br><span class="line"></span><br><span class="line">if (TransactionalMessageUtil.REMOVETAG.equals(opType)) &#123;</span><br><span class="line"></span><br><span class="line">return addRemoveTagInTransactionOp(messageExt, messageQueue);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return true;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private boolean addRemoveTagInTransactionOp(MessageExt messageExt, MessageQueue messageQueue) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@1 主题变更为RMQ_SYS_TRANS_OP_HALF_TOPIC</span><br><span class="line"></span><br><span class="line">Message message &#x3D; new Message(TransactionalMessageUtil.buildOpTopic(), TransactionalMessageUtil.REMOVETAG, String.valueOf(messageExt.getQueueOffset()).getBytes(TransactionalMessageUtil.charset));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@2 存储消息</span><br><span class="line"></span><br><span class="line">writeOp(message, messageQueue);</span><br><span class="line"></span><br><span class="line">return true;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：半消息的删除是将Topic从RMQ_SYS_TRANS_HALF_TOPIC变更为RMQ_SYS_TRANS_OP_HALF_TOPIC存储到日志文件，依靠文件删除机制删除。</span><br></pre></td></tr></table></figure>

<h2 id="处理事务回滚请求"><a href="#处理事务回滚请求" class="headerlink" title="处理事务回滚请求"></a>处理事务回滚请求</h2><p>方法：EndTransactionProcessor#processRequest</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;@1 查找半消息</span><br><span class="line"></span><br><span class="line">result &#x3D; this.brokerController.getTransactionalMessageService().rollbackMessage(requestHeader);</span><br><span class="line"></span><br><span class="line">if (result.getResponseCode() &#x3D;&#x3D; ResponseCode.SUCCESS) &#123;</span><br><span class="line"></span><br><span class="line">if (res.getCode() &#x3D;&#x3D; ResponseCode.SUCCESS) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@2 删除prepare消息 是将消息存储于RMQ_SYS_TRANS_OP_HALF_TOPIC中 this.brokerController.getTransactionalMessageService().deletePrepareMessage(result.getPrepareMessage());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return res;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：处理事务回滚请求，将半消息查找出来，将其删除即：将Topic从RMQ_SYS_TRANS_HALF_TOPIC变更为RMQ_SYS_TRANS_OP_HALF_TOPIC并存储，依靠文件删除机制删除。</span><br></pre></td></tr></table></figure>



<h1 id="事务消息服务端状态回查"><a href="#事务消息服务端状态回查" class="headerlink" title="事务消息服务端状态回查"></a>事务消息服务端状态回查</h1><h2 id="事务回查线程类调用链"><a href="#事务回查线程类调用链" class="headerlink" title="事务回查线程类调用链"></a>事务回查线程类调用链</h2><p>线程类初始化：TransactionalMessageCheckService</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@1 main(String[] args)</span><br><span class="line"></span><br><span class="line">start(createBrokerController(args));</span><br><span class="line"></span><br><span class="line">@2 createBrokerController</span><br><span class="line"></span><br><span class="line">@3 initialize()</span><br><span class="line"></span><br><span class="line">@4 initialTransaction()</span><br><span class="line"></span><br><span class="line">this.transactionalMessageCheckService &#x3D;</span><br><span class="line"></span><br><span class="line">new TransactionalMessageCheckService(this);</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：在Broker初始化启动时，TransactionalMessageCheckService线程类也随着启动初始化。</span><br></pre></td></tr></table></figure>



<h2 id="事务回查逻辑"><a href="#事务回查逻辑" class="headerlink" title="事务回查逻辑"></a>事务回查逻辑</h2><p>方法：TransactionalMessageCheckService#run</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;@1 时间间隔为60秒</span><br><span class="line"></span><br><span class="line">long checkInterval &#x3D; brokerController.getBrokerConfig().getTransactionCheckInterval();</span><br><span class="line"></span><br><span class="line">while (!this.isStopped()) &#123;</span><br><span class="line"></span><br><span class="line">this.waitForRunning(checkInterval);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>方法：TransactionalMessageCheckService#onWaitEnd</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;@2 transactionTimeOut默认6秒</span><br><span class="line"></span><br><span class="line">long timeout &#x3D; brokerController.getBrokerConfig().getTransactionTimeOut();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@3 最大核查次数为15次</span><br><span class="line"></span><br><span class="line">int checkMax &#x3D; brokerController.getBrokerConfig().getTransactionCheckMax();</span><br><span class="line"></span><br><span class="line">long begin &#x3D; System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">this.brokerController.getTransactionalMessageService().check(timeout, checkMax, this.brokerController.getTransactionalMessageCheckListener());</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：事务回查每隔60秒执行一次，一次执行超时时间为6秒，最大回查次数为15次。</span><br></pre></td></tr></table></figure>



<p>回查逻辑（一）。方法：TransactionalMessageServiceImpl#check</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;@1</span><br><span class="line"></span><br><span class="line">Set&lt;MessageQueue&gt; msgQueues &#x3D; transactionalMessageBridge.fetchMessageQueues(topic);</span><br><span class="line"></span><br><span class="line">for (MessageQueue messageQueue : msgQueues) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取对应的RMQ_SYS_TRANS_OP_HALF_TOPIC中的队列</span><br><span class="line"></span><br><span class="line">MessageQueue opQueue &#x3D; getOpQueue(messageQueue);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;半消息消费队列中偏移量</span><br><span class="line"></span><br><span class="line">long halfOffset &#x3D; transactionalMessageBridge.fetchConsumeOffset(messageQueue);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;OP已删除消费队列中的偏移量</span><br><span class="line"></span><br><span class="line">long opOffset &#x3D; transactionalMessageBridge.fetchConsumeOffset(opQueue);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@2</span><br><span class="line"></span><br><span class="line">PullResult pullResult &#x3D; fillOpRemoveMap(removeMap, opQueue, opOffset, halfOffset, doneOpOffset);</span><br></pre></td></tr></table></figure>



<p>方法：TransactionalMessageServiceImpl#fillOpRemoveMap</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;@3</span><br><span class="line"></span><br><span class="line">PullResult pullResult &#x3D; pullOpMsg(opQueue, pullOffsetOfOp, 32);</span><br><span class="line"></span><br><span class="line">List&lt;MessageExt&gt; opMsg &#x3D; pullResult.getMsgFoundList();</span><br><span class="line"></span><br><span class="line">for (MessageExt opMessageExt : opMsg) &#123;</span><br><span class="line"></span><br><span class="line">Long queueOffset &#x3D; getLong(new String(opMessageExt.getBody(), TransactionalMessageUtil.charset));</span><br><span class="line"></span><br><span class="line">if (TransactionalMessageUtil.REMOVETAG.equals(opMessageExt.getTags())) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;已经处理过的消息即commit和rollback</span><br><span class="line"></span><br><span class="line">if (queueOffset &lt; miniOffset) &#123;</span><br><span class="line"></span><br><span class="line">doneOpOffset.add(opMessageExt.getQueueOffset());</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;已经处理删除过了，但是半消息还没有更新</span><br><span class="line"></span><br><span class="line">removeMap.put(queueOffset, opMessageExt.getQueueOffset());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line"></span><br><span class="line">log.error(&quot;Found a illegal tag in opMessageExt&#x3D; &#123;&#125; &quot;, opMessageExt);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：</span><br><span class="line">@1 从半消息队列中查找消息队列</span><br><span class="line">@2 opQueue队列中的消息均为已经删除的半消息，需要检查下是否已经删除了，当时半消息队列还没有更新。</span><br><span class="line">@3 miniOffset为半消息消费队列中的最大偏移量；queueOffset为删除消费队列的消息偏移量；通过比较两者来确定是否已经删除了，而半消息状态还没有更新，并将这类消息存储在removeMap中。</span><br></pre></td></tr></table></figure>

<p>回查逻辑（二）。方法：TransactionalMessageServiceImpl#check</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while (true) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;查找消息</span><br><span class="line"></span><br><span class="line">GetResult getResult &#x3D; getHalfMsg(messageQueue, i);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@1 已经处理过了，半消息滞后了，偏移量继续递增往下走</span><br><span class="line"></span><br><span class="line">if (removeMap.containsKey(i)) &#123;</span><br><span class="line"></span><br><span class="line">log.info(&quot;Half offset &#123;&#125; has been committed&#x2F;rolled back&quot;, i);</span><br><span class="line"></span><br><span class="line">removeMap.remove(i);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@2 needSkip 超过存储时间（默认3天） needDiscard 超过回查次数，默认15次</span><br><span class="line"></span><br><span class="line">if (needDiscard(msgExt, transactionCheckMax) || needSkip(msgExt)) &#123;</span><br><span class="line"></span><br><span class="line">listener.resolveDiscardMsg(msgExt);</span><br><span class="line"></span><br><span class="line">newOffset &#x3D; i + 1;</span><br><span class="line"></span><br><span class="line">i++;</span><br><span class="line"></span><br><span class="line">continue;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@3 消息存储时间大于开始时间暂不处理</span><br><span class="line"></span><br><span class="line">if (msgExt.getStoreTimestamp() &gt;&#x3D; startTime) &#123;</span><br><span class="line"></span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@4 存储的时间小于需要回查的时间 跳过</span><br><span class="line"></span><br><span class="line">if (valueOfCurrentMinusBorn &lt; checkImmunityTime) &#123;</span><br><span class="line"></span><br><span class="line">if (checkPrepareQueueOffset(removeMap, doneOpOffset, msgExt)) &#123;</span><br><span class="line"></span><br><span class="line">newOffset &#x3D; i + 1;</span><br><span class="line"></span><br><span class="line">i++;</span><br><span class="line"></span><br><span class="line">continue;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;接着往下处理</span><br><span class="line"></span><br><span class="line">newOffset &#x3D; i + 1;</span><br><span class="line"></span><br><span class="line">i++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结</span><br><span class="line">@1 removeMap（即已删除队列有而半消息队列未更新的消息）有则不在处理跳过该消息。</span><br><span class="line">@2 超过存储时间或者回查次数超过15次不再处理</span><br><span class="line">@3 消息存储时间大于核查程序开始时间暂不处理</span><br><span class="line">@4 如果定义了回查的时间间隔需要判断是否到时间了</span><br></pre></td></tr></table></figure>

<p>回查逻辑（三）。方法：TransactionalMessageServiceImpl#check</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (isNeedCheck) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@1</span><br><span class="line"></span><br><span class="line">if (!putBackHalfMsgQueue(msgExt, i)) &#123;</span><br><span class="line"></span><br><span class="line">continue;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@2</span><br><span class="line"></span><br><span class="line">listener.resolveHalfMsg(msgExt);</span><br><span class="line"></span><br><span class="line">&#125;&#125; else &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@3</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;保存prepare消息队列的回查消费进度</span><br><span class="line"></span><br><span class="line">if (newOffset !&#x3D; halfOffset) &#123;</span><br><span class="line"></span><br><span class="line">transactionalMessageBridge.updateConsumeOffset(messageQueue, newOffset);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">long newOpOffset &#x3D; calculateOpOffset(doneOpOffset, opOffset);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;保存OP消费进度</span><br><span class="line"></span><br><span class="line">if (newOpOffset !&#x3D; opOffset) &#123;</span><br><span class="line"></span><br><span class="line">transactionalMessageBridge.updateConsumeOffset(opQueue, newOpOffset);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：</span><br><span class="line">@1 将半消息重新存储在RMQ_SYS_TRANS_HALF_TOPIC中，由于本次回查尚未知道结果，所以进行存储。</span><br><span class="line">@2 发到客户端进行回查，回查的RequestCode为CHECK_TRANSACTION_STATE &#x3D; 39，根据ProductGroup随机获取客户端通道Channel进行回查。</span><br><span class="line">@3 保存半消息和已处理消息的消费进度。</span><br></pre></td></tr></table></figure>



<h2 id="客户端响应事务回查"><a href="#客户端响应事务回查" class="headerlink" title="客户端响应事务回查"></a>客户端响应事务回查</h2><p>方法：ClientRemotingProcessor#checkTransactionState</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">producer.checkTransactionState(addr, messageExt, requestHeader);</span><br></pre></td></tr></table></figure>



<p>方法：MQProducerInner#checkTransactionState</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;@1</span><br><span class="line"></span><br><span class="line">localTransactionState &#x3D; transactionListener.checkLocalTransaction(message);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@2</span><br><span class="line"></span><br><span class="line">DefaultMQProducerImpl.this.mQClientFactory.getMQClientAPIImpl().endTransactionOneway(brokerAddr, thisHeader, remark,</span><br><span class="line"></span><br><span class="line">3000);</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小结：</span><br><span class="line">@1 执行本地事务回查并返回事务回查状态</span><br><span class="line">@2 将事务回查状态提交到Broker</span><br></pre></td></tr></table></figure>



<h1 id="事务消息交互示意图"><a href="#事务消息交互示意图" class="headerlink" title="事务消息交互示意图"></a>事务消息交互示意图</h1><p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219151320.png"></p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ43# Raft一致性算法整理</title>
    <url>/posts/86dc035b/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="Raft概述"><a href="#Raft概述" class="headerlink" title="Raft概述"></a>Raft概述</h1><h2 id="Raft定义"><a href="#Raft定义" class="headerlink" title="Raft定义"></a>Raft定义</h2><p>Raft是一种用来管理日志复制的一致性算法。一致性算法允许一组机器像一个整体一样工作，即使其中的一些机器出了错误也能正常工作。</p>
<a id="more"></a>

<h2 id="复制状态机"><a href="#复制状态机" class="headerlink" title="复制状态机"></a>复制状态机</h2><p>复制状态机(State Machine Replication)：通过复制服务副本，并和副本一起来协调客户端的交互，来实现容错服务。Raft复制状态机是通过复制日志来实现的，每一台服务器保存着一份日志。</p>
<h2 id="Raft一致性"><a href="#Raft一致性" class="headerlink" title="Raft一致性"></a>Raft一致性</h2><p>Raft实现一致性是首先选择一个确定的leader，然后leader负责管理日志复制。leader接受来自客户端的请求并追加到本地日志，然后把日志复制到其它的机器并告诉其它机器什么时候可以安全的将日志应用到状态机。<code>集群存在一个leader的好处可以简化日志复制的管理</code>。例如：leader可以决定日志的追加，而不需要经其它机器的同意。<code>整个集群的数据流向也是从leader流向其它机器</code>。如果leader宕机或者网络断开，其它的机器可以重新选举一个新的leader。</p>
<p>Raft一致性问题分解为3个相对独立的子问题</p>
<p>Leader election：当一个leader宕机后，一个新的leader必须被选举。</p>
<p>Log replication：leader必须响应客户端的请求，并把日志复制到整个集群来保证其它机器的日志和自己的相同。</p>
<p>Safety：状态机的安全是Raft优先保证的。如果任意一台机器将一条特定的日志应用到自己的状态机，那么其他的机器就不能应用一条不同的日志到自己的状态机。解决这个问题的方案就是在选举是增加额外的规则约束。</p>
<h2 id="Raft新的特性"><a href="#Raft新的特性" class="headerlink" title="Raft新的特性"></a>Raft新的特性</h2><p>强领导者（Strong Leader）：日志条目只从领导者发送向其他服务器。</p>
<p>领导选取（Leader Selection）：Raft使用了随机定时器来选择leader。</p>
<p>成员变化（Membership Change）：Raft使用了一种<code>联合一致性</code>的方法，使得集群中的机器发生变更的时候，整个集群也可以正常的工作。联合一致性配置是两个不同配置的大多数机器的重叠。</p>
<!--more-->



<h1 id="Raft一致性算法"><a href="#Raft一致性算法" class="headerlink" title="Raft一致性算法"></a>Raft一致性算法</h1><h2 id="State（状态）"><a href="#State（状态）" class="headerlink" title="State（状态）"></a>State（状态）</h2><p>所有机器需要持久化的状态（在RPC响应之前，需要更新稳定存储介质）</p>
<p>currentTerm 服务器存储的最新任期号从0开始递增</p>
<p>votedFor 在当前任期内收到选票的候选人id如果没有就为null</p>
<p>log[] 日志条目；每个条目包含状态机的要执行命令和从领导人处收到时的任期号</p>
<p>所有机器的可变状态</p>
<p>commitIndex 将被提交的日志记录的索引从0开始递增</p>
<p>lastApplied 已经被提交到状态机的最后一个日志的索引从0开始递增</p>
<p>leader的可变状态(每次选举后重新初始化)</p>
<p>nextIndex[] 每台机器在数组占据一个元素，元素的值为下条发送到该机器的日志索引(初始值为 leader最新一条日志的索引+1)</p>
<p>matchIndex[] 每台机器在数组中占据一个元素，元素的记录将要复制给该机器日志的索引的从0开始递增</p>
<h2 id="AppendEntries-RPC（日志追加远程过程调用）"><a href="#AppendEntries-RPC（日志追加远程过程调用）" class="headerlink" title="AppendEntries RPC（日志追加远程过程调用）"></a>AppendEntries RPC（日志追加远程过程调用）</h2><p>被leader用来复制日志；同时也被用作心跳。</p>
<p>Arguments：</p>
<p>term leader任期</p>
<p>leaderId 用来follower重定向到leader</p>
<p>prevLogIndex 前继日志记录的索引</p>
<p>prevLogTerm 前继日志的任期</p>
<p>entries[] 存储日志记录</p>
<p>leaderCommit leader的commitIndex</p>
<p>Results：</p>
<p>term 当前的任期号，用于领导人更新自己的任期号</p>
<p>success 如果follower包含索引为prevLogIndex和任期为prevLogItem的日志</p>
<p>接受者的实现</p>
<p>1.如果leader的任期小于自己的任期返回false。</p>
<p>2.如果自己不存在索引、任期和 prevLogIndex、prevLogItem匹配的日志返回false。</p>
<p>3.如果存在一条日志索引和prevLogIndex相等，但是任期和prevLogItem不相同的日志，需要删除这条日志及所有后继日志。</p>
<p>4.如果leader复制的日志本地没有，则直接追加存储。</p>
<p>5.如果leaderCommit&gt;commitIndex，设置本地commitIndex为leaderCommit和最新日志索引中较小的一个。</p>
<h2 id="RequestVote-RPC（投票请求RPC）"><a href="#RequestVote-RPC（投票请求RPC）" class="headerlink" title="RequestVote RPC（投票请求RPC）"></a>RequestVote RPC（投票请求RPC）</h2><p>被候选者用来收集选票</p>
<p>Arguments：</p>
<p>term 候选者的任期</p>
<p>candidateId 候选者编号</p>
<p>lastLogIndex 候选者最后一条日志记录的索引</p>
<p>lastLogTerm 候选者最后一条日志记录的索引的任期</p>
<p>Results：</p>
<p>term 当前任期，候选者用来更新自己</p>
<p>voteGranted 如果候选者当选则为true</p>
<p>接受者的实现：</p>
<p>1.如果leader的任期小于自己的任期返回false</p>
<p>2.如果本地voteFor为空，候选者日志和本地日志相同，则投票给该候选者</p>
<h2 id="Rules-for-Serve（服务器需要遵守的规则）"><a href="#Rules-for-Serve（服务器需要遵守的规则）" class="headerlink" title="Rules for Serve（服务器需要遵守的规则）"></a>Rules for Serve（服务器需要遵守的规则）</h2><p>所有机器</p>
<p>1.如果commitIndex &gt; lastApplied：增加lastApplied，并将日志log[lastApplied]应用到状态机</p>
<p>2.如果RPC的请求或者响应中包含一个term T大于currentTerm，则currentTerm赋值为T，并切换状态为追随者（Follower）</p>
<p>追随者/参与者（followers）</p>
<p>1.响应来自候选者或者leader的请求</p>
<p>2.如果在超过选取领导人时间之前没有收到来自当前领导人的AppendEntries RPC或者没有收到候选人的投票请求，则自己转换状态为候选人</p>
<p>候选人（candidate）</p>
<p>1.一旦变为候选者，则开始启动选举</p>
<p>1.1 currentTerm自增</p>
<p>1.2 选举自己</p>
<p>1.3 重置选举定时器</p>
<p>1.4 并行发送选举请求到其他所有机器</p>
<p>2.如果收到集群大多数机器的选票，则称为新的leader</p>
<p>3.如果收到了来自新领导人的AppendEntries RPC（heartbeat）转换为追随者</p>
<p>4.如果选举超时开始新一轮的选举</p>
<p>领导者（leaders）：</p>
<p>1.一旦成为领导人：向其他所有服务器发送空的AppendEntries RPC（heartbeat）; 在空闲时间重复发送以防止选举超时</p>
<p>2.如果接受到来自客户端的请求，追加日志记录到本地日志，如果成功应用日志记录到状态机则回应客户端。</p>
<p>3.如果某个参与者的最新日志索引大于等于本地存储该参与者的最新日志索引：给该参与者发送包含从 nextIndex开始的日志追加请求。</p>
<p>3.1 如果成功，更新该参与者的 nextIndex和matchIndex。</p>
<p>3.2 如果由于日志不一致而失败，减少nextIndex并重试。</p>
<p>4.如果存在N &gt; commitIndex（本地待提交日志的索引），majority(matchIndex[i]&gt;= N)（如果参与者大多数的最新日志的索引大于 N），并且这些参与者索引为N的日志的任期也等于leader的当前任期：commitIndex=N（leader的待提交的日志索引设置为N）</p>
<p>Raft 一致性算法的总结</p>
<p>选举安全原则（Election Safety） 在一个给定的任期最多只可以选举出一个leader。</p>
<p>领导人只增加原则（Leader Append-Only）对于一个leader它永远不会重写和删除日志中的日志记录，它只会追加日志记录。</p>
<p>日志匹配原则（Log Matching） 如果两个日志文件中存在相同索引和任期的日志记录那么两个日志文件所有的日志记录在给定索引情况下是相同的。</p>
<p>领导人完全原则（Leader Completeness) 如果一条日志在一个给定的任期已经提交，那么这条日志将会出现在所有任期大于给定任期的leader的日志中。</p>
<p>状态机安全原则（State Machine Safety）如果一个server已经将给定索引的日志应用到状态机，别的server将不能应用一个相同索引但内容不同的日志记录到自己的状态机。</p>
<h2 id="三种角色"><a href="#三种角色" class="headerlink" title="三种角色"></a>三种角色</h2><p>任意时刻，一台server会处在三种状态中的一种：<code>leader、follower和candidate</code>。</p>
<p>正常情况下，集群中包含一个leader和参与者。集群中的参与者是被动的，它们不会主动解决问题而是被动的响应leader或者参与者的请求。集群中leader负责处理所有的客户端请求，如果一个客户端的请求连接到了参与者，这个参与者会将请求重定向到leader。候选者是在选举中可能成为leader的状态。</p>
<h2 id="任期"><a href="#任期" class="headerlink" title="任期"></a>任期</h2><p>Raft将时间分为任意长度的间隔，每个间隔是一个任期。每个任期会由一个连续的整数进行表示。每个任期都是从选举开始的，在这个阶段会有一个或者多个候选者参与竞选。一旦某个候选者在选举中胜出，这个任期剩下的时间将有这个候选者作为leader。</p>
<p>一些特殊的情况下，一次选举可能出现选举分裂的情况。<code>选举分裂的情况下，当前任期将不会选举出leader。紧接着一个新的任期将会启动重新进行选举。Raft通过上面的过程保证每个任期只会选举出至多一个leader</code>。</p>
<p>当servers进行通讯的时候，也会交换当前的任期。如果一个 server 存储的任期小于其他机器存储的任期，那么它将更新自己的任期到其它机器存储的最大任期。如果是一个候选者或者leader发现自己的任期已经过期，它们会转变到参与者的状态。如果一个server接受到一个请求，这个请求中的任期是过时的，它将直接拒绝该请求。</p>
<h2 id="选主"><a href="#选主" class="headerlink" title="选主"></a>选主</h2><p>Raft使用心跳机制来触发选主的过程。当servers启动的时候，都是作为参与者。如果一个参与者收到来自leader或者候选者的合法请求，它将保持在参与者的状态。leader会发送心跳到其它的server来授权延长自己的任期。如果一个参与者的选举定时器超时的时候还没有收到任何请求，它可以假设整个集群没有可用的leader或者候选者，然后发起新的选举。</p>
<p>一次选举开始时，参与者增加自己本地存储的当前任期然后转变为候选者状态。这个候选者先选举自己，并行的给集群中的其它机器发送 RequestVote RPCs。</p>
<p>候选者将会一直保持候选状态直到下面三件事情中的任意一件发生：（a）：候选者本次选举胜出（b）：另外一台机器确认自己是leader（c）：僵持一段时候没有人胜出。</p>
<p>一个候选者如果接受到集群中大多数机器在同一个任期的选票，么它将胜出成为leader。每台机器在一个任期只能投票给一个候选者，按照先到先服务的原则。<code>大多数投票胜出规则可以保证在一个特定的任期至多选出一个leader。</code>。一旦一个候选者胜出将成为集群的leader，它将会并行的给集群的其它机器发送心跳来宣示自己胜出，并阻止进行新的选举。</p>
<p>在等待选票的过程中，一个候选者可能接受到来自其它server的请求，该请求声明自己已经成为 leader。如果请求中的leader的任期大于候选者本地存储的任期，那么当前候选者认为这个leader 是合法的并转变为参与者状态。<code>如果请求中leader的任期小于当前候选者本地存储的任期，那么候选将拒绝这个请求并保持在候选者状态</code>。</p>
<p>第三种可能是是整个集群的所有候选者都没有胜出。如果集群中所有的参与者同一时刻转变为候选者，</p>
<p>由于每个机器只能投票给一个候选者，这种情况新会很容易发生选举分裂即没有一个候选者获得半数以上选票。当这种情况发生，<code>所有的候选者的选举定时器将会超时，它们增加自己本地存储的任期并启动新一轮的选举</code>。从上面可以看出如果没有额外的规则约束，选举分裂的情况将极易发生。</p>
<p><code>Raft通过随机选举定时器来阻止选举分裂的发生，即使选举分裂发生也可以很快的被解决。选举超时将在 [150,300]ms之间随机生成，这样就大概率保证集群中会有一个机器会先超时，而避免所有机器同时超时从而降低选举分裂情况发生的概率</code>。如果首先超时的机器将会首先转变为候选者，它将会大概率的选举胜出成为leader，然后发送心跳续阻止其它机器定时器超时。</p>
<h2 id="日志复制"><a href="#日志复制" class="headerlink" title="日志复制"></a>日志复制</h2><p>一旦一个候选者成为leader，它将开始处理客户端的请求。客户端的每个请求包含了一条需要执行到状态机的命令。leader将命令追加到自己的日志记录，同时并发AppendEntries RPCs请求来进行日志复制。当日志安全的复制之后，leader 将日志应用到自己的状态机并将结果返回给客户端。<code>如果集群中有参与者宕机、处理速度慢、网络丢包等情况发生，leader将重试AppendEntries RPCs请求直到日志被安全的复制</code>。</p>
<p><code>leader来决定将一条日志应用到状态机的安全时机。这样的一条日志被称为committed</code>。Raft来保证日志的持久化并且所有已提交的日志将会都会被应用到状态机。一旦leader将一条日志成功的复制到集群的大多数机器，那么这条日志就是已提交状态。如果当前日志记录已提交，那么由前任leader或者当前leader创建的前继日志记录都会被提交。leader维护了即将被提交的日志记录的索引，并把这个索引放在未来的AppendEntries RPCs请求中。当参与者从请求获知已提交的索引，它会将本地该索引的日志应用到状态机。</p>
<p>###### Log Matching Property</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果两个日志的两条日志记录有相同的索引和任期，那么这两条日志记录中的命令必然也是相同的。</span><br><span class="line">如果两个日志的两条日志记录有相同的索引和任期，那么这两个日志中的前继日志记录也是相同的。</span><br></pre></td></tr></table></figure>

<p>在一个给定的任期，leader创建的日志索引是递增不重复的，一旦日志某条日志创建后是不会改变它在日志中位置。上面的事实保证了第一个性质的成立。每次当leader发送AppendEntries RPCs请求的时候，请求中会包含当前正在复制的日志记录的直接前继的任期和索引，如果参与者在自己的日志中没有发现有相同任期和索引的日志记录，它将直接拒绝请求。上面描述的一致性检测保证第二个性质的成立。`一致性检测的步骤如下：初始化时候是满足Log Matching Property的；当有追加日志的时候进行一次一致性检测来保护Log Matching Property。这样当leader接受到返回成功的</p>
<p>AppendEntries RPCs请求时，说明了参与者与自己的日志是相同的。`</p>
<p>正常情况下，leader 和参与者的日志都是相同的，日志一致性检测也不失败。当leader崩溃的时候就会导致日志的不一致，例如旧的leader没有将自己的日志记录安全的复制到其它机器。这些不一致可能聚合多个leader和参与者的崩溃。一个参与者可能缺失了leader有的日志记录，它也可能多出了leader没有的日志，或者上面的两种情况同时发生。缺失或多余的日志可能存在在多个任期。</p>
<p>Raft 是通过强制参与者只能复制leader的日志来解决不一致。这就意味者参与者的日志和leader的日志发生冲突的时候，参与者的日志将会重写或者删除。在额外附加的约束下上面的过程是安全的。</p>
<p>如果一致性检测失败后，为了保证参与者和自己的日志一致，<code>leader需要先确认参与者和自己一致的最后一条日志记录。然后通知参与者删除这条日志记录后面的日志，并将这条日志记录之后的日志复制给参与者</code>。leader为每个参与者维护了nextIndex，这个索引记录了leader将复制给该参与者的日志索引。当一个leader选举生效后，它将初始化nextIndex为它自己日志记录中最后一条日志记录的索引。如果leader的日志和参与者的日志不一致那么下一轮的AppendEntries RPCs进行AppendEntries一致性检测的时候就会发现。如果检测发生不一致，leader将会减少nextIndex并重试。经过多次重试leader就会确定参与者和自己一致的日志索引，然后通知参与者删除后面不一致的日志，然后复制自己的日志给参与者。经过上面的过程leader和参与者的一致就可以恢复一致。</p>
<p>上面过程中每次nextIndex减少1进行重试效率是存在问题的，但是也是可以优化的。一旦参与者进行日志一致性检测发现不一致之后，在响应leader请求中包含自己在这个任期存储的第一条日志。这样 leader接受到响应后，就可以直接跳过所有冲突的日志（其中可能包含了一致的日志）。这样就可以减少寻找一致点的过程。但是在实际中我们怀疑这种优化的必要性，因为失败发生的概率本来就很低，也不会同时存在大量不一致的日志记录。</p>
<p>使用上面的机制，一个leader生效的时候就不需要进行额外的操作来恢复日志的一致性。它只需按照正常的流程，日志的不一致经过多次AppendEntries RPCs一致性检测后会自动收敛。leader也不需要重写和删除本地日志。</p>
<p>Raft可以在集群只有半数以上存活的情况下接受、复制和应用新的日志记录；正常情况下只需要一轮 RPCs可以将日志记录复制到集群的大多数；单个速度慢的参与者不会影响整个集群的性能。</p>
<h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><p>上面描述了Raft的选主和日志复制。但是目前所描述的机制还不能安全的保证日志是按照相同顺序被应用到状态机。例如：在leader提交了若干条日志后，某个参与者宕机并被选为新的leader。新的leader重写其它机器的日志，结果导致不同的状态机有不同的命令序。我们通过添加额外约束控制某些机器能被选举为leader来完善Raft算法。<code>这个约束保证当选的leader包含了前任所有提交的日志。</code>通过约束我们可以精准的控制日志的提交。</p>
<p><strong>选举约束:</strong></p>
<p>Raft使用的方法是每个当选的leader必须之前所提交的所有日志，这种方法带来的好处是<code>集群中数据的流向只能是从leader到参与者，leader永远仅需要追加即可</code>。</p>
<p>Raft 使用选举过程来保证一个候选者必须包含有所有已提交的日志才能胜出。候选者为了胜出必须联系集群中的大多数机器，这就意味着每条日志至少出现在机群中的某一台机器上。<code>如果候选者的日志如果比集群其它任意一台机器的日志更新（下面精确定义“更新”），那么它将包含所有已提交的日志。</code>RequestVote RPCs来实现这个约束：请求中包含了 leader 的日志信息，<code>如果投票者的日志比候选者的日志更新，那么它就拒绝投票。</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">两个日志文件谁的日志更新是通过比较日志中最后一条日志记录的任期和索引。如果两个日志文件的最后一条日志的任期不相同，谁的任期更大谁的的日志将更新。如果两条日志记录的任期相同，那么谁的索引越大，谁的日志将更新。</span><br></pre></td></tr></table></figure>

<p><strong>提交上一个任期的日志</strong></p>
<p>如果当前任期的一条日志已经被复制到集群中的大多数，那么leader可以确定这条已经已经处于提交状态。如果上任leader在提交日志之前宕机，下一任leader将尝试完成日志的复制。然而，尽管上一任期的某条日志已经被复制到了大多数机器，但是新任leader还是不能准确断定这条日志是否是已提交。</p>
<p>Raft不能根据上一任期的日志是否被复制到大多数机器来决定是否提交日志。一旦当前任期看到一条日志被提交，由于Log Matching Property保证，那么这条日志之前的日志已自动被提交。</p>
<h1 id="集群成员变更"><a href="#集群成员变更" class="headerlink" title="集群成员变更"></a>集群成员变更</h1><p>在实际系统中，我们有时候可能需要变更配置，例如需要替换宕机的机器或者增加日志的副本数。为了保证安全，配置变更采用两阶段的方法。这里有很多方法可以实现两阶段，例如：有的系统在第一个阶段来停止旧配置，这样就不能响应客户端的请求；然后第二阶段切换到新配置。Raft集群第一阶段</p>
<p>会过渡到迁移配置（我们称之为联合一致性配置joint consensus）；一旦联合一致性被提交，系统将切换到新配置。<code>joint consensus配置组合了老配置和新配置</code>。</p>
<h1 id="客户端交互"><a href="#客户端交互" class="headerlink" title="客户端交互"></a>客户端交互</h1><p>Raft的客户端将自己的请求发送到leader。当一个客户端首次启动，它会随机的选择集群的一台机器。如果客户端的首次选择不是leader，这台机器将拒绝客户端的请求，并会告知自己最近监听到的 leader。如果leader宕机，客户端的请求将会超时，客户端可以随机的选择机器进行重试。</p>
<p>Raft的目标是实现线性语义（每个操作都是立刻被执行的），然而，目前为止我们描述的 Raft可以重复多次的执行一条命令；例如，如果leader提交了日志但是还没有来得及响应客户端就宕机，那么客户端将会换一个leader重试之前的命令。<code>解决方法就是客户端给每个命令一个唯一的编号，那么，状态机记录每个客户端处理的最新的编号。一旦接受到一条命令它的序列号已经被执行过，直接响应这个请求但是不重新执行这个请求</code>。</p>
<h1 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h1><p>本文笔记整理自Raft论文译文，全文详见以下链接。</p>
<p>Raft论文译文</p>
<p><a href="https://github.com/brandonwang001/raft_translation/blob/master/raft_translation.pdf">https://github.com/brandonwang001/raft_translation/blob/master/raft_translation.pdf</a></p>
<p>Raft论文原文</p>
<p><a href="https://ramcloud.atlassian.net/wiki/download/attachments/6586375/raft.pdf">https://ramcloud.atlassian.net/wiki/download/attachments/6586375/raft.pdf</a></p>
<p>Raft动画</p>
<p><a href="http://thesecretlivesofdata.com/raft/">http://thesecretlivesofdata.com/raft/</a></p>
<p>Raft可视化操作</p>
<p><a href="https://raft.github.io/">https://raft.github.io/</a></p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty7# Netty之事件传递</title>
    <url>/posts/8c88e43/</url>
    <content><![CDATA[<div id="vip-container"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前面的文章中写了Channel实例化、Channel初始化、Channel注册、异步通知机制、客户端发起连接、事件的轮询和处理机制。Netty作为client/server高效通信框架，事件在ChannelPipeline是如何传递的，本文就聊聊这事。</p>
<a id="more"></a>



<h1 id="事件传递过程"><a href="#事件传递过程" class="headerlink" title="事件传递过程"></a>事件传递过程</h1><p>ChannelPipeline随着Channel的创建而创建，在 <a href="https://mp.weixin.qq.com/s/tvy0j0Mo9H82SK4jztqu0w">Netty2# Netty组件之Channel初始化 </a> 文章中梳理了ChannelPipeline、ChannelHandlerContext、ChannelHandler的关系如下图。</p>
<p>ChannelPipeline大管道维护了一个ChannelHandlerContext链表，头部为HeadContext，尾部为TailContext。事件传播会沿着链表逐级向下传递。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201226112641.png"></p>
<h3 id="Inbound-amp-Outbound标识"><a href="#Inbound-amp-Outbound标识" class="headerlink" title="Inbound&amp;Outbound标识"></a>Inbound&amp;Outbound标识</h3><p>当ChannelHandlerContext创建时，它是Inbound还是Outbound，是哪个方向的就确定了。下面分析是这种身份是如何确定的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AbstractChannelHandlerContext(DefaultChannelPipeline pipeline, EventExecutor executor,</span><br><span class="line">                              String name, Class&lt;? extends ChannelHandler&gt; handlerClass) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = ObjectUtil.checkNotNull(name, <span class="string">&quot;name&quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>.pipeline = pipeline;</span><br><span class="line">    <span class="keyword">this</span>.executor = executor;</span><br><span class="line">    <span class="keyword">this</span>.executionMask = mask(handlerClass); <span class="comment">// 注解@1</span></span><br><span class="line">    ordered = executor == <span class="keyword">null</span> || executor <span class="keyword">instanceof</span> OrderedEventExecutor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@1</strong> 父类的构造函数中有一个mask(handlerClass)方法，这个方法确定了ChannelHandlerContext的身份。如下代码ChannelInboundHandler.class.isAssignableFrom(handlerType)即如果是ChannelInboundHandler类型mask |= MASK_ALL_INBOUND；反之如果是ChannelOutboundHandler类型，mask |= MASK_ALL_OUTBOUND；<strong>通过赋予mask不同的值来区分是哪个方向的Handler</strong>。isSkippable中的逻辑判断主要对加注解@Skip的方法不再进行事件回调。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mask0</span><span class="params">(Class&lt;? extends ChannelHandler&gt; handlerType)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mask = MASK_EXCEPTION_CAUGHT;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ChannelInboundHandler.class.isAssignableFrom(handlerType)) &#123;</span><br><span class="line">            mask |= MASK_ALL_INBOUND; <span class="comment">// 标识为INBOUND</span></span><br><span class="line">            <span class="keyword">if</span> (isSkippable(handlerType, <span class="string">&quot;channelRegistered&quot;</span>, ChannelHandlerContext.class))&#123;</span><br><span class="line">                mask &amp;= ~MASK_CHANNEL_REGISTERED;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ChannelOutboundHandler.class.isAssignableFrom(handlerType)) &#123;</span><br><span class="line">            mask |= MASK_ALL_OUTBOUND; <span class="comment">// 标识为OUTBOUND</span></span><br><span class="line">            <span class="keyword">if</span> (isSkippable(handlerType, <span class="string">&quot;bind&quot;</span>, ChannelHandlerContext.class,</span><br><span class="line">                    SocketAddress.class, ChannelPromise.class)) &#123;</span><br><span class="line">                mask &amp;= ~MASK_BIND;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">       <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Outbound传递过程"><a href="#Outbound传递过程" class="headerlink" title="Outbound传递过程"></a>Outbound传递过程</h3><p><strong>示例入口</strong> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ChannelFuture future = b.connect(HOST, PORT).sync(); </span><br><span class="line">future.channel().writeAndFlush(<span class="string">&quot;Hi&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>以writeAndFlush方法跟踪下Outbound事件在ChannelPipeline的传递过程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelFuture <span class="title">writeAndFlush</span><span class="params">(Object msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tail.writeAndFlush(msg); <span class="comment">// 注解@2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">private <span class="keyword">void</span> <span class="function"><span class="title">write</span>(<span class="params"><span class="built_in">Object</span> msg, boolean flush, ChannelPromise promise</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  	final AbstractChannelHandlerContext next = findContextOutbound(flush ?</span><br><span class="line">            (MASK_WRITE | MASK_FLUSH) : MASK_WRITE); <span class="comment">// 注解@3</span></span><br><span class="line">    final <span class="built_in">Object</span> m = pipeline.touch(msg, next);</span><br><span class="line">    EventExecutor executor = next.executor();</span><br><span class="line">    <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flush) &#123;</span><br><span class="line">            next.invokeWriteAndFlush(m, promise);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            next.invokeWrite(m, promise);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        final WriteTask task = WriteTask.newInstance(next, m, promise, flush);</span><br><span class="line">        <span class="keyword">if</span> (!safeExecute(executor, task, promise, m, !flush)) &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            task.cancel();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> AbstractChannelHandlerContext <span class="title">findContextOutbound</span><span class="params">(<span class="keyword">int</span> mask)</span> </span>&#123;</span><br><span class="line">    AbstractChannelHandlerContext ctx = <span class="keyword">this</span>;</span><br><span class="line">    EventExecutor currentExecutor = executor();</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        ctx = ctx.prev;</span><br><span class="line">    &#125; <span class="keyword">while</span> (skipContext(ctx, currentExecutor, mask, MASK_ONLY_OUTBOUND)); <span class="comment">// 注解@4</span></span><br><span class="line">    <span class="keyword">return</span> ctx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">skipContext</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        AbstractChannelHandlerContext ctx, EventExecutor currentExecutor, <span class="keyword">int</span> mask, <span class="keyword">int</span> onlyMask)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (ctx.executionMask &amp; (onlyMask | mask)) == <span class="number">0</span> ||</span><br><span class="line">            (ctx.executor() == currentExecutor &amp;&amp; (ctx.executionMask &amp; mask) == <span class="number">0</span>); <span class="comment">// 注解@5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@2</strong> 从链表尾部TailContext开始执行。</p>
<p><strong>注解@3</strong> 我们示例writeAndFlush所以findContextOutbound的mask为(MASK_WRITE | MASK_FLUSH)</p>
<p><strong>注解@4</strong> 循环链表查找，注意skipContext是判断的跳过逻辑。我们查找Outbound的ChannelHandlerContext，遇到Inbound的都会跳过。</p>
<p><strong>注解@5</strong> 判断是否跳过，这段逻辑是位操作，不好阅读。下面示例抽取各个入参的值测试下：如果下一个ChannelHandlerContext为inBound，则skipContext返回true，从而在查找outBound的do/while循环中跳过。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> executionMask =  MASK_EXCEPTION_CAUGHT |= MASK_ALL_INBOUND; <span class="comment">// inBound 身份标识</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mask = MASK_WRITE | MASK_FLUSH; <span class="comment">// writeAndFlush 标识</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> onlyMask = MASK_ONLY_OUTBOUND; <span class="comment">// outBound操作集合</span></span><br><span class="line"></span><br><span class="line">System.out.println((executionMask &amp; (onlyMask | mask))==<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">输出为：<span class="keyword">true</span></span><br></pre></td></tr></table></figure>



<p><strong>小结：</strong> outBound事件在ChannelPipeline中传递时，只会选择身份为outBound的ChannelHandlerContext执行。</p>
<h3 id="Inbound传递过程"><a href="#Inbound传递过程" class="headerlink" title="Inbound传递过程"></a>Inbound传递过程</h3><p>以上一篇文章 <a href="https://mp.weixin.qq.com/s/rcVDX0tNMhRGchjYHddARw">Netty6# Netty之事件轮询与处理</a> 当有新的客户端的连接时触发unsafe.read()执行。具体为NioMessageUnsafe#read()方法。具体为上文中<strong>注解@17</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 入口</span></span><br><span class="line">pipeline.fireChannelRead(readBuf.get(i));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">fireChannelRead</span><span class="params">(Object msg)</span> </span>&#123;</span><br><span class="line">  AbstractChannelHandlerContext.invokeChannelRead(head, msg);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeChannelRead</span><span class="params">(Object msg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (invokeHandler()) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      ((ChannelInboundHandler) handler()).channelRead(<span class="keyword">this</span>, msg);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      notifyHandlerException(t);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fireChannelRead(msg); <span class="comment">// 注解@6</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@6</strong> 下面的方法findContextInbound(MASK_CHANNEL_READ)，只查找Inbound的ChannelHandlerContext。具体逻辑与Outbound传递过程相似，不再重复。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelHandlerContext <span class="title">fireChannelRead</span><span class="params">(<span class="keyword">final</span> Object msg)</span> </span>&#123;</span><br><span class="line">    invokeChannelRead(findContextInbound(MASK_CHANNEL_READ), msg);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>小结：</strong> inBound事件在ChannelPipeline中传递时，只会选择身份为inBound的ChannelHandlerContext执行。</p>
<h1 id="ChannelPipeline重要API"><a href="#ChannelPipeline重要API" class="headerlink" title="ChannelPipeline重要API"></a>ChannelPipeline重要API</h1><p>ChannelPipeline的默认实现为DefaultChannelPipeline，以下API源码梳理均来自该实现类。</p>
<table>
<thead>
<tr>
<th>接口</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>ChannelPipeline addFirst(ChannelHandler… handlers)</td>
<td>在ChannelPipeline中，将ChannelHandlerContext添加HeadContext的后面。</td>
</tr>
<tr>
<td>ChannelPipeline addLast(ChannelHandler… handlers);</td>
<td>在ChannelPipeline中，将ChannelHandlerContext添加到TailContext的前面。</td>
</tr>
<tr>
<td>ChannelPipeline addBefore(String baseName, String name, ChannelHandler handler);</td>
<td>在ChannelPipeline中，将ChannelHandlerContext添加到某ChannelHandlerContext的前面。</td>
</tr>
<tr>
<td>ChannelPipeline addAfter(String baseName, String name, ChannelHandler handler);</td>
<td>在ChannelPipeline中，将ChannelHandlerContext添加到指定的ChannelHandlerContext的后面。</td>
</tr>
<tr>
<td>ChannelPipeline remove(ChannelHandler handler);</td>
<td>在ChannelPipeline中，将ChannelHandlerContext从链表中移除。</td>
</tr>
<tr>
<td>ChannelPipeline replace(ChannelHandler oldHandler, String newName, ChannelHandler newHandler);</td>
<td>在ChannelPipeline中，将新newCtx在链表中替换就得oldCtx。</td>
</tr>
</tbody></table>
<h3 id="addFirst"><a href="#addFirst" class="headerlink" title="addFirst"></a>addFirst</h3><p>说明：在ChannelPipeline中，将ChannelHandlerContext添加HeadContext的后面。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">addFirst</span><span class="params">(EventExecutorGroup group, String name, ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> AbstractChannelHandlerContext newCtx;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            checkMultiplicity(handler); <span class="comment">// 注解@7</span></span><br><span class="line">            name = filterName(name, handler); <span class="comment">// 注解@8</span></span><br><span class="line"></span><br><span class="line">            newCtx = newContext(group, name, handler); </span><br><span class="line"></span><br><span class="line">            addFirst0(newCtx); <span class="comment">// 注解@9</span></span><br><span class="line">						</span><br><span class="line">          	<span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        callHandlerAdded0(newCtx); <span class="comment">// 注解@10</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@7：</strong>checkMultiplicity()方法校验ChannelHandler是否重复。如果ChannelHandler中有注解@Sharable标识，则允许同一个ChannelHandler添加到不同的ChannelPipeline中。<strong>未加@Sharable注解的ChannelHandler只允许添加到一个ChannelPipeline</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkMultiplicity</span><span class="params">(ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> ChannelHandlerAdapter) &#123;</span><br><span class="line">        ChannelHandlerAdapter h = (ChannelHandlerAdapter) handler;</span><br><span class="line">        <span class="keyword">if</span> (!h.isSharable() &amp;&amp; h.added) &#123; <span class="comment">// 判断@Sharable注解和该Handler是否已经被添加</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ChannelPipelineException(</span><br><span class="line">                    h.getClass().getName() +</span><br><span class="line">                    <span class="string">&quot; is not a @Sharable handler, so can&#x27;t be added or removed multiple times.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        h.added = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@Sharable使用示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Sharable</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToMessageEncoder</span>&lt;<span class="title">CharSequence</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@8：</strong> ChannelHandler名字判断，没有设置Handler名字则自动生成一个；设置了Handler名字，不能与该ChannelPipeline其他ChannelHandler名字重复。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">filterName</span><span class="params">(String name, ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> generateName(handler); </span><br><span class="line">    &#125;</span><br><span class="line">    checkDuplicateName(name);</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@9：</strong>创建DefaultChannelHandlerContext，并加入将其加入到链表中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addFirst0</span><span class="params">(AbstractChannelHandlerContext newCtx)</span> </span>&#123;</span><br><span class="line">	AbstractChannelHandlerContext nextCtx = head.next;</span><br><span class="line">	newCtx.prev = head;</span><br><span class="line">	newCtx.next = nextCtx;</span><br><span class="line">	head.next = newCtx;</span><br><span class="line">	nextCtx.prev = newCtx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>经过上面链表的顺序调整，addFirst将ChannelHandlerContext添加到了HeadContext的后面。</strong></p>
<p><strong>注解@10</strong> ：当ChannelHandler添加ChannelPipeline后，回调该Handler的handlerAdded方法，也是通知机制的常用做法。</p>
<h3 id="addLast"><a href="#addLast" class="headerlink" title="addLast"></a>addLast</h3><p>说明：在ChannelPipeline中，将ChannelHandlerContext添加到TailContext的前面。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">addLast</span><span class="params">(EventExecutorGroup group, String name, ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AbstractChannelHandlerContext newCtx;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        checkMultiplicity(handler);</span><br><span class="line"></span><br><span class="line">        newCtx = newContext(group, filterName(name, handler), handler);</span><br><span class="line"></span><br><span class="line">        addLast0(newCtx); <span class="comment">// 注解@11</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    callHandlerAdded0(newCtx);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@11</strong>  <strong>其他逻辑同addFirst，addLast0将HandlerContext添加到TailContext的前一个位置。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addLast0</span><span class="params">(AbstractChannelHandlerContext newCtx)</span> </span>&#123;</span><br><span class="line">    AbstractChannelHandlerContext prev = tail.prev;</span><br><span class="line">    newCtx.prev = prev;</span><br><span class="line">    newCtx.next = tail;</span><br><span class="line">    prev.next = newCtx;</span><br><span class="line">    tail.prev = newCtx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>addBefore</strong></p>
<p>说明：在ChannelPipeline中，将ChannelHandlerContext添加到某ChannelHandlerContext的前面。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">addBefore</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        EventExecutorGroup group, String baseName, String name, ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AbstractChannelHandlerContext newCtx;</span><br><span class="line">    <span class="keyword">final</span> AbstractChannelHandlerContext ctx;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        checkMultiplicity(handler);</span><br><span class="line">        name = filterName(name, handler);</span><br><span class="line">        ctx = getContextOrDie(baseName); <span class="comment">// 注解@12</span></span><br><span class="line"></span><br><span class="line">        newCtx = newContext(group, name, handler); </span><br><span class="line"></span><br><span class="line">        addBefore0(ctx, newCtx); <span class="comment">// 注解@13</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    callHandlerAdded0(newCtx);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@12</strong> 根据传入的baseName在ChannelPipleline查找对应的HandlerContext。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> AbstractChannelHandlerContext <span class="title">getContextOrDie</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    AbstractChannelHandlerContext ctx = (AbstractChannelHandlerContext) context(name);</span><br><span class="line">    <span class="keyword">if</span> (ctx == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(name);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ctx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@13</strong> 添加到链表中，添加到baseName的前面。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addBefore0</span><span class="params">(AbstractChannelHandlerContext ctx, AbstractChannelHandlerContext newCtx)</span> </span>&#123;</span><br><span class="line">    newCtx.prev = ctx.prev;</span><br><span class="line">    newCtx.next = ctx;</span><br><span class="line">    ctx.prev.next = newCtx;</span><br><span class="line">    ctx.prev = newCtx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>addAfter</strong></p>
<p>说明：在ChannelPipeline中，将ChannelHandlerContext添加到指定的ChannelHandlerContext的后面。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">addAfter</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        EventExecutorGroup group, String baseName, String name, ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AbstractChannelHandlerContext newCtx;</span><br><span class="line">    <span class="keyword">final</span> AbstractChannelHandlerContext ctx;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        checkMultiplicity(handler);</span><br><span class="line">        name = filterName(name, handler);</span><br><span class="line">        ctx = getContextOrDie(baseName);</span><br><span class="line"></span><br><span class="line">        newCtx = newContext(group, name, handler);</span><br><span class="line"></span><br><span class="line">        addAfter0(ctx, newCtx); <span class="comment">// 注解@14</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    callHandlerAdded0(newCtx);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@14：</strong>调整链表顺序，调整方式同上。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addAfter0</span><span class="params">(AbstractChannelHandlerContext ctx, AbstractChannelHandlerContext newCtx)</span> </span>&#123;</span><br><span class="line">    newCtx.prev = ctx;</span><br><span class="line">    newCtx.next = ctx.next;</span><br><span class="line">    ctx.next.prev = newCtx;</span><br><span class="line">    ctx.next = newCtx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h3><p>说明：在ChannelPipeline中，将ChannelHandlerContext从链表中移除。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> AbstractChannelHandlerContext <span class="title">remove</span><span class="params">(<span class="keyword">final</span> AbstractChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> ctx != head &amp;&amp; ctx != tail; <span class="comment">// 注解@15</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        atomicRemoveFromHandlerList(ctx); <span class="comment">// 注解@16</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">    callHandlerRemoved0(ctx);</span><br><span class="line">    <span class="keyword">return</span> ctx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@15</strong> 被移除的ChannelHandlerContext不能是HeadContext和TailContext。</p>
<p><strong>注解@16</strong> 通过调整前后ChannelHandlerContext的指针指向实现移除操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">atomicRemoveFromHandlerList</span><span class="params">(AbstractChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">    AbstractChannelHandlerContext prev = ctx.prev;</span><br><span class="line">    AbstractChannelHandlerContext next = ctx.next;</span><br><span class="line">    prev.next = next;</span><br><span class="line">    next.prev = prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h3><p>说明：在ChannelPipeline中，将新newCtx在链表中替换就得oldCtx。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ChannelHandler <span class="title">replace</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> AbstractChannelHandlerContext ctx, String newName, ChannelHandler newHandler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> ctx != head &amp;&amp; ctx != tail; <span class="comment">// 注解@17</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> AbstractChannelHandlerContext newCtx;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        checkMultiplicity(newHandler);</span><br><span class="line">        <span class="keyword">if</span> (newName == <span class="keyword">null</span>) &#123;</span><br><span class="line">            newName = generateName(newHandler);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> sameName = ctx.name().equals(newName);</span><br><span class="line">            <span class="keyword">if</span> (!sameName) &#123;</span><br><span class="line">                checkDuplicateName(newName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        newCtx = newContext(ctx.executor, newName, newHandler);</span><br><span class="line">        replace0(ctx, newCtx); <span class="comment">// 注解@18</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> ctx.handler();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@17</strong> 被替换的ChannelHandlerContext不能是HeadContext和TailContext。</p>
<p><strong>注解@18</strong> 下面替换逻辑中，首先将oldCtx的前后指针暂存；newCtx前后指针指向刚才的暂存；把暂存的pre的next指向newCtx，暂存的next的prev指向newCtx，此时newCtx已经替换到了链表中；将oldCtx的prev和next都指向了newCtx，目的为了已经进入了oldCtx的数据正确流转无论是inbound还是outbound数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">replace0</span><span class="params">(AbstractChannelHandlerContext oldCtx, AbstractChannelHandlerContext newCtx)</span> </span>&#123;</span><br><span class="line">    AbstractChannelHandlerContext prev = oldCtx.prev;</span><br><span class="line">    AbstractChannelHandlerContext next = oldCtx.next;</span><br><span class="line">    newCtx.prev = prev;</span><br><span class="line">    newCtx.next = next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Finish the replacement of oldCtx with newCtx in the linked list.</span></span><br><span class="line">    <span class="comment">// Note that this doesn&#x27;t mean events will be sent to the new handler immediately</span></span><br><span class="line">    <span class="comment">// because we are currently at the event handler thread and no more than one handler methods can be invoked</span></span><br><span class="line">    <span class="comment">// at the same time (we ensured that in replace().)</span></span><br><span class="line">    prev.next = newCtx;</span><br><span class="line">    next.prev = newCtx;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// update the reference to the replacement so forward of buffered content will work correctly</span></span><br><span class="line">    oldCtx.prev = newCtx;</span><br><span class="line">    oldCtx.next = newCtx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>小结：</strong> ChannelPipeline提供了方便的API对链表中的ChannelHandlerContext进行插入、删除、添加、替换操作。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>Netty</tag>
      </tags>
  </entry>
</search>
