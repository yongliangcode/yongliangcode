<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="aFajlZ_qxnHSidfrI7ZwIC5dtkVavvKdk7iYyjMrG3c">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yongliangcode.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="瓜农老梁">
<meta property="og:url" content="https://yongliangcode.github.io/index.html">
<meta property="og:site_name" content="瓜农老梁">
<meta property="og:locale" content="zh_CN">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://yongliangcode.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>瓜农老梁</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">瓜农老梁</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">一个想分享点干货的家伙，微信公众号「瓜农老梁」</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yongliangcode.github.io/posts/821aaf66/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="瓜农老梁">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/821aaf66/" class="post-title-link" itemprop="url">Netty10# 堆外内存底盘PlatformDependent</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-30 22:47:01" itemprop="dateCreated datePublished" datetime="2021-01-30T22:47:01+08:00">2021-01-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-01-31 17:26:30" itemprop="dateModified" datetime="2021-01-31T17:26:30+08:00">2021-01-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Netty/" itemprop="url" rel="index"><span itemprop="name">Netty</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div id="vip-container"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>非池化/池化内存如何分配的？该撸这块了，奈何到处都在调用PlatformDependent类的方法，要不各种判断，要不分配堆外内存。反正到处都能看到它，得，索性先把这个撸一把。PlatformDependent又依赖了PlatformDependent0，那就一层一层剥好了。</p>
<p>嗯，有点碎，大伙随便看看。</p>
<h1 id="PlatformDependent0"><a href="#PlatformDependent0" class="headerlink" title="PlatformDependent0"></a>PlatformDependent0</h1><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><table>
<thead>
<tr>
<th>名称</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td>ADDRESS_FIELD_OFFSET</td>
<td align="left">Buffer#address字段的内存偏移地址</td>
</tr>
<tr>
<td>BYTE_ARRAY_BASE_OFFSET</td>
<td align="left">获取内存中第一个元素的内存偏移量</td>
</tr>
<tr>
<td>DIRECT_BUFFER_CONSTRUCTOR</td>
<td align="left">DirectByteBuffer构造器对象，用于反射实例化</td>
</tr>
<tr>
<td>EXPLICIT_NO_UNSAFE_CAUSE</td>
<td align="left">平台不支持UNSAFE时，不支持异常封装在EXPLICIT_NO_UNSAFE_CAUSE中</td>
</tr>
<tr>
<td>ALLOCATE_ARRAY_METHOD</td>
<td align="left">Unsafe#allocateUninitializedArray Method对象，用于反射调用</td>
</tr>
<tr>
<td>JAVA_VERSION</td>
<td align="left">获取Java版本</td>
</tr>
<tr>
<td>IS_ANDROID</td>
<td align="left">系统是否为Android</td>
</tr>
<tr>
<td>UNSAFE_UNAVAILABILITY_CAUSE</td>
<td align="left">系统不支持UNSAFE会将异常封装在此变量中</td>
</tr>
<tr>
<td>INTERNAL_UNSAFE</td>
<td align="left">Java9中Unsafe实例对象</td>
</tr>
<tr>
<td>IS_EXPLICIT_TRY_REFLECTION_SET_ACCESSIBLE</td>
<td align="left">启用反射访问，在Java9版本之前是禁止的；Java9以及之后版本需要开启（这点要注意，Netty到处都有对Java9之后的兼容判断）</td>
</tr>
<tr>
<td>UNSAFE</td>
<td align="left">Unsafe实例对象，操作堆外内存</td>
</tr>
<tr>
<td>UNSAFE_COPY_THRESHOLD</td>
<td align="left">Java8以及以下版本内存拷贝时的最大阈值，最大为1M（1024L * 1024L）</td>
</tr>
<tr>
<td>UNALIGNED</td>
<td align="left">java.nio.Bits#unaligned方法在当前系统是否可用</td>
</tr>
</tbody></table>
<h3 id="赋值流程"><a href="#赋值流程" class="headerlink" title="赋值流程"></a>赋值流程</h3><p>这部分主要针对当前运行的系统平台是否支持UNSAFE等众多涉及到堆外内存分配的属性是否支持，以及赋值给成员变量，在static静态块中判断。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210131171437.png"></p>
<p><strong>@1 检查平台是否支持Unsafe，不支持将异常错误封装在UNSAFE_UNAVAILABILITY_CAUSE中</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210131102931.png"></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210131103148.png"></p>
<p><strong>@2 如果系统支持Unsafe，检查Unsafe类中是否包含copyMemory方法，不支持禁用Unsaf</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210131103401.png"></p>
<p><strong>@3 检查Buffer类的内存地址address功能，不支持禁用Unsafe</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210131103802.png"></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210131172146.png"></p>
<p><strong>@4 检查Unsafe类中的arrayIndexScale方法是否支持，不支持禁用Unsafe</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210131104315.png"></p>
<p><strong>@5 检查是否支持反射获取DirectBuffer的构造器，方便堆外内存分配</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210131110146.png"></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210131110242.png"></p>
<p><strong>@6 检查系统是否支持java.nio.Bits#unaligned方法</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210131172239.png"></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210131172305.png"></p>
<p><strong>@7 Java9以及以上版本检查jdk.internal.misc.Unsafe以及其方法allocateUninitializedArray，并赋值给INTERNAL_UNSAFE和ALLOCATE_ARRAY_METHOD</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210131111631.png"></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210131172450.png"></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210131111747.png"></p>
<h3 id="重要方法走查"><a href="#重要方法走查" class="headerlink" title="重要方法走查"></a>重要方法走查</h3><p>PlatformDependent0提供的方法，主要判断Unsafe是否可用、Unsafe分配堆外内存、Unsafe从堆外内存获取数据等。下面挑几个走查下。</p>
<p><strong>@1 检查UNSAFE是否可用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasUnsafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> UNSAFE != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>@2 DirectByteBuffer的构造函数是否可用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasDirectBufferNoCleanerConstructor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> DIRECT_BUFFER_CONSTRUCTOR != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>@3 堆外内存分配</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  malloc()返回获得内存空间的首地址，失败返回null</span></span><br><span class="line"><span class="comment">*  根据返回的内存地址构造DirectBuffer</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> capacity</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> ByteBuffer <span class="title">allocateDirectNoCleaner</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * malloc()返回获得内存空间的首地址，失败返回null</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">	<span class="keyword">return</span> newDirectBuffer(UNSAFE.allocateMemory(Math.max(<span class="number">1</span>, capacity)), capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>@4 调用DirectByteBuffer构造函数分配堆外内存</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ByteBuffer <span class="title">newDirectBuffer</span><span class="params">(<span class="keyword">long</span> address, <span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        ObjectUtil.checkPositiveOrZero(capacity, <span class="string">&quot;capacity&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (ByteBuffer) DIRECT_BUFFER_CONSTRUCTOR.newInstance(address, capacity);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable cause) &#123;</span><br><span class="line">            <span class="comment">// Not expected to ever throw!</span></span><br><span class="line">            <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> Error) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (Error) cause;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(cause);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>@5 获取堆外内存数据</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">byte</span> <span class="title">getByte</span><span class="params">(<span class="keyword">long</span> address)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> UNSAFE.getByte(address);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="PlatformDependent"><a href="#PlatformDependent" class="headerlink" title="PlatformDependent"></a>PlatformDependent</h1><h3 id="成员变量-1"><a href="#成员变量-1" class="headerlink" title="成员变量"></a>成员变量</h3><table>
<thead>
<tr>
<th>名称</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>MAX_DIRECT_MEMORY_SIZE_ARG_PATTERN</td>
<td>允许最大堆外内存的正则表达式，可以通过MaxDirectMemorySize参数在应用启动时指定</td>
</tr>
<tr>
<td>IS_WINDOWS</td>
<td>判断系统是否为windows系统</td>
</tr>
<tr>
<td>IS_OSX</td>
<td>判断是否为MacOS系统</td>
</tr>
<tr>
<td>IS_J9_JVM</td>
<td>是否为jdk9版本</td>
</tr>
<tr>
<td>IS_IVKVM_DOT_NET</td>
<td>判断是否为IKVM.NET</td>
</tr>
<tr>
<td>MAYBE_SUPER_USER</td>
<td>判断是否为root超级用户</td>
</tr>
<tr>
<td>CAN_ENABLE_TCP_NODELAY_BY_DEFAULT</td>
<td>Linux系统可以开启TCP_NODELAY参数，当开启时数据会以最快的速度发出去同时也就禁用了纳格算法（Nagle algorithm）；如果不设置（开启纳格算法），数据会缓存满足阈值后发出</td>
</tr>
<tr>
<td>UNSAFE_UNAVAILABILITY_CAUSE</td>
<td>平台不支持UNSAFE会将异常封装在UNSAFE_UNAVAILABILITY_CAUSE中</td>
</tr>
<tr>
<td>DIRECT_BUFFER_PREFERRED</td>
<td>默认优先使用堆外内存分配</td>
</tr>
<tr>
<td>MAX_DIRECT_MEMORY</td>
<td>获取最大堆外内存通过sun.misc.VM#maxDirectMemory方法获取</td>
</tr>
<tr>
<td>MPSC_CHUNK_SIZE</td>
<td>使用JCTools提供的无锁队列，初始化队列容量，默认1024</td>
</tr>
<tr>
<td>MIN_MAX_MPSC_CAPACITY</td>
<td>使用JCTools提供的无锁队列，最大队列容量；MIN_MAX_MPSC_CAPACITY =  MPSC_CHUNK_SIZE * 2</td>
</tr>
<tr>
<td>MAX_ALLOWED_MPSC_CAPACITY</td>
<td>使用JCTools提供的无锁队列，允许队列最大容量，默认为1073741824（1 &lt;&lt; 30）；MAX_ALLOWED_MPSC_CAPACITY = Pow2.MAX_POW2</td>
</tr>
<tr>
<td>BYTE_ARRAY_BASE_OFFSET</td>
<td>获取内存中第一个元素的内存偏移量；UNSAFE.arrayBaseOffset</td>
</tr>
<tr>
<td>TMPDIR</td>
<td>Netty临时目录</td>
</tr>
<tr>
<td>BIT_MODE</td>
<td>操作系统是32位还是64位</td>
</tr>
<tr>
<td>NORMALIZED_ARCH</td>
<td>获取操作系统CPU architecture，例如：x86_64</td>
</tr>
<tr>
<td>NORMALIZED_OS</td>
<td>获取操作系统名称，例如：Linux</td>
</tr>
<tr>
<td>ALLOWED_LINUX_OS_CLASSIFIERS</td>
<td>Linux系统演化了众多版本，下面是允许的的Linux版本</td>
</tr>
<tr>
<td>LINUX_OS_CLASSIFIERS</td>
<td>通过系统识别文件将支持的Linux版本填充到该集合中，是ALLOWED_LINUX_OS_CLASSIFIERS子集</td>
</tr>
<tr>
<td>ADDRESS_SIZE</td>
<td>返回系统指针的大小，32位系统返回4；64位系统返回8</td>
</tr>
<tr>
<td>USE_DIRECT_BUFFER_NO_CLEANER</td>
<td>堆外内存是否能分配（系统是否支持unsafe、DirectByteBuffer是否可用）</td>
</tr>
<tr>
<td>DIRECT_MEMORY_COUNTER</td>
<td>堆外内存使用限制</td>
</tr>
<tr>
<td>ThreadLocalRandomProvider</td>
<td>随机数字生成器</td>
</tr>
<tr>
<td>CLEANER</td>
<td>可以用于堆外内存回收</td>
</tr>
<tr>
<td>UNINITIALIZED_ARRAY_ALLOCATION_THRESHOLD</td>
<td>堆外内存分配阈值，默认为1024（字节）；小于该阈值分配堆内存，大于分配堆外内存；可以通过-Dio.netty.uninitializedArrayAllocationThreshold指定</td>
</tr>
<tr>
<td>OS_RELEASE_FILES</td>
<td>包含了操作系统识别数据 /etc/os-release与/usr/lib/os-release；String[] OS_RELEASE_FILES = {“/etc/os-release”, “/usr/lib/os-release”}</td>
</tr>
<tr>
<td>BIG_ENDIAN_NATIVE_ORDER</td>
<td>是否为大端排序（默认大端排序）；boolean BIG_ENDIAN_NATIVE_ORDER = ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN</td>
</tr>
</tbody></table>
<h3 id="重要方法走查-1"><a href="#重要方法走查-1" class="headerlink" title="重要方法走查"></a>重要方法走查</h3><p>挑几个比较重要的方法走查下，</p>
<p><strong>@1 内存分配</strong></p>
<p>小于阈值默认1024（字节），使用堆内存；大于阈值使用堆外内存</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] allocateUninitializedArray(<span class="keyword">int</span> size) &#123;</span><br><span class="line">        <span class="keyword">return</span> UNINITIALIZED_ARRAY_ALLOCATION_THRESHOLD &lt; <span class="number">0</span> || UNINITIALIZED_ARRAY_ALLOCATION_THRESHOLD &gt; size ?</span><br><span class="line">                <span class="keyword">new</span> <span class="keyword">byte</span>[size] : PlatformDependent0.allocateUninitializedArray(size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>@2释放堆外内存</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">freeDirectBuffer</span><span class="params">(ByteBuffer buffer)</span> </span>&#123;</span><br><span class="line">        CLEANER.freeDirectBuffer(buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>@3 构造Queue</strong></p>
<p>使用了使用JCTools提供的无锁队列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Queue&lt;T&gt; <span class="title">newMpscQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Mpsc.newMpscQueue();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function">Queue&lt;T&gt; <span class="title">newMpscQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> USE_MPSC_CHUNKED_ARRAY_QUEUE ? <span class="keyword">new</span> MpscUnboundedArrayQueue&lt;T&gt;(MPSC_CHUNK_SIZE)</span><br><span class="line">    : <span class="keyword">new</span> MpscUnboundedAtomicArrayQueue&lt;T&gt;(MPSC_CHUNK_SIZE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>其他的方法基本在判断成员变量或者调用PlatformDependent0的方法分配堆外内存、获取堆外内存数据、释放堆外内存等。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>PlatformDependent与PlatformDependent0主要针对操作系统、JDK版本等环境因素是否支持堆外内存Unsafe以及一些关联类进行判断；通过封装Unsafe申请堆外内存、释放、获取数据等操作。另外Netty为了提高性能使用了JCTools提供的无锁队列、可以通过-XX:MaxDirectMemorySize参数调整Netty允许使用的最大堆外内存，超过最大限制将使堆外内存分配失败，抛出 “failed to allocate byte(s) of direct memory” 异常。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yongliangcode.github.io/posts/f75406c8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="瓜农老梁">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/f75406c8/" class="post-title-link" itemprop="url">MQ44# RocketMQ最近几个经常被问的问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-01-25 20:55:01 / 修改时间：23:07:18" itemprop="dateCreated datePublished" datetime="2021-01-25T20:55:01+08:00">2021-01-25</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/RocketMQ/" itemprop="url" rel="index"><span itemprop="name">RocketMQ</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div id="vip-container"><h1 id="常见问题一"><a href="#常见问题一" class="headerlink" title="常见问题一"></a>常见问题一</h1><p><strong>问：</strong> RocketMQ消费者订阅了tag，但却收不到消息无法消费，并且根据 msgid 去查询，发现这条消息的状态为 CONSUMED_BUT_FILTERED，那这是为什么？</p>
<p><strong>答：</strong> 在RocketMQ中，一个消费组能同时订阅多个 tag，但一个消费组的不同消费者不能分开订阅不同的tag，即同一个消费组的订阅关系必须保持一样。例如：常见错误使用方式同一个项目中，一段消费代码订阅tagA，然后拷贝到这段代码再更改为tagB。</p>
<p><strong>正确用法</strong> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">()</span></span>&#123;</span><br><span class="line">	DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">&quot;melon_online_test_consumer&quot;</span>);</span><br><span class="line">	consumer.subscribe(<span class="string">&quot;melon_online_test&quot;</span>,<span class="string">&quot;tag1 || tag2 || tag3&quot;</span>);</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p><strong>错误用法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubscribeTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribeA</span><span class="params">()</span></span>&#123;</span><br><span class="line">    DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">&quot;melon_online_test_consumer&quot;</span>);</span><br><span class="line">    consumer.subscribe(<span class="string">&quot;melon_online_test&quot;</span>,<span class="string">&quot;tag1&quot;</span>);</span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribeB</span><span class="params">()</span></span>&#123;</span><br><span class="line">    DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">&quot;melon_online_test_consumer&quot;</span>);</span><br><span class="line">    consumer.subscribe(<span class="string">&quot;melon_online_test&quot;</span>,<span class="string">&quot;tag2&quot;</span>);</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="常见问题二"><a href="#常见问题二" class="headerlink" title="常见问题二"></a>常见问题二</h1><p><strong>问：</strong> 发现大量的RocketMQ client 大量的info日志输出，我不关心，如何禁用呢？</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210125093344.png"></p>
<p><strong>答：</strong> 尝试以下设置，项目中使用了Slf4j<br>@1 可以配置RocketmqClient的logger设置优先级为warn</p>
<p>@2 也可以通过-Drocketmq.client.logUseSlf4j=false 和 -Drocketmq.client.logLevel=WARN 关闭MQ客户端使用Slf4j并提高日志等级</p>
<p>项目中没有使用Slf4j，可以通过-Drocketmq.client.logLevel=WARN调高日志等级。</p>
<h1 id="常见问题三"><a href="#常见问题三" class="headerlink" title="常见问题三"></a>常见问题三</h1><p><strong>问：</strong> 我的服务消费后需要调用第三方接口，别人的接口调用有限制，Rocketmq消费可以限流吗？</p>
<p><strong>答：</strong> RocketMQ本身没有类似每秒消费多少条数据的精确限流，我们可以结合Sentienl来实现，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String KEY = <span class="string">&quot;melon_topic:melon_consumer&quot;</span>; <span class="comment">// 资源名称由topic和消费组构成</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, MQClientException </span>&#123;</span><br><span class="line">    initFlowControlRule(); <span class="comment">// Sentinel流控规则</span></span><br><span class="line">    DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">&quot;melon_consumer&quot;</span>);</span><br><span class="line">    consumer.setNamesrvAddr(<span class="string">&quot;localhost:9876&quot;</span>);</span><br><span class="line">    consumer.subscribe(<span class="string">&quot;melon_topic&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">    consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class="line">    consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">                Entry entry = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ContextUtil.enter(KEY); <span class="comment">// 定义资源</span></span><br><span class="line">                    entry = SphU.entry(KEY, EntryType.OUT);</span><br><span class="line">                    System.out.printf(<span class="string">&quot;%s Receive New Messages: %s %n&quot;</span>, Thread.currentThread().getName(), msg);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BlockException ex) &#123;</span><br><span class="line">                    <span class="comment">// Blocked.被限流后消息重试</span></span><br><span class="line">                    <span class="keyword">return</span> ConsumeConcurrentlyStatus.RECONSUME_LATER;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (entry != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        entry.exit();</span><br><span class="line">                    &#125;</span><br><span class="line">                    ContextUtil.exit();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    consumer.start();</span><br><span class="line">    System.out.printf(<span class="string">&quot;Consumer Started.%n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initFlowControlRule</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FlowRule rule = <span class="keyword">new</span> FlowRule();</span><br><span class="line">    rule.setResource(KEY);</span><br><span class="line">    rule.setCount(<span class="number">5</span>);<span class="comment">// 每秒通过5条消息</span></span><br><span class="line">    rule.setGrade(RuleConstant.FLOW_GRADE_QPS);</span><br><span class="line">    rule.setControlBehavior(RuleConstant.CONTROL_BEHAVIOR_RATE_LIMITER);</span><br><span class="line">    rule.setMaxQueueingTimeMs(<span class="number">5</span> * <span class="number">1000</span>); <span class="comment">// 排队超时时间5秒</span></span><br><span class="line">    FlowRuleManager.loadRules(Collections.singletonList(rule));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="常见问题四"><a href="#常见问题四" class="headerlink" title="常见问题四"></a>常见问题四</h1><p><strong>问：</strong>RocketMQ默认延迟等级有18个，我可以扩增吗？</p>
<p><strong>答：</strong> 可以的，但是不建议扩增太多等级，可以通过修改broker属性messageDelayLevel来实现，注意修改了后需要重启broker。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">messageDelayLevel = 1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h <span class="number">1d</span> <span class="number">3d</span> <span class="number">7d</span> <span class="number">14d</span> <span class="number">21d</span></span><br></pre></td></tr></table></figure>







</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yongliangcode.github.io/posts/2e57625b/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="瓜农老梁">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/2e57625b/" class="post-title-link" itemprop="url">Netty9# Netty抽象内存分配器实现原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-16 11:55:01" itemprop="dateCreated datePublished" datetime="2021-01-16T11:55:01+08:00">2021-01-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-01-17 12:15:46" itemprop="dateModified" datetime="2021-01-17T12:15:46+08:00">2021-01-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Netty/" itemprop="url" rel="index"><span itemprop="name">Netty</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div id="vip-container"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p> 本文通过分析抽象内存分配器API梳理其基于堆内存、堆外内存分配的实现原理。最后走查了CompositeByteBuf这种类似数据库视图的实现原理。</p>
<h1 id="内存分配器概览"><a href="#内存分配器概览" class="headerlink" title="内存分配器概览"></a>内存分配器概览</h1><p><strong>堆外内存&amp;堆内存</strong> </p>
<table>
<thead>
<tr>
<th>分配方式</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>堆内存</td>
<td>JVM负责内存的分配与回收</td>
<td>数据过多会引起频繁GC和停顿；<br />多一次拷贝，在用户态分配、I/O通信需要数据拷贝到内核态</td>
</tr>
<tr>
<td>堆外内存</td>
<td>I/O性能高，直接在内核态分配<br />降低GC频率和停顿</td>
<td>内存分配和收回比较慢、需要手动处理</td>
</tr>
</tbody></table>
<p><strong>内存分配器类图</strong> </p>
<p>字节缓存的分配出自ByteBufAllocator，其实现类AbstractByteBufAllocator（抽象类）、PooledByteBufAllocator（池化内存分配器）、UnpooledByteBufAllocator（非池化内存分配器）、PreferHeapByteBufAllocator（堆内存分配器）、PreferredDirectByteBufAllocator（堆外内存分配器）。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8%E7%B1%BB%E5%9B%BE%20(1).png"></p>
<p><strong>主要接口</strong> </p>
<table>
<thead>
<tr>
<th>接口</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>ByteBuf buffer()</td>
<td>分配一块字节缓存，由其实现类决定堆外内存或者堆内存</td>
</tr>
<tr>
<td>ByteBuf ioBuffer()</td>
<td>系统支持UNSAFE和CLEANER则优先分配堆外内存；否则分配堆内存。</td>
</tr>
<tr>
<td>ByteBuf heapBuffer()</td>
<td>分配堆内存字节缓存区</td>
</tr>
<tr>
<td>ByteBuf directBuffer()</td>
<td>分配堆外内存字节缓存区</td>
</tr>
<tr>
<td>CompositeByteBuf compositeBuffer()</td>
<td>分配一个CompositeByteBuf（将多个buffers组合成一个buffer）<br />由实现类决定堆内存或者堆外内存</td>
</tr>
</tbody></table>
<h1 id="内存分配器API解读"><a href="#内存分配器API解读" class="headerlink" title="内存分配器API解读"></a>内存分配器API解读</h1><p>下面走查下抽象内存分配器AbstractByteBufAllocator的API。</p>
<p><strong>构造函数</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> directByDefault;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ByteBuf emptyBuf;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractByteBufAllocator</span><span class="params">(<span class="keyword">boolean</span> preferDirect)</span> </span>&#123;</span><br><span class="line">  directByDefault = preferDirect &amp;&amp; PlatformDependent.hasUnsafe(); <span class="comment">// 注解@1</span></span><br><span class="line">  emptyBuf = <span class="keyword">new</span> EmptyByteBuf(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@1</strong> directByDefault是否使用堆外内存分配，满足两个条件。preferDirect布尔型用户传入；PlatformDependent.hasUnsafe() 系统是否支持UNSAFE（通过内存指针进行堆外内存分配）；即：用户传入preferDirect=true并且系统支持UNSAFE则使用堆外内存。</p>
<p><strong>buffer()</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">buffer</span><span class="params">()</span> </span>&#123; <span class="comment">// 注解@2</span></span><br><span class="line">  <span class="keyword">if</span> (directByDefault) &#123;</span><br><span class="line">    <span class="keyword">return</span> directBuffer();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> heapBuffer();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@2</strong> directByDefault如果为true使用堆外内存分配DirectByteBuffer，底层使用unsafe.allocateMemory分配。</p>
<p>directByDefault如果为false使用堆内存分配 new byte[initialCapacity]。</p>
<p><strong>ioBuffer</strong> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">ioBuffer</span><span class="params">()</span> </span>&#123; <span class="comment">// 注解@3</span></span><br><span class="line">  <span class="keyword">if</span> (PlatformDependent.hasUnsafe() || isDirectBufferPooled()) &#123;</span><br><span class="line">  <span class="keyword">return</span> directBuffer(DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> heapBuffer(DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@3</strong> 如果系统支持UNSAFE或者使用池化内存，优先分配堆外内存，否则分配堆内存。</p>
<p><strong>heapBuffer</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">heapBuffer</span><span class="params">()</span> </span>&#123; <span class="comment">// 注解@4</span></span><br><span class="line">	<span class="keyword">return</span> heapBuffer(DEFAULT_INITIAL_CAPACITY, DEFAULT_MAX_CAPACITY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@4</strong> 分配堆外内存new一个byte数组（new byte[]）。</p>
<p><strong>directBuffer</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">directBuffer</span><span class="params">()</span> </span>&#123; <span class="comment">// 注解@5</span></span><br><span class="line">	<span class="keyword">return</span> directBuffer(DEFAULT_INITIAL_CAPACITY, DEFAULT_MAX_CAPACITY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@5</strong> 分配堆外内存。</p>
<p><strong>compositeBuffer</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompositeByteBuf <span class="title">compositeBuffer</span><span class="params">()</span> </span>&#123; <span class="comment">// 注解@6</span></span><br><span class="line">  <span class="keyword">if</span> (directByDefault) &#123;</span><br><span class="line">  	<span class="keyword">return</span> compositeDirectBuffer();</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="keyword">return</span> compositeHeapBuffer();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@6</strong> 跟上面一样的，只是分配的CompositeByteBuf。下面看下这种将多个个buffer组合成一个buffer是如何实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompositeByteBuf <span class="title">compositeHeapBuffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> compositeHeapBuffer(DEFAULT_MAX_COMPONENTS);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompositeByteBuf <span class="title">compositeHeapBuffer</span><span class="params">(<span class="keyword">int</span> maxNumComponents)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> toLeakAwareBuffer(<span class="keyword">new</span> CompositeByteBuf(<span class="keyword">this</span>, <span class="keyword">false</span>, maxNumComponents));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">CompositeByteBuf</span><span class="params">(ByteBufAllocator alloc, <span class="keyword">boolean</span> direct, <span class="keyword">int</span> maxNumComponents, <span class="keyword">int</span> initSize)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>(AbstractByteBufAllocator.DEFAULT_MAX_CAPACITY);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.alloc = ObjectUtil.checkNotNull(alloc, <span class="string">&quot;alloc&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (maxNumComponents &lt; <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">  <span class="string">&quot;maxNumComponents: &quot;</span> + maxNumComponents + <span class="string">&quot; (expected: &gt;= 1)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.direct = direct;</span><br><span class="line">  <span class="keyword">this</span>.maxNumComponents = maxNumComponents;</span><br><span class="line">  components = newCompArray(initSize, maxNumComponents); <span class="comment">// 注解@6.1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@6.1</strong> 在CompositeByteBuf的构造方法中初始化了一个components，这个默认initSize=0；maxNumComponents默认为16。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Component[] newCompArray(<span class="keyword">int</span> initComponents, <span class="keyword">int</span> maxNumComponents) &#123;</span><br><span class="line">	<span class="keyword">int</span> capacityGuess = Math.min(AbstractByteBufAllocator.DEFAULT_MAX_COMPONENTS, maxNumComponents);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> Component[Math.max(initComponents, capacityGuess)]; <span class="comment">// 注解@6.2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@6.2</strong> components是Component的对象数组，数组大小默认为16. </p>
<h1 id="CompositeByteBuf实现原理"><a href="#CompositeByteBuf实现原理" class="headerlink" title="CompositeByteBuf实现原理"></a>CompositeByteBuf实现原理</h1><p>下面通过例子来体验一把CompositeByteBuf，先直观感受下。</p>
<p><strong>示例代码</strong> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCompositeByteBuf</span><span class="params">()</span></span>&#123;</span><br><span class="line">  String str1 = <span class="string">&quot;瓜农&quot;</span>;</span><br><span class="line">  String str2 = <span class="string">&quot;老梁&quot;</span>;</span><br><span class="line">  ByteBuf buf1 = Unpooled.buffer(<span class="number">10</span>);</span><br><span class="line">  buf1.writeBytes(str1.getBytes(CharsetUtil.UTF_8));</span><br><span class="line">  System.out.println(<span class="string">&quot;buf1&#x27;s readerIndex:&quot;</span> + buf1.readerIndex());</span><br><span class="line">  System.out.println(<span class="string">&quot;buf1&#x27;s writeIndex&quot;</span> + buf1.writerIndex());</span><br><span class="line"></span><br><span class="line">  ByteBuf buf2 = Unpooled.buffer(<span class="number">10</span>);</span><br><span class="line">  buf2.writeBytes(str2.getBytes(CharsetUtil.UTF_8));</span><br><span class="line">  System.out.println(<span class="string">&quot;buf2&#x27;s readerIndex:&quot;</span> + buf2.readerIndex());</span><br><span class="line">  System.out.println(<span class="string">&quot;buf2&#x27;s writeIndex&quot;</span> + buf2.writerIndex());</span><br><span class="line"></span><br><span class="line">  ByteBuf compositeByteBuf = Unpooled.wrappedBuffer(buf1,buf2);</span><br><span class="line">  System.out.println(<span class="string">&quot;compositeByteBuf&#x27;s readerIndex:&quot;</span> + compositeByteBuf.readerIndex());</span><br><span class="line">  System.out.println(<span class="string">&quot;compositeByteBuf&#x27;s writeIndex&quot;</span> + compositeByteBuf.writerIndex());</span><br><span class="line">  System.out.print(compositeByteBuf.toString(CharsetUtil.UTF_8));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结果输出</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">buf1&#39;s readerIndex:0</span><br><span class="line">buf1&#39;s writeIndex6</span><br><span class="line">buf2&#39;s readerIndex:0</span><br><span class="line">buf2&#39;s writeIndex6</span><br><span class="line">compositeByteBuf&#39;s readerIndex:0</span><br><span class="line">compositeByteBuf&#39;s writeIndex12</span><br><span class="line">瓜农老梁</span><br></pre></td></tr></table></figure>

<p><strong>小结</strong>  Unpooled.wrappedBuffer(buf1,buf2)将两个ByteBuf进行了合并一个ByteBuf；对外提供统一的读写指针供使用。</p>
<p>接下来看下他是如何合并的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuf <span class="title">wrappedBuffer</span><span class="params">(<span class="keyword">int</span> maxNumComponents, ByteBuf... buffers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (buffers.length) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            ByteBuf buffer = buffers[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span> (buffer.isReadable()) &#123;</span><br><span class="line">                <span class="keyword">return</span> wrappedBuffer(buffer.order(BIG_ENDIAN));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                buffer.release();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buffers.length; i++) &#123;</span><br><span class="line">                ByteBuf buf = buffers[i];</span><br><span class="line">                <span class="keyword">if</span> (buf.isReadable()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> CompositeByteBuf(ALLOC, <span class="keyword">false</span>, maxNumComponents, buffers, i); <span class="comment">// 注解@7</span></span><br><span class="line">                &#125;</span><br><span class="line">                buf.release();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> EMPTY_BUFFER;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@7</strong> 通过创建一个CompositeByteBuf，将ByteBuf数组传入构造函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CompositeByteBuf(ByteBufAllocator alloc, <span class="keyword">boolean</span> direct, <span class="keyword">int</span> maxNumComponents,</span><br><span class="line">            ByteBuf[] buffers, <span class="keyword">int</span> offset) &#123;</span><br><span class="line">            <span class="keyword">this</span>(alloc, direct, maxNumComponents, buffers.length - offset);</span><br><span class="line"></span><br><span class="line">	addComponents0(<span class="keyword">false</span>, <span class="number">0</span>, buffers, offset); <span class="comment">// 注解@8</span></span><br><span class="line">	consolidateIfNeeded();</span><br><span class="line">	setIndex0(<span class="number">0</span>, capacity()); <span class="comment">// 注解@9</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@8</strong>  填充Component[]数据，每个Component元素包含了传入的ByteBuf。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> CompositeByteBuf <span class="title">addComponents0</span><span class="params">(<span class="keyword">boolean</span> increaseWriterIndex,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">final</span> <span class="keyword">int</span> cIndex, ByteBuf[] buffers, <span class="keyword">int</span> arrOffset)</span> </span>&#123;</span><br><span class="line">  			<span class="comment">//  buffers数组的长度；本例中arrOffset=0；count=len</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> len = buffers.length, count = len - arrOffset;</span><br><span class="line">        <span class="keyword">int</span> ci = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            checkComponentIndex(cIndex); <span class="comment">// 合法性校验</span></span><br><span class="line">            shiftComps(cIndex, count); <span class="comment">// 注解@8.1</span></span><br><span class="line">            <span class="keyword">int</span> nextOffset = cIndex &gt; <span class="number">0</span> ? components[cIndex - <span class="number">1</span>].endOffset : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (ci = cIndex; arrOffset &lt; len; arrOffset++, ci++) &#123; <span class="comment">// 注解@8.2</span></span><br><span class="line">                <span class="comment">// 从数组中拿出传入的ByteBuf</span></span><br><span class="line">              	ByteBuf b = buffers[arrOffset];</span><br><span class="line">                <span class="keyword">if</span> (b == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 构建Component</span></span><br><span class="line">                Component c = newComponent(ensureAccessible(b), nextOffset); </span><br><span class="line">              	<span class="comment">// 加入components数组</span></span><br><span class="line">                components[ci] = c;</span><br><span class="line">                <span class="comment">// 递增endOffset</span></span><br><span class="line">                nextOffset = c.endOffset;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@8.1</strong> 扩容Component数组，默认的数量为16个，当添加的buffer的数量超过16时就需要扩容了，下面看下其如何扩容的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">shiftComps</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> size = componentCount, newSize = size + count;</span><br><span class="line">        <span class="keyword">assert</span> i &gt;= <span class="number">0</span> &amp;&amp; i &lt;= size &amp;&amp; count &gt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (newSize &gt; components.length) &#123;</span><br><span class="line">            <span class="comment">// grow the array </span></span><br><span class="line">          	<span class="keyword">int</span> newArrSize = Math.max(size + (size &gt;&gt; <span class="number">1</span>), newSize); <span class="comment">// 注解@8.1.1</span></span><br><span class="line">            Component[] newArr;</span><br><span class="line">            <span class="comment">// 注解@8.1.2</span></span><br><span class="line">            <span class="keyword">if</span> (i == size) &#123;</span><br><span class="line">                newArr = Arrays.copyOf(components, newArrSize, Component[].class);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                newArr = <span class="keyword">new</span> Component[newArrSize];</span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    System.arraycopy(components, <span class="number">0</span>, newArr, <span class="number">0</span>, i);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i &lt; size) &#123;</span><br><span class="line">                    System.arraycopy(components, i, newArr, i + count, size - i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            components = newArr;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; size) &#123;</span><br><span class="line">            System.arraycopy(components, i, components, i + count, size - i);</span><br><span class="line">        &#125;</span><br><span class="line">        componentCount = newSize;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>**注解@8.1.1 ** 默认size=16，size &gt;&gt; 1 = 8 也就是扩容会以原大小一半的容量进行扩容。</p>
<p><strong>注解@8.1.2</strong> 下面判断根据场景通过Arrays.copyOf、System.arraycopy将Component数组扩容；插入尾部、中部、头部等情况。本示例中没有超过16，所以不会扩容，componentCount=2。</p>
<p><strong>注解@8.2</strong> 循环拿出传入的ByteBuf数组构建Component，并将其加入Component数组中；最后移动nextOffset。关于各个参数的含义，源码给出了注释。构造函数中</p>
<p>第一个参数：传入的ByteBuf<br>第二个参数：源ByteBuf的readerIndex<br>第三个参数：unwrapped的buffer<br>第四个参数：unwrappedIndex<br>第五个参数：offset = components[cIndex - 1].endOffset<br>第六个参数：len = buf.readableBytes()  buf为源buffer<br>第七个参数：slice = null （示例）</p>
<p>以endOffset为例，等于插入数组中上一个Conponent的endOffset + 当前ByteBuf的可读长度，从而维护了其在整个CompositeByteBuf的写索引情况。</p>
<p>一个buffer对应一个Component，每个Component持有源buffer并维护了其在整个CompositeByteBuf的索引情况。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210117101614.png"></p>
<p><strong>注解@9</strong> 设置整个CompositeByteBuf的读索引和写索引，读索引初始值为0；写索引为components[size - 1].endOffset，也就是整个Conponent数组中其每个元素维护的ByteBuf可读字节（writerIndex - readerIndex）大小的总和。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setIndex0</span><span class="params">(<span class="keyword">int</span> readerIndex, <span class="keyword">int</span> writerIndex)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.readerIndex = readerIndex;</span><br><span class="line">	<span class="keyword">this</span>.writerIndex = writerIndex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">capacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> size = componentCount;</span><br><span class="line">  <span class="keyword">return</span> size &gt; <span class="number">0</span> ? components[size - <span class="number">1</span>].endOffset : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>小结：</strong> CompositeByteBuf通过将多个ByteBuf装入component数组中，对其统一维护读写索引，在外面看起来是一个统一的buffer；类似数据库中的视图。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yongliangcode.github.io/posts/17c9a786/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="瓜农老梁">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/17c9a786/" class="post-title-link" itemprop="url">Netty8# Netty之ByteBuf初体验</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-02 11:55:01" itemprop="dateCreated datePublished" datetime="2021-01-02T11:55:01+08:00">2021-01-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-01-04 19:05:12" itemprop="dateModified" datetime="2021-01-04T19:05:12+08:00">2021-01-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Netty/" itemprop="url" rel="index"><span itemprop="name">Netty</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div id="vip-container"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>字节的流动形成了流，Netty作为优秀的通信框架他的字节是如何流动的，本文就理一下这个事。梳理完Netty的字节流动与JDK提供的ByteBuffer一对比看下Netty方便在哪里。本分从官方文档概念原理入手梳理，然后看下源码解读下这些原理如何实现的，体验一把Netty写入数据自动扩容，探究下这个过程如何实现的。</p>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p><strong>ByteBuf创建</strong></p>
<p>使用Unpooled类来创建ByteBuf，不建议使用ByteBuf的构造函数自己去创建。</p>
<p><strong>读写索引</strong></p>
<p>ByteBuf提供了两个指针readerIndex和writerIndex，分别记录读、写的开始位置。两个指针将ByteBuf分成了三个区域。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210102104805.png"></p>
<p><strong>discardable bytes</strong> </p>
<p>这个区间的范围为0~readerIndex，已经被读过的、可废弃的区域。通过调用discardReadBytes()，可以释放discardable bytes区域。这个区域释放后，可写区域（writable bytes）部分增多。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210102141428.png"></p>
<p><strong>readable bytes</strong></p>
<p>可读区域的范围为（writerIndex-readerIndex）</p>
<p><strong>writable bytes</strong></p>
<p>可写区域的范围为（capacity-writerIndex）</p>
<p><strong>清理索引</strong></p>
<p>调用Buffer.clear()后，读写索引全部归零，缓存buffer被释放。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210102143322.png"></p>
<h1 id="ByteBuf的构建"><a href="#ByteBuf的构建" class="headerlink" title="ByteBuf的构建"></a><strong>ByteBuf的构建</strong></h1><p>接下来通过示例窜下上面的知识点，看下源码是如何实现的，示例中将字符串写入ByteBuf中，然后再读出来打印。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWriteUtf81</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     String str1 = <span class="string">&quot;瓜农&quot;</span>;</span><br><span class="line">     ByteBuf buf = Unpooled.buffer(<span class="number">1</span>);</span><br><span class="line">     buf.writeBytes(str1.getBytes(CharsetUtil.UTF_8));</span><br><span class="line">     ByteBuf readByteBuf = ByteBufUtil.readBytes(UnpooledByteBufAllocator.DEFAULT,buf,str1.getBytes(CharsetUtil.UTF_8).length);</span><br><span class="line">     System.out.print(readByteBuf.toString(CharsetUtil.UTF_8));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>源码解读</strong> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuf <span class="title">buffer</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> ALLOC.heapBuffer(initialCapacity); <span class="comment">// 注解@1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">heapBuffer</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> heapBuffer(initialCapacity, DEFAULT_MAX_CAPACITY); <span class="comment">// 注解@2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">InstrumentedUnpooledUnsafeHeapByteBuf(UnpooledByteBufAllocator alloc, <span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity) &#123;</span><br><span class="line">  <span class="keyword">super</span>(alloc, initialCapacity, maxCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UnpooledHeapByteBuf</span><span class="params">(ByteBufAllocator alloc, <span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>(maxCapacity);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (initialCapacity &gt; maxCapacity) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(</span><br><span class="line">      <span class="string">&quot;initialCapacity(%d) &gt; maxCapacity(%d)&quot;</span>, initialCapacity, maxCapacity));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.alloc = checkNotNull(alloc, <span class="string">&quot;alloc&quot;</span>);</span><br><span class="line">  setArray(allocateArray(initialCapacity)); <span class="comment">// 注解@3</span></span><br><span class="line">  setIndex(<span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 注解@4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@1</strong> 使用ByteBufAllocator来分配ByteBuf，默认为UnpooledByteBufAllocator。</p>
<p><strong>注解@2</strong> initialCapacity为初始容量例子中给的为16，maxCapacity为默认的DEFAULT_MAX_CAPACITY=Integer.MAX_VALUE。</p>
<p><strong>注解@3</strong> allocateArray()的方法如下，此时使用JDK的byte[]初始化缓存区。通过setArray()，UnpooledHeapByteBuf持有byte[]缓存区。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">protected</span> <span class="keyword">byte</span>[] allocateArray(<span class="keyword">int</span> initialCapacity) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">byte</span>[initialCapacity];</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setArray</span><span class="params">(<span class="keyword">byte</span>[] initialArray)</span> </span>&#123;</span><br><span class="line">  array = initialArray;</span><br><span class="line">  tmpNioBuf = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@4</strong> 初始化readerIndex和writerIndex，均为0。</p>
<p><strong>小结</strong> ByteBuf的构建通过Unpooled来分配，示例中通过UnpooledByteBufAllocator持有byte[]、 readerIndex、writerIndex、maxCapacity完成ByteBuf的初始化。 示例中array数组大小为16；readerIndex=writerIndex=0；maxCapacity=Integer.MAX_VALUE。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210103092431.png"></p>
<h1 id="写入数据"><a href="#写入数据" class="headerlink" title="写入数据"></a>写入数据</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">writeBytes</span><span class="params">(<span class="keyword">byte</span>[] src, <span class="keyword">int</span> srcIndex, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">  ensureWritable(length); <span class="comment">// 注解@5</span></span><br><span class="line">  setBytes(writerIndex, src, srcIndex, length); <span class="comment">// 注解@6</span></span><br><span class="line">  writerIndex += length; <span class="comment">// 注解@7</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@5</strong> 确保剩余的空间能够容纳需写入的数据。</p>
<p>具体逻辑如下：<br>如果写入的数据长度小于已经分配的容量空间capacity则允许直接返回；</p>
<p>如果写入的数据长度超过允许的最大容量maxCapacity直接抛出IndexOutOfBoundsException拒绝；</p>
<p>如果写入数据长度大于已经分配的空间capacity但是小于最大最大允许空间maxCapacity，则需要扩容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">ensureWritable0</span><span class="params">(<span class="keyword">int</span> minWritableBytes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> writerIndex = writerIndex(); <span class="comment">// 注解@5.1</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> targetCapacity = writerIndex + minWritableBytes; <span class="comment">// 注解@5.2</span></span><br><span class="line">    <span class="keyword">if</span> (targetCapacity &lt;= capacity()) &#123; <span class="comment">// 注解@5.3</span></span><br><span class="line">        ensureAccessible();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (checkBounds &amp;&amp; targetCapacity &gt; maxCapacity) &#123; <span class="comment">// 注解@5.4 </span></span><br><span class="line">        ensureAccessible();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(String.format(</span><br><span class="line">                <span class="string">&quot;writerIndex(%d) + minWritableBytes(%d) exceeds maxCapacity(%d): %s&quot;</span>,</span><br><span class="line">                writerIndex, minWritableBytes, maxCapacity, <span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Normalize the target capacity to the power of 2.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> fastWritable = maxFastWritableBytes(); <span class="comment">// 注解@5.5 </span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = fastWritable &gt;= minWritableBytes ? writerIndex + fastWritable</span><br><span class="line">            : alloc().calculateNewCapacity(targetCapacity, maxCapacity); <span class="comment">// 注解@5.6</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Adjust to the new capacity.</span></span><br><span class="line">    capacity(newCapacity); <span class="comment">// 注解@5.7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@5.1</strong>  获取当前写索引</p>
<p><strong>注解@5.2</strong> 计算需要的容量</p>
<p>**注解@5.3 ** 与当前已分配的容量capacity进行比较</p>
<p><strong>注解@5.4</strong> 不能超过最大允许的容量maxCapacity</p>
<p><strong>注解@5.5</strong> fastWritable = capacity() - writerIndex</p>
<p><strong>注解@5.6</strong> newCapacity的判断通常走到这里应该为，剩余的空间不够了。所以通常会进入alloc().calculateNewCapacity(targetCapacity, maxCapacity)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculateNewCapacity</span><span class="params">(<span class="keyword">int</span> minNewCapacity, <span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> threshold = CALCULATE_THRESHOLD; <span class="comment">// 4 MiB page</span></span><br><span class="line">        <span class="keyword">if</span> (minNewCapacity == threshold) &#123; <span class="comment">// 注解@5.6.1</span></span><br><span class="line">            <span class="keyword">return</span> threshold;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// If over threshold, do not double but just increase by threshold.</span></span><br><span class="line">        <span class="keyword">if</span> (minNewCapacity &gt; threshold) &#123; <span class="comment">// 注解@5.6.2</span></span><br><span class="line">            <span class="keyword">int</span> newCapacity = minNewCapacity / threshold * threshold;</span><br><span class="line">            <span class="keyword">if</span> (newCapacity &gt; maxCapacity - threshold) &#123;</span><br><span class="line">                newCapacity = maxCapacity;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                newCapacity += threshold;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> newCapacity;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Not over threshold. Double up to 4 MiB, starting from 64.</span></span><br><span class="line">        <span class="keyword">int</span> newCapacity = <span class="number">64</span>;</span><br><span class="line">        <span class="keyword">while</span> (newCapacity &lt; minNewCapacity) &#123; <span class="comment">// 注解@5.6.3</span></span><br><span class="line">            newCapacity &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Math.min(newCapacity, maxCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@5.6.1</strong> 如果写入的数据长度刚好为4M则返回threshold=4M</p>
<p><strong>注解@5.6.2</strong> 如果写入的数据长度大于4M，newCapacity不再翻倍增长，通过minNewCapacity / threshold * threshold计算刚容下需要的数据即可。</p>
<p><strong>注解@5.6.3</strong> 如果写入的数据长度小于4M，则newCapacity从64翻倍增长（128、256、512…），直到newCapacity能够容纳需要写入的数据。</p>
<p><strong>注解@5.7</strong> 确定了要扩容的容量newCapacity后，我们看下如何扩容的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">capacity</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">    checkNewCapacity(newCapacity);</span><br><span class="line">    <span class="keyword">byte</span>[] oldArray = array;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldArray.length;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity == oldCapacity) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> bytesToCopy;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity &gt; oldCapacity) &#123;</span><br><span class="line">      bytesToCopy = oldCapacity;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      trimIndicesToCapacity(newCapacity);</span><br><span class="line">      bytesToCopy = newCapacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">byte</span>[] newArray = allocateArray(newCapacity); <span class="comment">// 注解@5.7.1</span></span><br><span class="line">    System.arraycopy(oldArray, <span class="number">0</span>, newArray, <span class="number">0</span>, bytesToCopy); <span class="comment">// 注解@5.7.2</span></span><br><span class="line">    setArray(newArray); <span class="comment">// 注解@5.7.3</span></span><br><span class="line">    freeArray(oldArray); <span class="comment">// 注解@5.7.4</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@5.7.1</strong> 使用新的容量初始化newArray=new byte[initialCapacity]</p>
<p><strong>注解@5.7.2</strong> 将旧的oldArray数据拷贝到新的newArray=new中</p>
<p><strong>注解@5.7.3</strong> 将UnpooledHeapByteBuf的byte[]引用替换为newArray</p>
<p><strong>注解@5.7.4</strong> oldArray清理操作</p>
<p><strong>注解@6</strong> 写入数据，通过System.arraycopy将数据写入array中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">setBytes</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">byte</span>[] src, <span class="keyword">int</span> srcIndex, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">  checkSrcIndex(index, length, srcIndex, src.length);</span><br><span class="line">  System.arraycopy(src, srcIndex, array, index, length);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@7</strong> 移动writerIndex指针。</p>
<p><strong>小结：</strong> 将上面例子的initialCapacity设置成1，促使写入数据时扩充容量。下面运行时截图：array被扩容到64，writerIndex从0位置移动到6. </p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210103110741.png"></p>
<p>在写入数据时，判断剩余容量是否足够；不够则需要扩容，如果写入的数据小于4M，则双倍增长，直到容纳写写入的数据。如果写入的数据大于4M，通过（minNewCapacity / threshold * threshold）计算需要扩容的大小。</p>
<h1 id="读出数据"><a href="#读出数据" class="headerlink" title="读出数据"></a>读出数据</h1><p>从buf中把刚才写入的数据（”瓜农“）读出来，通过工具类ByteBufUtil.readBytes来实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ByteBuf readByteBuf = ByteBufUtil.readBytes(UnpooledByteBufAllocator.DEFAULT,buf,str1.getBytes(CharsetUtil.UTF_8).length);</span><br><span class="line">System.out.print(readByteBuf.toString(CharsetUtil.UTF_8));</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuf <span class="title">readBytes</span><span class="params">(ByteBufAllocator alloc, ByteBuf buffer, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> release = <span class="keyword">true</span>;</span><br><span class="line">    ByteBuf dst = alloc.buffer(length); <span class="comment">// 注解@8</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        buffer.readBytes(dst); <span class="comment">// 注解@9</span></span><br><span class="line">        release = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> dst;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (release) &#123;</span><br><span class="line">            dst.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@8</strong> 重新构造了一个ByteBuf（dst）用于存储读取的数据</p>
<p><strong>注解@9</strong> 读取数据，并移动读索引。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">readBytes</span><span class="params">(ByteBuf dst, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (checkBounds) &#123;</span><br><span class="line">        <span class="keyword">if</span> (length &gt; dst.writableBytes()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(String.format(</span><br><span class="line">                    <span class="string">&quot;length(%d) exceeds dst.writableBytes(%d) where dst is: %s&quot;</span>, length, dst.writableBytes(), dst));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    readBytes(dst, dst.writerIndex(), length); <span class="comment">// 注解@9.1</span></span><br><span class="line">    dst.writerIndex(dst.writerIndex() + length); <span class="comment">// 注解@9.2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@9.1</strong> 读取字节到新的ByteBuf。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">readBytes</span><span class="params">(ByteBuf dst, <span class="keyword">int</span> dstIndex, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    checkReadableBytes(length);</span><br><span class="line">    getBytes(readerIndex, dst, dstIndex, length); <span class="comment">// 注解@9.1.1</span></span><br><span class="line">    readerIndex += length; <span class="comment">// 注解@9.1.2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@9.1.1</strong> 通过native api UNSAFE.copyMemory() 实现byte数组之间的拷贝</p>
<p><strong>注解@9.1.2</strong> 源byteBuf读索引readerIndex向前移动</p>
<p><strong>注解@9.2</strong> 数据读入新构建的缓存区dst，dst的写索引向前移动</p>
<p><strong>小结：</strong> 示例中通过构造一个新的ByteBuf（dst），将源ByteBuf（buf）的数据读入到dst。数据读取结束后，源ByteBuf（buf）readerIndex向前移动；ByteBuf（dst）的writerIndex向前移动。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20210103125302.png"></p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yongliangcode.github.io/posts/8c88e43/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="瓜农老梁">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/8c88e43/" class="post-title-link" itemprop="url">Netty7# Netty之事件传递</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-26 11:55:01" itemprop="dateCreated datePublished" datetime="2020-12-26T11:55:01+08:00">2020-12-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-27 13:23:22" itemprop="dateModified" datetime="2020-12-27T13:23:22+08:00">2020-12-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Netty/" itemprop="url" rel="index"><span itemprop="name">Netty</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div id="vip-container"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前面的文章中写了Channel实例化、Channel初始化、Channel注册、异步通知机制、客户端发起连接、事件的轮询和处理机制。Netty作为client/server高效通信框架，事件在ChannelPipeline是如何传递的，本文就聊聊这事。</p>
<h1 id="事件传递过程"><a href="#事件传递过程" class="headerlink" title="事件传递过程"></a>事件传递过程</h1><p>ChannelPipeline随着Channel的创建而创建，在 <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/tvy0j0Mo9H82SK4jztqu0w">Netty2# Netty组件之Channel初始化 </a> 文章中梳理了ChannelPipeline、ChannelHandlerContext、ChannelHandler的关系如下图。</p>
<p>ChannelPipeline大管道维护了一个ChannelHandlerContext链表，头部为HeadContext，尾部为TailContext。事件传播会沿着链表逐级向下传递。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201226112641.png"></p>
<h3 id="Inbound-amp-Outbound标识"><a href="#Inbound-amp-Outbound标识" class="headerlink" title="Inbound&amp;Outbound标识"></a>Inbound&amp;Outbound标识</h3><p>当ChannelHandlerContext创建时，它是Inbound还是Outbound，是哪个方向的就确定了。下面分析是这种身份是如何确定的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">AbstractChannelHandlerContext(DefaultChannelPipeline pipeline, EventExecutor executor,</span><br><span class="line">                              String name, Class&lt;? extends ChannelHandler&gt; handlerClass) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = ObjectUtil.checkNotNull(name, <span class="string">&quot;name&quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>.pipeline = pipeline;</span><br><span class="line">    <span class="keyword">this</span>.executor = executor;</span><br><span class="line">    <span class="keyword">this</span>.executionMask = mask(handlerClass); <span class="comment">// 注解@1</span></span><br><span class="line">    ordered = executor == <span class="keyword">null</span> || executor <span class="keyword">instanceof</span> OrderedEventExecutor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@1</strong> 父类的构造函数中有一个mask(handlerClass)方法，这个方法确定了ChannelHandlerContext的身份。如下代码ChannelInboundHandler.class.isAssignableFrom(handlerType)即如果是ChannelInboundHandler类型mask |= MASK_ALL_INBOUND；反之如果是ChannelOutboundHandler类型，mask |= MASK_ALL_OUTBOUND；<strong>通过赋予mask不同的值来区分是哪个方向的Handler</strong>。isSkippable中的逻辑判断主要对加注解@Skip的方法不再进行事件回调。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mask0</span><span class="params">(Class&lt;? extends ChannelHandler&gt; handlerType)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mask = MASK_EXCEPTION_CAUGHT;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ChannelInboundHandler.class.isAssignableFrom(handlerType)) &#123;</span><br><span class="line">            mask |= MASK_ALL_INBOUND; <span class="comment">// 标识为INBOUND</span></span><br><span class="line">            <span class="keyword">if</span> (isSkippable(handlerType, <span class="string">&quot;channelRegistered&quot;</span>, ChannelHandlerContext.class))&#123;</span><br><span class="line">                mask &amp;= ~MASK_CHANNEL_REGISTERED;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ChannelOutboundHandler.class.isAssignableFrom(handlerType)) &#123;</span><br><span class="line">            mask |= MASK_ALL_OUTBOUND; <span class="comment">// 标识为OUTBOUND</span></span><br><span class="line">            <span class="keyword">if</span> (isSkippable(handlerType, <span class="string">&quot;bind&quot;</span>, ChannelHandlerContext.class,</span><br><span class="line">                    SocketAddress.class, ChannelPromise.class)) &#123;</span><br><span class="line">                mask &amp;= ~MASK_BIND;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">       <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Outbound传递过程"><a href="#Outbound传递过程" class="headerlink" title="Outbound传递过程"></a>Outbound传递过程</h3><p><strong>示例入口</strong> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ChannelFuture future = b.connect(HOST, PORT).sync(); </span><br><span class="line">future.channel().writeAndFlush(<span class="string">&quot;Hi&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>以writeAndFlush方法跟踪下Outbound事件在ChannelPipeline的传递过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelFuture <span class="title">writeAndFlush</span><span class="params">(Object msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tail.writeAndFlush(msg); <span class="comment">// 注解@2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private <span class="keyword">void</span> <span class="function"><span class="title">write</span>(<span class="params"><span class="built_in">Object</span> msg, boolean flush, ChannelPromise promise</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  	final AbstractChannelHandlerContext next = findContextOutbound(flush ?</span><br><span class="line">            (MASK_WRITE | MASK_FLUSH) : MASK_WRITE); <span class="comment">// 注解@3</span></span><br><span class="line">    final <span class="built_in">Object</span> m = pipeline.touch(msg, next);</span><br><span class="line">    EventExecutor executor = next.executor();</span><br><span class="line">    <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flush) &#123;</span><br><span class="line">            next.invokeWriteAndFlush(m, promise);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            next.invokeWrite(m, promise);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        final WriteTask task = WriteTask.newInstance(next, m, promise, flush);</span><br><span class="line">        <span class="keyword">if</span> (!safeExecute(executor, task, promise, m, !flush)) &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            task.cancel();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> AbstractChannelHandlerContext <span class="title">findContextOutbound</span><span class="params">(<span class="keyword">int</span> mask)</span> </span>&#123;</span><br><span class="line">    AbstractChannelHandlerContext ctx = <span class="keyword">this</span>;</span><br><span class="line">    EventExecutor currentExecutor = executor();</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        ctx = ctx.prev;</span><br><span class="line">    &#125; <span class="keyword">while</span> (skipContext(ctx, currentExecutor, mask, MASK_ONLY_OUTBOUND)); <span class="comment">// 注解@4</span></span><br><span class="line">    <span class="keyword">return</span> ctx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">skipContext</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        AbstractChannelHandlerContext ctx, EventExecutor currentExecutor, <span class="keyword">int</span> mask, <span class="keyword">int</span> onlyMask)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (ctx.executionMask &amp; (onlyMask | mask)) == <span class="number">0</span> ||</span><br><span class="line">            (ctx.executor() == currentExecutor &amp;&amp; (ctx.executionMask &amp; mask) == <span class="number">0</span>); <span class="comment">// 注解@5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@2</strong> 从链表尾部TailContext开始执行。</p>
<p><strong>注解@3</strong> 我们示例writeAndFlush所以findContextOutbound的mask为(MASK_WRITE | MASK_FLUSH)</p>
<p><strong>注解@4</strong> 循环链表查找，注意skipContext是判断的跳过逻辑。我们查找Outbound的ChannelHandlerContext，遇到Inbound的都会跳过。</p>
<p><strong>注解@5</strong> 判断是否跳过，这段逻辑是位操作，不好阅读。下面示例抽取各个入参的值测试下：如果下一个ChannelHandlerContext为inBound，则skipContext返回true，从而在查找outBound的do/while循环中跳过。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> executionMask =  MASK_EXCEPTION_CAUGHT |= MASK_ALL_INBOUND; <span class="comment">// inBound 身份标识</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mask = MASK_WRITE | MASK_FLUSH; <span class="comment">// writeAndFlush 标识</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> onlyMask = MASK_ONLY_OUTBOUND; <span class="comment">// outBound操作集合</span></span><br><span class="line"></span><br><span class="line">System.out.println((executionMask &amp; (onlyMask | mask))==<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">输出为：<span class="keyword">true</span></span><br></pre></td></tr></table></figure>



<p><strong>小结：</strong> outBound事件在ChannelPipeline中传递时，只会选择身份为outBound的ChannelHandlerContext执行。</p>
<h3 id="Inbound传递过程"><a href="#Inbound传递过程" class="headerlink" title="Inbound传递过程"></a>Inbound传递过程</h3><p>以上一篇文章 <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/rcVDX0tNMhRGchjYHddARw">Netty6# Netty之事件轮询与处理</a> 当有新的客户端的连接时触发unsafe.read()执行。具体为NioMessageUnsafe#read()方法。具体为上文中<strong>注解@17</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 入口</span></span><br><span class="line">pipeline.fireChannelRead(readBuf.get(i));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">fireChannelRead</span><span class="params">(Object msg)</span> </span>&#123;</span><br><span class="line">  AbstractChannelHandlerContext.invokeChannelRead(head, msg);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeChannelRead</span><span class="params">(Object msg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (invokeHandler()) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      ((ChannelInboundHandler) handler()).channelRead(<span class="keyword">this</span>, msg);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      notifyHandlerException(t);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fireChannelRead(msg); <span class="comment">// 注解@6</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@6</strong> 下面的方法findContextInbound(MASK_CHANNEL_READ)，只查找Inbound的ChannelHandlerContext。具体逻辑与Outbound传递过程相似，不再重复。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelHandlerContext <span class="title">fireChannelRead</span><span class="params">(<span class="keyword">final</span> Object msg)</span> </span>&#123;</span><br><span class="line">    invokeChannelRead(findContextInbound(MASK_CHANNEL_READ), msg);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>小结：</strong> inBound事件在ChannelPipeline中传递时，只会选择身份为inBound的ChannelHandlerContext执行。</p>
<h1 id="ChannelPipeline重要API"><a href="#ChannelPipeline重要API" class="headerlink" title="ChannelPipeline重要API"></a>ChannelPipeline重要API</h1><p>ChannelPipeline的默认实现为DefaultChannelPipeline，以下API源码梳理均来自该实现类。</p>
<table>
<thead>
<tr>
<th>接口</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>ChannelPipeline addFirst(ChannelHandler… handlers)</td>
<td>在ChannelPipeline中，将ChannelHandlerContext添加HeadContext的后面。</td>
</tr>
<tr>
<td>ChannelPipeline addLast(ChannelHandler… handlers);</td>
<td>在ChannelPipeline中，将ChannelHandlerContext添加到TailContext的前面。</td>
</tr>
<tr>
<td>ChannelPipeline addBefore(String baseName, String name, ChannelHandler handler);</td>
<td>在ChannelPipeline中，将ChannelHandlerContext添加到某ChannelHandlerContext的前面。</td>
</tr>
<tr>
<td>ChannelPipeline addAfter(String baseName, String name, ChannelHandler handler);</td>
<td>在ChannelPipeline中，将ChannelHandlerContext添加到指定的ChannelHandlerContext的后面。</td>
</tr>
<tr>
<td>ChannelPipeline remove(ChannelHandler handler);</td>
<td>在ChannelPipeline中，将ChannelHandlerContext从链表中移除。</td>
</tr>
<tr>
<td>ChannelPipeline replace(ChannelHandler oldHandler, String newName, ChannelHandler newHandler);</td>
<td>在ChannelPipeline中，将新newCtx在链表中替换就得oldCtx。</td>
</tr>
</tbody></table>
<h3 id="addFirst"><a href="#addFirst" class="headerlink" title="addFirst"></a>addFirst</h3><p>说明：在ChannelPipeline中，将ChannelHandlerContext添加HeadContext的后面。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">addFirst</span><span class="params">(EventExecutorGroup group, String name, ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> AbstractChannelHandlerContext newCtx;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            checkMultiplicity(handler); <span class="comment">// 注解@7</span></span><br><span class="line">            name = filterName(name, handler); <span class="comment">// 注解@8</span></span><br><span class="line"></span><br><span class="line">            newCtx = newContext(group, name, handler); </span><br><span class="line"></span><br><span class="line">            addFirst0(newCtx); <span class="comment">// 注解@9</span></span><br><span class="line">						</span><br><span class="line">          	<span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        callHandlerAdded0(newCtx); <span class="comment">// 注解@10</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@7：</strong>checkMultiplicity()方法校验ChannelHandler是否重复。如果ChannelHandler中有注解@Sharable标识，则允许同一个ChannelHandler添加到不同的ChannelPipeline中。<strong>未加@Sharable注解的ChannelHandler只允许添加到一个ChannelPipeline</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkMultiplicity</span><span class="params">(ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> ChannelHandlerAdapter) &#123;</span><br><span class="line">        ChannelHandlerAdapter h = (ChannelHandlerAdapter) handler;</span><br><span class="line">        <span class="keyword">if</span> (!h.isSharable() &amp;&amp; h.added) &#123; <span class="comment">// 判断@Sharable注解和该Handler是否已经被添加</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ChannelPipelineException(</span><br><span class="line">                    h.getClass().getName() +</span><br><span class="line">                    <span class="string">&quot; is not a @Sharable handler, so can&#x27;t be added or removed multiple times.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        h.added = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@Sharable使用示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Sharable</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToMessageEncoder</span>&lt;<span class="title">CharSequence</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@8：</strong> ChannelHandler名字判断，没有设置Handler名字则自动生成一个；设置了Handler名字，不能与该ChannelPipeline其他ChannelHandler名字重复。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">filterName</span><span class="params">(String name, ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> generateName(handler); </span><br><span class="line">    &#125;</span><br><span class="line">    checkDuplicateName(name);</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@9：</strong>创建DefaultChannelHandlerContext，并加入将其加入到链表中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addFirst0</span><span class="params">(AbstractChannelHandlerContext newCtx)</span> </span>&#123;</span><br><span class="line">	AbstractChannelHandlerContext nextCtx = head.next;</span><br><span class="line">	newCtx.prev = head;</span><br><span class="line">	newCtx.next = nextCtx;</span><br><span class="line">	head.next = newCtx;</span><br><span class="line">	nextCtx.prev = newCtx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>经过上面链表的顺序调整，addFirst将ChannelHandlerContext添加到了HeadContext的后面。</strong></p>
<p><strong>注解@10</strong> ：当ChannelHandler添加ChannelPipeline后，回调该Handler的handlerAdded方法，也是通知机制的常用做法。</p>
<h3 id="addLast"><a href="#addLast" class="headerlink" title="addLast"></a>addLast</h3><p>说明：在ChannelPipeline中，将ChannelHandlerContext添加到TailContext的前面。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">addLast</span><span class="params">(EventExecutorGroup group, String name, ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AbstractChannelHandlerContext newCtx;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        checkMultiplicity(handler);</span><br><span class="line"></span><br><span class="line">        newCtx = newContext(group, filterName(name, handler), handler);</span><br><span class="line"></span><br><span class="line">        addLast0(newCtx); <span class="comment">// 注解@11</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    callHandlerAdded0(newCtx);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@11</strong>  <strong>其他逻辑同addFirst，addLast0将HandlerContext添加到TailContext的前一个位置。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addLast0</span><span class="params">(AbstractChannelHandlerContext newCtx)</span> </span>&#123;</span><br><span class="line">    AbstractChannelHandlerContext prev = tail.prev;</span><br><span class="line">    newCtx.prev = prev;</span><br><span class="line">    newCtx.next = tail;</span><br><span class="line">    prev.next = newCtx;</span><br><span class="line">    tail.prev = newCtx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>addBefore</strong></p>
<p>说明：在ChannelPipeline中，将ChannelHandlerContext添加到某ChannelHandlerContext的前面。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">addBefore</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        EventExecutorGroup group, String baseName, String name, ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AbstractChannelHandlerContext newCtx;</span><br><span class="line">    <span class="keyword">final</span> AbstractChannelHandlerContext ctx;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        checkMultiplicity(handler);</span><br><span class="line">        name = filterName(name, handler);</span><br><span class="line">        ctx = getContextOrDie(baseName); <span class="comment">// 注解@12</span></span><br><span class="line"></span><br><span class="line">        newCtx = newContext(group, name, handler); </span><br><span class="line"></span><br><span class="line">        addBefore0(ctx, newCtx); <span class="comment">// 注解@13</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    callHandlerAdded0(newCtx);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@12</strong> 根据传入的baseName在ChannelPipleline查找对应的HandlerContext。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> AbstractChannelHandlerContext <span class="title">getContextOrDie</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    AbstractChannelHandlerContext ctx = (AbstractChannelHandlerContext) context(name);</span><br><span class="line">    <span class="keyword">if</span> (ctx == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(name);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ctx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@13</strong> 添加到链表中，添加到baseName的前面。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addBefore0</span><span class="params">(AbstractChannelHandlerContext ctx, AbstractChannelHandlerContext newCtx)</span> </span>&#123;</span><br><span class="line">    newCtx.prev = ctx.prev;</span><br><span class="line">    newCtx.next = ctx;</span><br><span class="line">    ctx.prev.next = newCtx;</span><br><span class="line">    ctx.prev = newCtx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>addAfter</strong></p>
<p>说明：在ChannelPipeline中，将ChannelHandlerContext添加到指定的ChannelHandlerContext的后面。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">addAfter</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        EventExecutorGroup group, String baseName, String name, ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AbstractChannelHandlerContext newCtx;</span><br><span class="line">    <span class="keyword">final</span> AbstractChannelHandlerContext ctx;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        checkMultiplicity(handler);</span><br><span class="line">        name = filterName(name, handler);</span><br><span class="line">        ctx = getContextOrDie(baseName);</span><br><span class="line"></span><br><span class="line">        newCtx = newContext(group, name, handler);</span><br><span class="line"></span><br><span class="line">        addAfter0(ctx, newCtx); <span class="comment">// 注解@14</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    callHandlerAdded0(newCtx);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@14：</strong>调整链表顺序，调整方式同上。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addAfter0</span><span class="params">(AbstractChannelHandlerContext ctx, AbstractChannelHandlerContext newCtx)</span> </span>&#123;</span><br><span class="line">    newCtx.prev = ctx;</span><br><span class="line">    newCtx.next = ctx.next;</span><br><span class="line">    ctx.next.prev = newCtx;</span><br><span class="line">    ctx.next = newCtx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h3><p>说明：在ChannelPipeline中，将ChannelHandlerContext从链表中移除。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> AbstractChannelHandlerContext <span class="title">remove</span><span class="params">(<span class="keyword">final</span> AbstractChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> ctx != head &amp;&amp; ctx != tail; <span class="comment">// 注解@15</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        atomicRemoveFromHandlerList(ctx); <span class="comment">// 注解@16</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">    callHandlerRemoved0(ctx);</span><br><span class="line">    <span class="keyword">return</span> ctx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@15</strong> 被移除的ChannelHandlerContext不能是HeadContext和TailContext。</p>
<p><strong>注解@16</strong> 通过调整前后ChannelHandlerContext的指针指向实现移除操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">atomicRemoveFromHandlerList</span><span class="params">(AbstractChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">    AbstractChannelHandlerContext prev = ctx.prev;</span><br><span class="line">    AbstractChannelHandlerContext next = ctx.next;</span><br><span class="line">    prev.next = next;</span><br><span class="line">    next.prev = prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h3><p>说明：在ChannelPipeline中，将新newCtx在链表中替换就得oldCtx。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ChannelHandler <span class="title">replace</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> AbstractChannelHandlerContext ctx, String newName, ChannelHandler newHandler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> ctx != head &amp;&amp; ctx != tail; <span class="comment">// 注解@17</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> AbstractChannelHandlerContext newCtx;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        checkMultiplicity(newHandler);</span><br><span class="line">        <span class="keyword">if</span> (newName == <span class="keyword">null</span>) &#123;</span><br><span class="line">            newName = generateName(newHandler);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> sameName = ctx.name().equals(newName);</span><br><span class="line">            <span class="keyword">if</span> (!sameName) &#123;</span><br><span class="line">                checkDuplicateName(newName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        newCtx = newContext(ctx.executor, newName, newHandler);</span><br><span class="line">        replace0(ctx, newCtx); <span class="comment">// 注解@18</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> ctx.handler();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解@17</strong> 被替换的ChannelHandlerContext不能是HeadContext和TailContext。</p>
<p><strong>注解@18</strong> 下面替换逻辑中，首先将oldCtx的前后指针暂存；newCtx前后指针指向刚才的暂存；把暂存的pre的next指向newCtx，暂存的next的prev指向newCtx，此时newCtx已经替换到了链表中；将oldCtx的prev和next都指向了newCtx，目的为了已经进入了oldCtx的数据正确流转无论是inbound还是outbound数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">replace0</span><span class="params">(AbstractChannelHandlerContext oldCtx, AbstractChannelHandlerContext newCtx)</span> </span>&#123;</span><br><span class="line">    AbstractChannelHandlerContext prev = oldCtx.prev;</span><br><span class="line">    AbstractChannelHandlerContext next = oldCtx.next;</span><br><span class="line">    newCtx.prev = prev;</span><br><span class="line">    newCtx.next = next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Finish the replacement of oldCtx with newCtx in the linked list.</span></span><br><span class="line">    <span class="comment">// Note that this doesn&#x27;t mean events will be sent to the new handler immediately</span></span><br><span class="line">    <span class="comment">// because we are currently at the event handler thread and no more than one handler methods can be invoked</span></span><br><span class="line">    <span class="comment">// at the same time (we ensured that in replace().)</span></span><br><span class="line">    prev.next = newCtx;</span><br><span class="line">    next.prev = newCtx;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// update the reference to the replacement so forward of buffered content will work correctly</span></span><br><span class="line">    oldCtx.prev = newCtx;</span><br><span class="line">    oldCtx.next = newCtx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>小结：</strong> ChannelPipeline提供了方便的API对链表中的ChannelHandlerContext进行插入、删除、添加、替换操作。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yongliangcode.github.io/posts/86dc035b/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="瓜农老梁">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/86dc035b/" class="post-title-link" itemprop="url">MQ43# Raft一致性算法整理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-20 23:55:01" itemprop="dateCreated datePublished" datetime="2020-12-20T23:55:01+08:00">2020-12-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-19 15:26:32" itemprop="dateModified" datetime="2020-12-19T15:26:32+08:00">2020-12-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/RocketMQ/" itemprop="url" rel="index"><span itemprop="name">RocketMQ</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Raft概述"><a href="#Raft概述" class="headerlink" title="Raft概述"></a>Raft概述</h1><h2 id="Raft定义"><a href="#Raft定义" class="headerlink" title="Raft定义"></a>Raft定义</h2><p>Raft是一种用来管理日志复制的一致性算法。一致性算法允许一组机器像一个整体一样工作，即使其中的一些机器出了错误也能正常工作。</p>
<h2 id="复制状态机"><a href="#复制状态机" class="headerlink" title="复制状态机"></a>复制状态机</h2><p>复制状态机(State Machine Replication)：通过复制服务副本，并和副本一起来协调客户端的交互，来实现容错服务。Raft复制状态机是通过复制日志来实现的，每一台服务器保存着一份日志。</p>
<h2 id="Raft一致性"><a href="#Raft一致性" class="headerlink" title="Raft一致性"></a>Raft一致性</h2><p>Raft实现一致性是首先选择一个确定的leader，然后leader负责管理日志复制。leader接受来自客户端的请求并追加到本地日志，然后把日志复制到其它的机器并告诉其它机器什么时候可以安全的将日志应用到状态机。<code>集群存在一个leader的好处可以简化日志复制的管理</code>。例如：leader可以决定日志的追加，而不需要经其它机器的同意。<code>整个集群的数据流向也是从leader流向其它机器</code>。如果leader宕机或者网络断开，其它的机器可以重新选举一个新的leader。</p>
<p>Raft一致性问题分解为3个相对独立的子问题</p>
<p>Leader election：当一个leader宕机后，一个新的leader必须被选举。</p>
<p>Log replication：leader必须响应客户端的请求，并把日志复制到整个集群来保证其它机器的日志和自己的相同。</p>
<p>Safety：状态机的安全是Raft优先保证的。如果任意一台机器将一条特定的日志应用到自己的状态机，那么其他的机器就不能应用一条不同的日志到自己的状态机。解决这个问题的方案就是在选举是增加额外的规则约束。</p>
<h2 id="Raft新的特性"><a href="#Raft新的特性" class="headerlink" title="Raft新的特性"></a>Raft新的特性</h2><p>强领导者（Strong Leader）：日志条目只从领导者发送向其他服务器。</p>
<p>领导选取（Leader Selection）：Raft使用了随机定时器来选择leader。</p>
<p>成员变化（Membership Change）：Raft使用了一种<code>联合一致性</code>的方法，使得集群中的机器发生变更的时候，整个集群也可以正常的工作。联合一致性配置是两个不同配置的大多数机器的重叠。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/posts/86dc035b/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yongliangcode.github.io/posts/ea80cc10/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="瓜农老梁">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/ea80cc10/" class="post-title-link" itemprop="url">MQ42# RocketMQ消息轨迹</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-20 23:45:01" itemprop="dateCreated datePublished" datetime="2020-12-20T23:45:01+08:00">2020-12-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-19 15:26:32" itemprop="dateModified" datetime="2020-12-19T15:26:32+08:00">2020-12-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/RocketMQ/" itemprop="url" rel="index"><span itemprop="name">RocketMQ</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div id="vip-container"><h1 id="Broker配置"><a href="#Broker配置" class="headerlink" title="Broker配置"></a>Broker配置</h1><p>首先看下broker.conf配置的两个属性</p>
<p>| 属性 |默认值 |</p>
<p>| — | — |</p>
<p>|traceTopicEnable |false |</p>
<p>| msgTraceTopicName | RMQ_SYS_TRACE_TOPIC |</p>
<p>在一个集群中可以配置一台机器专门负责消息轨迹的收集工作，该台机器上配置traceTopicEnable = true,</p>
<p>borker启动的时候自动创建默认轨迹topic</p>
<p>TopicConfigManager.java构造方法，BrokerController在启动的时候，会初始化TopicConfigManager实现trace topic的创建工作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.brokerController.getBrokerConfig().isTraceTopicEnable()) &#123;</span><br><span class="line"></span><br><span class="line">String topic = <span class="keyword">this</span>.brokerController.getBrokerConfig().getMsgTraceTopicName();</span><br><span class="line"></span><br><span class="line">TopicConfig topicConfig = <span class="keyword">new</span> TopicConfig(topic);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.systemTopicList.add(topic);</span><br><span class="line"></span><br><span class="line">topicConfig.setReadQueueNums(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">topicConfig.setWriteQueueNums(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.topicConfigTable.put(topicConfig.getTopicName(), topicConfig);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="客户端发送实现"><a href="#客户端发送实现" class="headerlink" title="客户端发送实现"></a><strong>客户端发送实现</strong></h1><p>客户端发送</p>
<p>DefaultMQProducer producer = new DefaultMQProducer(“ProducerGroupName”,true);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public DefaultMQProducer(final String producerGroup, RPCHook rpcHook, boolean enableMsgTrace,final String customizedTraceTopic) &#123;</span><br><span class="line"></span><br><span class="line">this.producerGroup &#x3D; producerGroup;</span><br><span class="line"></span><br><span class="line">defaultMQProducerImpl &#x3D; new DefaultMQProducerImpl(this, rpcHook);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;if client open the message trace feature</span><br><span class="line"></span><br><span class="line">if (enableMsgTrace) &#123;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">AsyncTraceDispatcher dispatcher &#x3D; new AsyncTraceDispatcher(customizedTraceTopic, rpcHook);</span><br><span class="line"></span><br><span class="line">dispatcher.setHostProducer(this.getDefaultMQProducerImpl());</span><br><span class="line"></span><br><span class="line">traceDispatcher &#x3D; dispatcher;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;为消息轨迹注册hook,在消息发送前执行</span><br><span class="line"></span><br><span class="line">this.getDefaultMQProducerImpl().registerSendMessageHook(</span><br><span class="line"></span><br><span class="line">new SendMessageTraceHookImpl(traceDispatcher));</span><br><span class="line"></span><br><span class="line">&#125; catch (Throwable e) &#123;</span><br><span class="line"></span><br><span class="line">log.error(&quot;system mqtrace hook init failed ,maybe can&#39;t send msg trace data&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SendMessageTraceHookImpl 实现了SendMessageHook接口，在消息发送前后会被调用</p>
<p>AsyncTraceDispatcher 主要负责消息的发送工作；内部队列，由线程池批量（100条）发送</p>
<h1 id="Hook调用"><a href="#Hook调用" class="headerlink" title="Hook调用"></a><strong>Hook调用</strong></h1><p>发送前hook调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;如果有hook在消息发送前执行，消息轨迹通过这种方式记录</span><br><span class="line"></span><br><span class="line">if (this.hasSendMessageHook()) &#123;</span><br><span class="line"></span><br><span class="line">context &#x3D; new SendMessageContext();</span><br><span class="line"></span><br><span class="line">context.setProducer(this); &#x2F;&#x2F;发送对象</span><br><span class="line"></span><br><span class="line">context.setProducerGroup(this.defaultMQProducer.getProducerGroup()); &#x2F;&#x2F;生产组</span><br><span class="line"></span><br><span class="line">context.setCommunicationMode(communicationMode); &#x2F;&#x2F;发送模式</span><br><span class="line"></span><br><span class="line">context.setBornHost(this.defaultMQProducer.getClientIP()); &#x2F;&#x2F;客户端IP</span><br><span class="line"></span><br><span class="line">context.setBrokerAddr(brokerAddr); &#x2F;&#x2F;发往broker的地址</span><br><span class="line"></span><br><span class="line">context.setMessage(msg); &#x2F;&#x2F;消息内容</span><br><span class="line"></span><br><span class="line">context.setMq(mq); &#x2F;&#x2F;消息 Queue</span><br><span class="line"></span><br><span class="line">String isTrans &#x3D; msg.getProperty(MessageConst.PROPERTY_TRANSACTION_PREPARED);</span><br><span class="line"></span><br><span class="line">if (isTrans !&#x3D; null &amp;&amp; isTrans.equals(&quot;true&quot;)) &#123;</span><br><span class="line"></span><br><span class="line">context.setMsgType(MessageType.Trans_Msg_Half);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (msg.getProperty(&quot;__STARTDELIVERTIME&quot;) !&#x3D; null || msg.getProperty(MessageConst.PROPERTY_DELAY_TIME_LEVEL) !&#x3D; null) &#123;</span><br><span class="line"></span><br><span class="line">context.setMsgType(MessageType.Delay_Msg);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">this.executeSendMessageHookBefore(context); &#x2F;&#x2F;执行自定义个hook业务</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>发送后hook调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;消息发送后执行的hook，消息轨迹会调用</span><br><span class="line"></span><br><span class="line">if (this.hasSendMessageHook()) &#123;</span><br><span class="line"></span><br><span class="line">context.setSendResult(sendResult);</span><br><span class="line"></span><br><span class="line">this.executeSendMessageHookAfter(context);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="发送轨迹"><a href="#发送轨迹" class="headerlink" title="发送轨迹"></a><strong>发送轨迹</strong></h1><p>Producer启动时注册钩子，该钩子持有负责消息发送的AsyncTraceDispatcher实例，消息发送后进而发送消息轨迹</p>
<p><strong>发送轨迹的消息格式</strong></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219151653.png"></p>
<h1 id="客户端消费轨迹实现"><a href="#客户端消费轨迹实现" class="headerlink" title="客户端消费轨迹实现"></a>客户端消费轨迹实现</h1><p>消费轨迹：与消息发送的轨迹实现思路相同</p>
<p>DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(“CID_JODIE_1”,true);</p>
<p><strong>注册消费钩子</strong></p>
<p>ConsumeMessageTraceHookImpl实现了ConsumeMessageHook，在消费的前后会进行回调</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public DefaultMQPushConsumer(final String consumerGroup, RPCHook rpcHook,</span><br><span class="line"></span><br><span class="line">AllocateMessageQueueStrategy allocateMessageQueueStrategy, boolean enableMsgTrace, final String customizedTraceTopic) &#123;</span><br><span class="line"></span><br><span class="line">this.consumerGroup &#x3D; consumerGroup;</span><br><span class="line"></span><br><span class="line">this.allocateMessageQueueStrategy &#x3D; allocateMessageQueueStrategy;</span><br><span class="line"></span><br><span class="line">defaultMQPushConsumerImpl &#x3D; new DefaultMQPushConsumerImpl(this, rpcHook);</span><br><span class="line"></span><br><span class="line">if (enableMsgTrace) &#123;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">AsyncTraceDispatcher dispatcher &#x3D; new AsyncTraceDispatcher(customizedTraceTopic, rpcHook);</span><br><span class="line"></span><br><span class="line">dispatcher.setHostConsumer(this.getDefaultMQPushConsumerImpl());</span><br><span class="line"></span><br><span class="line">traceDispatcher &#x3D; dispatcher;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;注册消费hook</span><br><span class="line"></span><br><span class="line">this.getDefaultMQPushConsumerImpl().registerConsumeMessageHook(</span><br><span class="line"></span><br><span class="line">new ConsumeMessageTraceHookImpl(traceDispatcher));</span><br><span class="line"></span><br><span class="line">&#125; catch (Throwable e) &#123;</span><br><span class="line"></span><br><span class="line">log.error(&quot;system mqtrace hook init failed ,maybe can&#39;t send msg trace data&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ConsumeMessageConcurrentlyService.ConsumeRequest.run消费前执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;消费前执行hook 消费轨迹会执行</span><br><span class="line"></span><br><span class="line">ConsumeMessageContext consumeMessageContext &#x3D; null;</span><br><span class="line"></span><br><span class="line">if (ConsumeMessageConcurrentlyService.this.defaultMQPushConsumerImpl.hasHook()) &#123;</span><br><span class="line"></span><br><span class="line">consumeMessageContext &#x3D; new ConsumeMessageContext();</span><br><span class="line"></span><br><span class="line">consumeMessageContext.setConsumerGroup(defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line"></span><br><span class="line">consumeMessageContext.setProps(new HashMap&lt;String, String&gt;());</span><br><span class="line"></span><br><span class="line">consumeMessageContext.setMq(messageQueue);</span><br><span class="line"></span><br><span class="line">consumeMessageContext.setMsgList(msgs);</span><br><span class="line"></span><br><span class="line">consumeMessageContext.setSuccess(false); &#x2F;&#x2F;消费状态</span><br><span class="line"></span><br><span class="line">ConsumeMessageConcurrentlyService.this.defaultMQPushConsumerImpl.executeHookBefore(consumeMessageContext);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>消费后执行</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if (ConsumeMessageConcurrentlyService.this.defaultMQPushConsumerImpl.hasHook()) &#123;</span><br><span class="line"></span><br><span class="line">consumeMessageContext.setStatus(status.toString());</span><br><span class="line"></span><br><span class="line">consumeMessageContext.setSuccess(ConsumeConcurrentlyStatus.CONSUME_SUCCESS &#x3D;&#x3D; status);</span><br><span class="line"></span><br><span class="line">ConsumeMessageConcurrentlyService.this.defaultMQPushConsumerImpl.executeHookAfter(consumeMessageContext);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>消费轨迹格式</strong></p>
<p>分为两部分，一部分为消费前，一部分为消费后</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219151820.png"></p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219151831.png"></p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "19728-1607829271089-768",
			        "name": "瓜农老梁",
			        "qrcode": "https://img-blog.csdnimg.cn/2020121311123065.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yongliangcode.github.io/posts/2f29fd72/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="瓜农老梁">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/2f29fd72/" class="post-title-link" itemprop="url">MQ41# RocketMQ特性--事物消息</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-20 23:43:01" itemprop="dateCreated datePublished" datetime="2020-12-20T23:43:01+08:00">2020-12-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-19 15:26:32" itemprop="dateModified" datetime="2020-12-19T15:26:32+08:00">2020-12-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/RocketMQ/" itemprop="url" rel="index"><span itemprop="name">RocketMQ</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="问题思考"><a href="#问题思考" class="headerlink" title="问题思考"></a>问题思考</h1><p>从官方给的例子入手，代码如下:</p>
<p>示例类：org.apache.rocketmq.example.transaction.TransactionProducer.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws MQClientException, InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@1 定义TransactionListener</span><br><span class="line"></span><br><span class="line">TransactionListener transactionListener &#x3D; new TransactionListenerImpl();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@2 使用事务发送Producer</span><br><span class="line"></span><br><span class="line">TransactionMQProducer producer &#x3D; new TransactionMQProducer(&quot;please_rename_unique_group_name&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@3 定义线程池</span><br><span class="line"></span><br><span class="line">ExecutorService executorService &#x3D; new ThreadPoolExecutor(2, 5, 100, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(2000), new ThreadFactory() &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line"></span><br><span class="line">public Thread newThread(Runnable r) &#123;</span><br><span class="line"></span><br><span class="line">Thread thread &#x3D; new Thread(r);</span><br><span class="line"></span><br><span class="line">thread.setName(&quot;client-transaction-msg-check-thread&quot;);</span><br><span class="line"></span><br><span class="line">return thread;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设置线程池</span><br><span class="line"></span><br><span class="line">producer.setExecutorService(executorService);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设置监听器</span><br><span class="line"></span><br><span class="line">producer.setTransactionListener(transactionListener);</span><br><span class="line"></span><br><span class="line">producer.setNamesrvAddr(&quot;127.0.0.1:9876&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@4 发送者启动</span><br><span class="line"></span><br><span class="line">producer.start();</span><br><span class="line"></span><br><span class="line">String[] tags &#x3D; new String[] &#123;&quot;TagA&quot;, &quot;TagB&quot;, &quot;TagC&quot;, &quot;TagD&quot;, &quot;TagE&quot;&#125;;</span><br><span class="line"></span><br><span class="line">for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">Message msg &#x3D;</span><br><span class="line"></span><br><span class="line">new Message(&quot;TopicTest1234&quot;, tags[i % tags.length], &quot;KEY&quot; + i,</span><br><span class="line"></span><br><span class="line">(&quot;Hello RocketMQ &quot; + i).getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@5 消息发送</span><br><span class="line"></span><br><span class="line">SendResult sendResult &#x3D; producer.sendMessageInTransaction(msg, null);</span><br><span class="line"></span><br><span class="line">System.out.printf(&quot;%s%n&quot;, sendResult);</span><br><span class="line"></span><br><span class="line">Thread.sleep(10);</span><br><span class="line"></span><br><span class="line">&#125; catch (MQClientException | UnsupportedEncodingException e) &#123;</span><br><span class="line"></span><br><span class="line">e.printStackTrace();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (int i &#x3D; 0; i &lt; 100000; i++) &#123;</span><br><span class="line"></span><br><span class="line">Thread.sleep(1000);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;发送者关闭</span><br><span class="line"></span><br><span class="line">producer.shutdown();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>从上面客户端例子中思考一些问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. @1定义TransactionListener做什么用？</span><br><span class="line">2. @2定义的TransactionMQProducer与普通Produer区别在哪里？</span><br><span class="line">3. @3定义线程池executorService又是干啥的？</span><br><span class="line">4. @4事务发送者启动发送流程是怎么样？</span><br><span class="line">5. 发送事务消息如何和Broker进行交互的？</span><br></pre></td></tr></table></figure>



<h1 id="事务消息客户端发送流程"><a href="#事务消息客户端发送流程" class="headerlink" title="事务消息客户端发送流程"></a>事务消息客户端发送流程</h1><h2 id="事务发送与普通启动差异"><a href="#事务发送与普通启动差异" class="headerlink" title="事务发送与普通启动差异"></a>事务发送与普通启动差异</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@1 producer.start();</span><br><span class="line"></span><br><span class="line">@2 TransactionMQProducer#start</span><br><span class="line"></span><br><span class="line">this.defaultMQProducerImpl.initTransactionEnv();</span><br><span class="line"></span><br><span class="line">super.start();</span><br><span class="line"></span><br><span class="line">@3 DefaultMQProducerImpl#initTransactionEnv()</span><br><span class="line"></span><br><span class="line">this.checkExecutor &#x3D; producer.getExecutorService();</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小结：事务发送时比普通发送启动多了initTransactionEnv操作，即：给ExecutorService checkExecutor赋值。</span><br></pre></td></tr></table></figure>



<h2 id="事务消息发送调用链"><a href="#事务消息发送调用链" class="headerlink" title="事务消息发送调用链"></a>事务消息发送调用链</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@1 SendResult sendResult &#x3D; producer.sendMessageInTransaction</span><br><span class="line"></span><br><span class="line">@2 TransactionMQProducer#sendMessageInTransaction</span><br><span class="line"></span><br><span class="line">@3 DefaultMQProducerImpl#sendMessageInTransaction</span><br></pre></td></tr></table></figure>



<h2 id="事务消息发送分析"><a href="#事务消息发送分析" class="headerlink" title="事务消息发送分析"></a>事务消息发送分析</h2><p>方法：DefaultMQProducerImpl#sendMessageInTransaction</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;@1</span><br><span class="line"></span><br><span class="line">TransactionListener transactionListener &#x3D; getCheckListener();</span><br><span class="line"></span><br><span class="line">if (null &#x3D;&#x3D; localTransactionExecuter &amp;&amp; null &#x3D;&#x3D; transactionListener) &#123;</span><br><span class="line"></span><br><span class="line">throw new MQClientException(&quot;tranExecutor is null&quot;, null);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Validators.checkMessage(msg, this.defaultMQProducer);</span><br><span class="line"></span><br><span class="line">SendResult sendResult &#x3D; null;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@2 表示消息的prepare消息</span><br><span class="line"></span><br><span class="line">MessageAccessor.putProperty(msg, MessageConst.PROPERTY_TRANSACTION_PREPARED, &quot;true&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@3 生产者组，用于回查本地事务事，从生产者组中选择随机选择一个生产者即可</span><br><span class="line"></span><br><span class="line">MessageAccessor.putProperty(msg, MessageConst.PROPERTY_PRODUCER_GROUP, this.defaultMQProducer.getProducerGroup());</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@4 消息发送</span><br><span class="line"></span><br><span class="line">sendResult &#x3D; this.send(msg);</span><br><span class="line"></span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">throw new MQClientException(&quot;send message Exception&quot;, e);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>方法：DefaultMQProducerImpl#sendKernelImpl</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;事务消息发送，设置PREPARED标记</span><br><span class="line"></span><br><span class="line">final String tranMsg &#x3D; msg.getProperty(MessageConst.PROPERTY_TRANSACTION_PREPARED);</span><br><span class="line"></span><br><span class="line">if (tranMsg !&#x3D; null &amp;&amp; Boolean.parseBoolean(tranMsg)) &#123;</span><br><span class="line"></span><br><span class="line">sysFlag |&#x3D; MessageSysFlag.TRANSACTION_PREPARED_TYPE;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@5 请求header中设置事务标记</span><br><span class="line"></span><br><span class="line">requestHeader.setSysFlag(sysFlag);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@6 发送消息请求的RequestCode</span><br><span class="line"></span><br><span class="line">request &#x3D; RemotingCommand.createRequestCommand(RequestCode.SEND_MESSAGE, requestHeader);</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">小结：</span><br><span class="line">@1获取TransactionListener即示例代码传入的Listener</span><br><span class="line">@2在消息属性中加入PROPERTY_TRANSACTION_PREPARED &#x3D; &quot;TRAN_MSG&quot;即事务半消息</span><br><span class="line">@3设置ProducerGroup Broker在事务回查时调用</span><br><span class="line">@4事务消息发送采用同步发送，发送流程与普通消息发送一致</span><br><span class="line">@5请求header中设置事务标记SEND_MESSAGE &#x3D; 10</span><br></pre></td></tr></table></figure>



<h2 id="事务消息发送结果分析"><a href="#事务消息发送结果分析" class="headerlink" title="事务消息发送结果分析"></a>事务消息发送结果分析</h2><p>方法：DefaultMQProducerImpl#sendMessageInTransaction</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">LocalTransactionState localTransactionState &#x3D; LocalTransactionState.UNKNOW;</span><br><span class="line"></span><br><span class="line">switch (sendResult.getSendStatus()) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@1</span><br><span class="line"></span><br><span class="line">case SEND_OK: &#123;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@2 执行本地事务</span><br><span class="line"></span><br><span class="line">localTransactionState &#x3D; transactionListener.executeLocalTransaction(msg, arg);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">case FLUSH_DISK_TIMEOUT:</span><br><span class="line"></span><br><span class="line">case FLUSH_SLAVE_TIMEOUT:</span><br><span class="line"></span><br><span class="line">case SLAVE_NOT_AVAILABLE:</span><br><span class="line"></span><br><span class="line">localTransactionState &#x3D; LocalTransactionState.ROLLBACK_MESSAGE;</span><br><span class="line"></span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">default:</span><br><span class="line"></span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">小结：</span><br><span class="line">@1 发送半消息（Prepared）消息成功，设置transactionId。</span><br><span class="line">@2 发送半消息成功后，通过transactionListener回调客户端查询本地事务执行情况，并返回事务执行状态。</span><br><span class="line">LocalTransactionState有COMMIT_MESSAGE、ROLLBACK_MESSAGE、UNKNOW三种状态。</span><br></pre></td></tr></table></figure>



<h2 id="结束事务分析"><a href="#结束事务分析" class="headerlink" title="结束事务分析"></a>结束事务分析</h2><p>方法：DefaultMQProducerImpl#sendMessageInTransaction</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@1 结束事务，根据返回的事务状态执行提交、回滚、暂时不处理</span><br><span class="line"></span><br><span class="line">this.endTransaction(sendResult, localTransactionState, localException);</span><br><span class="line"></span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">log.warn(&quot;local transaction execute &quot; + localTransactionState + &quot;, but end broker transaction failed&quot;, e);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TransactionSendResult transactionSendResult &#x3D; new TransactionSendResult();</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">return transactionSendResult;</span><br></pre></td></tr></table></figure>



<p>方法：DefaultMQProducerImpl#endTransaction</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">switch (localTransactionState) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@2 设置事务提交标记Header</span><br><span class="line"></span><br><span class="line">case COMMIT_MESSAGE: requestHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_COMMIT_TYPE);</span><br><span class="line"></span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@3 设置事务回滚标记Header</span><br><span class="line"></span><br><span class="line">case ROLLBACK_MESSAGE:</span><br><span class="line"></span><br><span class="line">requestHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_ROLLBACK_TYPE);</span><br><span class="line"></span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@4 设置事务未知标记Header</span><br><span class="line"></span><br><span class="line">case UNKNOW:</span><br><span class="line"></span><br><span class="line">requestHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_NOT_TYPE);</span><br><span class="line"></span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">default:</span><br><span class="line"></span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@5 通过一次发送方式向Broker提交事务 this.mQClientFactory.getMQClientAPIImpl().endTransactionOneway(brokerAddr, requestHeader, remark,</span><br><span class="line"></span><br><span class="line">this.defaultMQProducer.getSendMsgTimeout());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">小结：</span><br><span class="line">@1 根据本地事务执行返回的状态localTransactionState，调用结束事务方法</span><br><span class="line">@2 requestHeader设置事务提交标记0x2 &lt;&lt; 2&#x3D;8</span><br><span class="line">@3 requestHeader设置事务回滚标记0x3 &lt;&lt; 2&#x3D;12</span><br><span class="line">@4 requestHeader设置未知标记0</span><br><span class="line">@5 通过一次发送方式向Broker提交事务 RequestCode为END_TRANSACTION &#x3D; 37</span><br></pre></td></tr></table></figure>



<h1 id="事务消息服务端存储流程"><a href="#事务消息服务端存储流程" class="headerlink" title="事务消息服务端存储流程"></a>事务消息服务端存储流程</h1><h2 id="事务消息存储调用链"><a href="#事务消息存储调用链" class="headerlink" title="事务消息存储调用链"></a>事务消息存储调用链</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@1 SendMessageProcessor#processRequest</span><br><span class="line"></span><br><span class="line">response &#x3D; this.sendMessage(ctx, request, mqtraceContext, requestHeader)</span><br><span class="line"></span><br><span class="line">@2 SendMessageProcessor#sendMessage</span><br></pre></td></tr></table></figure>



<h2 id="事务半消息存储代码分析（一）"><a href="#事务半消息存储代码分析（一）" class="headerlink" title="事务半消息存储代码分析（一）"></a>事务半消息存储代码分析（一）</h2><p>方法：SendMessageProcessor#sendMessage</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;@1 可以通过配置来是否接受事务消息存储</span><br><span class="line"></span><br><span class="line">if (traFlag !&#x3D; null &amp;&amp; Boolean.parseBoolean(traFlag)) &#123;</span><br><span class="line"></span><br><span class="line">if (this.brokerController.getBrokerConfig().isRejectTransactionMessage())&#123;</span><br><span class="line"></span><br><span class="line">response.setCode(ResponseCode.NO_PERMISSION);</span><br><span class="line"></span><br><span class="line">response.setRemark(</span><br><span class="line"></span><br><span class="line">&quot;the broker[&quot; + this.brokerController.getBrokerConfig().getBrokerIP1()</span><br><span class="line"></span><br><span class="line">\+ &quot;] sending transaction message is forbidden&quot;);</span><br><span class="line"></span><br><span class="line">return response;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@2 prepare消息存储</span><br><span class="line"></span><br><span class="line">putMessageResult &#x3D; this.brokerController.getTransactionalMessageService().prepareMessage(msgInner);</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line"></span><br><span class="line">putMessageResult &#x3D; this.brokerController.getMessageStore().putMessage(msgInner);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">小结：</span><br><span class="line">@1 可以通过Broker配置属性rejectTransactionMessage来决定是否接受事务消息请求，默认为false即接受。</span><br><span class="line">@2 半消息存储</span><br></pre></td></tr></table></figure>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/posts/2f29fd72/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yongliangcode.github.io/posts/302db5ac/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="瓜农老梁">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/302db5ac/" class="post-title-link" itemprop="url">MQ40# RocketMQ一次消费性能问题排查</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-20 23:41:01" itemprop="dateCreated datePublished" datetime="2020-12-20T23:41:01+08:00">2020-12-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-19 15:26:32" itemprop="dateModified" datetime="2020-12-19T15:26:32+08:00">2020-12-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/RocketMQ/" itemprop="url" rel="index"><span itemprop="name">RocketMQ</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="需求描述"><a href="#需求描述" class="headerlink" title="需求描述"></a>需求描述</h1><p>在容器推广中，为了测试容器的性能，需要消息SDK与ECS上在发送和消费的性能对比；在对比消费性能时，发现容器中的消费性能居然是ECS的2倍。容器并发消费的20个线程TPS在3万左右，ECS中20个消费线程TPS在1.5万左右。</p>
<p>问题：配置均采用8C16G，容器中的性能几乎是ECS的两倍，这不科学，事出反常必有妖。</p>
<h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><h2 id="tcpdump网络情况"><a href="#tcpdump网络情况" class="headerlink" title="tcpdump网络情况"></a>tcpdump网络情况</h2><p>tcpdump显示在消费的机器存在频繁的域名解析过程；10.x.x.185向DNS服务器100.x.x.136.domain和10.x.x.138.domain请求解析。而10.x.x.185这台机器又是消息发送者的机器IP，测试的发送和消费分别部署在两台机器上。</p>
<p>问题：消费时为何会有消息发送方的IP呢？而且该IP还不断进行域名解析。</p>
<p><img src="https://gitee.com/laoliangcode/md-picture/raw/master/img/20201219150223.png"></p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/posts/302db5ac/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yongliangcode.github.io/posts/9126d179/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="瓜农老梁">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/9126d179/" class="post-title-link" itemprop="url">MQ39# RocketMQ消息发送Broker端流程处理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-20 23:39:01" itemprop="dateCreated datePublished" datetime="2020-12-20T23:39:01+08:00">2020-12-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-19 15:26:32" itemprop="dateModified" datetime="2020-12-19T15:26:32+08:00">2020-12-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/RocketMQ/" itemprop="url" rel="index"><span itemprop="name">RocketMQ</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Broker处理消息的入口类SendMessageProcessor"><a href="#Broker处理消息的入口类SendMessageProcessor" class="headerlink" title="Broker处理消息的入口类SendMessageProcessor"></a>Broker处理消息的入口类SendMessageProcessor</h1><p>processRequest方法主要三件事情：</p>
<p>1.处理consumer发回broker的消息重试</p>
<p>2.处理批量发送</p>
<p>3.处理单条消息发送</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line"></span><br><span class="line">public RemotingCommand processRequest(ChannelHandlerContext ctx, RemotingCommand request) throws RemotingCommandException &#123;</span><br><span class="line"></span><br><span class="line">SendMessageContext mqtraceContext;</span><br><span class="line"></span><br><span class="line">switch (request.getCode()) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;处理消息重试</span><br><span class="line"></span><br><span class="line">case RequestCode.CONSUMER_SEND_MSG_BACK:</span><br><span class="line"></span><br><span class="line">return this.consumerSendMsgBack(ctx, request);</span><br><span class="line"></span><br><span class="line">default:</span><br><span class="line"></span><br><span class="line">SendMessageRequestHeader requestHeader &#x3D; parseRequestHeader(request);</span><br><span class="line"></span><br><span class="line">if (requestHeader &#x3D;&#x3D; null) &#123;</span><br><span class="line"></span><br><span class="line">return null;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mqtraceContext &#x3D; buildMsgContext(ctx, requestHeader);</span><br><span class="line"></span><br><span class="line">this.executeSendMessageHookBefore(ctx, request, mqtraceContext);</span><br><span class="line"></span><br><span class="line">RemotingCommand response;</span><br><span class="line"></span><br><span class="line">if (requestHeader.isBatch()) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;批量发送</span><br><span class="line"></span><br><span class="line">response &#x3D; this.sendBatchMessage(ctx, request, mqtraceContext, requestHeader);</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;处理消息发送</span><br><span class="line"></span><br><span class="line">response &#x3D; this.sendMessage(ctx, request, mqtraceContext, requestHeader);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">this.executeSendMessageHookAfter(response, mqtraceContext);</span><br><span class="line"></span><br><span class="line">return response;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="单条处理流程"><a href="#单条处理流程" class="headerlink" title="单条处理流程"></a>单条处理流程</h1><p>批处理流程与单条处理基本一致</p>
<p>SendMessageProcessor.sendMessage主要流程：</p>
<p>1.broker可以在指定的时间开始服务通过startAcceptSendRequestTimeStamp设定</p>
<p>2.消息校验：</p>
<p>* broker没有写入权限并且topic为顺序topic则拒绝服务</p>
<p>* 检查Topic不能和系统保留Topic[TBW102]冲突</p>
<p>* 若Topic未创建，Broker开启自动创建</p>
<p>* queueId校验，不能大于队列最大值</p>
<p>3.判断是否超过消费次数（16次），决定是否写入死信队列</p>
<p>4.消息内容组织</p>
<p>* 设置Message扩展字段</p>
<p>* 设置Message在客户端生成的时间</p>
<p>* 设置发送Message机器的地址</p>
<p>* 设置存储Message的Broker地址</p>
<p>* 设置消费重试消息的次数</p>
<p>5.消息存储（单独梳理）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">private RemotingCommand sendMessage(final ChannelHandlerContext ctx, &#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">final RemotingCommand request, &#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">final SendMessageContext sendMessageContext, &#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">final SendMessageRequestHeader requestHeader) throws RemotingCommandException &#123;</span><br><span class="line"></span><br><span class="line">final RemotingCommand response &#x3D; RemotingCommand.createResponseCommand(SendMessageResponseHeader.class);</span><br><span class="line"></span><br><span class="line">final SendMessageResponseHeader responseHeader &#x3D; (SendMessageResponseHeader) response.readCustomHeader();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;标识RPC的SeqNumber</span><br><span class="line"></span><br><span class="line">response.setOpaque(request.getOpaque());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;埋点不清楚用处</span><br><span class="line"></span><br><span class="line">response.addExtField(MessageConst.PROPERTY_MSG_REGION, this.brokerController.getBrokerConfig().getRegionId());</span><br><span class="line"></span><br><span class="line">response.addExtField(MessageConst.PROPERTY_TRACE_SWITCH, String.valueOf(this.brokerController.getBrokerConfig().isTraceOn()));</span><br><span class="line"></span><br><span class="line">log.debug(&quot;receive SendMessage request command, &#123;&#125;&quot;, request);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Broker启动后在设定的时间处理请求，通过startAcceptSendRequestTimeStamp来设置</span><br><span class="line"></span><br><span class="line">final long startTimstamp &#x3D; this.brokerController.getBrokerConfig().getStartAcceptSendRequestTimeStamp();</span><br><span class="line"></span><br><span class="line">if (this.brokerController.getMessageStore().now() &lt; startTimstamp) &#123;</span><br><span class="line"></span><br><span class="line">response.setCode(ResponseCode.SYSTEM_ERROR);</span><br><span class="line"></span><br><span class="line">response.setRemark(String.format(&quot;broker unable to service, until %s&quot;, UtilAll.timeMillisToHumanString2(startTimstamp)));</span><br><span class="line"></span><br><span class="line">return response;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">response.setCode(-1);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建Topic</span><br><span class="line"></span><br><span class="line">super.msgCheck(ctx, requestHeader, response);</span><br><span class="line"></span><br><span class="line">if (response.getCode() !&#x3D; -1) &#123;</span><br><span class="line"></span><br><span class="line">return response;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final byte[] body &#x3D; request.getBody();</span><br><span class="line"></span><br><span class="line">int queueIdInt &#x3D; requestHeader.getQueueId();</span><br><span class="line"></span><br><span class="line">TopicConfig topicConfig &#x3D; this.brokerController.getTopicConfigManager().selectTopicConfig(requestHeader.getTopic());</span><br><span class="line"></span><br><span class="line">if (queueIdInt &lt; 0) &#123;</span><br><span class="line"></span><br><span class="line">queueIdInt &#x3D; Math.abs(this.random.nextInt() % 99999999) % topicConfig.getWriteQueueNums();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MessageExtBrokerInner msgInner &#x3D; new MessageExtBrokerInner();</span><br><span class="line"></span><br><span class="line">msgInner.setTopic(requestHeader.getTopic());</span><br><span class="line"></span><br><span class="line">msgInner.setQueueId(queueIdInt);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;判断是否超过消费次数（16次），决定是否写入死信队列</span><br><span class="line"></span><br><span class="line">if (!handleRetryAndDLQ(requestHeader, response, request, msgInner, topicConfig)) &#123;</span><br><span class="line"></span><br><span class="line">return response;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">msgInner.setBody(body);</span><br><span class="line"></span><br><span class="line">msgInner.setFlag(requestHeader.getFlag());</span><br><span class="line"></span><br><span class="line">MessageAccessor.setProperties(msgInner, MessageDecoder.string2messageProperties(requestHeader.getProperties()));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Message扩展字段，比如：Unikey, Keys, Tag都在这里面</span><br><span class="line"></span><br><span class="line">msgInner.setPropertiesString(requestHeader.getProperties());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Message在客户端生成的时间</span><br><span class="line"></span><br><span class="line">msgInner.setBornTimestamp(requestHeader.getBornTimestamp());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;发送Message机器的地址</span><br><span class="line"></span><br><span class="line">msgInner.setBornHost(ctx.channel().remoteAddress());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;存储Message的Broker地址</span><br><span class="line"></span><br><span class="line">msgInner.setStoreHost(this.getStoreHost());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;重试消息的次数</span><br><span class="line"></span><br><span class="line">msgInner.setReconsumeTimes(requestHeader.getReconsumeTimes() &#x3D;&#x3D; null ? 0 : requestHeader.getReconsumeTimes());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;判断broker是否拒绝事物消息[rejectTransactionMessage]默认false</span><br><span class="line"></span><br><span class="line">if (this.brokerController.getBrokerConfig().isRejectTransactionMessage()) &#123;</span><br><span class="line"></span><br><span class="line">String traFlag &#x3D; msgInner.getProperty(MessageConst.PROPERTY_TRANSACTION_PREPARED);</span><br><span class="line"></span><br><span class="line">if (traFlag !&#x3D; null) &#123;</span><br><span class="line"></span><br><span class="line">response.setCode(ResponseCode.NO_PERMISSION);</span><br><span class="line"></span><br><span class="line">response.setRemark(</span><br><span class="line"></span><br><span class="line">&quot;the broker[&quot; + this.brokerController.getBrokerConfig().getBrokerIP1() + &quot;] sending transaction message is forbidden&quot;);</span><br><span class="line"></span><br><span class="line">return response;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;消息存储</span><br><span class="line"></span><br><span class="line">PutMessageResult putMessageResult &#x3D; this.brokerController.getMessageStore().putMessage(msgInner);</span><br><span class="line"></span><br><span class="line">return handlePutMessageResult(putMessageResult, response, request, msgInner, responseHeader, sendMessageContext, ctx, queueIdInt);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/posts/9126d179/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name"></p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">54</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://mp.weixin.qq.com/s/kPx7F1iD1lgvYiZ1_oymwQ" title="联系老梁 → https:&#x2F;&#x2F;mp.weixin.qq.com&#x2F;s&#x2F;kPx7F1iD1lgvYiZ1_oymwQ" rel="noopener" target="_blank"><i class="fa fa-weixin fa-fw"></i>联系老梁</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder"></span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
